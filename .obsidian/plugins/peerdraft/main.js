/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cuint/lib/uint32.js
var require_uint32 = __commonJS({
  "node_modules/cuint/lib/uint32.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        36: UINT32(Math.pow(36, 5)),
        16: UINT32(Math.pow(16, 7)),
        10: UINT32(Math.pow(10, 9)),
        2: UINT32(Math.pow(2, 30))
      };
      var radixCache = {
        36: UINT32(36),
        16: UINT32(16),
        10: UINT32(10),
        2: UINT32(2)
      };
      function UINT32(l, h) {
        if (!(this instanceof UINT32))
          return new UINT32(l, h);
        this._low = 0;
        this._high = 0;
        this.remainder = null;
        if (typeof h == "undefined")
          return fromNumber.call(this, l);
        if (typeof l == "string")
          return fromString.call(this, l, h);
        fromBits.call(this, l, h);
      }
      function fromBits(l, h) {
        this._low = l | 0;
        this._high = h | 0;
        return this;
      }
      UINT32.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        var value = parseInt(s, radix || 10);
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromString = fromString;
      UINT32.prototype.toNumber = function() {
        return this._high * 65536 + this._low;
      };
      UINT32.prototype.toString = function(radix) {
        return this.toNumber().toString(radix || 10);
      };
      UINT32.prototype.add = function(other) {
        var a00 = this._low + other._low;
        var a16 = a00 >>> 16;
        a16 += this._high + other._high;
        this._low = a00 & 65535;
        this._high = a16 & 65535;
        return this;
      };
      UINT32.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT32.prototype.multiply = function(other) {
        var a16 = this._high;
        var a00 = this._low;
        var b16 = other._high;
        var b00 = other._low;
        var c16, c00;
        c00 = a00 * b00;
        c16 = c00 >>> 16;
        c16 += a16 * b00;
        c16 &= 65535;
        c16 += a00 * b16;
        this._low = c00 & 65535;
        this._high = c16 & 65535;
        return this;
      };
      UINT32.prototype.div = function(other) {
        if (other._low == 0 && other._high == 0)
          throw Error("division by zero");
        if (other._high == 0 && other._low == 1) {
          this.remainder = new UINT32(0);
          return this;
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._low = 0;
          this._high = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT32(0);
          this._low = 1;
          this._high = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._low = 0;
        this._high = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 16) {
              this._high |= 1 << i - 16;
            } else {
              this._low |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT32.prototype.negate = function() {
        var v = (~this._low & 65535) + 1;
        this._low = v & 65535;
        this._high = ~this._high + (v >>> 16) & 65535;
        return this;
      };
      UINT32.prototype.equals = UINT32.prototype.eq = function(other) {
        return this._low == other._low && this._high == other._high;
      };
      UINT32.prototype.greaterThan = UINT32.prototype.gt = function(other) {
        if (this._high > other._high)
          return true;
        if (this._high < other._high)
          return false;
        return this._low > other._low;
      };
      UINT32.prototype.lessThan = UINT32.prototype.lt = function(other) {
        if (this._high < other._high)
          return true;
        if (this._high > other._high)
          return false;
        return this._low < other._low;
      };
      UINT32.prototype.or = function(other) {
        this._low |= other._low;
        this._high |= other._high;
        return this;
      };
      UINT32.prototype.and = function(other) {
        this._low &= other._low;
        this._high &= other._high;
        return this;
      };
      UINT32.prototype.not = function() {
        this._low = ~this._low & 65535;
        this._high = ~this._high & 65535;
        return this;
      };
      UINT32.prototype.xor = function(other) {
        this._low ^= other._low;
        this._high ^= other._high;
        return this;
      };
      UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function(n) {
        if (n > 16) {
          this._low = this._high >> n - 16;
          this._high = 0;
        } else if (n == 16) {
          this._low = this._high;
          this._high = 0;
        } else {
          this._low = this._low >> n | this._high << 16 - n & 65535;
          this._high >>= n;
        }
        return this;
      };
      UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function(n, allowOverflow) {
        if (n > 16) {
          this._high = this._low << n - 16;
          this._low = 0;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        } else if (n == 16) {
          this._high = this._low;
          this._low = 0;
        } else {
          this._high = this._high << n | this._low >> 16 - n;
          this._low = this._low << n & 65535;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        }
        return this;
      };
      UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function(n) {
        var v = this._high << 16 | this._low;
        v = v << n | v >>> 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.rotateRight = UINT32.prototype.rotr = function(n) {
        var v = this._high << 16 | this._low;
        v = v >>> n | v << 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.clone = function() {
        return new UINT32(this._low, this._high);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT32;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT32;
      } else {
        root["UINT32"] = UINT32;
      }
    })(exports);
  }
});

// node_modules/cuint/lib/uint64.js
var require_uint64 = __commonJS({
  "node_modules/cuint/lib/uint64.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        16: UINT64(Math.pow(16, 5)),
        10: UINT64(Math.pow(10, 5)),
        2: UINT64(Math.pow(2, 5))
      };
      var radixCache = {
        16: UINT64(16),
        10: UINT64(10),
        2: UINT64(2)
      };
      function UINT64(a00, a16, a32, a48) {
        if (!(this instanceof UINT64))
          return new UINT64(a00, a16, a32, a48);
        this.remainder = null;
        if (typeof a00 == "string")
          return fromString.call(this, a00, a16);
        if (typeof a16 == "undefined")
          return fromNumber.call(this, a00);
        fromBits.apply(this, arguments);
      }
      function fromBits(a00, a16, a32, a48) {
        if (typeof a32 == "undefined") {
          this._a00 = a00 & 65535;
          this._a16 = a00 >>> 16;
          this._a32 = a16 & 65535;
          this._a48 = a16 >>> 16;
          return this;
        }
        this._a00 = a00 | 0;
        this._a16 = a16 | 0;
        this._a32 = a32 | 0;
        this._a48 = a48 | 0;
        return this;
      }
      UINT64.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._a00 = value & 65535;
        this._a16 = value >>> 16;
        this._a32 = 0;
        this._a48 = 0;
        return this;
      }
      UINT64.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        radix = radix || 10;
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        var radixUint = radixPowerCache[radix] || new UINT64(Math.pow(radix, 5));
        for (var i = 0, len = s.length; i < len; i += 5) {
          var size2 = Math.min(5, len - i);
          var value = parseInt(s.slice(i, i + size2), radix);
          this.multiply(
            size2 < 5 ? new UINT64(Math.pow(radix, size2)) : radixUint
          ).add(new UINT64(value));
        }
        return this;
      }
      UINT64.prototype.fromString = fromString;
      UINT64.prototype.toNumber = function() {
        return this._a16 * 65536 + this._a00;
      };
      UINT64.prototype.toString = function(radix) {
        radix = radix || 10;
        var radixUint = radixCache[radix] || new UINT64(radix);
        if (!this.gt(radixUint))
          return this.toNumber().toString(radix);
        var self2 = this.clone();
        var res = new Array(64);
        for (var i = 63; i >= 0; i--) {
          self2.div(radixUint);
          res[i] = self2.remainder.toNumber().toString(radix);
          if (!self2.gt(radixUint))
            break;
        }
        res[i - 1] = self2.toNumber().toString(radix);
        return res.join("");
      };
      UINT64.prototype.add = function(other) {
        var a00 = this._a00 + other._a00;
        var a16 = a00 >>> 16;
        a16 += this._a16 + other._a16;
        var a32 = a16 >>> 16;
        a32 += this._a32 + other._a32;
        var a48 = a32 >>> 16;
        a48 += this._a48 + other._a48;
        this._a00 = a00 & 65535;
        this._a16 = a16 & 65535;
        this._a32 = a32 & 65535;
        this._a48 = a48 & 65535;
        return this;
      };
      UINT64.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT64.prototype.multiply = function(other) {
        var a00 = this._a00;
        var a16 = this._a16;
        var a32 = this._a32;
        var a48 = this._a48;
        var b00 = other._a00;
        var b16 = other._a16;
        var b32 = other._a32;
        var b48 = other._a48;
        var c00 = a00 * b00;
        var c16 = c00 >>> 16;
        c16 += a00 * b16;
        var c32 = c16 >>> 16;
        c16 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c32 += a00 * b32;
        var c48 = c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c48 += a00 * b48;
        c48 &= 65535;
        c48 += a16 * b32;
        c48 &= 65535;
        c48 += a32 * b16;
        c48 &= 65535;
        c48 += a48 * b00;
        this._a00 = c00 & 65535;
        this._a16 = c16 & 65535;
        this._a32 = c32 & 65535;
        this._a48 = c48 & 65535;
        return this;
      };
      UINT64.prototype.div = function(other) {
        if (other._a16 == 0 && other._a32 == 0 && other._a48 == 0) {
          if (other._a00 == 0)
            throw Error("division by zero");
          if (other._a00 == 1) {
            this.remainder = new UINT64(0);
            return this;
          }
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._a00 = 0;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT64(0);
          this._a00 = 1;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 48) {
              this._a48 |= 1 << i - 48;
            } else if (i >= 32) {
              this._a32 |= 1 << i - 32;
            } else if (i >= 16) {
              this._a16 |= 1 << i - 16;
            } else {
              this._a00 |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT64.prototype.negate = function() {
        var v = (~this._a00 & 65535) + 1;
        this._a00 = v & 65535;
        v = (~this._a16 & 65535) + (v >>> 16);
        this._a16 = v & 65535;
        v = (~this._a32 & 65535) + (v >>> 16);
        this._a32 = v & 65535;
        this._a48 = ~this._a48 + (v >>> 16) & 65535;
        return this;
      };
      UINT64.prototype.equals = UINT64.prototype.eq = function(other) {
        return this._a48 == other._a48 && this._a00 == other._a00 && this._a32 == other._a32 && this._a16 == other._a16;
      };
      UINT64.prototype.greaterThan = UINT64.prototype.gt = function(other) {
        if (this._a48 > other._a48)
          return true;
        if (this._a48 < other._a48)
          return false;
        if (this._a32 > other._a32)
          return true;
        if (this._a32 < other._a32)
          return false;
        if (this._a16 > other._a16)
          return true;
        if (this._a16 < other._a16)
          return false;
        return this._a00 > other._a00;
      };
      UINT64.prototype.lessThan = UINT64.prototype.lt = function(other) {
        if (this._a48 < other._a48)
          return true;
        if (this._a48 > other._a48)
          return false;
        if (this._a32 < other._a32)
          return true;
        if (this._a32 > other._a32)
          return false;
        if (this._a16 < other._a16)
          return true;
        if (this._a16 > other._a16)
          return false;
        return this._a00 < other._a00;
      };
      UINT64.prototype.or = function(other) {
        this._a00 |= other._a00;
        this._a16 |= other._a16;
        this._a32 |= other._a32;
        this._a48 |= other._a48;
        return this;
      };
      UINT64.prototype.and = function(other) {
        this._a00 &= other._a00;
        this._a16 &= other._a16;
        this._a32 &= other._a32;
        this._a48 &= other._a48;
        return this;
      };
      UINT64.prototype.xor = function(other) {
        this._a00 ^= other._a00;
        this._a16 ^= other._a16;
        this._a32 ^= other._a32;
        this._a48 ^= other._a48;
        return this;
      };
      UINT64.prototype.not = function() {
        this._a00 = ~this._a00 & 65535;
        this._a16 = ~this._a16 & 65535;
        this._a32 = ~this._a32 & 65535;
        this._a48 = ~this._a48 & 65535;
        return this;
      };
      UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function(n) {
        n %= 64;
        if (n >= 48) {
          this._a00 = this._a48 >> n - 48;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a00 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a16 = this._a48 >> n & 65535;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a00 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a16 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a32 = this._a48 >> n & 65535;
          this._a48 = 0;
        } else {
          this._a00 = (this._a00 >> n | this._a16 << 16 - n) & 65535;
          this._a16 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a32 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a48 = this._a48 >> n & 65535;
        }
        return this;
      };
      UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function(n, allowOverflow) {
        n %= 64;
        if (n >= 48) {
          this._a48 = this._a00 << n - 48;
          this._a32 = 0;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a48 = this._a16 << n | this._a00 >> 16 - n;
          this._a32 = this._a00 << n & 65535;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a48 = this._a32 << n | this._a16 >> 16 - n;
          this._a32 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a16 = this._a00 << n & 65535;
          this._a00 = 0;
        } else {
          this._a48 = this._a48 << n | this._a32 >> 16 - n;
          this._a32 = (this._a32 << n | this._a16 >> 16 - n) & 65535;
          this._a16 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a00 = this._a00 << n & 65535;
        }
        if (!allowOverflow) {
          this._a48 &= 65535;
        }
        return this;
      };
      UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high << n | low >>> 32 - n;
        var _low = low << n | high >>> 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.rotateRight = UINT64.prototype.rotr = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high >>> n | low << 32 - n;
        var _low = low >>> n | high << 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.clone = function() {
        return new UINT64(this._a00, this._a16, this._a32, this._a48);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT64;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT64;
      } else {
        root["UINT64"] = UINT64;
      }
    })(exports);
  }
});

// node_modules/cuint/index.js
var require_cuint = __commonJS({
  "node_modules/cuint/index.js"(exports) {
    exports.UINT32 = require_uint32();
    exports.UINT64 = require_uint64();
  }
});

// node_modules/xxhashjs/lib/xxhash.js
var require_xxhash = __commonJS({
  "node_modules/xxhashjs/lib/xxhash.js"(exports, module2) {
    var UINT32 = require_cuint().UINT32;
    UINT32.prototype.xxh_update = function(low, high) {
      var b00 = PRIME32_2._low;
      var b16 = PRIME32_2._high;
      var c16, c00;
      c00 = low * b00;
      c16 = c00 >>> 16;
      c16 += high * b00;
      c16 &= 65535;
      c16 += low * b16;
      var a00 = this._low + (c00 & 65535);
      var a16 = a00 >>> 16;
      a16 += this._high + (c16 & 65535);
      var v = a16 << 16 | a00 & 65535;
      v = v << 13 | v >>> 19;
      a00 = v & 65535;
      a16 = v >>> 16;
      b00 = PRIME32_1._low;
      b16 = PRIME32_1._high;
      c00 = a00 * b00;
      c16 = c00 >>> 16;
      c16 += a16 * b00;
      c16 &= 65535;
      c16 += a00 * b16;
      this._low = c00 & 65535;
      this._high = c16 & 65535;
    };
    var PRIME32_1 = UINT32("2654435761");
    var PRIME32_2 = UINT32("2246822519");
    var PRIME32_3 = UINT32("3266489917");
    var PRIME32_4 = UINT32("668265263");
    var PRIME32_5 = UINT32("374761393");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH2() {
      if (arguments.length == 2)
        return new XXH2(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH2))
        return new XXH2(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
      this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
      this.v2 = this.seed.clone().add(PRIME32_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME32_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH2.prototype.init = init;
    XXH2.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(16);
        } else {
          this.memory = new Buffer(16);
        }
      }
      if (this.memsize + len < 16) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 16 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 16 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 16 - this.memsize);
        }
        var p32 = 0;
        if (isString) {
          this.v1.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
        } else {
          this.v1.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
        }
        p += 16 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 16) {
        var limit = bEnd - 16;
        do {
          if (isString) {
            this.v1.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v2.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v3.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v4.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
          } else {
            this.v1.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v2.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v3.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v4.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
          }
          p += 4;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH2.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h322, h;
      var u = new UINT32();
      if (this.total_len >= 16) {
        h322 = this.v1.rotl(1).add(this.v2.rotl(7).add(this.v3.rotl(12).add(this.v4.rotl(18))));
      } else {
        h322 = this.seed.clone().add(PRIME32_5);
      }
      h322.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 4) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2]
          );
        }
        h322.add(u.multiply(PRIME32_3)).rotl(17).multiply(PRIME32_4);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0);
        h322.add(u.multiply(PRIME32_5)).rotl(11).multiply(PRIME32_1);
      }
      h = h322.clone().shiftRight(15);
      h322.xor(h).multiply(PRIME32_2);
      h = h322.clone().shiftRight(13);
      h322.xor(h).multiply(PRIME32_3);
      h = h322.clone().shiftRight(16);
      h322.xor(h);
      this.init(this.seed);
      return h322;
    };
    module2.exports = XXH2;
  }
});

// node_modules/xxhashjs/lib/xxhash64.js
var require_xxhash64 = __commonJS({
  "node_modules/xxhashjs/lib/xxhash64.js"(exports, module2) {
    var UINT64 = require_cuint().UINT64;
    var PRIME64_1 = UINT64("11400714785074694791");
    var PRIME64_2 = UINT64("14029467366897019727");
    var PRIME64_3 = UINT64("1609587929392839161");
    var PRIME64_4 = UINT64("9650029242287828579");
    var PRIME64_5 = UINT64("2870177450012600261");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH64() {
      if (arguments.length == 2)
        return new XXH64(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH64))
        return new XXH64(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
      this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
      this.v2 = this.seed.clone().add(PRIME64_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME64_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH64.prototype.init = init;
    XXH64.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(32);
        } else {
          this.memory = new Buffer(32);
        }
      }
      if (this.memsize + len < 32) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 32 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 32 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 32 - this.memsize);
        }
        var p64 = 0;
        if (isString) {
          var other;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        } else {
          var other;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        }
        p += 32 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 32) {
        var limit = bEnd - 32;
        do {
          if (isString) {
            var other;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          } else {
            var other;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          }
          p += 8;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH64.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h64, h;
      var u = new UINT64();
      if (this.total_len >= 32) {
        h64 = this.v1.clone().rotl(1);
        h64.add(this.v2.clone().rotl(7));
        h64.add(this.v3.clone().rotl(12));
        h64.add(this.v4.clone().rotl(18));
        h64.xor(this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
      } else {
        h64 = this.seed.clone().add(PRIME64_5);
      }
      h64.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 8) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
            input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            input[p + 5] << 8 | input[p + 4],
            input[p + 7] << 8 | input[p + 6]
          );
        }
        u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
        h64.xor(u).rotl(27).multiply(PRIME64_1).add(PRIME64_4);
        p += 8;
      }
      if (p + 4 <= bEnd) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            0,
            0
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            0,
            0
          );
        }
        h64.xor(u.multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0);
        h64.xor(u.multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);
      }
      h = h64.clone().shiftRight(33);
      h64.xor(h).multiply(PRIME64_2);
      h = h64.clone().shiftRight(29);
      h64.xor(h).multiply(PRIME64_3);
      h = h64.clone().shiftRight(32);
      h64.xor(h);
      this.init(this.seed);
      return h64;
    };
    module2.exports = XXH64;
  }
});

// node_modules/xxhashjs/lib/index.js
var require_lib = __commonJS({
  "node_modules/xxhashjs/lib/index.js"(exports, module2) {
    module2.exports = {
      h32: require_xxhash(),
      h64: require_xxhash64()
    };
  }
});

// node_modules/simple-peer/simplepeer.min.js
var require_simplepeer_min = __commonJS({
  "node_modules/simple-peer/simplepeer.min.js"(exports, module2) {
    (function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var t;
        t = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t.SimplePeer = e();
      }
    })(function() {
      var t = Math.floor, n = Math.abs, r = Math.pow;
      return function() {
        function d(s, e, n2) {
          function t2(o, i) {
            if (!e[o]) {
              if (!s[o]) {
                var l = "function" == typeof require && require;
                if (!i && l)
                  return l(o, true);
                if (r2)
                  return r2(o, true);
                var c = new Error("Cannot find module '" + o + "'");
                throw c.code = "MODULE_NOT_FOUND", c;
              }
              var a2 = e[o] = { exports: {} };
              s[o][0].call(a2.exports, function(e2) {
                var r3 = s[o][1][e2];
                return t2(r3 || e2);
              }, a2, a2.exports, d, s, e, n2);
            }
            return e[o].exports;
          }
          for (var r2 = "function" == typeof require && require, a = 0; a < n2.length; a++)
            t2(n2[a]);
          return t2;
        }
        return d;
      }()({ 1: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          var t3 = e2.length;
          if (0 < t3 % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var n3 = e2.indexOf("=");
          -1 === n3 && (n3 = t3);
          var r3 = n3 === t3 ? 0 : 4 - n3 % 4;
          return [n3, r3];
        }
        function a(e2, t3, n3) {
          return 3 * (t3 + n3) / 4 - n3;
        }
        function o(e2) {
          var t3, n3, o2 = r2(e2), d2 = o2[0], s2 = o2[1], l2 = new p(a(e2, d2, s2)), c2 = 0, f2 = 0 < s2 ? d2 - 4 : d2;
          for (n3 = 0; n3 < f2; n3 += 4)
            t3 = u[e2.charCodeAt(n3)] << 18 | u[e2.charCodeAt(n3 + 1)] << 12 | u[e2.charCodeAt(n3 + 2)] << 6 | u[e2.charCodeAt(n3 + 3)], l2[c2++] = 255 & t3 >> 16, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3;
          return 2 === s2 && (t3 = u[e2.charCodeAt(n3)] << 2 | u[e2.charCodeAt(n3 + 1)] >> 4, l2[c2++] = 255 & t3), 1 === s2 && (t3 = u[e2.charCodeAt(n3)] << 10 | u[e2.charCodeAt(n3 + 1)] << 4 | u[e2.charCodeAt(n3 + 2)] >> 2, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3), l2;
        }
        function d(e2) {
          return c[63 & e2 >> 18] + c[63 & e2 >> 12] + c[63 & e2 >> 6] + c[63 & e2];
        }
        function s(e2, t3, n3) {
          for (var r3, a2 = [], o2 = t3; o2 < n3; o2 += 3)
            r3 = (16711680 & e2[o2] << 16) + (65280 & e2[o2 + 1] << 8) + (255 & e2[o2 + 2]), a2.push(d(r3));
          return a2.join("");
        }
        function l(e2) {
          for (var t3, n3 = e2.length, r3 = n3 % 3, a2 = [], o2 = 16383, d2 = 0, l2 = n3 - r3; d2 < l2; d2 += o2)
            a2.push(s(e2, d2, d2 + o2 > l2 ? l2 : d2 + o2));
          return 1 === r3 ? (t3 = e2[n3 - 1], a2.push(c[t3 >> 2] + c[63 & t3 << 4] + "==")) : 2 === r3 && (t3 = (e2[n3 - 2] << 8) + e2[n3 - 1], a2.push(c[t3 >> 10] + c[63 & t3 >> 4] + c[63 & t3 << 2] + "=")), a2.join("");
        }
        n2.byteLength = function(e2) {
          var t3 = r2(e2), n3 = t3[0], a2 = t3[1];
          return 3 * (n3 + a2) / 4 - a2;
        }, n2.toByteArray = o, n2.fromByteArray = l;
        for (var c = [], u = [], p = "undefined" == typeof Uint8Array ? Array : Uint8Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, _ = f.length; g < _; ++g)
          c[g] = f[g], u[f.charCodeAt(g)] = g;
        u[45] = 62, u[95] = 63;
      }, {}], 2: [function() {
      }, {}], 3: [function(e, t2, n2) {
        (function() {
          (function() {
            "use strict";
            var t3 = String.fromCharCode, o = Math.min;
            function d(e2) {
              if (2147483647 < e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t4 = new Uint8Array(e2);
              return t4.__proto__ = s.prototype, t4;
            }
            function s(e2, t4, n3) {
              if ("number" == typeof e2) {
                if ("string" == typeof t4)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return p(e2);
              }
              return l(e2, t4, n3);
            }
            function l(e2, t4, n3) {
              if ("string" == typeof e2)
                return f(e2, t4);
              if (ArrayBuffer.isView(e2))
                return g(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (K(e2, ArrayBuffer) || e2 && K(e2.buffer, ArrayBuffer))
                return _(e2, t4, n3);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var r2 = e2.valueOf && e2.valueOf();
              if (null != r2 && r2 !== e2)
                return s.from(r2, t4, n3);
              var a = h(e2);
              if (a)
                return a;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return s.from(e2[Symbol.toPrimitive]("string"), t4, n3);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function c(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              else if (0 > e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u(e2, t4, n3) {
              return c(e2), 0 >= e2 ? d(e2) : void 0 === t4 ? d(e2) : "string" == typeof n3 ? d(e2).fill(t4, n3) : d(e2).fill(t4);
            }
            function p(e2) {
              return c(e2), d(0 > e2 ? 0 : 0 | m(e2));
            }
            function f(e2, t4) {
              if (("string" != typeof t4 || "" === t4) && (t4 = "utf8"), !s.isEncoding(t4))
                throw new TypeError("Unknown encoding: " + t4);
              var n3 = 0 | b(e2, t4), r2 = d(n3), a = r2.write(e2, t4);
              return a !== n3 && (r2 = r2.slice(0, a)), r2;
            }
            function g(e2) {
              for (var t4 = 0 > e2.length ? 0 : 0 | m(e2.length), n3 = d(t4), r2 = 0; r2 < t4; r2 += 1)
                n3[r2] = 255 & e2[r2];
              return n3;
            }
            function _(e2, t4, n3) {
              if (0 > t4 || e2.byteLength < t4)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (e2.byteLength < t4 + (n3 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var r2;
              return r2 = void 0 === t4 && void 0 === n3 ? new Uint8Array(e2) : void 0 === n3 ? new Uint8Array(e2, t4) : new Uint8Array(e2, t4, n3), r2.__proto__ = s.prototype, r2;
            }
            function h(e2) {
              if (s.isBuffer(e2)) {
                var t4 = 0 | m(e2.length), n3 = d(t4);
                return 0 === n3.length ? n3 : (e2.copy(n3, 0, 0, t4), n3);
              }
              return void 0 === e2.length ? "Buffer" === e2.type && Array.isArray(e2.data) ? g(e2.data) : void 0 : "number" != typeof e2.length || X(e2.length) ? d(0) : g(e2);
            }
            function m(e2) {
              if (e2 >= 2147483647)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
              return 0 | e2;
            }
            function b(e2, t4) {
              if (s.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || K(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var n3 = e2.length, r2 = 2 < arguments.length && true === arguments[2];
              if (!r2 && 0 === n3)
                return 0;
              for (var a = false; ; )
                switch (t4) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n3;
                  case "utf8":
                  case "utf-8":
                    return H(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n3;
                  case "hex":
                    return n3 >>> 1;
                  case "base64":
                    return z(e2).length;
                  default:
                    if (a)
                      return r2 ? -1 : H(e2).length;
                    t4 = ("" + t4).toLowerCase(), a = true;
                }
            }
            function y(e2, t4, n3) {
              var r2 = false;
              if ((void 0 === t4 || 0 > t4) && (t4 = 0), t4 > this.length)
                return "";
              if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), 0 >= n3)
                return "";
              if (n3 >>>= 0, t4 >>>= 0, n3 <= t4)
                return "";
              for (e2 || (e2 = "utf8"); ; )
                switch (e2) {
                  case "hex":
                    return P(this, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return x(this, t4, n3);
                  case "ascii":
                    return D(this, t4, n3);
                  case "latin1":
                  case "binary":
                    return I(this, t4, n3);
                  case "base64":
                    return A(this, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, t4, n3);
                  default:
                    if (r2)
                      throw new TypeError("Unknown encoding: " + e2);
                    e2 = (e2 + "").toLowerCase(), r2 = true;
                }
            }
            function C(e2, t4, n3) {
              var r2 = e2[t4];
              e2[t4] = e2[n3], e2[n3] = r2;
            }
            function R(e2, t4, n3, r2, a) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof n3 ? (r2 = n3, n3 = 0) : 2147483647 < n3 ? n3 = 2147483647 : -2147483648 > n3 && (n3 = -2147483648), n3 = +n3, X(n3) && (n3 = a ? 0 : e2.length - 1), 0 > n3 && (n3 = e2.length + n3), n3 >= e2.length) {
                if (a)
                  return -1;
                n3 = e2.length - 1;
              } else if (0 > n3)
                if (a)
                  n3 = 0;
                else
                  return -1;
              if ("string" == typeof t4 && (t4 = s.from(t4, r2)), s.isBuffer(t4))
                return 0 === t4.length ? -1 : E(e2, t4, n3, r2, a);
              if ("number" == typeof t4)
                return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a ? Uint8Array.prototype.indexOf.call(e2, t4, n3) : Uint8Array.prototype.lastIndexOf.call(e2, t4, n3) : E(e2, [t4], n3, r2, a);
              throw new TypeError("val must be string, number or Buffer");
            }
            function E(e2, t4, n3, r2, a) {
              function o2(e3, t5) {
                return 1 === d2 ? e3[t5] : e3.readUInt16BE(t5 * d2);
              }
              var d2 = 1, s2 = e2.length, l2 = t4.length;
              if (void 0 !== r2 && (r2 = (r2 + "").toLowerCase(), "ucs2" === r2 || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
                if (2 > e2.length || 2 > t4.length)
                  return -1;
                d2 = 2, s2 /= 2, l2 /= 2, n3 /= 2;
              }
              var c2;
              if (a) {
                var u2 = -1;
                for (c2 = n3; c2 < s2; c2++)
                  if (o2(e2, c2) !== o2(t4, -1 === u2 ? 0 : c2 - u2))
                    -1 !== u2 && (c2 -= c2 - u2), u2 = -1;
                  else if (-1 === u2 && (u2 = c2), c2 - u2 + 1 === l2)
                    return u2 * d2;
              } else
                for (n3 + l2 > s2 && (n3 = s2 - l2), c2 = n3; 0 <= c2; c2--) {
                  for (var p2 = true, f2 = 0; f2 < l2; f2++)
                    if (o2(e2, c2 + f2) !== o2(t4, f2)) {
                      p2 = false;
                      break;
                    }
                  if (p2)
                    return c2;
                }
              return -1;
            }
            function w(e2, t4, n3, r2) {
              n3 = +n3 || 0;
              var a = e2.length - n3;
              r2 ? (r2 = +r2, r2 > a && (r2 = a)) : r2 = a;
              var o2 = t4.length;
              r2 > o2 / 2 && (r2 = o2 / 2);
              for (var d2, s2 = 0; s2 < r2; ++s2) {
                if (d2 = parseInt(t4.substr(2 * s2, 2), 16), X(d2))
                  return s2;
                e2[n3 + s2] = d2;
              }
              return s2;
            }
            function S(e2, t4, n3, r2) {
              return G(H(t4, e2.length - n3), e2, n3, r2);
            }
            function T(e2, t4, n3, r2) {
              return G(Y(t4), e2, n3, r2);
            }
            function v(e2, t4, n3, r2) {
              return T(e2, t4, n3, r2);
            }
            function k(e2, t4, n3, r2) {
              return G(z(t4), e2, n3, r2);
            }
            function L(e2, t4, n3, r2) {
              return G(V(t4, e2.length - n3), e2, n3, r2);
            }
            function A(e2, t4, n3) {
              return 0 === t4 && n3 === e2.length ? $.fromByteArray(e2) : $.fromByteArray(e2.slice(t4, n3));
            }
            function x(e2, t4, n3) {
              n3 = o(e2.length, n3);
              for (var r2 = [], a = t4; a < n3; ) {
                var d2 = e2[a], s2 = null, l2 = 239 < d2 ? 4 : 223 < d2 ? 3 : 191 < d2 ? 2 : 1;
                if (a + l2 <= n3) {
                  var c2, u2, p2, f2;
                  1 === l2 ? 128 > d2 && (s2 = d2) : 2 === l2 ? (c2 = e2[a + 1], 128 == (192 & c2) && (f2 = (31 & d2) << 6 | 63 & c2, 127 < f2 && (s2 = f2))) : 3 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], 128 == (192 & c2) && 128 == (192 & u2) && (f2 = (15 & d2) << 12 | (63 & c2) << 6 | 63 & u2, 2047 < f2 && (55296 > f2 || 57343 < f2) && (s2 = f2))) : 4 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], p2 = e2[a + 3], 128 == (192 & c2) && 128 == (192 & u2) && 128 == (192 & p2) && (f2 = (15 & d2) << 18 | (63 & c2) << 12 | (63 & u2) << 6 | 63 & p2, 65535 < f2 && 1114112 > f2 && (s2 = f2))) : void 0;
                }
                null === s2 ? (s2 = 65533, l2 = 1) : 65535 < s2 && (s2 -= 65536, r2.push(55296 | 1023 & s2 >>> 10), s2 = 56320 | 1023 & s2), r2.push(s2), a += l2;
              }
              return N(r2);
            }
            function N(e2) {
              var n3 = e2.length;
              if (n3 <= 4096)
                return t3.apply(String, e2);
              for (var r2 = "", a = 0; a < n3; )
                r2 += t3.apply(String, e2.slice(a, a += 4096));
              return r2;
            }
            function D(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(127 & e2[d2]);
              return a;
            }
            function I(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(e2[d2]);
              return a;
            }
            function P(e2, t4, n3) {
              var r2 = e2.length;
              (!t4 || 0 > t4) && (t4 = 0), (!n3 || 0 > n3 || n3 > r2) && (n3 = r2);
              for (var a = "", o2 = t4; o2 < n3; ++o2)
                a += W(e2[o2]);
              return a;
            }
            function M(e2, n3, r2) {
              for (var a = e2.slice(n3, r2), o2 = "", d2 = 0; d2 < a.length; d2 += 2)
                o2 += t3(a[d2] + 256 * a[d2 + 1]);
              return o2;
            }
            function O(e2, t4, n3) {
              if (0 != e2 % 1 || 0 > e2)
                throw new RangeError("offset is not uint");
              if (e2 + t4 > n3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function F(e2, t4, n3, r2, a, o2) {
              if (!s.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t4 > a || t4 < o2)
                throw new RangeError('"value" argument is out of bounds');
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function B(e2, t4, n3, r2) {
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
              if (0 > n3)
                throw new RangeError("Index out of range");
            }
            function U(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 4, 34028234663852886e22, -34028234663852886e22), J.write(e2, t4, n3, r2, 23, 4), n3 + 4;
            }
            function j(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 8, 17976931348623157e292, -17976931348623157e292), J.write(e2, t4, n3, r2, 52, 8), n3 + 8;
            }
            function q(e2) {
              if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Q, ""), 2 > e2.length)
                return "";
              for (; 0 != e2.length % 4; )
                e2 += "=";
              return e2;
            }
            function W(e2) {
              return 16 > e2 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function H(e2, t4) {
              t4 = t4 || 1 / 0;
              for (var n3, r2 = e2.length, a = null, o2 = [], d2 = 0; d2 < r2; ++d2) {
                if (n3 = e2.charCodeAt(d2), 55295 < n3 && 57344 > n3) {
                  if (!a) {
                    if (56319 < n3) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    } else if (d2 + 1 === r2) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    }
                    a = n3;
                    continue;
                  }
                  if (56320 > n3) {
                    -1 < (t4 -= 3) && o2.push(239, 191, 189), a = n3;
                    continue;
                  }
                  n3 = (a - 55296 << 10 | n3 - 56320) + 65536;
                } else
                  a && -1 < (t4 -= 3) && o2.push(239, 191, 189);
                if (a = null, 128 > n3) {
                  if (0 > (t4 -= 1))
                    break;
                  o2.push(n3);
                } else if (2048 > n3) {
                  if (0 > (t4 -= 2))
                    break;
                  o2.push(192 | n3 >> 6, 128 | 63 & n3);
                } else if (65536 > n3) {
                  if (0 > (t4 -= 3))
                    break;
                  o2.push(224 | n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else if (1114112 > n3) {
                  if (0 > (t4 -= 4))
                    break;
                  o2.push(240 | n3 >> 18, 128 | 63 & n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else
                  throw new Error("Invalid code point");
              }
              return o2;
            }
            function Y(e2) {
              for (var t4 = [], n3 = 0; n3 < e2.length; ++n3)
                t4.push(255 & e2.charCodeAt(n3));
              return t4;
            }
            function V(e2, t4) {
              for (var n3, r2, a, o2 = [], d2 = 0; d2 < e2.length && !(0 > (t4 -= 2)); ++d2)
                n3 = e2.charCodeAt(d2), r2 = n3 >> 8, a = n3 % 256, o2.push(a), o2.push(r2);
              return o2;
            }
            function z(e2) {
              return $.toByteArray(q(e2));
            }
            function G(e2, t4, n3, r2) {
              for (var a = 0; a < r2 && !(a + n3 >= t4.length || a >= e2.length); ++a)
                t4[a + n3] = e2[a];
              return a;
            }
            function K(e2, t4) {
              return e2 instanceof t4 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t4.name;
            }
            function X(e2) {
              return e2 !== e2;
            }
            var $ = e("base64-js"), J = e("ieee754");
            n2.Buffer = s, n2.SlowBuffer = function(e2) {
              return +e2 != e2 && (e2 = 0), s.alloc(+e2);
            }, n2.INSPECT_MAX_BYTES = 50;
            n2.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (t4) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.buffer : void 0;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.byteOffset : void 0;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t4, n3) {
              return l(e2, t4, n3);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t4, n3) {
              return u(e2, t4, n3);
            }, s.allocUnsafe = function(e2) {
              return p(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return p(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t4) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), K(t4, Uint8Array) && (t4 = s.from(t4, t4.offset, t4.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t4))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t4)
                return 0;
              for (var n3 = e2.length, r2 = t4.length, d2 = 0, l2 = o(n3, r2); d2 < l2; ++d2)
                if (e2[d2] !== t4[d2]) {
                  n3 = e2[d2], r2 = t4[d2];
                  break;
                }
              return n3 < r2 ? -1 : r2 < n3 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch ((e2 + "").toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t4) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return s.alloc(0);
              var n3;
              if (t4 === void 0)
                for (t4 = 0, n3 = 0; n3 < e2.length; ++n3)
                  t4 += e2[n3].length;
              var r2 = s.allocUnsafe(t4), a = 0;
              for (n3 = 0; n3 < e2.length; ++n3) {
                var o2 = e2[n3];
                if (K(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(r2, a), a += o2.length;
              }
              return r2;
            }, s.byteLength = b, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (0 != e2 % 2)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t4 = 0; t4 < e2; t4 += 2)
                C(this, t4, t4 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (0 != e2 % 4)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t4 = 0; t4 < e2; t4 += 4)
                C(this, t4, t4 + 3), C(this, t4 + 1, t4 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (0 != e2 % 8)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t4 = 0; t4 < e2; t4 += 8)
                C(this, t4, t4 + 7), C(this, t4 + 1, t4 + 6), C(this, t4 + 2, t4 + 5), C(this, t4 + 3, t4 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? x(this, 0, e2) : y.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t4 = n2.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t4, n3, r2, a) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t4 && (t4 = 0), void 0 === n3 && (n3 = e2 ? e2.length : 0), void 0 === r2 && (r2 = 0), void 0 === a && (a = this.length), 0 > t4 || n3 > e2.length || 0 > r2 || a > this.length)
                throw new RangeError("out of range index");
              if (r2 >= a && t4 >= n3)
                return 0;
              if (r2 >= a)
                return -1;
              if (t4 >= n3)
                return 1;
              if (t4 >>>= 0, n3 >>>= 0, r2 >>>= 0, a >>>= 0, this === e2)
                return 0;
              for (var d2 = a - r2, l2 = n3 - t4, c2 = o(d2, l2), u2 = this.slice(r2, a), p2 = e2.slice(t4, n3), f2 = 0; f2 < c2; ++f2)
                if (u2[f2] !== p2[f2]) {
                  d2 = u2[f2], l2 = p2[f2];
                  break;
                }
              return d2 < l2 ? -1 : l2 < d2 ? 1 : 0;
            }, s.prototype.includes = function(e2, t4, n3) {
              return -1 !== this.indexOf(e2, t4, n3);
            }, s.prototype.indexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, true);
            }, s.prototype.lastIndexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, false);
            }, s.prototype.write = function(e2, t4, n3, r2) {
              if (void 0 === t4)
                r2 = "utf8", n3 = this.length, t4 = 0;
              else if (void 0 === n3 && "string" == typeof t4)
                r2 = t4, n3 = this.length, t4 = 0;
              else if (isFinite(t4))
                t4 >>>= 0, isFinite(n3) ? (n3 >>>= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n3, n3 = void 0);
              else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              var a = this.length - t4;
              if ((void 0 === n3 || n3 > a) && (n3 = a), 0 < e2.length && (0 > n3 || 0 > t4) || t4 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              r2 || (r2 = "utf8");
              for (var o2 = false; ; )
                switch (r2) {
                  case "hex":
                    return w(this, e2, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return S(this, e2, t4, n3);
                  case "ascii":
                    return T(this, e2, t4, n3);
                  case "latin1":
                  case "binary":
                    return v(this, e2, t4, n3);
                  case "base64":
                    return k(this, e2, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return L(this, e2, t4, n3);
                  default:
                    if (o2)
                      throw new TypeError("Unknown encoding: " + r2);
                    r2 = ("" + r2).toLowerCase(), o2 = true;
                }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            s.prototype.slice = function(e2, t4) {
              var n3 = this.length;
              e2 = ~~e2, t4 = t4 === void 0 ? n3 : ~~t4, 0 > e2 ? (e2 += n3, 0 > e2 && (e2 = 0)) : e2 > n3 && (e2 = n3), 0 > t4 ? (t4 += n3, 0 > t4 && (t4 = 0)) : t4 > n3 && (t4 = n3), t4 < e2 && (t4 = e2);
              var r2 = this.subarray(e2, t4);
              return r2.__proto__ = s.prototype, r2;
            }, s.prototype.readUIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2], a = 1, o2 = 0; ++o2 < t4 && (a *= 256); )
                r2 += this[e2 + o2] * a;
              return r2;
            }, s.prototype.readUIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2 + --t4], a = 1; 0 < t4 && (a *= 256); )
                r2 += this[e2 + --t4] * a;
              return r2;
            }, s.prototype.readUInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = this[e2], o2 = 1, d2 = 0; ++d2 < t4 && (o2 *= 256); )
                a += this[e2 + d2] * o2;
              return o2 *= 128, a >= o2 && (a -= r(2, 8 * t4)), a;
            }, s.prototype.readIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = t4, o2 = 1, d2 = this[e2 + --a]; 0 < a && (o2 *= 256); )
                d2 += this[e2 + --a] * o2;
              return o2 *= 128, d2 >= o2 && (d2 -= r(2, 8 * t4)), d2;
            }, s.prototype.readInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2] | this[e2 + 1] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt16BE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2 + 1] | this[e2] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = 1, s2 = 0;
              for (this[t4] = 255 & e2; ++s2 < n3 && (d2 *= 256); )
                this[t4 + s2] = 255 & e2 / d2;
              return t4 + n3;
            }, s.prototype.writeUIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = n3 - 1, s2 = 1;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                this[t4 + d2] = 255 & e2 / s2;
              return t4 + n3;
            }, s.prototype.writeUInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 255, 0), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4 + 3] = e2 >>> 24, this[t4 + 2] = e2 >>> 16, this[t4 + 1] = e2 >>> 8, this[t4] = 255 & e2, t4 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = 0, s2 = 1, l2 = 0;
              for (this[t4] = 255 & e2; ++d2 < n3 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 - 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = n3 - 1, s2 = 1, l2 = 0;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 + 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 127, -128), 0 > e2 && (e2 = 255 + e2 + 1), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, this[t4 + 2] = e2 >>> 16, this[t4 + 3] = e2 >>> 24, t4 + 4;
            }, s.prototype.writeInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), 0 > e2 && (e2 = 4294967295 + e2 + 1), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeFloatLE = function(e2, t4, n3) {
              return U(this, e2, t4, true, n3);
            }, s.prototype.writeFloatBE = function(e2, t4, n3) {
              return U(this, e2, t4, false, n3);
            }, s.prototype.writeDoubleLE = function(e2, t4, n3) {
              return j(this, e2, t4, true, n3);
            }, s.prototype.writeDoubleBE = function(e2, t4, n3) {
              return j(this, e2, t4, false, n3);
            }, s.prototype.copy = function(e2, t4, n3, r2) {
              if (!s.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (n3 || (n3 = 0), r2 || 0 === r2 || (r2 = this.length), t4 >= e2.length && (t4 = e2.length), t4 || (t4 = 0), 0 < r2 && r2 < n3 && (r2 = n3), r2 === n3)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (0 > t4)
                throw new RangeError("targetStart out of bounds");
              if (0 > n3 || n3 >= this.length)
                throw new RangeError("Index out of range");
              if (0 > r2)
                throw new RangeError("sourceEnd out of bounds");
              r2 > this.length && (r2 = this.length), e2.length - t4 < r2 - n3 && (r2 = e2.length - t4 + n3);
              var a = r2 - n3;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t4, n3, r2);
              else if (this === e2 && n3 < t4 && t4 < r2)
                for (var o2 = a - 1; 0 <= o2; --o2)
                  e2[o2 + t4] = this[o2 + n3];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(n3, r2), t4);
              return a;
            }, s.prototype.fill = function(e2, t4, n3, r2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t4 ? (r2 = t4, t4 = 0, n3 = this.length) : "string" == typeof n3 && (r2 = n3, n3 = this.length), void 0 !== r2 && "string" != typeof r2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof r2 && !s.isEncoding(r2))
                  throw new TypeError("Unknown encoding: " + r2);
                if (1 === e2.length) {
                  var a = e2.charCodeAt(0);
                  ("utf8" === r2 && 128 > a || "latin1" === r2) && (e2 = a);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (0 > t4 || this.length < t4 || this.length < n3)
                throw new RangeError("Out of range index");
              if (n3 <= t4)
                return this;
              t4 >>>= 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e2 || (e2 = 0);
              var o2;
              if ("number" == typeof e2)
                for (o2 = t4; o2 < n3; ++o2)
                  this[o2] = e2;
              else {
                var d2 = s.isBuffer(e2) ? e2 : s.from(e2, r2), l2 = d2.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < n3 - t4; ++o2)
                  this[o2 + t4] = d2[o2 % l2];
              }
              return this;
            };
            var Q = /[^+/0-9A-Za-z-_]/g;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 1, buffer: 3, ieee754: 9 }], 4: [function(e, t2, n2) {
        (function(a) {
          (function() {
            function r2() {
              let e2;
              try {
                e2 = n2.storage.getItem("debug");
              } catch (e3) {
              }
              return !e2 && "undefined" != typeof a && "env" in a && (e2 = a.env.DEBUG), e2;
            }
            n2.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t2.exports.humanize(this.diff), !this.useColors)
                return;
              const n3 = "color: " + this.color;
              e2.splice(1, 0, n3, "color: inherit");
              let r3 = 0, a2 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" === e3 || (r3++, "%c" === e3 && (a2 = r3));
              }), e2.splice(a2, 0, n3);
            }, n2.save = function(e2) {
              try {
                e2 ? n2.storage.setItem("debug", e2) : n2.storage.removeItem("debug");
              } catch (e3) {
              }
            }, n2.load = r2, n2.useColors = function() {
              return !!("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }, n2.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), n2.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), n2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n2.log = console.debug || console.log || (() => {
            }), t2.exports = e("./common")(n2);
            const { formatters: o } = t2.exports;
            o.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 5, _process: 12 }], 5: [function(e, t2) {
        t2.exports = function(t3) {
          function r2(e2) {
            function t4(...e3) {
              if (!t4.enabled)
                return;
              const a2 = t4, o3 = +new Date(), i = o3 - (n2 || o3);
              a2.diff = i, a2.prev = n2, a2.curr = o3, n2 = o3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let d = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t5, n3) => {
                if ("%%" === t5)
                  return "%";
                d++;
                const o4 = r2.formatters[n3];
                if ("function" == typeof o4) {
                  const n4 = e3[d];
                  t5 = o4.call(a2, n4), e3.splice(d, 1), d--;
                }
                return t5;
              }), r2.formatArgs.call(a2, e3);
              const s = a2.log || r2.log;
              s.apply(a2, e3);
            }
            let n2, o2 = null;
            return t4.namespace = e2, t4.useColors = r2.useColors(), t4.color = r2.selectColor(e2), t4.extend = a, t4.destroy = r2.destroy, Object.defineProperty(t4, "enabled", { enumerable: true, configurable: false, get: () => null === o2 ? r2.enabled(e2) : o2, set: (e3) => {
              o2 = e3;
            } }), "function" == typeof r2.init && r2.init(t4), t4;
          }
          function a(e2, t4) {
            const n2 = r2(this.namespace + ("undefined" == typeof t4 ? ":" : t4) + e2);
            return n2.log = this.log, n2;
          }
          function o(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            return e2 instanceof Error ? e2.stack || e2.message : e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(o), ...r2.skips.map(o).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            r2.save(e2), r2.names = [], r2.skips = [];
            let t4;
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), a2 = n2.length;
            for (t4 = 0; t4 < a2; t4++)
              n2[t4] && (e2 = n2[t4].replace(/\*/g, ".*?"), "-" === e2[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t4, n2;
            for (t4 = 0, n2 = r2.skips.length; t4 < n2; t4++)
              if (r2.skips[t4].test(e2))
                return false;
            for (t4 = 0, n2 = r2.names.length; t4 < n2; t4++)
              if (r2.names[t4].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t3).forEach((e2) => {
            r2[e2] = t3[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t4 = 0;
            for (let n2 = 0; n2 < e2.length; n2++)
              t4 = (t4 << 5) - t4 + e2.charCodeAt(n2), t4 |= 0;
            return r2.colors[n(t4) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 11 }], 6: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          for (const n3 in t3)
            Object.defineProperty(e2, n3, { value: t3[n3], enumerable: true, configurable: true });
          return e2;
        }
        t2.exports = function(e2, t3, r2) {
          if (!e2 || "string" == typeof e2)
            throw new TypeError("Please pass an Error to err-code");
          r2 || (r2 = {}), "object" == typeof t3 && (r2 = t3, t3 = ""), t3 && (r2.code = t3);
          try {
            return n2(e2, r2);
          } catch (t4) {
            r2.message = e2.message, r2.stack = e2.stack;
            const a = function() {
            };
            a.prototype = Object.create(Object.getPrototypeOf(e2));
            const o = n2(new a(), r2);
            return o;
          }
        };
      }, {}], 7: [function(e, t2) {
        "use strict";
        function n2(e2) {
          console && console.warn && console.warn(e2);
        }
        function r2() {
          r2.init.call(this);
        }
        function a(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function o(e2) {
          return void 0 === e2._maxListeners ? r2.defaultMaxListeners : e2._maxListeners;
        }
        function i(e2, t3, r3, i2) {
          var d2, s2, l2;
          if (a(r3), s2 = e2._events, void 0 === s2 ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t3, r3.listener ? r3.listener : r3), s2 = e2._events), l2 = s2[t3]), void 0 === l2)
            l2 = s2[t3] = r3, ++e2._eventsCount;
          else if ("function" == typeof l2 ? l2 = s2[t3] = i2 ? [r3, l2] : [l2, r3] : i2 ? l2.unshift(r3) : l2.push(r3), d2 = o(e2), 0 < d2 && l2.length > d2 && !l2.warned) {
            l2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + (t3 + " listeners added. Use emitter.setMaxListeners() to increase limit"));
            c2.name = "MaxListenersExceededWarning", c2.emitter = e2, c2.type = t3, c2.count = l2.length, n2(c2);
          }
          return e2;
        }
        function d() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function s(e2, t3, n3) {
          var r3 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: n3 }, a2 = d.bind(r3);
          return a2.listener = n3, r3.wrapFn = a2, a2;
        }
        function l(e2, t3, n3) {
          var r3 = e2._events;
          if (r3 === void 0)
            return [];
          var a2 = r3[t3];
          return void 0 === a2 ? [] : "function" == typeof a2 ? n3 ? [a2.listener || a2] : [a2] : n3 ? f(a2) : u(a2, a2.length);
        }
        function c(e2) {
          var t3 = this._events;
          if (t3 !== void 0) {
            var n3 = t3[e2];
            if ("function" == typeof n3)
              return 1;
            if (void 0 !== n3)
              return n3.length;
          }
          return 0;
        }
        function u(e2, t3) {
          for (var n3 = Array(t3), r3 = 0; r3 < t3; ++r3)
            n3[r3] = e2[r3];
          return n3;
        }
        function p(e2, t3) {
          for (; t3 + 1 < e2.length; t3++)
            e2[t3] = e2[t3 + 1];
          e2.pop();
        }
        function f(e2) {
          for (var t3 = Array(e2.length), n3 = 0; n3 < t3.length; ++n3)
            t3[n3] = e2[n3].listener || e2[n3];
          return t3;
        }
        function g(e2, t3, n3) {
          "function" == typeof e2.on && _(e2, "error", t3, n3);
        }
        function _(e2, t3, n3, r3) {
          if ("function" == typeof e2.on)
            r3.once ? e2.once(t3, n3) : e2.on(t3, n3);
          else if ("function" == typeof e2.addEventListener)
            e2.addEventListener(t3, function a2(o2) {
              r3.once && e2.removeEventListener(t3, a2), n3(o2);
            });
          else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
        }
        var h, m = "object" == typeof Reflect ? Reflect : null, b = m && "function" == typeof m.apply ? m.apply : function(e2, t3, n3) {
          return Function.prototype.apply.call(e2, t3, n3);
        };
        h = m && "function" == typeof m.ownKeys ? m.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var y = Number.isNaN || function(e2) {
          return e2 !== e2;
        };
        t2.exports = r2, t2.exports.once = function(e2, t3) {
          return new Promise(function(n3, r3) {
            function a2(n4) {
              e2.removeListener(t3, o2), r3(n4);
            }
            function o2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", a2), n3([].slice.call(arguments));
            }
            _(e2, t3, o2, { once: true }), "error" !== t3 && g(e2, a2, { once: true });
          });
        }, r2.EventEmitter = r2, r2.prototype._events = void 0, r2.prototype._eventsCount = 0, r2.prototype._maxListeners = void 0;
        var C = 10;
        Object.defineProperty(r2, "defaultMaxListeners", { enumerable: true, get: function() {
          return C;
        }, set: function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          C = e2;
        } }), r2.init = function() {
          (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, r2.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, r2.prototype.getMaxListeners = function() {
          return o(this);
        }, r2.prototype.emit = function(e2) {
          for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
            t3.push(arguments[n3]);
          var r3 = "error" === e2, a2 = this._events;
          if (a2 !== void 0)
            r3 = r3 && a2.error === void 0;
          else if (!r3)
            return false;
          if (r3) {
            var o2;
            if (0 < t3.length && (o2 = t3[0]), o2 instanceof Error)
              throw o2;
            var d2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw d2.context = o2, d2;
          }
          var s2 = a2[e2];
          if (s2 === void 0)
            return false;
          if ("function" == typeof s2)
            b(s2, this, t3);
          else
            for (var l2 = s2.length, c2 = u(s2, l2), n3 = 0; n3 < l2; ++n3)
              b(c2[n3], this, t3);
          return true;
        }, r2.prototype.addListener = function(e2, t3) {
          return i(this, e2, t3, false);
        }, r2.prototype.on = r2.prototype.addListener, r2.prototype.prependListener = function(e2, t3) {
          return i(this, e2, t3, true);
        }, r2.prototype.once = function(e2, t3) {
          return a(t3), this.on(e2, s(this, e2, t3)), this;
        }, r2.prototype.prependOnceListener = function(e2, t3) {
          return a(t3), this.prependListener(e2, s(this, e2, t3)), this;
        }, r2.prototype.removeListener = function(e2, t3) {
          var n3, r3, o2, d2, s2;
          if (a(t3), r3 = this._events, void 0 === r3)
            return this;
          if (n3 = r3[e2], void 0 === n3)
            return this;
          if (n3 === t3 || n3.listener === t3)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e2], r3.removeListener && this.emit("removeListener", e2, n3.listener || t3));
          else if ("function" != typeof n3) {
            for (o2 = -1, d2 = n3.length - 1; 0 <= d2; d2--)
              if (n3[d2] === t3 || n3[d2].listener === t3) {
                s2 = n3[d2].listener, o2 = d2;
                break;
              }
            if (0 > o2)
              return this;
            0 === o2 ? n3.shift() : p(n3, o2), 1 === n3.length && (r3[e2] = n3[0]), void 0 !== r3.removeListener && this.emit("removeListener", e2, s2 || t3);
          }
          return this;
        }, r2.prototype.off = r2.prototype.removeListener, r2.prototype.removeAllListeners = function(e2) {
          var t3, n3, r3;
          if (n3 = this._events, void 0 === n3)
            return this;
          if (void 0 === n3.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e2]), this;
          if (0 === arguments.length) {
            var a2, o2 = Object.keys(n3);
            for (r3 = 0; r3 < o2.length; ++r3)
              a2 = o2[r3], "removeListener" !== a2 && this.removeAllListeners(a2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (t3 = n3[e2], "function" == typeof t3)
            this.removeListener(e2, t3);
          else if (void 0 !== t3)
            for (r3 = t3.length - 1; 0 <= r3; r3--)
              this.removeListener(e2, t3[r3]);
          return this;
        }, r2.prototype.listeners = function(e2) {
          return l(this, e2, true);
        }, r2.prototype.rawListeners = function(e2) {
          return l(this, e2, false);
        }, r2.listenerCount = function(e2, t3) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t3) : c.call(e2, t3);
        }, r2.prototype.listenerCount = c, r2.prototype.eventNames = function() {
          return 0 < this._eventsCount ? h(this._events) : [];
        };
      }, {}], 8: [function(e, t2) {
        t2.exports = function() {
          if ("undefined" == typeof globalThis)
            return null;
          var e2 = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate };
          return e2.RTCPeerConnection ? e2 : null;
        };
      }, {}], 9: [function(e, a, o) {
        o.read = function(t2, n2, a2, o2, l) {
          var c, u, p = 8 * l - o2 - 1, f = (1 << p) - 1, g = f >> 1, _ = -7, h = a2 ? l - 1 : 0, b = a2 ? -1 : 1, d = t2[n2 + h];
          for (h += b, c = d & (1 << -_) - 1, d >>= -_, _ += p; 0 < _; c = 256 * c + t2[n2 + h], h += b, _ -= 8)
            ;
          for (u = c & (1 << -_) - 1, c >>= -_, _ += o2; 0 < _; u = 256 * u + t2[n2 + h], h += b, _ -= 8)
            ;
          if (0 === c)
            c = 1 - g;
          else {
            if (c === f)
              return u ? NaN : (d ? -1 : 1) * (1 / 0);
            u += r(2, o2), c -= g;
          }
          return (d ? -1 : 1) * u * r(2, c - o2);
        }, o.write = function(a2, o2, l, u, p, f) {
          var h, b, y, g = Math.LN2, _ = Math.log, C = 8 * f - p - 1, R = (1 << C) - 1, E = R >> 1, w = 23 === p ? r(2, -24) - r(2, -77) : 0, S = u ? 0 : f - 1, T = u ? 1 : -1, d = 0 > o2 || 0 === o2 && 0 > 1 / o2 ? 1 : 0;
          for (o2 = n(o2), isNaN(o2) || o2 === 1 / 0 ? (b = isNaN(o2) ? 1 : 0, h = R) : (h = t(_(o2) / g), 1 > o2 * (y = r(2, -h)) && (h--, y *= 2), o2 += 1 <= h + E ? w / y : w * r(2, 1 - E), 2 <= o2 * y && (h++, y /= 2), h + E >= R ? (b = 0, h = R) : 1 <= h + E ? (b = (o2 * y - 1) * r(2, p), h += E) : (b = o2 * r(2, E - 1) * r(2, p), h = 0)); 8 <= p; a2[l + S] = 255 & b, S += T, b /= 256, p -= 8)
            ;
          for (h = h << p | b, C += p; 0 < C; a2[l + S] = 255 & h, S += T, h /= 256, C -= 8)
            ;
          a2[l + S - T] |= 128 * d;
        };
      }, {}], 10: [function(e, t2) {
        t2.exports = "function" == typeof Object.create ? function(e2, t3) {
          t3 && (e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : function(e2, t3) {
          if (t3) {
            e2.super_ = t3;
            var n2 = function() {
            };
            n2.prototype = t3.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 11: [function(e, t2) {
        var r2 = Math.round;
        function a(e2) {
          if (e2 += "", !(100 < e2.length)) {
            var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
            if (t3) {
              var r3 = parseFloat(t3[1]), n2 = (t3[2] || "ms").toLowerCase();
              return "years" === n2 || "year" === n2 || "yrs" === n2 || "yr" === n2 || "y" === n2 ? 315576e5 * r3 : "weeks" === n2 || "week" === n2 || "w" === n2 ? 6048e5 * r3 : "days" === n2 || "day" === n2 || "d" === n2 ? 864e5 * r3 : "hours" === n2 || "hour" === n2 || "hrs" === n2 || "hr" === n2 || "h" === n2 ? 36e5 * r3 : "minutes" === n2 || "minute" === n2 || "mins" === n2 || "min" === n2 || "m" === n2 ? 6e4 * r3 : "seconds" === n2 || "second" === n2 || "secs" === n2 || "sec" === n2 || "s" === n2 ? 1e3 * r3 : "milliseconds" === n2 || "millisecond" === n2 || "msecs" === n2 || "msec" === n2 || "ms" === n2 ? r3 : void 0;
            }
          }
        }
        function o(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? r2(e2 / 864e5) + "d" : 36e5 <= t3 ? r2(e2 / 36e5) + "h" : 6e4 <= t3 ? r2(e2 / 6e4) + "m" : 1e3 <= t3 ? r2(e2 / 1e3) + "s" : e2 + "ms";
        }
        function i(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? s(e2, t3, 864e5, "day") : 36e5 <= t3 ? s(e2, t3, 36e5, "hour") : 6e4 <= t3 ? s(e2, t3, 6e4, "minute") : 1e3 <= t3 ? s(e2, t3, 1e3, "second") : e2 + " ms";
        }
        function s(e2, t3, a2, n2) {
          return r2(e2 / a2) + " " + n2 + (t3 >= 1.5 * a2 ? "s" : "");
        }
        var l = 24 * (60 * 6e4);
        t2.exports = function(e2, t3) {
          t3 = t3 || {};
          var n2 = typeof e2;
          if ("string" == n2 && 0 < e2.length)
            return a(e2);
          if ("number" === n2 && isFinite(e2))
            return t3.long ? i(e2) : o(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 12: [function(e, t2) {
        function n2() {
          throw new Error("setTimeout has not been defined");
        }
        function r2() {
          throw new Error("clearTimeout has not been defined");
        }
        function a(t3) {
          if (c === setTimeout)
            return setTimeout(t3, 0);
          if ((c === n2 || !c) && setTimeout)
            return c = setTimeout, setTimeout(t3, 0);
          try {
            return c(t3, 0);
          } catch (n3) {
            try {
              return c.call(null, t3, 0);
            } catch (n4) {
              return c.call(this, t3, 0);
            }
          }
        }
        function o(t3) {
          if (u === clearTimeout)
            return clearTimeout(t3);
          if ((u === r2 || !u) && clearTimeout)
            return u = clearTimeout, clearTimeout(t3);
          try {
            return u(t3);
          } catch (n3) {
            try {
              return u.call(null, t3);
            } catch (n4) {
              return u.call(this, t3);
            }
          }
        }
        function i() {
          _ && f && (_ = false, f.length ? g = f.concat(g) : h = -1, g.length && d());
        }
        function d() {
          if (!_) {
            var e2 = a(i);
            _ = true;
            for (var t3 = g.length; t3; ) {
              for (f = g, g = []; ++h < t3; )
                f && f[h].run();
              h = -1, t3 = g.length;
            }
            f = null, _ = false, o(e2);
          }
        }
        function s(e2, t3) {
          this.fun = e2, this.array = t3;
        }
        function l() {
        }
        var c, u, p = t2.exports = {};
        (function() {
          try {
            c = "function" == typeof setTimeout ? setTimeout : n2;
          } catch (t3) {
            c = n2;
          }
          try {
            u = "function" == typeof clearTimeout ? clearTimeout : r2;
          } catch (t3) {
            u = r2;
          }
        })();
        var f, g = [], _ = false, h = -1;
        p.nextTick = function(e2) {
          var t3 = Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var n3 = 1; n3 < arguments.length; n3++)
              t3[n3 - 1] = arguments[n3];
          g.push(new s(e2, t3)), 1 !== g.length || _ || a(d);
        }, s.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function() {
          return [];
        }, p.binding = function() {
          throw new Error("process.binding is not supported");
        }, p.cwd = function() {
          return "/";
        }, p.chdir = function() {
          throw new Error("process.chdir is not supported");
        }, p.umask = function() {
          return 0;
        };
      }, {}], 13: [function(e, t2) {
        (function(e2) {
          (function() {
            let n2;
            t2.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" == typeof window ? e2 : window) : (e3) => (n2 || (n2 = Promise.resolve())).then(e3).catch((e4) => setTimeout(() => {
              throw e4;
            }, 0));
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], 14: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            var a = e("safe-buffer").Buffer, o = r2.crypto || r2.msCrypto;
            t2.exports = o && o.getRandomValues ? function(e2, t3) {
              if (e2 > 4294967295)
                throw new RangeError("requested too many random bytes");
              var r3 = a.allocUnsafe(e2);
              if (0 < e2)
                if (65536 < e2)
                  for (var i = 0; i < e2; i += 65536)
                    o.getRandomValues(r3.slice(i, i + 65536));
                else
                  o.getRandomValues(r3);
              return "function" == typeof t3 ? n2.nextTick(function() {
                t3(null, r3);
              }) : r3;
            } : function() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { _process: 12, "safe-buffer": 30 }], 15: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          e2.prototype = Object.create(t3.prototype), e2.prototype.constructor = e2, e2.__proto__ = t3;
        }
        function r2(e2, t3, r3) {
          function a2(e3, n3, r4) {
            return "string" == typeof t3 ? t3 : t3(e3, n3, r4);
          }
          r3 || (r3 = Error);
          var o2 = function(e3) {
            function t4(t5, n3, r4) {
              return e3.call(this, a2(t5, n3, r4)) || this;
            }
            return n2(t4, e3), t4;
          }(r3);
          o2.prototype.name = r3.name, o2.prototype.code = e2, s[e2] = o2;
        }
        function a(e2, t3) {
          if (Array.isArray(e2)) {
            var n3 = e2.length;
            return e2 = e2.map(function(e3) {
              return e3 + "";
            }), 2 < n3 ? "one of ".concat(t3, " ").concat(e2.slice(0, n3 - 1).join(", "), ", or ") + e2[n3 - 1] : 2 === n3 ? "one of ".concat(t3, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t3, " ").concat(e2[0]);
          }
          return "of ".concat(t3, " ").concat(e2 + "");
        }
        function o(e2, t3, n3) {
          return e2.substr(!n3 || 0 > n3 ? 0 : +n3, t3.length) === t3;
        }
        function i(e2, t3, n3) {
          return (void 0 === n3 || n3 > e2.length) && (n3 = e2.length), e2.substring(n3 - t3.length, n3) === t3;
        }
        function d(e2, t3, n3) {
          return "number" != typeof n3 && (n3 = 0), !(n3 + t3.length > e2.length) && -1 !== e2.indexOf(t3, n3);
        }
        var s = {};
        r2("ERR_INVALID_OPT_VALUE", function(e2, t3) {
          return 'The value "' + t3 + '" is invalid for option "' + e2 + '"';
        }, TypeError), r2("ERR_INVALID_ARG_TYPE", function(e2, t3, n3) {
          var r3;
          "string" == typeof t3 && o(t3, "not ") ? (r3 = "must not be", t3 = t3.replace(/^not /, "")) : r3 = "must be";
          var s2;
          if (i(e2, " argument"))
            s2 = "The ".concat(e2, " ").concat(r3, " ").concat(a(t3, "type"));
          else {
            var l = d(e2, ".") ? "property" : "argument";
            s2 = 'The "'.concat(e2, '" ').concat(l, " ").concat(r3, " ").concat(a(t3, "type"));
          }
          return s2 += ". Received type ".concat(typeof n3), s2;
        }, TypeError), r2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r2("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), r2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r2("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), r2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r2("ERR_STREAM_WRITE_AFTER_END", "write after end"), r2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r2("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), r2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t2.exports.codes = s;
      }, {}], 16: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2) {
              return this instanceof r2 ? void (d.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a)))) : new r2(e2);
            }
            function a() {
              this._writableState.ended || n2.nextTick(o, this);
            }
            function o(e2) {
              e2.end();
            }
            var i = Object.keys || function(e2) {
              var t3 = [];
              for (var n3 in e2)
                t3.push(n3);
              return t3;
            };
            t2.exports = r2;
            var d = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(r2, d);
            for (var l, c = i(s.prototype), u = 0; u < c.length; u++)
              l = c[u], r2.prototype[l] || (r2.prototype[l] = s.prototype[l]);
            Object.defineProperty(r2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(r2.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(r2.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(r2.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            }, set: function(e2) {
              void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 18, "./_stream_writable": 20, _process: 12, inherits: 10 }], 17: [function(e, t2) {
        "use strict";
        function n2(e2) {
          return this instanceof n2 ? void r2.call(this, e2) : new n2(e2);
        }
        t2.exports = n2;
        var r2 = e("./_stream_transform");
        e("inherits")(n2, r2), n2.prototype._transform = function(e2, t3, n3) {
          n3(null, e2);
        };
      }, { "./_stream_transform": 19, inherits: 10 }], 18: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              return P.from(e2);
            }
            function o(e2) {
              return P.isBuffer(e2) || e2 instanceof M;
            }
            function i(e2, t3, n3) {
              return "function" == typeof e2.prependListener ? e2.prependListener(t3, n3) : void (e2._events && e2._events[t3] ? Array.isArray(e2._events[t3]) ? e2._events[t3].unshift(n3) : e2._events[t3] = [n3, e2._events[t3]] : e2.on(t3, n3));
            }
            function d(t3, n3, r3) {
              A = A || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof A), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.readableObjectMode), this.highWaterMark = H(this, t3, "readableHighWaterMark", r3), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (!F && (F = e("string_decoder/").StringDecoder), this.decoder = new F(t3.encoding), this.encoding = t3.encoding);
            }
            function s(t3) {
              if (A = A || e("./_stream_duplex"), !(this instanceof s))
                return new s(t3);
              var n3 = this instanceof A;
              this._readableState = new d(t3, this, n3), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), I.call(this);
            }
            function l(e2, t3, n3, r3, o2) {
              x("readableAddChunk", t3);
              var i2 = e2._readableState;
              if (null === t3)
                i2.reading = false, g(e2, i2);
              else {
                var d2;
                if (o2 || (d2 = u(i2, t3)), d2)
                  X(e2, d2);
                else if (!(i2.objectMode || t3 && 0 < t3.length))
                  r3 || (i2.reading = false, m(e2, i2));
                else if ("string" == typeof t3 || i2.objectMode || Object.getPrototypeOf(t3) === P.prototype || (t3 = a(t3)), r3)
                  i2.endEmitted ? X(e2, new K()) : c(e2, i2, t3, true);
                else if (i2.ended)
                  X(e2, new z());
                else {
                  if (i2.destroyed)
                    return false;
                  i2.reading = false, i2.decoder && !n3 ? (t3 = i2.decoder.write(t3), i2.objectMode || 0 !== t3.length ? c(e2, i2, t3, false) : m(e2, i2)) : c(e2, i2, t3, false);
                }
              }
              return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
            }
            function c(e2, t3, n3, r3) {
              t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e2.emit("data", n3)) : (t3.length += t3.objectMode ? 1 : n3.length, r3 ? t3.buffer.unshift(n3) : t3.buffer.push(n3), t3.needReadable && _(e2)), m(e2, t3);
            }
            function u(e2, t3) {
              var n3;
              return o(t3) || "string" == typeof t3 || void 0 === t3 || e2.objectMode || (n3 = new V("chunk", ["string", "Buffer", "Uint8Array"], t3)), n3;
            }
            function p(e2) {
              return 1073741824 <= e2 ? e2 = 1073741824 : (e2--, e2 |= e2 >>> 1, e2 |= e2 >>> 2, e2 |= e2 >>> 4, e2 |= e2 >>> 8, e2 |= e2 >>> 16, e2++), e2;
            }
            function f(e2, t3) {
              return 0 >= e2 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e2 === e2 ? (e2 > t3.highWaterMark && (t3.highWaterMark = p(e2)), e2 <= t3.length ? e2 : t3.ended ? t3.length : (t3.needReadable = true, 0)) : t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length;
            }
            function g(e2, t3) {
              if (x("onEofChunk"), !t3.ended) {
                if (t3.decoder) {
                  var n3 = t3.decoder.end();
                  n3 && n3.length && (t3.buffer.push(n3), t3.length += t3.objectMode ? 1 : n3.length);
                }
                t3.ended = true, t3.sync ? _(e2) : (t3.needReadable = false, !t3.emittedReadable && (t3.emittedReadable = true, h(e2)));
              }
            }
            function _(e2) {
              var t3 = e2._readableState;
              x("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (x("emitReadable", t3.flowing), t3.emittedReadable = true, n2.nextTick(h, e2));
            }
            function h(e2) {
              var t3 = e2._readableState;
              x("emitReadable_", t3.destroyed, t3.length, t3.ended), !t3.destroyed && (t3.length || t3.ended) && (e2.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, S(e2);
            }
            function m(e2, t3) {
              t3.readingMore || (t3.readingMore = true, n2.nextTick(b, e2, t3));
            }
            function b(e2, t3) {
              for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
                var n3 = t3.length;
                if (x("maybeReadMore read 0"), e2.read(0), n3 === t3.length)
                  break;
              }
              t3.readingMore = false;
            }
            function y(e2) {
              return function() {
                var t3 = e2._readableState;
                x("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && D(e2, "data") && (t3.flowing = true, S(e2));
              };
            }
            function C(e2) {
              var t3 = e2._readableState;
              t3.readableListening = 0 < e2.listenerCount("readable"), t3.resumeScheduled && !t3.paused ? t3.flowing = true : 0 < e2.listenerCount("data") && e2.resume();
            }
            function R(e2) {
              x("readable nexttick read 0"), e2.read(0);
            }
            function E(e2, t3) {
              t3.resumeScheduled || (t3.resumeScheduled = true, n2.nextTick(w, e2, t3));
            }
            function w(e2, t3) {
              x("resume", t3.reading), t3.reading || e2.read(0), t3.resumeScheduled = false, e2.emit("resume"), S(e2), t3.flowing && !t3.reading && e2.read(0);
            }
            function S(e2) {
              var t3 = e2._readableState;
              for (x("flow", t3.flowing); t3.flowing && null !== e2.read(); )
                ;
            }
            function T(e2, t3) {
              if (0 === t3.length)
                return null;
              var n3;
              return t3.objectMode ? n3 = t3.buffer.shift() : !e2 || e2 >= t3.length ? (n3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : n3 = t3.buffer.consume(e2, t3.decoder), n3;
            }
            function v(e2) {
              var t3 = e2._readableState;
              x("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, n2.nextTick(k, t3, e2));
            }
            function k(e2, t3) {
              if (x("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t3.readable = false, t3.emit("end"), e2.autoDestroy)) {
                var n3 = t3._writableState;
                (!n3 || n3.autoDestroy && n3.finished) && t3.destroy();
              }
            }
            function L(e2, t3) {
              for (var n3 = 0, r3 = e2.length; n3 < r3; n3++)
                if (e2[n3] === t3)
                  return n3;
              return -1;
            }
            t2.exports = s;
            var A;
            s.ReadableState = d;
            var x, N = e("events").EventEmitter, D = function(e2, t3) {
              return e2.listeners(t3).length;
            }, I = e("./internal/streams/stream"), P = e("buffer").Buffer, M = r2.Uint8Array || function() {
            }, O = e("util");
            x = O && O.debuglog ? O.debuglog("stream") : function() {
            };
            var F, B, U, j = e("./internal/streams/buffer_list"), q = e("./internal/streams/destroy"), W = e("./internal/streams/state"), H = W.getHighWaterMark, Y = e("../errors").codes, V = Y.ERR_INVALID_ARG_TYPE, z = Y.ERR_STREAM_PUSH_AFTER_EOF, G = Y.ERR_METHOD_NOT_IMPLEMENTED, K = Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(s, I);
            var X = q.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
            Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function(e2, t3) {
              t3(e2);
            }, s.prototype.push = function(e2, t3) {
              var n3, r3 = this._readableState;
              return r3.objectMode ? n3 = true : "string" == typeof e2 && (t3 = t3 || r3.defaultEncoding, t3 !== r3.encoding && (e2 = P.from(e2, t3), t3 = ""), n3 = true), l(this, e2, t3, false, n3);
            }, s.prototype.unshift = function(e2) {
              return l(this, e2, null, true, false);
            }, s.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, s.prototype.setEncoding = function(t3) {
              F || (F = e("string_decoder/").StringDecoder);
              var n3 = new F(t3);
              this._readableState.decoder = n3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var r3 = this._readableState.buffer.head, a2 = ""; null !== r3; )
                a2 += n3.write(r3.data), r3 = r3.next;
              return this._readableState.buffer.clear(), "" !== a2 && this._readableState.buffer.push(a2), this._readableState.length = a2.length, this;
            };
            s.prototype.read = function(e2) {
              x("read", e2), e2 = parseInt(e2, 10);
              var t3 = this._readableState, r3 = e2;
              if (0 !== e2 && (t3.emittedReadable = false), 0 === e2 && t3.needReadable && ((0 === t3.highWaterMark ? 0 < t3.length : t3.length >= t3.highWaterMark) || t3.ended))
                return x("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? v(this) : _(this), null;
              if (e2 = f(e2, t3), 0 === e2 && t3.ended)
                return 0 === t3.length && v(this), null;
              var a2 = t3.needReadable;
              x("need readable", a2), (0 === t3.length || t3.length - e2 < t3.highWaterMark) && (a2 = true, x("length less than watermark", a2)), t3.ended || t3.reading ? (a2 = false, x("reading or ended", a2)) : a2 && (x("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, !t3.reading && (e2 = f(r3, t3)));
              var o2;
              return o2 = 0 < e2 ? T(e2, t3) : null, null === o2 ? (t3.needReadable = t3.length <= t3.highWaterMark, e2 = 0) : (t3.length -= e2, t3.awaitDrain = 0), 0 === t3.length && (!t3.ended && (t3.needReadable = true), r3 !== e2 && t3.ended && v(this)), null !== o2 && this.emit("data", o2), o2;
            }, s.prototype._read = function() {
              X(this, new G("_read()"));
            }, s.prototype.pipe = function(e2, t3) {
              function r3(e3, t4) {
                x("onunpipe"), e3 === p2 && t4 && false === t4.hasUnpiped && (t4.hasUnpiped = true, o2());
              }
              function a2() {
                x("onend"), e2.end();
              }
              function o2() {
                x("cleanup"), e2.removeListener("close", l2), e2.removeListener("finish", c2), e2.removeListener("drain", h2), e2.removeListener("error", s2), e2.removeListener("unpipe", r3), p2.removeListener("end", a2), p2.removeListener("end", u2), p2.removeListener("data", d2), m2 = true, f2.awaitDrain && (!e2._writableState || e2._writableState.needDrain) && h2();
              }
              function d2(t4) {
                x("ondata");
                var n3 = e2.write(t4);
                x("dest.write", n3), false === n3 && ((1 === f2.pipesCount && f2.pipes === e2 || 1 < f2.pipesCount && -1 !== L(f2.pipes, e2)) && !m2 && (x("false write response, pause", f2.awaitDrain), f2.awaitDrain++), p2.pause());
              }
              function s2(t4) {
                x("onerror", t4), u2(), e2.removeListener("error", s2), 0 === D(e2, "error") && X(e2, t4);
              }
              function l2() {
                e2.removeListener("finish", c2), u2();
              }
              function c2() {
                x("onfinish"), e2.removeListener("close", l2), u2();
              }
              function u2() {
                x("unpipe"), p2.unpipe(e2);
              }
              var p2 = this, f2 = this._readableState;
              switch (f2.pipesCount) {
                case 0:
                  f2.pipes = e2;
                  break;
                case 1:
                  f2.pipes = [f2.pipes, e2];
                  break;
                default:
                  f2.pipes.push(e2);
              }
              f2.pipesCount += 1, x("pipe count=%d opts=%j", f2.pipesCount, t3);
              var g2 = (!t3 || false !== t3.end) && e2 !== n2.stdout && e2 !== n2.stderr, _2 = g2 ? a2 : u2;
              f2.endEmitted ? n2.nextTick(_2) : p2.once("end", _2), e2.on("unpipe", r3);
              var h2 = y(p2);
              e2.on("drain", h2);
              var m2 = false;
              return p2.on("data", d2), i(e2, "error", s2), e2.once("close", l2), e2.once("finish", c2), e2.emit("pipe", p2), f2.flowing || (x("pipe resume"), p2.resume()), e2;
            }, s.prototype.unpipe = function(e2) {
              var t3 = this._readableState, n3 = { hasUnpiped: false };
              if (0 === t3.pipesCount)
                return this;
              if (1 === t3.pipesCount)
                return e2 && e2 !== t3.pipes ? this : (e2 || (e2 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e2 && e2.emit("unpipe", this, n3), this);
              if (!e2) {
                var r3 = t3.pipes, a2 = t3.pipesCount;
                t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
                for (var o2 = 0; o2 < a2; o2++)
                  r3[o2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var d2 = L(t3.pipes, e2);
              return -1 === d2 ? this : (t3.pipes.splice(d2, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e2.emit("unpipe", this, n3), this);
            }, s.prototype.on = function(e2, t3) {
              var r3 = I.prototype.on.call(this, e2, t3), a2 = this._readableState;
              return "data" === e2 ? (a2.readableListening = 0 < this.listenerCount("readable"), false !== a2.flowing && this.resume()) : "readable" == e2 && !a2.endEmitted && !a2.readableListening && (a2.readableListening = a2.needReadable = true, a2.flowing = false, a2.emittedReadable = false, x("on readable", a2.length, a2.reading), a2.length ? _(this) : !a2.reading && n2.nextTick(R, this)), r3;
            }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function(e2, t3) {
              var r3 = I.prototype.removeListener.call(this, e2, t3);
              return "readable" === e2 && n2.nextTick(C, this), r3;
            }, s.prototype.removeAllListeners = function(e2) {
              var t3 = I.prototype.removeAllListeners.apply(this, arguments);
              return ("readable" === e2 || void 0 === e2) && n2.nextTick(C, this), t3;
            }, s.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (x("resume"), e2.flowing = !e2.readableListening, E(this, e2)), e2.paused = false, this;
            }, s.prototype.pause = function() {
              return x("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (x("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, s.prototype.wrap = function(e2) {
              var t3 = this, r3 = this._readableState, a2 = false;
              for (var o2 in e2.on("end", function() {
                if (x("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t3.push(e3);
                }
                t3.push(null);
              }), e2.on("data", function(n3) {
                if ((x("wrapped data"), r3.decoder && (n3 = r3.decoder.write(n3)), !(r3.objectMode && (null === n3 || void 0 === n3))) && (r3.objectMode || n3 && n3.length)) {
                  var o3 = t3.push(n3);
                  o3 || (a2 = true, e2.pause());
                }
              }), e2)
                void 0 === this[o2] && "function" == typeof e2[o2] && (this[o2] = function(t4) {
                  return function() {
                    return e2[t4].apply(e2, arguments);
                  };
                }(o2));
              for (var i2 = 0; i2 < $.length; i2++)
                e2.on($[i2], this.emit.bind(this, $[i2]));
              return this._read = function(t4) {
                x("wrapped _read", t4), a2 && (a2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function() {
              return void 0 === B && (B = e("./internal/streams/async_iterator")), B(this);
            }), Object.defineProperty(s.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(s.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(s.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), s._fromList = T, Object.defineProperty(s.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (s.from = function(t3, n3) {
              return void 0 === U && (U = e("./internal/streams/from")), U(s, t3, n3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/async_iterator": 21, "./internal/streams/buffer_list": 22, "./internal/streams/destroy": 23, "./internal/streams/from": 25, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, events: 7, inherits: 10, "string_decoder/": 31, util: 2 }], 19: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = this._transformState;
          n3.transforming = false;
          var r3 = n3.writecb;
          if (null === r3)
            return this.emit("error", new s());
          n3.writechunk = null, n3.writecb = null, null != t3 && this.push(t3), r3(e2);
          var a2 = this._readableState;
          a2.reading = false, (a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
        }
        function r2(e2) {
          return this instanceof r2 ? void (u.call(this, e2), this._transformState = { afterTransform: n2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a)) : new r2(e2);
        }
        function a() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function(t3, n3) {
            o(e2, t3, n3);
          });
        }
        function o(e2, t3, n3) {
          if (t3)
            return e2.emit("error", t3);
          if (null != n3 && e2.push(n3), e2._writableState.length)
            throw new c();
          if (e2._transformState.transforming)
            throw new l();
          return e2.push(null);
        }
        t2.exports = r2;
        var i = e("../errors").codes, d = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, c = i.ERR_TRANSFORM_WITH_LENGTH_0, u = e("./_stream_duplex");
        e("inherits")(r2, u), r2.prototype.push = function(e2, t3) {
          return this._transformState.needTransform = false, u.prototype.push.call(this, e2, t3);
        }, r2.prototype._transform = function(e2, t3, n3) {
          n3(new d("_transform()"));
        }, r2.prototype._write = function(e2, t3, n3) {
          var r3 = this._transformState;
          if (r3.writecb = n3, r3.writechunk = e2, r3.writeencoding = t3, !r3.transforming) {
            var a2 = this._readableState;
            (r3.needTransform || a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
          }
        }, r2.prototype._read = function() {
          var e2 = this._transformState;
          null === e2.writechunk || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
        }, r2.prototype._destroy = function(e2, t3) {
          u.prototype._destroy.call(this, e2, function(e3) {
            t3(e3);
          });
        };
      }, { "../errors": 15, "./_stream_duplex": 16, inherits: 10 }], 20: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              var t3 = this;
              this.next = null, this.entry = null, this.finish = function() {
                v(t3, e2);
              };
            }
            function o(e2) {
              return x.from(e2);
            }
            function i(e2) {
              return x.isBuffer(e2) || e2 instanceof N;
            }
            function d() {
            }
            function s(t3, n3, r3) {
              k = k || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof k), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.writableObjectMode), this.highWaterMark = P(this, t3, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var o2 = false === t3.decodeStrings;
              this.decodeStrings = !o2, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                m(n3, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
            }
            function l(t3) {
              k = k || e("./_stream_duplex");
              var n3 = this instanceof k;
              return n3 || V.call(l, this) ? void (this._writableState = new s(t3, this, n3), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), A.call(this)) : new l(t3);
            }
            function c(e2, t3) {
              var r3 = new W();
              Y(e2, r3), n2.nextTick(t3, r3);
            }
            function u(e2, t3, r3, a2) {
              var o2;
              return null === r3 ? o2 = new q() : "string" != typeof r3 && !t3.objectMode && (o2 = new O("chunk", ["string", "Buffer"], r3)), !o2 || (Y(e2, o2), n2.nextTick(a2, o2), false);
            }
            function p(e2, t3, n3) {
              return e2.objectMode || false === e2.decodeStrings || "string" != typeof t3 || (t3 = x.from(t3, n3)), t3;
            }
            function f(e2, t3, n3, r3, a2, o2) {
              if (!n3) {
                var i2 = p(t3, r3, a2);
                r3 !== i2 && (n3 = true, a2 = "buffer", r3 = i2);
              }
              var d2 = t3.objectMode ? 1 : r3.length;
              t3.length += d2;
              var s2 = t3.length < t3.highWaterMark;
              if (s2 || (t3.needDrain = true), t3.writing || t3.corked) {
                var l2 = t3.lastBufferedRequest;
                t3.lastBufferedRequest = { chunk: r3, encoding: a2, isBuf: n3, callback: o2, next: null }, l2 ? l2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
              } else
                g(e2, t3, false, d2, r3, a2, o2);
              return s2;
            }
            function g(e2, t3, n3, r3, a2, o2, i2) {
              t3.writelen = r3, t3.writecb = i2, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new j("write")) : n3 ? e2._writev(a2, t3.onwrite) : e2._write(a2, o2, t3.onwrite), t3.sync = false;
            }
            function _(e2, t3, r3, a2, o2) {
              --t3.pendingcb, r3 ? (n2.nextTick(o2, a2), n2.nextTick(S, e2, t3), e2._writableState.errorEmitted = true, Y(e2, a2)) : (o2(a2), e2._writableState.errorEmitted = true, Y(e2, a2), S(e2, t3));
            }
            function h(e2) {
              e2.writing = false, e2.writecb = null, e2.length -= e2.writelen, e2.writelen = 0;
            }
            function m(e2, t3) {
              var r3 = e2._writableState, a2 = r3.sync, o2 = r3.writecb;
              if ("function" != typeof o2)
                throw new B();
              if (h(r3), t3)
                _(e2, r3, a2, t3, o2);
              else {
                var i2 = R(r3) || e2.destroyed;
                i2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || C(e2, r3), a2 ? n2.nextTick(b, e2, r3, i2, o2) : b(e2, r3, i2, o2);
              }
            }
            function b(e2, t3, n3, r3) {
              n3 || y(e2, t3), t3.pendingcb--, r3(), S(e2, t3);
            }
            function y(e2, t3) {
              0 === t3.length && t3.needDrain && (t3.needDrain = false, e2.emit("drain"));
            }
            function C(e2, t3) {
              t3.bufferProcessing = true;
              var n3 = t3.bufferedRequest;
              if (e2._writev && n3 && n3.next) {
                var r3 = t3.bufferedRequestCount, o2 = Array(r3), i2 = t3.corkedRequestsFree;
                i2.entry = n3;
                for (var d2 = 0, s2 = true; n3; )
                  o2[d2] = n3, n3.isBuf || (s2 = false), n3 = n3.next, d2 += 1;
                o2.allBuffers = s2, g(e2, t3, true, t3.length, o2, "", i2.finish), t3.pendingcb++, t3.lastBufferedRequest = null, i2.next ? (t3.corkedRequestsFree = i2.next, i2.next = null) : t3.corkedRequestsFree = new a(t3), t3.bufferedRequestCount = 0;
              } else {
                for (; n3; ) {
                  var l2 = n3.chunk, c2 = n3.encoding, u2 = n3.callback, p2 = t3.objectMode ? 1 : l2.length;
                  if (g(e2, t3, false, p2, l2, c2, u2), n3 = n3.next, t3.bufferedRequestCount--, t3.writing)
                    break;
                }
                null === n3 && (t3.lastBufferedRequest = null);
              }
              t3.bufferedRequest = n3, t3.bufferProcessing = false;
            }
            function R(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function E(e2, t3) {
              e2._final(function(n3) {
                t3.pendingcb--, n3 && Y(e2, n3), t3.prefinished = true, e2.emit("prefinish"), S(e2, t3);
              });
            }
            function w(e2, t3) {
              t3.prefinished || t3.finalCalled || ("function" != typeof e2._final || t3.destroyed ? (t3.prefinished = true, e2.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, n2.nextTick(E, e2, t3)));
            }
            function S(e2, t3) {
              var n3 = R(t3);
              if (n3 && (w(e2, t3), 0 === t3.pendingcb && (t3.finished = true, e2.emit("finish"), t3.autoDestroy))) {
                var r3 = e2._readableState;
                (!r3 || r3.autoDestroy && r3.endEmitted) && e2.destroy();
              }
              return n3;
            }
            function T(e2, t3, r3) {
              t3.ending = true, S(e2, t3), r3 && (t3.finished ? n2.nextTick(r3) : e2.once("finish", r3)), t3.ended = true, e2.writable = false;
            }
            function v(e2, t3, n3) {
              var r3 = e2.entry;
              for (e2.entry = null; r3; ) {
                var a2 = r3.callback;
                t3.pendingcb--, a2(n3), r3 = r3.next;
              }
              t3.corkedRequestsFree.next = e2;
            }
            t2.exports = l;
            var k;
            l.WritableState = s;
            var L = { deprecate: e("util-deprecate") }, A = e("./internal/streams/stream"), x = e("buffer").Buffer, N = r2.Uint8Array || function() {
            }, D = e("./internal/streams/destroy"), I = e("./internal/streams/state"), P = I.getHighWaterMark, M = e("../errors").codes, O = M.ERR_INVALID_ARG_TYPE, F = M.ERR_METHOD_NOT_IMPLEMENTED, B = M.ERR_MULTIPLE_CALLBACK, U = M.ERR_STREAM_CANNOT_PIPE, j = M.ERR_STREAM_DESTROYED, q = M.ERR_STREAM_NULL_VALUES, W = M.ERR_STREAM_WRITE_AFTER_END, H = M.ERR_UNKNOWN_ENCODING, Y = D.errorOrDestroy;
            e("inherits")(l, A), s.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t3 = []; e2; )
                t3.push(e2), e2 = e2.next;
              return t3;
            }, function() {
              try {
                Object.defineProperty(s.prototype, "buffer", { get: L.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }();
            var V;
            "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, { value: function(e2) {
              return !!V.call(this, e2) || !(this !== l) && e2 && e2._writableState instanceof s;
            } })) : V = function(e2) {
              return e2 instanceof this;
            }, l.prototype.pipe = function() {
              Y(this, new U());
            }, l.prototype.write = function(e2, t3, n3) {
              var r3 = this._writableState, a2 = false, s2 = !r3.objectMode && i(e2);
              return s2 && !x.isBuffer(e2) && (e2 = o(e2)), "function" == typeof t3 && (n3 = t3, t3 = null), s2 ? t3 = "buffer" : !t3 && (t3 = r3.defaultEncoding), "function" != typeof n3 && (n3 = d), r3.ending ? c(this, n3) : (s2 || u(this, r3, e2, n3)) && (r3.pendingcb++, a2 = f(this, r3, s2, e2, t3, n3)), a2;
            }, l.prototype.cork = function() {
              this._writableState.corked++;
            }, l.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, !e2.writing && !e2.corked && !e2.bufferProcessing && e2.bufferedRequest && C(this, e2));
            }, l.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase())))
                throw new H(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(l.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), l.prototype._write = function(e2, t3, n3) {
              n3(new F("_write()"));
            }, l.prototype._writev = null, l.prototype.end = function(e2, t3, n3) {
              var r3 = this._writableState;
              return "function" == typeof e2 ? (n3 = e2, e2 = null, t3 = null) : "function" == typeof t3 && (n3 = t3, t3 = null), null !== e2 && void 0 !== e2 && this.write(e2, t3), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || T(this, r3, n3), this;
            }, Object.defineProperty(l.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(l.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), l.prototype.destroy = D.destroy, l.prototype._undestroy = D.undestroy, l.prototype._destroy = function(e2, t3) {
              t3(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/destroy": 23, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, inherits: 10, "util-deprecate": 32 }], 21: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2, t3, n3) {
              return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
            }
            function a(e2, t3) {
              return { value: e2, done: t3 };
            }
            function o(e2) {
              var t3 = e2[c];
              if (null !== t3) {
                var n3 = e2[h].read();
                null !== n3 && (e2[g] = null, e2[c] = null, e2[u] = null, t3(a(n3, false)));
              }
            }
            function i(e2) {
              n2.nextTick(o, e2);
            }
            function d(e2, t3) {
              return function(n3, r3) {
                e2.then(function() {
                  return t3[f] ? void n3(a(void 0, true)) : void t3[_](n3, r3);
                }, r3);
              };
            }
            var s, l = e("./end-of-stream"), c = Symbol("lastResolve"), u = Symbol("lastReject"), p = Symbol("error"), f = Symbol("ended"), g = Symbol("lastPromise"), _ = Symbol("handlePromise"), h = Symbol("stream"), m = Object.getPrototypeOf(function() {
            }), b = Object.setPrototypeOf((s = { get stream() {
              return this[h];
            }, next: function() {
              var e2 = this, t3 = this[p];
              if (null !== t3)
                return Promise.reject(t3);
              if (this[f])
                return Promise.resolve(a(void 0, true));
              if (this[h].destroyed)
                return new Promise(function(t4, r4) {
                  n2.nextTick(function() {
                    e2[p] ? r4(e2[p]) : t4(a(void 0, true));
                  });
                });
              var r3, o2 = this[g];
              if (o2)
                r3 = new Promise(d(o2, this));
              else {
                var i2 = this[h].read();
                if (null !== i2)
                  return Promise.resolve(a(i2, false));
                r3 = new Promise(this[_]);
              }
              return this[g] = r3, r3;
            } }, r2(s, Symbol.asyncIterator, function() {
              return this;
            }), r2(s, "return", function() {
              var e2 = this;
              return new Promise(function(t3, n3) {
                e2[h].destroy(null, function(e3) {
                  return e3 ? void n3(e3) : void t3(a(void 0, true));
                });
              });
            }), s), m);
            t2.exports = function(e2) {
              var t3, n3 = Object.create(b, (t3 = {}, r2(t3, h, { value: e2, writable: true }), r2(t3, c, { value: null, writable: true }), r2(t3, u, { value: null, writable: true }), r2(t3, p, { value: null, writable: true }), r2(t3, f, { value: e2._readableState.endEmitted, writable: true }), r2(t3, _, { value: function(e3, t4) {
                var r3 = n3[h].read();
                r3 ? (n3[g] = null, n3[c] = null, n3[u] = null, e3(a(r3, false))) : (n3[c] = e3, n3[u] = t4);
              }, writable: true }), t3));
              return n3[g] = null, l(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t4 = n3[u];
                  return null !== t4 && (n3[g] = null, n3[c] = null, n3[u] = null, t4(e3)), void (n3[p] = e3);
                }
                var r3 = n3[c];
                null !== r3 && (n3[g] = null, n3[c] = null, n3[u] = null, r3(a(void 0, true))), n3[f] = true;
              }), e2.on("readable", i.bind(null, n3)), n3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 24, _process: 12 }], 22: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e2);
            t3 && (r3 = r3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function r2(e2) {
          for (var t3, r3 = 1; r3 < arguments.length; r3++)
            t3 = null == arguments[r3] ? {} : arguments[r3], r3 % 2 ? n2(Object(t3), true).forEach(function(n3) {
              a(e2, n3, t3[n3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : n2(Object(t3)).forEach(function(n3) {
              Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t3, n3));
            });
          return e2;
        }
        function a(e2, t3, n3) {
          return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
        }
        function o(e2, t3) {
          if (!(e2 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function i(e2, t3) {
          for (var n3, r3 = 0; r3 < t3.length; r3++)
            n3 = t3[r3], n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
        }
        function d(e2, t3, n3) {
          return t3 && i(e2.prototype, t3), n3 && i(e2, n3), e2;
        }
        function s(e2, t3, n3) {
          u.prototype.copy.call(e2, t3, n3);
        }
        var l = e("buffer"), u = l.Buffer, p = e("util"), f = p.inspect, g = f && f.custom || "inspect";
        t2.exports = function() {
          function e2() {
            o(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          return d(e2, [{ key: "push", value: function(e3) {
            var t3 = { data: e3, next: null };
            0 < this.length ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t3 = this.head, n3 = "" + t3.data; t3 = t3.next; )
              n3 += e3 + t3.data;
            return n3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return u.alloc(0);
            for (var t3 = u.allocUnsafe(e3 >>> 0), n3 = this.head, r3 = 0; n3; )
              s(n3.data, t3, r3), r3 += n3.data.length, n3 = n3.next;
            return t3;
          } }, { key: "consume", value: function(e3, t3) {
            var n3;
            return e3 < this.head.data.length ? (n3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : e3 === this.head.data.length ? n3 = this.shift() : n3 = t3 ? this._getString(e3) : this._getBuffer(e3), n3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t3 = this.head, r3 = 1, a2 = t3.data;
            for (e3 -= a2.length; t3 = t3.next; ) {
              var o2 = t3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (a2 += i2 === o2.length ? o2 : o2.slice(0, e3), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++r3, this.head = t3.next ? t3.next : this.tail = null) : (this.head = t3, t3.data = o2.slice(i2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, a2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t3 = u.allocUnsafe(e3), r3 = this.head, a2 = 1;
            for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
              var o2 = r3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (o2.copy(t3, t3.length - e3, 0, i2), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++a2, this.head = r3.next ? r3.next : this.tail = null) : (this.head = r3, r3.data = o2.slice(i2));
                break;
              }
              ++a2;
            }
            return this.length -= a2, t3;
          } }, { key: g, value: function(e3, t3) {
            return f(this, r2({}, t3, { depth: 0, customInspect: false }));
          } }]), e2;
        }();
      }, { buffer: 3, util: 2 }], 23: [function(e, t2) {
        (function(e2) {
          (function() {
            "use strict";
            function n2(e3, t3) {
              a(e3, t3), r2(e3);
            }
            function r2(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function a(e3, t3) {
              e3.emit("error", t3);
            }
            t2.exports = { destroy: function(t3, o) {
              var i = this, d = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
              return d || s ? (o ? o(t3) : t3 && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = true, e2.nextTick(a, this, t3)) : e2.nextTick(a, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, function(t4) {
                !o && t4 ? i._writableState ? i._writableState.errorEmitted ? e2.nextTick(r2, i) : (i._writableState.errorEmitted = true, e2.nextTick(n2, i, t4)) : e2.nextTick(n2, i, t4) : o ? (e2.nextTick(r2, i), o(t4)) : e2.nextTick(r2, i);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t3) {
              var n3 = e3._readableState, r3 = e3._writableState;
              n3 && n3.autoDestroy || r3 && r3.autoDestroy ? e3.destroy(t3) : e3.emit("error", t3);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 12 }], 24: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            if (!t3) {
              t3 = true;
              for (var n3 = arguments.length, r3 = Array(n3), a2 = 0; a2 < n3; a2++)
                r3[a2] = arguments[a2];
              e2.apply(this, r3);
            }
          };
        }
        function r2() {
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(e2, t3, d) {
          if ("function" == typeof t3)
            return o(e2, null, t3);
          t3 || (t3 = {}), d = n2(d || r2);
          var s = t3.readable || false !== t3.readable && e2.readable, l = t3.writable || false !== t3.writable && e2.writable, c = function() {
            e2.writable || p();
          }, u = e2._writableState && e2._writableState.finished, p = function() {
            l = false, u = true, s || d.call(e2);
          }, f = e2._readableState && e2._readableState.endEmitted, g = function() {
            s = false, f = true, l || d.call(e2);
          }, _ = function(t4) {
            d.call(e2, t4);
          }, h = function() {
            var t4;
            return s && !f ? (e2._readableState && e2._readableState.ended || (t4 = new i()), d.call(e2, t4)) : l && !u ? (e2._writableState && e2._writableState.ended || (t4 = new i()), d.call(e2, t4)) : void 0;
          }, m = function() {
            e2.req.on("finish", p);
          };
          return a(e2) ? (e2.on("complete", p), e2.on("abort", h), e2.req ? m() : e2.on("request", m)) : l && !e2._writableState && (e2.on("end", c), e2.on("close", c)), e2.on("end", g), e2.on("finish", p), false !== t3.error && e2.on("error", _), e2.on("close", h), function() {
            e2.removeListener("complete", p), e2.removeListener("abort", h), e2.removeListener("request", m), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", c), e2.removeListener("close", c), e2.removeListener("finish", p), e2.removeListener("end", g), e2.removeListener("error", _), e2.removeListener("close", h);
          };
        }
        var i = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        t2.exports = o;
      }, { "../../../errors": 15 }], 25: [function(e, t2) {
        t2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 26: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            t3 || (t3 = true, e2.apply(void 0, arguments));
          };
        }
        function r2(e2) {
          if (e2)
            throw e2;
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(t3, r3, o2, i2) {
          i2 = n2(i2);
          var d2 = false;
          t3.on("close", function() {
            d2 = true;
          }), l === void 0 && (l = e("./end-of-stream")), l(t3, { readable: r3, writable: o2 }, function(e2) {
            return e2 ? i2(e2) : void (d2 = true, i2());
          });
          var s2 = false;
          return function(e2) {
            if (!d2)
              return s2 ? void 0 : (s2 = true, a(t3) ? t3.abort() : "function" == typeof t3.destroy ? t3.destroy() : void i2(e2 || new p("pipe")));
          };
        }
        function i(e2) {
          e2();
        }
        function d(e2, t3) {
          return e2.pipe(t3);
        }
        function s(e2) {
          return e2.length ? "function" == typeof e2[e2.length - 1] ? e2.pop() : r2 : r2;
        }
        var l, c = e("../../../errors").codes, u = c.ERR_MISSING_ARGS, p = c.ERR_STREAM_DESTROYED;
        t2.exports = function() {
          for (var e2 = arguments.length, t3 = Array(e2), n3 = 0; n3 < e2; n3++)
            t3[n3] = arguments[n3];
          var r3 = s(t3);
          if (Array.isArray(t3[0]) && (t3 = t3[0]), 2 > t3.length)
            throw new u("streams");
          var a2, l2 = t3.map(function(e3, n4) {
            var d2 = n4 < t3.length - 1;
            return o(e3, d2, 0 < n4, function(e4) {
              a2 || (a2 = e4), e4 && l2.forEach(i), d2 || (l2.forEach(i), r3(a2));
            });
          });
          return t3.reduce(d);
        };
      }, { "../../../errors": 15, "./end-of-stream": 24 }], 27: [function(e, n2) {
        "use strict";
        function r2(e2, t2, n3) {
          return null == e2.highWaterMark ? t2 ? e2[n3] : null : e2.highWaterMark;
        }
        var a = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        n2.exports = { getHighWaterMark: function(e2, n3, o, i) {
          var d = r2(n3, i, o);
          if (null != d) {
            if (!(isFinite(d) && t(d) === d) || 0 > d) {
              var s = i ? o : "highWaterMark";
              throw new a(s, d);
            }
            return t(d);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 15 }], 28: [function(e, t2) {
        t2.exports = e("events").EventEmitter;
      }, { events: 7 }], 29: [function(e, t2, n2) {
        n2 = t2.exports = e("./lib/_stream_readable.js"), n2.Stream = n2, n2.Readable = n2, n2.Writable = e("./lib/_stream_writable.js"), n2.Duplex = e("./lib/_stream_duplex.js"), n2.Transform = e("./lib/_stream_transform.js"), n2.PassThrough = e("./lib/_stream_passthrough.js"), n2.finished = e("./lib/internal/streams/end-of-stream.js"), n2.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20, "./lib/internal/streams/end-of-stream.js": 24, "./lib/internal/streams/pipeline.js": 26 }], 30: [function(e, t2, n2) {
        function r2(e2, t3) {
          for (var n3 in e2)
            t3[n3] = e2[n3];
        }
        function a(e2, t3, n3) {
          return i(e2, t3, n3);
        }
        var o = e("buffer"), i = o.Buffer;
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t2.exports = o : (r2(o, n2), n2.Buffer = a), a.prototype = Object.create(i.prototype), r2(i, a), a.from = function(e2, t3, n3) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t3, n3);
        }, a.alloc = function(e2, t3, n3) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var r3 = i(e2);
          return void 0 === t3 ? r3.fill(0) : "string" == typeof n3 ? r3.fill(t3, n3) : r3.fill(t3), r3;
        }, a.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, a.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return o.SlowBuffer(e2);
        };
      }, { buffer: 3 }], 31: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          if (!e2)
            return "utf8";
          for (var t3; ; )
            switch (e2) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return e2;
              default:
                if (t3)
                  return;
                e2 = ("" + e2).toLowerCase(), t3 = true;
            }
        }
        function a(e2) {
          var t3 = r2(e2);
          if ("string" != typeof t3 && (m.isEncoding === b || !b(e2)))
            throw new Error("Unknown encoding: " + e2);
          return t3 || e2;
        }
        function o(e2) {
          this.encoding = a(e2);
          var t3;
          switch (this.encoding) {
            case "utf16le":
              this.text = u, this.end = p, t3 = 4;
              break;
            case "utf8":
              this.fillLast = c, t3 = 4;
              break;
            case "base64":
              this.text = f, this.end = g, t3 = 3;
              break;
            default:
              return this.write = _, void (this.end = h);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m.allocUnsafe(t3);
        }
        function d(e2) {
          if (127 >= e2)
            return 0;
          return 6 == e2 >> 5 ? 2 : 14 == e2 >> 4 ? 3 : 30 == e2 >> 3 ? 4 : 2 == e2 >> 6 ? -1 : -2;
        }
        function s(e2, t3, n3) {
          var r3 = t3.length - 1;
          if (r3 < n3)
            return 0;
          var a2 = d(t3[r3]);
          return 0 <= a2 ? (0 < a2 && (e2.lastNeed = a2 - 1), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2) ? (0 < a2 && (e2.lastNeed = a2 - 2), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2 ? (0 < a2 && (2 === a2 ? a2 = 0 : e2.lastNeed = a2 - 3), a2) : 0);
        }
        function l(e2, t3) {
          if (128 != (192 & t3[0]))
            return e2.lastNeed = 0, "\uFFFD";
          if (1 < e2.lastNeed && 1 < t3.length) {
            if (128 != (192 & t3[1]))
              return e2.lastNeed = 1, "\uFFFD";
            if (2 < e2.lastNeed && 2 < t3.length && 128 != (192 & t3[2]))
              return e2.lastNeed = 2, "\uFFFD";
          }
        }
        function c(e2) {
          var t3 = this.lastTotal - this.lastNeed, n3 = l(this, e2, t3);
          return void 0 === n3 ? this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, t3, 0, e2.length), this.lastNeed -= e2.length) : n3;
        }
        function u(e2, t3) {
          if (0 == (e2.length - t3) % 2) {
            var n3 = e2.toString("utf16le", t3);
            if (n3) {
              var r3 = n3.charCodeAt(n3.length - 1);
              if (55296 <= r3 && 56319 >= r3)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], n3.slice(0, -1);
            }
            return n3;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t3, e2.length - 1);
        }
        function p(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var n3 = this.lastTotal - this.lastNeed;
            return t3 + this.lastChar.toString("utf16le", 0, n3);
          }
          return t3;
        }
        function f(e2, t3) {
          var r3 = (e2.length - t3) % 3;
          return 0 == r3 ? e2.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 == r3 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t3, e2.length - r3));
        }
        function g(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
        }
        function _(e2) {
          return e2.toString(this.encoding);
        }
        function h(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        var m = e("safe-buffer").Buffer, b = m.isEncoding || function(e2) {
          switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        n2.StringDecoder = o, o.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t3, n3;
          if (this.lastNeed) {
            if (t3 = this.fillLast(e2), void 0 === t3)
              return "";
            n3 = this.lastNeed, this.lastNeed = 0;
          } else
            n3 = 0;
          return n3 < e2.length ? t3 ? t3 + this.text(e2, n3) : this.text(e2, n3) : t3 || "";
        }, o.prototype.end = function(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + "\uFFFD" : t3;
        }, o.prototype.text = function(e2, t3) {
          var n3 = s(this, e2, t3);
          if (!this.lastNeed)
            return e2.toString("utf8", t3);
          this.lastTotal = n3;
          var r3 = e2.length - (n3 - this.lastNeed);
          return e2.copy(this.lastChar, 0, r3), e2.toString("utf8", t3, r3);
        }, o.prototype.fillLast = function(e2) {
          return this.lastNeed <= e2.length ? (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length);
        };
      }, { "safe-buffer": 30 }], 32: [function(e, t2) {
        (function(e2) {
          (function() {
            function n2(t3) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var n3 = e2.localStorage[t3];
              return null != n3 && "true" === (n3 + "").toLowerCase();
            }
            t2.exports = function(e3, t3) {
              function r2() {
                if (!a) {
                  if (n2("throwDeprecation"))
                    throw new Error(t3);
                  else
                    n2("traceDeprecation") ? console.trace(t3) : console.warn(t3);
                  a = true;
                }
                return e3.apply(this, arguments);
              }
              if (n2("noDeprecation"))
                return e3;
              var a = false;
              return r2;
            };
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], "/": [function(e, t2) {
        function n2(e2) {
          return e2.replace(/a=ice-options:trickle\s\n/g, "");
        }
        function r2(e2) {
          console.warn(e2);
        }
        const a = e("debug")("simple-peer"), o = e("get-browser-rtc"), i = e("randombytes"), d = e("readable-stream"), s = e("queue-microtask"), l = e("err-code"), { Buffer: c } = e("buffer"), u = 65536;
        class p extends d.Duplex {
          constructor(e2) {
            if (e2 = Object.assign({ allowHalfOpen: false }, e2), super(e2), this._id = i(4).toString("hex").slice(0, 7), this._debug("new peer %o", e2), this.channelName = e2.initiator ? e2.channelName || i(20).toString("hex") : null, this.initiator = e2.initiator || false, this.channelConfig = e2.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e2.config), this.offerOptions = e2.offerOptions || {}, this.answerOptions = e2.answerOptions || {}, this.sdpTransform = e2.sdpTransform || ((e3) => e3), this.streams = e2.streams || (e2.stream ? [e2.stream] : []), this.trickle = void 0 === e2.trickle || e2.trickle, this.allowHalfTrickle = void 0 !== e2.allowHalfTrickle && e2.allowHalfTrickle, this.iceCompleteTimeout = e2.iceCompleteTimeout || 5e3, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e2.wrtc && "object" == typeof e2.wrtc ? e2.wrtc : o(), !this._wrtc)
              if ("undefined" == typeof window)
                throw l(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
              else
                throw l(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
            try {
              this._pc = new this._wrtc.RTCPeerConnection(this.config);
            } catch (e3) {
              return void this.destroy(l(e3, "ERR_PC_CONSTRUCTOR"));
            }
            this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onicegatheringstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onconnectionstatechange = () => {
              this._onConnectionStateChange();
            }, this._pc.onsignalingstatechange = () => {
              this._onSignalingStateChange();
            }, this._pc.onicecandidate = (e3) => {
              this._onIceCandidate(e3);
            }, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e3) => {
              this.destroy(l(e3, "ERR_PC_PEER_IDENTITY"));
            }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e3) => {
              this._setupData(e3);
            }, this.streams && this.streams.forEach((e3) => {
              this.addStream(e3);
            }), this._pc.ontrack = (e3) => {
              this._onTrack(e3);
            }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
              this._onFinish();
            }, this.once("finish", this._onFinishBound);
          }
          get bufferSize() {
            return this._channel && this._channel.bufferedAmount || 0;
          }
          get connected() {
            return this._connected && "open" === this._channel.readyState;
          }
          address() {
            return { port: this.localPort, family: this.localFamily, address: this.localAddress };
          }
          signal(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
              if ("string" == typeof e2)
                try {
                  e2 = JSON.parse(e2);
                } catch (t3) {
                  e2 = {};
                }
              this._debug("signal()"), e2.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e2.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e2.transceiverRequest.kind, e2.transceiverRequest.init)), e2.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e2.candidate) : this._pendingCandidates.push(e2.candidate)), e2.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e2)).then(() => {
                this.destroyed || (this._pendingCandidates.forEach((e3) => {
                  this._addIceCandidate(e3);
                }), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer());
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_REMOTE_DESCRIPTION"));
              }), e2.sdp || e2.candidate || e2.renegotiate || e2.transceiverRequest || this.destroy(l(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
            }
          }
          _addIceCandidate(e2) {
            const t3 = new this._wrtc.RTCIceCandidate(e2);
            this._pc.addIceCandidate(t3).catch((e3) => {
              !t3.address || t3.address.endsWith(".local") ? r2("Ignoring unsupported ICE candidate.") : this.destroy(l(e3, "ERR_ADD_ICE_CANDIDATE"));
            });
          }
          send(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
              this._channel.send(e2);
            }
          }
          addTransceiver(e2, t3) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
              if (this._debug("addTransceiver()"), this.initiator)
                try {
                  this._pc.addTransceiver(e2, t3), this._needsNegotiation();
                } catch (e3) {
                  this.destroy(l(e3, "ERR_ADD_TRANSCEIVER"));
                }
              else
                this.emit("signal", { type: "transceiverRequest", transceiverRequest: { kind: e2, init: t3 } });
            }
          }
          addStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addStream()"), e2.getTracks().forEach((t3) => {
                this.addTrack(t3, e2);
              });
            }
          }
          addTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("addTrack()");
            const n3 = this._senderMap.get(e2) || /* @__PURE__ */ new Map();
            let r3 = n3.get(t3);
            if (!r3)
              r3 = this._pc.addTrack(e2, t3), n3.set(t3, r3), this._senderMap.set(e2, n3), this._needsNegotiation();
            else if (r3.removed)
              throw l(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
            else
              throw l(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
          replaceTrack(e2, t3, n3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("replaceTrack()");
            const r3 = this._senderMap.get(e2), a2 = r3 ? r3.get(n3) : null;
            if (!a2)
              throw l(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
            t3 && this._senderMap.set(t3, r3), null == a2.replaceTrack ? this.destroy(l(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")) : a2.replaceTrack(t3);
          }
          removeTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("removeSender()");
            const n3 = this._senderMap.get(e2), r3 = n3 ? n3.get(t3) : null;
            if (!r3)
              throw l(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
            try {
              r3.removed = true, this._pc.removeTrack(r3);
            } catch (e3) {
              "NS_ERROR_UNEXPECTED" === e3.name ? this._sendersAwaitingStable.push(r3) : this.destroy(l(e3, "ERR_REMOVE_TRACK"));
            }
            this._needsNegotiation();
          }
          removeStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSenders()"), e2.getTracks().forEach((t3) => {
                this.removeTrack(t3, e2);
              });
            }
          }
          _needsNegotiation() {
            this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = true, s(() => {
              this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
            }));
          }
          negotiate() {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
              this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
                this._createOffer();
              }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: true })), this._isNegotiating = true;
            }
          }
          destroy(e2) {
            this._destroy(e2, () => {
            });
          }
          _destroy(e2, t3) {
            this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e2 && (e2.message || e2)), s(() => {
              if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e2 && (e2.message || e2)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                try {
                  this._channel.close();
                } catch (e3) {
                }
                this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
              }
              if (this._pc) {
                try {
                  this._pc.close();
                } catch (e3) {
                }
                this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
              }
              this._pc = null, this._channel = null, e2 && this.emit("error", e2), this.emit("close"), t3();
            }));
          }
          _setupData(e2) {
            if (!e2.channel)
              return this.destroy(l(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
            this._channel = e2.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u), this.channelName = this._channel.label, this._channel.onmessage = (e3) => {
              this._onChannelMessage(e3);
            }, this._channel.onbufferedamountlow = () => {
              this._onChannelBufferedAmountLow();
            }, this._channel.onopen = () => {
              this._onChannelOpen();
            }, this._channel.onclose = () => {
              this._onChannelClose();
            }, this._channel.onerror = (e3) => {
              const t4 = e3.error instanceof Error ? e3.error : new Error(`Datachannel error: ${e3.message} ${e3.filename}:${e3.lineno}:${e3.colno}`);
              this.destroy(l(t4, "ERR_DATA_CHANNEL"));
            };
            let t3 = false;
            this._closingInterval = setInterval(() => {
              this._channel && "closing" === this._channel.readyState ? (t3 && this._onChannelClose(), t3 = true) : t3 = false;
            }, 5e3);
          }
          _read() {
          }
          _write(e2, t3, n3) {
            if (this.destroyed)
              return n3(l(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
            if (this._connected) {
              try {
                this.send(e2);
              } catch (e3) {
                return this.destroy(l(e3, "ERR_DATA_CHANNEL"));
              }
              this._channel.bufferedAmount > u ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n3) : n3(null);
            } else
              this._debug("write before connect"), this._chunk = e2, this._cb = n3;
          }
          _onFinish() {
            if (!this.destroyed) {
              const e2 = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              this._connected ? e2() : this.once("connect", e2);
            }
          }
          _startIceCompleteTimeout() {
            this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
              this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
            }, this.iceCompleteTimeout));
          }
          _createOffer() {
            this.destroyed || this._pc.createOffer(this.offerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp });
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_OFFER"));
            });
          }
          _requestMissingTransceivers() {
            this._pc.getTransceivers && this._pc.getTransceivers().forEach((e2) => {
              e2.mid || !e2.sender.track || e2.requested || (e2.requested = true, this.addTransceiver(e2.sender.track.kind));
            });
          }
          _createAnswer() {
            this.destroyed || this._pc.createAnswer(this.answerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp }), this.initiator || this._requestMissingTransceivers();
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_ANSWER"));
            });
          }
          _onConnectionStateChange() {
            this.destroyed || "failed" === this._pc.connectionState && this.destroy(l(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
          _onIceStateChange() {
            if (this.destroyed)
              return;
            const e2 = this._pc.iceConnectionState, t3 = this._pc.iceGatheringState;
            this._debug("iceStateChange (connection: %s) (gathering: %s)", e2, t3), this.emit("iceStateChange", e2, t3), ("connected" === e2 || "completed" === e2) && (this._pcReady = true, this._maybeReady()), "failed" === e2 && this.destroy(l(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e2 && this.destroy(l(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
          getStats(e2) {
            const t3 = (e3) => ("[object Array]" === Object.prototype.toString.call(e3.values) && e3.values.forEach((t4) => {
              Object.assign(e3, t4);
            }), e3);
            0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n3) => {
              const r3 = [];
              n3.forEach((e3) => {
                r3.push(t3(e3));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : 0 < this._pc.getStats.length ? this._pc.getStats((n3) => {
              if (this.destroyed)
                return;
              const r3 = [];
              n3.result().forEach((e3) => {
                const n4 = {};
                e3.names().forEach((t4) => {
                  n4[t4] = e3.stat(t4);
                }), n4.id = e3.id, n4.type = e3.type, n4.timestamp = e3.timestamp, r3.push(t3(n4));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : e2(null, []);
          }
          _maybeReady() {
            if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
              return;
            this._connecting = true;
            const e2 = () => {
              this.destroyed || this.getStats((t3, n3) => {
                if (this.destroyed)
                  return;
                t3 && (n3 = []);
                const r3 = {}, a2 = {}, o2 = {};
                let i2 = false;
                n3.forEach((e3) => {
                  ("remotecandidate" === e3.type || "remote-candidate" === e3.type) && (r3[e3.id] = e3), ("localcandidate" === e3.type || "local-candidate" === e3.type) && (a2[e3.id] = e3), ("candidatepair" === e3.type || "candidate-pair" === e3.type) && (o2[e3.id] = e3);
                });
                const d2 = (e3) => {
                  i2 = true;
                  let t4 = a2[e3.localCandidateId];
                  t4 && (t4.ip || t4.address) ? (this.localAddress = t4.ip || t4.address, this.localPort = +t4.port) : t4 && t4.ipAddress ? (this.localAddress = t4.ipAddress, this.localPort = +t4.portNumber) : "string" == typeof e3.googLocalAddress && (t4 = e3.googLocalAddress.split(":"), this.localAddress = t4[0], this.localPort = +t4[1]), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                  let n4 = r3[e3.remoteCandidateId];
                  n4 && (n4.ip || n4.address) ? (this.remoteAddress = n4.ip || n4.address, this.remotePort = +n4.port) : n4 && n4.ipAddress ? (this.remoteAddress = n4.ipAddress, this.remotePort = +n4.portNumber) : "string" == typeof e3.googRemoteAddress && (n4 = e3.googRemoteAddress.split(":"), this.remoteAddress = n4[0], this.remotePort = +n4[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                };
                if (n3.forEach((e3) => {
                  "transport" === e3.type && e3.selectedCandidatePairId && d2(o2[e3.selectedCandidatePairId]), ("googCandidatePair" === e3.type && "true" === e3.googActiveConnection || ("candidatepair" === e3.type || "candidate-pair" === e3.type) && e3.selected) && d2(e3);
                }), !i2 && (!Object.keys(o2).length || Object.keys(a2).length))
                  return void setTimeout(e2, 100);
                if (this._connecting = false, this._connected = true, this._chunk) {
                  try {
                    this.send(this._chunk);
                  } catch (e4) {
                    return this.destroy(l(e4, "ERR_DATA_CHANNEL"));
                  }
                  this._chunk = null, this._debug('sent chunk from "write before connect"');
                  const e3 = this._cb;
                  this._cb = null, e3(null);
                }
                "number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
              });
            };
            e2();
          }
          _onInterval() {
            this._cb && this._channel && !(this._channel.bufferedAmount > u) && this._onChannelBufferedAmountLow();
          }
          _onSignalingStateChange() {
            this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e2) => {
              this._pc.removeTrack(e2), this._queuedNegotiation = true;
            }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
          }
          _onIceCandidate(e2) {
            this.destroyed || (e2.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e2.candidate.candidate, sdpMLineIndex: e2.candidate.sdpMLineIndex, sdpMid: e2.candidate.sdpMid } }) : !e2.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e2.candidate && this._startIceCompleteTimeout());
          }
          _onChannelMessage(e2) {
            if (this.destroyed)
              return;
            let t3 = e2.data;
            t3 instanceof ArrayBuffer && (t3 = c.from(t3)), this.push(t3);
          }
          _onChannelBufferedAmountLow() {
            if (!this.destroyed && this._cb) {
              this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              const e2 = this._cb;
              this._cb = null, e2(null);
            }
          }
          _onChannelOpen() {
            this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
          }
          _onChannelClose() {
            this.destroyed || (this._debug("on channel close"), this.destroy());
          }
          _onTrack(e2) {
            this.destroyed || e2.streams.forEach((t3) => {
              this._debug("on track"), this.emit("track", e2.track, t3), this._remoteTracks.push({ track: e2.track, stream: t3 }), this._remoteStreams.some((e3) => e3.id === t3.id) || (this._remoteStreams.push(t3), s(() => {
                this._debug("on stream"), this.emit("stream", t3);
              }));
            });
          }
          _debug() {
            const e2 = [].slice.call(arguments);
            e2[0] = "[" + this._id + "] " + e2[0], a.apply(null, e2);
          }
        }
        p.WEBRTC_SUPPORT = !!o(), p.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, p.channelConfig = {}, t2.exports = p;
      }, { buffer: 3, debug: 4, "err-code": 6, "get-browser-rtc": 8, "queue-microtask": 13, randombytes: 14, "readable-stream": 29 }] }, {}, [])("/");
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/peerdraftPlugin.ts
var import_obsidian16 = require("obsidian");

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var log10 = Math.log10;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var pow = Math.pow;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
};
var from = Array.from;
var some = (arr, f) => {
  for (let i = 0; i < arr.length; i++) {
    if (f(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};
var isArray = Array.isArray;

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(name, _f);
      f(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};

// src/sharedEntities/sharedDocument.ts
var import_obsidian11 = require("obsidian");

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i = 0; i < keys3.length; i++) {
          const key = keys3[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create3 = (s) => new Error(s);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var rand = Math.random;
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);
var reject = (reason) => Promise.reject(reason);
var resolve = (res) => Promise.resolve(res);

// node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === void 0 ? null : v;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var size = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || size(a) === size(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
};
var nop = () => {
};
var id = (a) => a;
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalityDeep(a[i], b[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("--no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("--color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s) => {
  const a = atob(s);
  const bytes = createUint8ArrayFromLen(a.length);
  for (let i = 0; i < a.length; i++) {
    bytes[i] = a.charCodeAt(i);
  }
  return bytes;
};
var fromBase64Node = (s) => {
  const buf = Buffer.from(s, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);
var forEach2 = (arr, f) => arr.forEach((p) => f(p.left, p.right));

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = (name) => doc.createElement(name);
var createDocumentFragment = () => doc.createDocumentFragment();
var createTextNode = (text2) => doc.createTextNode(text2);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = (el, attrs) => {
  forEach2(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};
var fragment = (children) => {
  const fragment2 = createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    appendChild(fragment2, children[i]);
  }
  return fragment2;
};
var append = (parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
};
var element = (name, attrs = [], children = []) => append(setAttributes(createElement(name), attrs), children);
var text = createTextNode;
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var appendChild = (parent, child) => parent.appendChild(child);
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/json.js
var stringify = JSON.stringify;

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  var _a;
  if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg === void 0) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
var nextColor = 0;
var lastLoggingTime = getUnixTime();
var createModuleLogger = (_print, moduleName) => {
  const color = loggingColors[nextColor];
  const debugRegexVar = getVariable("log");
  const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
  nextColor = (nextColor + 1) % loggingColors.length;
  moduleName += ": ";
  return !doLogging ? nop : (...args2) => {
    var _a;
    if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
      args2 = args2[0]();
    }
    const timeNow = getUnixTime();
    const timeDiff = timeNow - lastLoggingTime;
    lastLoggingTime = timeNow;
    _print(
      color,
      moduleName,
      UNCOLOR,
      ...args2.map((arg) => {
        if (arg != null && arg.constructor === Uint8Array) {
          arg = Array.from(arg);
        }
        const t = typeof arg;
        switch (t) {
          case "string":
          case "symbol":
            return arg;
          default: {
            return stringify(arg);
          }
        }
      }),
      color,
      " +" + timeDiff + "ms"
    );
  };
};

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  var _a;
  if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create2();
var createModuleLogger2 = (moduleName) => createModuleLogger(print, moduleName);

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i = 0; i < deletes.length; i++) {
    const del2 = deletes[i];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length3) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length3));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve2) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve2(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve2) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve2();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type2 = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type2.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type2._map;
        type2._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type2._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type2._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type2
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type2) => {
  for (const [key, value] of type2.doc.share.entries()) {
    if (value === type2) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type2, tname, item, assoc = 0) {
    this.type = type2;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var relativePositionToJSON = (rpos) => {
  const json = {};
  if (rpos.type) {
    json.type = rpos.type;
  }
  if (rpos.tname) {
    json.tname = rpos.tname;
  }
  if (rpos.item) {
    json.item = rpos.item;
  }
  if (rpos.assoc != null) {
    json.assoc = rpos.assoc;
  }
  return json;
};
var createRelativePositionFromJSON = (json) => {
  var _a;
  return new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), (_a = json.tname) != null ? _a : null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
};
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type2, index, assoc = 0) {
    this.type = type2;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type2, index, assoc = 0) => new AbsolutePosition(type2, index, assoc);
var createRelativePosition = (type2, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type2._item === null) {
    tname = findRootTypeKey(type2);
  } else {
    typeid = createID(type2._item.id.client, type2._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type2, index, assoc = 0) => {
  let t = type2._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type2, null, assoc);
    }
    index--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index) {
        return createRelativePosition(type2, createID(t.id.client, t.id.clock + index), assoc);
      }
      index -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type2, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type2, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2, followUndoneDeletions = true) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type2 = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followUndoneDeletions ? followRedone(store, rightID) : { item: getItem(store, rightID), diff: 0 };
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type2 = /** @type {AbstractType<any>} */
    right.parent;
    if (type2._item === null || !type2._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type2 = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
      if (item instanceof Item && item.content instanceof ContentType) {
        type2 = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type2._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type2, index, rpos.assoc);
};
var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type2, parentSub) => {
  const item = type2._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type2, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i = pos;
  for (; i > 0; right = left, left = structs[--i - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type2) => {
          if (type2._dEH.l.length > 0 && (type2._item === null || !type2._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type2;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type2._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {
            i2 -= 1 + tryToMergeWithLefts(structs, i2);
          }
        }
      });
      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type2) => isParentOf(type2, item))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type2) => isParentOf(
            type2,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type2) => isParentOf(type2, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i = itemsToDelete.length - 1; i >= 0; i--) {
        const item = itemsToDelete[i];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type2) => {
      if (subProps.has(null) && type2._searchMarker) {
        type2._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  const res = undoManager.currStackItem;
  if (res != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return res;
};
var UndoManager = class extends ObservableV2 {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type2) => transaction.changedParentTypes.has(type2)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type2) => isParentOf(type2, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        if (ytype.doc !== this.doc)
          warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path4 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path4.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i += c.length;
        }
        c = c.right;
      }
      path4.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path4;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var callTypeObservers = (type2, transaction, event) => {
  const changedType = type2;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type2, () => []).push(event);
    if (type2._item === null) {
      break;
    }
    type2 = /** @type {AbstractType<any>} */
    type2._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type2, start, end) => {
  if (start < 0) {
    start = type2._length + start;
  }
  if (end < 0) {
    end = type2._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type2._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start; i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type2) => {
  const cs = [];
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type2, f) => {
  let index = 0;
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        f(c[i], index++, type2);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type2, f) => {
  const result = [];
  typeListForEach(type2, (c, i) => {
    result.push(f(c, i, type2));
  });
  return result;
};
var typeListCreateIterator = (type2) => {
  let n = type2._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type2, index) => {
  const marker = findMarker(type2, index);
  let n = type2._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length3) => {
  if (length3 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length3;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length3 > 0 && n !== null) {
    if (!n.deleted) {
      if (length3 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
      }
      n.delete(transaction);
      length3 -= n.length;
    }
    n = n.right;
  }
  if (length3 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length3
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map2) => iteratorFilter(
  map2.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map2 = new YMap();
    this.forEach((value, key) => {
      map2.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map2;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map2 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map2[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map2;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map2) {
          typeMapDelete(transaction, map2, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  var _a;
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      (_a = attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ]) != null ? _a : null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  var _a;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = (_a = currPos.currentAttributes.get(key)) != null ? _a : null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length3, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key];
            if (attr !== void 0) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length3 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  var _a, _b;
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = (_a = startAttributes.get(key)) != null ? _a : null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && ((_b = currAttributes.get(key)) != null ? _b : null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type2) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type2.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type2._start
      );
      let end = type2._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        var _a, _b, _c;
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = (_a = currentAttributes.get(key)) != null ? _a : null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, (_b = oldAttributes.get(key)) != null ? _b : null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = (_c = currentAttributes.get(key)) != null ? _c : null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length3) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length3);
      });
    } else {
      this._pending.push(() => this.delete(index, length3));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length3, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type2 = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type2))) {
      do {
        type2 = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type2.constructor === YXmlElement || type2.constructor === YXmlFragment) && type2._start !== null) {
          n = type2._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys3[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text2 = new YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length3) {
    this.id = id2;
    this.length = length3;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type2) {
    this.type = type2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s) => isDeleted(s.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone)
          left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/tools.ts
var XXH = __toESM(require_lib());
var createRandomId = () => {
  return window.crypto.randomUUID();
};
var randomUint32 = () => {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
};
var generateRandomString = function() {
  return Math.random().toString(20).substring(2, 8);
};
var calculateHash = (text2) => {
  return XXH.h32(text2, 43981).toString(16);
};
var serialize = (obj) => {
  if (Array.isArray(obj)) {
    return `[${obj.map((el) => serialize(el)).join(",")}]`;
  } else if (typeof obj === "object" && obj !== null) {
    let acc = "";
    const keys3 = Object.keys(obj).sort();
    acc += `{${JSON.stringify(keys3)}`;
    for (let i = 0; i < keys3.length; i++) {
      acc += `${serialize(obj[keys3[i]])},`;
    }
    return `${acc}}`;
  }
  return `${JSON.stringify(obj)}`;
};

// src/sharedEntities/sharedDocument.ts
var import_state = require("@codemirror/state");

// src/ui.ts
var import_obsidian = require("obsidian");
var ShowTextModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.message = message;
    this.title = title;
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.contentEl.setText(this.message);
  }
  onClose() {
    this.containerEl.empty();
  }
};
var showTextModal = (app, title, text2) => {
  new ShowTextModal(app, title, text2).open();
};
var showNotice = (text2, duration) => {
  return new import_obsidian.Notice(text2, duration);
};
var openFileInNewTab = async (file, workspace) => {
  const leaf = workspace.getLeaf("tab");
  await leaf.openFile(file);
  return leaf;
};
var pinLeaf = (leaf) => {
  leaf.setPinned(true);
  showNotice(`auto-pinned "${leaf.getDisplayText()}"`);
};
var usercolors = [
  { dark: "#30bced", light: "#30bced33" },
  { dark: "#6eeb83", light: "#6eeb8333" },
  { dark: "#ffbc42", light: "#ffbc4233" },
  { dark: "#ecd444", light: "#ecd44433" },
  { dark: "#ee6352", light: "#ee635233" },
  { dark: "#9ac2c9", light: "#9ac2c933" },
  { dark: "#8acb88", light: "#8acb8833" },
  { dark: "#1be7ff", light: "#1be7ff33" }
];

// node_modules/y-codemirror.next/src/index.js
var cmView4 = __toESM(require("@codemirror/view"), 1);
var cmState4 = __toESM(require("@codemirror/state"), 1);

// node_modules/y-codemirror.next/src/y-range.js
var YRange = class {
  /**
   * @param {Y.RelativePosition} yanchor
   * @param {Y.RelativePosition} yhead
   */
  constructor(yanchor, yhead) {
    this.yanchor = yanchor;
    this.yhead = yhead;
  }
  /**
   * @returns {any}
   */
  toJSON() {
    return {
      yanchor: relativePositionToJSON(this.yanchor),
      yhead: relativePositionToJSON(this.yhead)
    };
  }
  /**
   * @param {any} json
   * @return {YRange}
   */
  static fromJSON(json) {
    return new YRange(createRelativePositionFromJSON(json.yanchor), createRelativePositionFromJSON(json.yhead));
  }
};

// node_modules/y-codemirror.next/src/y-sync.js
var cmState = __toESM(require("@codemirror/state"), 1);
var cmView = __toESM(require("@codemirror/view"), 1);
var YSyncConfig = class {
  constructor(ytext, awareness) {
    this.ytext = ytext;
    this.awareness = awareness;
    this.undoManager = new UndoManager(ytext);
  }
  /**
   * Helper function to transform an absolute index position to a Yjs-based relative position
   * (https://docs.yjs.dev/api/relative-positions).
   *
   * A relative position can be transformed back to an absolute position even after the document has changed. The position is
   * automatically adapted. This does not require any position transformations. Relative positions are computed based on
   * the internal Yjs document model. Peers that share content through Yjs are guaranteed that their positions will always
   * synced up when using relatve positions.
   *
   * ```js
   * import { ySyncFacet } from 'y-codemirror'
   *
   * ..
   * const ysync = view.state.facet(ySyncFacet)
   * // transform an absolute index position to a ypos
   * const ypos = ysync.getYPos(3)
   * // transform the ypos back to an absolute position
   * ysync.fromYPos(ypos) // => 3
   * ```
   *
   * It cannot be guaranteed that absolute index positions can be synced up between peers.
   * This might lead to undesired behavior when implementing features that require that all peers see the
   * same marked range (e.g. a comment plugin).
   *
   * @param {number} pos
   * @param {number} [assoc]
   */
  toYPos(pos, assoc = 0) {
    return createRelativePositionFromTypeIndex(this.ytext, pos, assoc);
  }
  /**
   * @param {Y.RelativePosition | Object} rpos
   */
  fromYPos(rpos) {
    const pos = createAbsolutePositionFromRelativePosition(createRelativePositionFromJSON(rpos), this.ytext.doc);
    if (pos == null || pos.type !== this.ytext) {
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    }
    return {
      pos: pos.index,
      assoc: pos.assoc
    };
  }
  /**
   * @param {cmState.SelectionRange} range
   * @return {YRange}
   */
  toYRange(range) {
    const assoc = range.assoc;
    const yanchor = this.toYPos(range.anchor, assoc);
    const yhead = this.toYPos(range.head, assoc);
    return new YRange(yanchor, yhead);
  }
  /**
   * @param {YRange} yrange
   */
  fromYRange(yrange) {
    const anchor = this.fromYPos(yrange.yanchor);
    const head = this.fromYPos(yrange.yhead);
    if (anchor.pos === head.pos) {
      return cmState.EditorSelection.cursor(head.pos, head.assoc);
    }
    return cmState.EditorSelection.range(anchor.pos, head.pos);
  }
};
var ySyncFacet = cmState.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var ySyncAnnotation = cmState.Annotation.define();
var YSyncPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(ySyncFacet);
    this._observer = (event, tr) => {
      if (tr.origin !== this.conf) {
        const delta = event.delta;
        const changes = [];
        let pos = 0;
        for (let i = 0; i < delta.length; i++) {
          const d = delta[i];
          if (d.insert != null) {
            changes.push({ from: pos, to: pos, insert: d.insert });
          } else if (d.delete != null) {
            changes.push({ from: pos, to: pos + d.delete, insert: "" });
            pos += d.delete;
          } else {
            pos += d.retain;
          }
        }
        view.dispatch({ changes, annotations: [ySyncAnnotation.of(this.conf)] });
      }
    };
    this._ytext = this.conf.ytext;
    this._ytext.observe(this._observer);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (!update.docChanged || update.transactions.length > 0 && update.transactions[0].annotation(ySyncAnnotation) === this.conf) {
      return;
    }
    const ytext = this.conf.ytext;
    ytext.doc.transact(() => {
      let adj = 0;
      update.changes.iterChanges((fromA, toA, fromB, toB, insert) => {
        const insertText2 = insert.sliceString(0, insert.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
};
var ySync = cmView.ViewPlugin.fromClass(YSyncPluginValue);

// node_modules/y-codemirror.next/src/y-remote-selections.js
var cmView2 = __toESM(require("@codemirror/view"), 1);
var cmState2 = __toESM(require("@codemirror/state"), 1);
var yRemoteSelectionsTheme = cmView2.EditorView.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    // these should be separate
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var yRemoteSelectionsAnnotation = cmState2.Annotation.define();
var YRemoteCaretWidget = class extends cmView2.WidgetType {
  /**
   * @param {string} color
   * @param {string} name
   */
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM() {
    return (
      /** @type {HTMLElement} */
      element("span", [create5("class", "cm-ySelectionCaret"), create5("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionCaretDot")
        ]),
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionInfo")
        ], [
          text(this.name)
        ]),
        text("\u2060")
      ])
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
var YRemoteSelectionsPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.conf = view.state.facet(ySyncFacet);
    this._listener = ({ added, updated, removed }, s, t) => {
      const clients = added.concat(updated).concat(removed);
      if (clients.findIndex((id2) => id2 !== this.conf.awareness.doc.clientID) >= 0) {
        view.dispatch({ annotations: [yRemoteSelectionsAnnotation.of([])] });
      }
    };
    this._awareness = this.conf.awareness;
    this._awareness.on("change", this._listener);
    this.decorations = cmState2.RangeSet.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    const ytext = this.conf.ytext;
    const ydoc = (
      /** @type {Y.Doc} */
      ytext.doc
    );
    const awareness = this.conf.awareness;
    const decorations = [];
    const localAwarenessState = this.conf.awareness.getLocalState();
    if (localAwarenessState != null) {
      const hasFocus = update.view.hasFocus && update.view.dom.ownerDocument.hasFocus();
      const sel = hasFocus ? update.state.selection.main : null;
      const currentAnchor = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.anchor);
      const currentHead = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.head);
      if (sel != null) {
        const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
        const head = createRelativePositionFromTypeIndex(ytext, sel.head);
        if (localAwarenessState.cursor == null || !compareRelativePositions(currentAnchor, anchor) || !compareRelativePositions(currentHead, head)) {
          awareness.setLocalStateField("cursor", {
            anchor,
            head
          });
        }
      } else if (localAwarenessState.cursor != null && hasFocus) {
        awareness.setLocalStateField("cursor", null);
      }
    }
    awareness.getStates().forEach((state, clientid) => {
      if (clientid === awareness.doc.clientID) {
        return;
      }
      const cursor = state.cursor;
      if (cursor == null || cursor.anchor == null || cursor.head == null) {
        return;
      }
      const anchor = createAbsolutePositionFromRelativePosition(cursor.anchor, ydoc);
      const head = createAbsolutePositionFromRelativePosition(cursor.head, ydoc);
      if (anchor == null || head == null || anchor.type !== ytext || head.type !== ytext) {
        return;
      }
      const { color = "#30bced", name = "Anonymous" } = state.user || {};
      const colorLight = state.user && state.user.colorLight || color + "33";
      const start = min(anchor.index, head.index);
      const end = max(anchor.index, head.index);
      const startLine = update.view.state.doc.lineAt(start);
      const endLine = update.view.state.doc.lineAt(end);
      if (startLine.number === endLine.number) {
        decorations.push({
          from: start,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
      } else {
        decorations.push({
          from: start,
          to: startLine.from + startLine.length,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        decorations.push({
          from: endLine.from,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        for (let i = startLine.number + 1; i < endLine.number; i++) {
          const linePos = update.view.state.doc.line(i).from;
          decorations.push({
            from: linePos,
            to: linePos,
            value: cmView2.Decoration.line({
              attributes: { style: `background-color: ${colorLight}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: cmView2.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          // the local cursor should be rendered outside the remote selection
          block: false,
          widget: new YRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = cmView2.Decoration.set(decorations, true);
  }
};
var yRemoteSelections = cmView2.ViewPlugin.fromClass(YRemoteSelectionsPluginValue, {
  decorations: (v) => v.decorations
});

// node_modules/y-codemirror.next/src/y-undomanager.js
var cmState3 = __toESM(require("@codemirror/state"), 1);
var cmView3 = __toESM(require("@codemirror/view"), 1);

// node_modules/lib0/mutex.js
var createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};

// node_modules/y-codemirror.next/src/y-undomanager.js
var YUndoManagerConfig = class {
  /**
   * @param {Y.UndoManager} undoManager
   */
  constructor(undoManager) {
    this.undoManager = undoManager;
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.undoManager.addTrackedOrigin(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.undoManager.removeTrackedOrigin(origin);
  }
  /**
   * @return {boolean} Whether a change was undone.
   */
  undo() {
    return this.undoManager.undo() != null;
  }
  /**
   * @return {boolean} Whether a change was redone.
   */
  redo() {
    return this.undoManager.redo() != null;
  }
};
var yUndoManagerFacet = cmState3.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var yUndoManagerAnnotation = cmState3.Annotation.define();
var YUndoManagerPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(yUndoManagerFacet);
    this._undoManager = this.conf.undoManager;
    this.syncConf = view.state.facet(ySyncFacet);
    this._beforeChangeSelection = null;
    this._mux = createMutex();
    this._onStackItemAdded = ({ stackItem, changedParentTypes }) => {
      if (changedParentTypes.has(this.syncConf.ytext) && this._beforeChangeSelection && !stackItem.meta.has(this)) {
        stackItem.meta.set(this, this._beforeChangeSelection);
      }
    };
    this._onStackItemPopped = ({ stackItem }) => {
      const sel = stackItem.meta.get(this);
      if (sel) {
        const selection = this.syncConf.fromYRange(sel);
        view.dispatch(view.state.update({
          selection,
          effects: [cmView3.EditorView.scrollIntoView(selection)]
        }));
        this._storeSelection();
      }
    };
    this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    };
    this._undoManager.on("stack-item-added", this._onStackItemAdded);
    this._undoManager.on("stack-item-popped", this._onStackItemPopped);
    this._undoManager.addTrackedOrigin(this.syncConf);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (update.selectionSet && (update.transactions.length === 0 || update.transactions[0].annotation(ySyncAnnotation) !== this.syncConf)) {
      this._storeSelection();
    }
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded);
    this._undoManager.off("stack-item-popped", this._onStackItemPopped);
    this._undoManager.removeTrackedOrigin(this.syncConf);
  }
};
var yUndoManager = cmView3.ViewPlugin.fromClass(YUndoManagerPluginValue);
var undo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).undo() || true;
var redo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).redo() || true;

// node_modules/y-codemirror.next/src/index.js
var yCollab = (ytext, awareness, { undoManager = new UndoManager(ytext) } = {}) => {
  const ySyncConfig = new YSyncConfig(ytext, awareness);
  const plugins = [
    ySyncFacet.of(ySyncConfig),
    ySync
  ];
  if (awareness) {
    plugins.push(
      yRemoteSelectionsTheme,
      yRemoteSelections
    );
  }
  if (undoManager !== false) {
    plugins.push(
      yUndoManagerFacet.of(new YUndoManagerConfig(undoManager)),
      yUndoManager,
      cmView4.EditorView.domEventHandlers({
        beforeinput(e, view) {
          if (e.inputType === "historyUndo")
            return undo(view);
          if (e.inputType === "historyRedo")
            return redo(view);
          return false;
        }
      })
    );
  }
  return plugins;
};

// src/sharedEntities/sharedDocument.ts
var import_state2 = require("@codemirror/state");

// src/utils/peerdraftRecord.ts
var PeerdraftRecord = class extends ObservableV2 {
  constructor() {
    super(...arguments);
    this.record = {};
  }
  set(key, value) {
    const oldValue = this.record[key];
    this.record[key] = value;
    if (oldValue === void 0) {
      this.emit("add", [key, value]);
    } else if (oldValue != value) {
      this.emit("update", [key, oldValue, value]);
    }
  }
  get(key) {
    return this.record[key];
  }
  delete(key) {
    const oldValue = this.record[key];
    delete this.record[key];
    this.emit("delete", [key, oldValue]);
  }
  get size() {
    return Object.keys(this.record).length;
  }
  get keys() {
    return Object.keys(this.record);
  }
};

// src/workspace/peerdraftLeaf.ts
var PeerdraftLeaf = class extends ObservableV2 {
  constructor(path4, isPreview) {
    super();
    this._isPreview = isPreview, this._path = path4;
  }
  get isPreview() {
    return this._isPreview;
  }
  set isPreview(value) {
    const old = this._isPreview;
    this._isPreview = value;
    if (value != old) {
      this.emit("changeIsPreview", [old, value]);
    }
  }
  get path() {
    return this._path;
  }
  set path(value) {
    const old = this._path;
    this._path = value;
    if (value != old) {
      this.emit("changePath", [old, value]);
    }
  }
};

// src/workspace/peerdraftWorkspace.ts
var import_obsidian2 = require("obsidian");
var updatePeerdraftWorkspace = (ws, pws) => {
  var _a, _b;
  const leafs = ws.getLeavesOfType("markdown");
  const oldLeafIds = pws.keys;
  const existingLeafIds = leafs.map((leaf) => {
    return leaf.id;
  });
  for (const leaf of leafs) {
    const leafId = leaf.id;
    const isPreview = leaf.view.containerEl.getAttribute("data-mode") === "preview";
    const path4 = (_b = (_a = leaf.view.file) == null ? void 0 : _a.path) != null ? _b : "";
    let pleaf = pws.get(leafId);
    if (pleaf) {
      pleaf.isPreview = isPreview;
      pleaf.path = path4;
    } else {
      pleaf = new PeerdraftLeaf(path4, isPreview);
      pws.set(leafId, pleaf);
    }
  }
  for (const oldLeafId of oldLeafIds) {
    if (!existingLeafIds.contains(oldLeafId)) {
      pws.delete(oldLeafId);
    }
  }
};
var getLeafsByPath = (path4, pws) => {
  return pws.keys.map((key) => {
    return pws.get(key);
  }).filter((leaf) => {
    return leaf.path === path4;
  });
};
var getLeafIdsByPath = (path4, pws) => {
  const normalizedPath = (0, import_obsidian2.normalizePath)(path4);
  return pws.keys.filter((key) => {
    return (0, import_obsidian2.normalizePath)(pws.get(key).path) === normalizedPath;
  });
};

// node_modules/lib0/websocket.js
var reconnectTimeoutBase = 1200;
var maxReconnectTimeout = 2500;
var messageReconnectTimeout = 3e4;
var setupWS = (wsclient) => {
  if (wsclient.shouldConnect && wsclient.ws === null) {
    const websocket = new WebSocket(wsclient.url);
    const binaryType = wsclient.binaryType;
    let pingTimeout = null;
    if (binaryType) {
      websocket.binaryType = binaryType;
    }
    wsclient.ws = websocket;
    wsclient.connecting = true;
    wsclient.connected = false;
    websocket.onmessage = (event) => {
      wsclient.lastMessageReceived = getUnixTime();
      const data = event.data;
      const message = typeof data === "string" ? JSON.parse(data) : data;
      if (message && message.type === "pong") {
        clearTimeout(pingTimeout);
        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
      }
      wsclient.emit("message", [message, wsclient]);
    };
    const onclose = (error) => {
      if (wsclient.ws !== null) {
        wsclient.ws = null;
        wsclient.connecting = false;
        if (wsclient.connected) {
          wsclient.connected = false;
          wsclient.emit("disconnect", [{ type: "disconnect", error }, wsclient]);
        } else {
          wsclient.unsuccessfulReconnects++;
        }
        setTimeout(setupWS, min(log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);
      }
      clearTimeout(pingTimeout);
    };
    const sendPing = () => {
      if (wsclient.ws === websocket) {
        wsclient.send({
          type: "ping"
        });
      }
    };
    websocket.onclose = () => onclose(null);
    websocket.onerror = (error) => onclose(error);
    websocket.onopen = () => {
      wsclient.lastMessageReceived = getUnixTime();
      wsclient.connecting = false;
      wsclient.connected = true;
      wsclient.unsuccessfulReconnects = 0;
      wsclient.emit("connect", [{ type: "connect" }, wsclient]);
      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
    };
  }
};
var WebsocketClient = class extends Observable {
  /**
   * @param {string} url
   * @param {object} opts
   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`
   */
  constructor(url, { binaryType } = {}) {
    super();
    this.url = url;
    this.ws = null;
    this.binaryType = binaryType || null;
    this.connected = false;
    this.connecting = false;
    this.unsuccessfulReconnects = 0;
    this.lastMessageReceived = 0;
    this.shouldConnect = true;
    this._checkInterval = setInterval(() => {
      if (this.connected && messageReconnectTimeout < getUnixTime() - this.lastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout / 2);
    setupWS(this);
  }
  /**
   * @param {any} message
   */
  send(message) {
    if (this.ws) {
      this.ws.send(JSON.stringify(message));
    }
  }
  destroy() {
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.connected && this.ws === null) {
      setupWS(this);
    }
  }
};

// node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e) => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create2();
  const bc = new BC(room);
  bc.onmessage = (e) => subs.forEach((sub) => sub(e.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};

// node_modules/y-webrtc/src/y-webrtc.js
var import_simplepeer_min = __toESM(require_simplepeer_min(), 1);

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc2) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc2, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc2) => writeSyncStep2(encoder, doc2, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    const clientID = clients[i];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i = 0; i < len; i++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/y-webrtc/src/crypto.js
var deriveKey = (secret, roomName) => {
  const secretBuffer = encodeUtf8(secret).buffer;
  const salt = encodeUtf8(roomName).buffer;
  return crypto.subtle.importKey(
    "raw",
    secretBuffer,
    "PBKDF2",
    false,
    ["deriveKey"]
  ).then(
    (keyMaterial) => crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 1e5,
        hash: "SHA-256"
      },
      keyMaterial,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    )
  );
};
var encrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const iv = crypto.getRandomValues(new Uint8Array(12));
  return crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    data
  ).then((cipher) => {
    const encryptedDataEncoder = createEncoder();
    writeVarString(encryptedDataEncoder, "AES-GCM");
    writeVarUint8Array(encryptedDataEncoder, iv);
    writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));
    return toUint8Array(encryptedDataEncoder);
  });
};
var encryptJson = (data, key) => {
  const dataEncoder = createEncoder();
  writeAny(dataEncoder, data);
  return encrypt(toUint8Array(dataEncoder), key);
};
var decrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const dataDecoder = createDecoder(data);
  const algorithm = readVarString(dataDecoder);
  if (algorithm !== "AES-GCM") {
    reject(create3("Unknown encryption algorithm"));
  }
  const iv = readVarUint8Array(dataDecoder);
  const cipher = readVarUint8Array(dataDecoder);
  return crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    cipher
  ).then((data2) => new Uint8Array(data2));
};
var decryptJson = (data, key) => decrypt(data, key).then(
  (decryptedValue) => readAny(createDecoder(new Uint8Array(decryptedValue)))
);

// node_modules/y-webrtc/src/y-webrtc.js
var log = createModuleLogger2("y-webrtc");
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageBcPeerId = 4;
var signalingConns = /* @__PURE__ */ new Map();
var rooms = /* @__PURE__ */ new Map();
var checkIsSynced = (room) => {
  let synced = true;
  room.webrtcConns.forEach((peer) => {
    if (!peer.synced) {
      synced = false;
    }
  });
  if (!synced && room.synced || synced && !room.synced) {
    room.synced = synced;
    room.provider.emit("synced", [{ synced }]);
    log("synced ", BOLD, room.name, UNBOLD, " with all peers");
  }
};
var readMessage = (room, buf, syncedCallback) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  if (room === void 0) {
    return null;
  }
  const awareness = room.awareness;
  const doc2 = room.doc;
  let sendReply = false;
  switch (messageType) {
    case messageSync: {
      writeVarUint(encoder, messageSync);
      const syncMessageType = readSyncMessage(decoder, encoder, doc2, room);
      if (syncMessageType === messageYjsSyncStep2 && !room.synced) {
        syncedCallback();
      }
      if (syncMessageType === messageYjsSyncStep1) {
        sendReply = true;
      }
      break;
    }
    case messageQueryAwareness:
      writeVarUint(encoder, messageAwareness);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));
      sendReply = true;
      break;
    case messageAwareness:
      applyAwarenessUpdate(awareness, readVarUint8Array(decoder), room);
      break;
    case messageBcPeerId: {
      const add2 = readUint8(decoder) === 1;
      const peerName = readVarString(decoder);
      if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add2 || !room.bcConns.has(peerName) && add2)) {
        const removed = [];
        const added = [];
        if (add2) {
          room.bcConns.add(peerName);
          added.push(peerName);
        } else {
          room.bcConns.delete(peerName);
          removed.push(peerName);
        }
        room.provider.emit("peers", [{
          added,
          removed,
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
        broadcastBcPeerId(room);
      }
      break;
    }
    default:
      console.error("Unable to compute message");
      return encoder;
  }
  if (!sendReply) {
    return null;
  }
  return encoder;
};
var readPeerMessage = (peerConn, buf) => {
  const room = peerConn.room;
  log("received message from ", BOLD, peerConn.remotePeerId, GREY, " (", room.name, ")", UNBOLD, UNCOLOR);
  return readMessage(room, buf, () => {
    peerConn.synced = true;
    log("synced ", BOLD, room.name, UNBOLD, " with ", BOLD, peerConn.remotePeerId);
    checkIsSynced(room);
  });
};
var sendWebrtcConn = (webrtcConn, encoder) => {
  log("send message to ", BOLD, webrtcConn.remotePeerId, UNBOLD, GREY, " (", webrtcConn.room.name, ")", UNCOLOR);
  try {
    webrtcConn.peer.send(toUint8Array(encoder));
  } catch (e) {
  }
};
var broadcastWebrtcConn = (room, m) => {
  log("broadcast message in ", BOLD, room.name, UNBOLD);
  room.webrtcConns.forEach((conn) => {
    try {
      conn.peer.send(m);
    } catch (e) {
    }
  });
};
var WebrtcConn = class {
  /**
   * @param {SignalingConn} signalingConn
   * @param {boolean} initiator
   * @param {string} remotePeerId
   * @param {Room} room
   */
  constructor(signalingConn, initiator, remotePeerId, room) {
    log("establishing connection to ", BOLD, remotePeerId);
    this.room = room;
    this.remotePeerId = remotePeerId;
    this.glareToken = void 0;
    this.closed = false;
    this.connected = false;
    this.synced = false;
    this.peer = new import_simplepeer_min.default({ initiator, ...room.provider.peerOpts });
    this.peer.on("signal", (signal) => {
      if (this.glareToken === void 0) {
        this.glareToken = Date.now() + Math.random();
      }
      publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: "signal", token: this.glareToken, signal });
    });
    this.peer.on("connect", () => {
      log("connected to ", BOLD, remotePeerId);
      this.connected = true;
      const provider = room.provider;
      const doc2 = provider.doc;
      const awareness = room.awareness;
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeSyncStep1(encoder, doc2);
      sendWebrtcConn(this, encoder);
      const awarenessStates = awareness.getStates();
      if (awarenessStates.size > 0) {
        const encoder2 = createEncoder();
        writeVarUint(encoder2, messageAwareness);
        writeVarUint8Array(encoder2, encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));
        sendWebrtcConn(this, encoder2);
      }
    });
    this.peer.on("close", () => {
      this.connected = false;
      this.closed = true;
      if (room.webrtcConns.has(this.remotePeerId)) {
        room.webrtcConns.delete(this.remotePeerId);
        room.provider.emit("peers", [{
          removed: [this.remotePeerId],
          added: [],
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
      }
      checkIsSynced(room);
      this.peer.destroy();
      log("closed connection to ", BOLD, remotePeerId);
      announceSignalingInfo(room);
    });
    this.peer.on("error", (err) => {
      log("Error in connection to ", BOLD, remotePeerId, ": ", err);
      announceSignalingInfo(room);
    });
    this.peer.on("data", (data) => {
      const answer = readPeerMessage(this, data);
      if (answer !== null) {
        sendWebrtcConn(this, answer);
      }
    });
  }
  destroy() {
    this.peer.destroy();
  }
};
var broadcastBcMessage = (room, m) => encrypt(m, room.key).then(
  (data) => room.mux(
    () => publish(room.name, data)
  )
);
var broadcastRoomMessage = (room, m) => {
  if (room.bcconnected) {
    broadcastBcMessage(room, m);
  }
  broadcastWebrtcConn(room, m);
};
var announceSignalingInfo = (room) => {
  signalingConns.forEach((conn) => {
    if (conn.connected) {
      conn.send({ type: "subscribe", topics: [room.name] });
      if (room.webrtcConns.size < room.provider.maxConns) {
        publishSignalingMessage(conn, room, { type: "announce", from: room.peerId });
      }
    }
  });
};
var broadcastBcPeerId = (room) => {
  if (room.provider.filterBcConns) {
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 1);
    writeVarString(encoderPeerIdBc, room.peerId);
    broadcastBcMessage(room, toUint8Array(encoderPeerIdBc));
  }
};
var Room = class {
  /**
   * @param {Y.Doc} doc
   * @param {WebrtcProvider} provider
   * @param {string} name
   * @param {CryptoKey|null} key
   */
  constructor(doc2, provider, name, key) {
    this.peerId = uuidv4();
    this.doc = doc2;
    this.awareness = provider.awareness;
    this.provider = provider;
    this.synced = false;
    this.name = name;
    this.key = key;
    this.webrtcConns = /* @__PURE__ */ new Map();
    this.bcConns = /* @__PURE__ */ new Set();
    this.mux = createMutex();
    this.bcconnected = false;
    this._bcSubscriber = (data) => decrypt(new Uint8Array(data), key).then(
      (m) => this.mux(() => {
        const reply = readMessage(this, m, () => {
        });
        if (reply) {
          broadcastBcMessage(this, toUint8Array(reply));
        }
      })
    );
    this._docUpdateHandler = (update, _origin) => {
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeUpdate(encoder, update);
      broadcastRoomMessage(this, toUint8Array(encoder));
    };
    this._awarenessUpdateHandler = ({ added, updated, removed }, _origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoderAwareness = createEncoder();
      writeVarUint(encoderAwareness, messageAwareness);
      writeVarUint8Array(encoderAwareness, encodeAwarenessUpdate(this.awareness, changedClients));
      broadcastRoomMessage(this, toUint8Array(encoderAwareness));
    };
    this._beforeUnloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc2.clientID], "window unload");
      rooms.forEach((room) => {
        room.disconnect();
      });
    };
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", this._beforeUnloadHandler);
    }
  }
  connect() {
    this.doc.on("update", this._docUpdateHandler);
    this.awareness.on("update", this._awarenessUpdateHandler);
    announceSignalingInfo(this);
    const roomName = this.name;
    subscribe(roomName, this._bcSubscriber);
    this.bcconnected = true;
    broadcastBcPeerId(this);
    const encoderSync = createEncoder();
    writeVarUint(encoderSync, messageSync);
    writeSyncStep1(encoderSync, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderSync));
    const encoderState = createEncoder();
    writeVarUint(encoderState, messageSync);
    writeSyncStep2(encoderState, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderState));
    const encoderAwarenessQuery = createEncoder();
    writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
    broadcastBcMessage(this, toUint8Array(encoderAwarenessQuery));
    const encoderAwarenessState = createEncoder();
    writeVarUint(encoderAwarenessState, messageAwareness);
    writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
    broadcastBcMessage(this, toUint8Array(encoderAwarenessState));
  }
  disconnect() {
    signalingConns.forEach((conn) => {
      if (conn.connected) {
        conn.send({ type: "unsubscribe", topics: [this.name] });
      }
    });
    removeAwarenessStates(this.awareness, [this.doc.clientID], "disconnect");
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 0);
    writeVarString(encoderPeerIdBc, this.peerId);
    broadcastBcMessage(this, toUint8Array(encoderPeerIdBc));
    unsubscribe(this.name, this._bcSubscriber);
    this.bcconnected = false;
    this.doc.off("update", this._docUpdateHandler);
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.webrtcConns.forEach((conn) => conn.destroy());
  }
  destroy() {
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", this._beforeUnloadHandler);
    }
  }
};
var openRoom = (doc2, provider, name, key) => {
  if (rooms.has(name)) {
    throw create3(`A Yjs Doc connected to room "${name}" already exists!`);
  }
  const room = new Room(doc2, provider, name, key);
  rooms.set(
    name,
    /** @type {Room} */
    room
  );
  return room;
};
var publishSignalingMessage = (conn, room, data) => {
  if (room.key) {
    encryptJson(data, room.key).then((data2) => {
      conn.send({ type: "publish", topic: room.name, data: toBase64(data2) });
    });
  } else {
    conn.send({ type: "publish", topic: room.name, data });
  }
};
var SignalingConn = class extends WebsocketClient {
  constructor(url) {
    super(url);
    this.providers = /* @__PURE__ */ new Set();
    this.on("connect", () => {
      log(`connected (${url})`);
      const topics = Array.from(rooms.keys());
      this.send({ type: "subscribe", topics });
      rooms.forEach(
        (room) => publishSignalingMessage(this, room, { type: "announce", from: room.peerId })
      );
    });
    this.on("message", (m) => {
      switch (m.type) {
        case "publish": {
          const roomName = m.topic;
          const room = rooms.get(roomName);
          if (room == null || typeof roomName !== "string") {
            return;
          }
          const execMessage = (data) => {
            const webrtcConns = room.webrtcConns;
            const peerId = room.peerId;
            if (data == null || data.from === peerId || data.to !== void 0 && data.to !== peerId || room.bcConns.has(data.from)) {
              return;
            }
            const emitPeerChange = webrtcConns.has(data.from) ? () => {
            } : () => room.provider.emit("peers", [{
              removed: [],
              added: [data.from],
              webrtcPeers: Array.from(room.webrtcConns.keys()),
              bcPeers: Array.from(room.bcConns)
            }]);
            switch (data.type) {
              case "announce":
                if (webrtcConns.size < room.provider.maxConns) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));
                  emitPeerChange();
                }
                break;
              case "signal":
                if (data.signal.type === "offer") {
                  const existingConn = webrtcConns.get(data.from);
                  if (existingConn) {
                    const remoteToken = data.token;
                    const localToken = existingConn.glareToken;
                    if (localToken && localToken > remoteToken) {
                      log("offer rejected: ", data.from);
                      return;
                    }
                    existingConn.glareToken = void 0;
                  }
                }
                if (data.signal.type === "answer") {
                  log("offer answered by: ", data.from);
                  const existingConn = webrtcConns.get(data.from);
                  existingConn.glareToken = void 0;
                }
                if (data.to === peerId) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);
                  emitPeerChange();
                }
                break;
            }
          };
          if (room.key) {
            if (typeof m.data === "string") {
              decryptJson(fromBase64(m.data), room.key).then(execMessage);
            }
          } else {
            execMessage(m.data);
          }
        }
      }
    });
    this.on("disconnect", () => log(`disconnect (${url})`));
  }
};
var emitStatus = (provider) => {
  provider.emit("status", [{
    connected: provider.connected
  }]);
};
var WebrtcProvider = class extends ObservableV2 {
  /**
   * @param {string} roomName
   * @param {Y.Doc} doc
   * @param {ProviderOptions?} opts
   */
  constructor(roomName, doc2, {
    signaling = ["wss://y-webrtc-eu.fly.dev"],
    password = null,
    awareness = new Awareness(doc2),
    maxConns = 20 + floor(rand() * 15),
    // the random factor reduces the chance that n clients form a cluster
    filterBcConns = true,
    peerOpts = {}
    // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts
  } = {}) {
    super();
    this.roomName = roomName;
    this.doc = doc2;
    this.filterBcConns = filterBcConns;
    this.awareness = awareness;
    this.shouldConnect = false;
    this.signalingUrls = signaling;
    this.signalingConns = [];
    this.maxConns = maxConns;
    this.peerOpts = peerOpts;
    this.key = password ? deriveKey(password, roomName) : (
      /** @type {PromiseLike<null>} */
      resolve(null)
    );
    this.room = null;
    this.key.then((key) => {
      this.room = openRoom(doc2, this, roomName, key);
      if (this.shouldConnect) {
        this.room.connect();
      } else {
        this.room.disconnect();
      }
      emitStatus(this);
    });
    this.connect();
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  /**
   * Indicates whether the provider is looking for other peers.
   *
   * Other peers can be found via signaling servers or via broadcastchannel (cross browser-tab
   * communication). You never know when you are connected to all peers. You also don't know if
   * there are other peers. connected doesn't mean that you are connected to any physical peers
   * working on the same resource as you. It does not change unless you call provider.disconnect()
   *
   * `this.on('status', (event) => { console.log(event.connected) })`
   *
   * @type {boolean}
   */
  get connected() {
    return this.room !== null && this.shouldConnect;
  }
  connect() {
    this.shouldConnect = true;
    this.signalingUrls.forEach((url) => {
      const signalingConn = setIfUndefined(signalingConns, url, () => new SignalingConn(url));
      this.signalingConns.push(signalingConn);
      signalingConn.providers.add(this);
    });
    if (this.room) {
      this.room.connect();
      emitStatus(this);
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.signalingConns.forEach((conn) => {
      conn.providers.delete(this);
      if (conn.providers.size === 0) {
        conn.destroy();
        signalingConns.delete(conn.url);
      }
    });
    if (this.room) {
      this.room.disconnect();
      emitStatus(this);
    }
  }
  destroy() {
    this.doc.off("destroy", this.destroy);
    this.key.then(() => {
      this.room.destroy();
      rooms.delete(this.roomName);
    });
    super.destroy();
  }
};

// src/sharedEntities/sharedEntity.ts
var import_obsidian3 = require("obsidian");
var SharedEntity = class {
  constructor(plugin) {
    this.plugin = plugin;
    this._webRTCTimeout = null;
  }
  get shareId() {
    return this._shareId;
  }
  get path() {
    return this._path;
  }
  get indexedDBProvider() {
    return this._indexedDBProvider;
  }
  get webRTCProvider() {
    return this._webRTCProvider;
  }
  static findByPath(path4) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(path4);
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.path === normalizedPath;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static findById(id2) {
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.shareId === id2;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static getAll() {
    return Object.assign([], this._sharedEntites);
  }
  initServerYDoc() {
    return new Promise((resolve2) => {
      const tempId = createRandomId();
      const handler = (serverTempId, id2, checksum) => {
        if (serverTempId === tempId) {
          this.plugin.serverSync.off("new-doc-confirmed", handler);
          this._shareId = id2;
          resolve2(checksum);
        }
      };
      this.plugin.serverSync.on("new-doc-confirmed", handler);
      this.plugin.serverSync.sendNewDocument(this, tempId);
    });
  }
  syncWithServer() {
    return new Promise((resolve2) => {
      const handler = async (id2, hash) => {
        if (id2 === this.shareId) {
          this.plugin.serverSync.off("synced", handler);
          this.plugin.log("synced " + this.path);
          resolve2(hash);
        }
      };
      this.plugin.serverSync.on("synced", handler);
      this.plugin.serverSync.sendSyncStep1(this);
      this.plugin.log("syncing " + this.path);
    });
  }
  startWebRTCSync(init) {
    this.plugin.log(`WebRTC for ${this.path}: start`);
    if (!this.shareId)
      return;
    if (this._webRTCProvider) {
      this._webRTCProvider.connect();
      return this._webRTCProvider;
    }
    const webRTCProvider = new WebrtcProvider(this._shareId, this.yDoc, { signaling: [this.plugin.settings.signaling], peerOpts: { iceServers: [{ urls: "stun:freeturn.net:5349" }, { urls: "turns:freeturn.net:5349", username: "free", credential: "free" }, { urls: "stun:stun.l.google.com:19302" }, { urls: "stun:global.stun.twilio.com:3478?transport=udp" }] } });
    this._webRTCProvider = webRTCProvider;
    if (init) {
      init(webRTCProvider);
    }
    return webRTCProvider;
  }
  stopWebRTCSync() {
    var _a, _b, _c;
    if (!this._webRTCProvider)
      return;
    this.plugin.log(`WebRTC for ${this.path}: stop`);
    (_a = this._webRTCProvider) == null ? void 0 : _a.awareness.destroy();
    (_b = this._webRTCProvider) == null ? void 0 : _b.disconnect();
    (_c = this._webRTCProvider) == null ? void 0 : _c.destroy();
    this._webRTCProvider = void 0;
  }
  async stopIndexedDBSync() {
    if (!this._indexedDBProvider)
      return;
    await this._indexedDBProvider.destroy();
  }
  destroy() {
    this.stopWebRTCSync();
  }
};
SharedEntity.DB_PERSISTENCE_PREFIX = "peerdraft_persistence_";

// src/sharedEntities/sharedDocument.ts
var path2 = __toESM(require("path"));

// node_modules/lib0/indexeddb.js
var rtop = (request) => create4((resolve2, reject2) => {
  request.onerror = (event) => reject2(new Error(event.target.error));
  request.onsuccess = (event) => resolve2(event.target.result);
});
var openDB = (name, initDB) => create4((resolve2, reject2) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject2(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve2(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count = (store, range) => rtop(store.count(range));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range, limit) => rtop(store.getAll(range, limit));
var queryFirst = (store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
};
var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
var iterateOnRequest = (request, f) => create4((resolve2, reject2) => {
  request.onerror = reject2;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve2();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t, store) => t.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve2) => this.on("synced", () => resolve2(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed)
          return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// src/workspace/explorerView.ts
var addIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.addClass("pd-explorer-shared");
  });
};
var removeIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.removeClass("pd-explorer-shared");
  });
};

// src/sharedEntities/sharedFolder.ts
var import_obsidian10 = require("obsidian");
var path = __toESM(require("path"));

// src/settings.ts
var import_obsidian7 = require("obsidian");

// src/ui/selectFolder.ts
var import_obsidian4 = require("obsidian");
var SelectFolderModal = class extends import_obsidian4.SuggestModal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
    this.folders = [];
    import_obsidian4.Vault.recurseChildren(app.vault.getRoot(), (file) => {
      if (file instanceof import_obsidian4.TFolder)
        this.folders.push(file);
    });
    this.folders.shift();
    this.folders.sort((a, b) => {
      return a.path.toLocaleLowerCase().localeCompare(b.path.toLocaleLowerCase());
    });
  }
  onOpen() {
    super.onOpen();
    this.inputEl.placeholder = "Choose a location";
  }
  getSuggestions(query) {
    return this.folders.filter((folder) => {
      return folder.path.toLocaleLowerCase().includes(query.toLocaleLowerCase());
    });
  }
  renderSuggestion(value, el) {
    el.setText(value.path);
  }
  selectSuggestion(value, evt) {
    this.selectedFolder = value;
    super.selectSuggestion(value, evt);
  }
  onChooseSuggestion(item, evt) {
  }
  onClose() {
    this.cb(this.selectedFolder);
  }
};
var promptForFolderSelection = async (app) => {
  return new Promise((resolve2) => {
    new SelectFolderModal(app, (folder) => {
      resolve2(folder);
    }).open();
  });
};

// node_modules/dexie/dist/modern/dexie.mjs
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys2 = Object.keys;
var isArray2 = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys2(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys2 : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args2, start, end) {
  return _slice.call(args2, start, end);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
function asap$1(fn) {
  if (_global.setImmediate)
    setImmediate(fn);
  else
    setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn, onerror, args2) {
  try {
    fn.apply(null, args2);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string" && hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray2(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray2(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m in obj) {
    if (hasOwn(obj, m))
      rv[m] = obj[m];
  }
  return rv;
}
var concat = [].concat;
function flatten(a) {
  return concat.apply([], a);
}
var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
var intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject(intrinsicTypeNames, (x) => [x, true]);
var circularRefs = null;
function deepClone(any2) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any2);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any2) {
  if (!any2 || typeof any2 !== "object")
    return any2;
  let rv = circularRefs && circularRefs.get(any2);
  if (rv)
    return rv;
  if (isArray2(any2)) {
    rv = [];
    circularRefs && circularRefs.set(any2, rv);
    for (var i = 0, l = any2.length; i < l; ++i) {
      rv.push(innerDeepClone(any2[i]));
    }
  } else if (intrinsicTypes.indexOf(any2.constructor) >= 0) {
    rv = any2;
  } else {
    const proto = getProto(any2);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any2, rv);
    for (var prop in any2) {
      if (hasOwn(any2, prop)) {
        rv[prop] = innerDeepClone(any2[prop]);
      }
    }
  }
  return rv;
}
var { toString } = {};
function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a, x, it;
  if (arguments.length === 1) {
    if (isArray2(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a = [];
      while (x = it.next(), !x.done)
        a.push(x.value);
      return a;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a = new Array(i);
      while (i--)
        a[i] = arrayLike[i];
      return a;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a = new Array(i);
  while (i--)
    a[i] = arguments[i];
  return a;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? (fn) => fn[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}
var libraryFilter = () => true;
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
var BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop2() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args2 = new Array(i);
      while (i--)
        args2[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args2);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var ZONE_ECHO_LIMIT = 100;
var [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})();
var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args2) {
  microtickQueue.push([callback, args2]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop2;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn !== "function") {
    if (fn !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}
var thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve2, reject2) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve2, reject2, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve2, reject2) => {
      var handle = setTimeout(() => reject2(new exceptions.Timeout(msg)), ms);
      this.then(resolve2, reject2).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve2, reject2, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve2;
  this.reject = reject2;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve2, reject2) {
      if (values.length === 0)
        resolve2([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve2(values);
      }, reject2));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve2, reject2) => {
        value.then(resolve2, reject2);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve2, reject2) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve2, reject2));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve2, reject2) => {
      return newScope((resolve3, reject3) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject3;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve3() : reject3(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve2, reject2);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2) => {
        if (possiblePromises.length === 0)
          resolve2([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve2(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2, reject2) => {
        if (possiblePromises.length === 0)
          reject2(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => resolve2(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject2(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn) {
  try {
    fn((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve2, reject2) => {
          value instanceof DexiePromise ? value._then(resolve2, reject2) : value.then(resolve2, reject2);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit) {
  if (stacks.length === limit)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;
      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p) => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p) => p._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
var task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props2, a1, a2) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn, a1, a2);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop2;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== "function" ? fn : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn) {
  if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }
    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop2);
    }
    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db._close();
        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve2, reject2) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve2, reject2, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
var DEXIE_VERSION = "3.2.7";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
var AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
var Table = class {
  _trans(mode, fn, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve2, reject2, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray2(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys2(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => {
      if (ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0)) {
        for (let i = 0; i < keyPaths.length; ++i) {
          if (keyPaths.indexOf(ix.keyPath[i]) === -1)
            return false;
        }
        return true;
      }
      return false;
    }).sort((a, b) => a.keyPath.length - b.keyPath.length)[0];
    if (compoundIndex && this.db._maxKey !== maxString) {
      const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
      return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp) => indexOrCrit[kp]));
    }
    if (!compoundIndex && debug)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a, b) {
      try {
        return idb.cmp(a, b) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray2(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset) {
    return this.toCollection().offset(offset);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray2(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    this.schema.mappedClass = constructor;
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (var m in obj)
        if (hasOwn(obj, m))
          try {
            res[m] = obj[m];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray2(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys2(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys3) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys3,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys3, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys3, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys3) {
    const numKeys = keys3.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys3 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
};
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args2 = new Array(i2 - 1);
      while (--i2)
        args2[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args2);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add2;
  for (var i = 1, l = arguments.length; i < l; ++i) {
    add2(arguments[i]);
  }
  return rv;
  function add2(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop2;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context.subscribers = context.subscribers.filter(function(fn) {
          return fn !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }
  function addConfiguredEvents(cfg) {
    keys2(cfg).forEach(function(eventName) {
      var args2 = cfg[eventName];
      if (isArray2(args2)) {
        add2(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args2 === "asap") {
        var context = add2(eventName, mirror, function fire() {
          var i2 = arguments.length, args3 = new Array(i2);
          while (i2--)
            args3[i2] = arguments[i2];
          context.subscribers.forEach(function(fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args3);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table3(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop2],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop2],
      "deleting": [hookDeletingChain, nop2]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
  ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};
    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, (result) => cursor.stop(result), (err) => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set, key)) {
          set[key] = true;
          fn(item, cursor, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor) => {
    if (cursor) {
      return cursor.start(() => {
        var c = () => cursor.continue();
        if (!filter || filter(cursor, (advancer) => c = advancer, (val) => {
          cursor.stop(val);
          c = nop2;
        }, (e) => {
          cursor.fail(e);
          c = nop2;
        }))
          wrappedFn(cursor.value, cursor, (advancer) => c = advancer);
        c();
      });
    }
  });
}
function cmp(a, b) {
  try {
    const ta = type(a);
    const tb = type(b);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a > b ? 1 : a < b ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
      }
      case "Array":
        return compareArrays(a, b);
    }
  } catch (_a) {
  }
  return NaN;
}
function compareArrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    const res = cmp(a[i], b[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    if (a[i] !== b[i])
      return a[i] < b[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
  if (a instanceof Uint8Array)
    return a;
  if (ArrayBuffer.isView(a))
    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}
var Collection = class {
  _read(fn, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
  }
  _write(fn) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
  }
  _addAlgorithm(fn) {
    var ctx = this._ctx;
    ctx.algorithm = combine(ctx.algorithm, fn);
  }
  _iterate(fn, coreTrans) {
    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count3) => Math.min(count3, ctx.limit));
      } else {
        var count2 = 0;
        return iter(ctx, () => {
          ++count2;
          return false;
        }, trans, coreTable).then(() => count2);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a, b) {
      var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
      return aVal < bVal ? -order : aVal > bVal ? order : 0;
    }
    return this.toArray(function(a) {
      return a.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a = [];
        return iter(ctx, (item) => a.push(item), trans, ctx.table.core).then(() => a);
      }
    }, cb);
  }
  offset(offset) {
    var ctx = this._ctx;
    if (offset <= 0)
      return this;
    ctx.offset += offset;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return (cursor, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor, advance, resolve2) {
        if (--rowsLeft <= 0)
          advance(resolve2);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor, advance, resolve2) {
      if (filterFunction(cursor.value)) {
        advance(resolve2);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a) {
      return a[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor) {
      return filterFunction(cursor.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter) {
    return this.filter(filter);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.key, cursor);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.primaryKey, cursor);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.key);
    }).then(function() {
      return a;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.primaryKey);
    }).then(function() {
      return a;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a) {
      return a[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set = {};
    addFilter(this._ctx, function(cursor) {
      var strKey = cursor.primaryKey.toString();
      var found = hasOwn(set, strKey);
      set[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys2(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey } = coreTable.schema.primaryKey;
      const limit = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys2(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys3) => {
        const nextChunk = (offset) => {
          const count2 = Math.min(limit, keys3.length - offset);
          return coreTable.getMany({
            trans,
            keys: keys3.slice(offset, offset + count2),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count2; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys3[offset + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys3[offset + i]);
                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {
                  deleteKeys.push(keys3[offset + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys3[offset + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys3.length > offset + count2 && nextChunk(offset + limit);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys3.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count2) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count2 - numFailures);
            return count2 - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
};
var deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a, b) {
  return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
  return a > b ? -1 : a === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s) => s.toUpperCase() : (s) => s.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s) => s.toLowerCase() : (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length3 = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length3; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length3 < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length3 < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s) => typeof s === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a, b) {
      return compare(a.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c._ondirectionchange = function(direction2) {
    initDirection(direction2);
  };
  var firstPossibleNeedle = 0;
  c._addAlgorithm(function(cursor, advance, resolve2) {
    var key = cursor.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve2);
      }
      return false;
    }
  });
  return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
var WhereClause = class {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.some((n) => x.indexOf(n) === 0), set, maxString);
  }
  anyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare = this._cmp;
    try {
      set.sort(compare);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set.length === 0)
      return emptyCollection(this);
    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
    c._ondirectionchange = (direction) => {
      compare = direction === "next" ? this._ascending : this._descending;
      set.sort(compare);
    };
    let i = 0;
    c._addAlgorithm((cursor, advance, resolve2) => {
      const key = cursor.key;
      while (compare(key, set[i]) > 0) {
        ++i;
        if (i === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (compare(key, set[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor.continue(set[i]);
        });
        return false;
      }
    });
    return c;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return new this.Collection(this);
    try {
      set.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set[set.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range) => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options || options.includeLowers !== false;
    const includeUppers = options && options.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l = ranges2.length;
      for (; i < l; ++i) {
        const range = ranges2[i];
        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
          range[0] = min2(range[0], newRange[0]);
          range[1] = max2(range[1], newRange[1]);
          break;
        }
      }
      if (i === l)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a, b) {
      return sortDirection(a[0], b[0]);
    }
    let set;
    try {
      set = ranges.reduce(addRange2, []);
      set.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set[rangePos][1]) > 0 : (key) => ascending(key, set[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set[rangePos][0]) > 0 : (key) => descending(key, set[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
    c._ondirectionchange = (direction) => {
      if (direction === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set.sort(rangeSorter);
    };
    c._addAlgorithm((cursor, advance, resolve2) => {
      var key = cursor.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor.continue(set[rangePos][0]);
          else
            cursor.continue(set[rangePos][1]);
        });
        return false;
      }
    });
    return c;
  }
  startsWithAnyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set.every((s) => typeof s === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set.map((str) => [str, str + maxString]));
  }
};
function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a, b) => indexedDB2.cmp(b, a);
    this._max = (a, b) => indexedDB2.cmp(a, b) > 0 ? a : b;
    this._min = (a, b) => indexedDB2.cmp(a, b) < 0 ? a : b;
    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject2) {
  return wrap(function(event) {
    preventDefault(event);
    reject2(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction2 = class {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve2, reject2) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn, bWriteLock).then(resolve2, reject2);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p2 = new DexiePromise((resolve2, reject2) => {
          this._lock();
          const rv = fn(resolve2, reject2, this);
          if (rv && rv.then)
            rv.then(resolve2, reject2);
        });
        p2.finally(() => this._unlock());
        p2._lib = true;
        return p2;
      });
    } else {
      var p = new DexiePromise((resolve2, reject2) => {
        var rv = fn(resolve2, reject2, this);
        if (rv && rv.then)
          rv.then(resolve2, reject2);
      });
      p._lib = true;
      return p;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve2, reject2) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve2.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject2.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
};
function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction2.prototype, function Transaction3(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve2, reject2) => {
      this._resolve = resolve2;
      this._reject = reject2;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split(".");
  if (split.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db2, trans) {
    const tables2 = arrayify(db2.objectStoreNames);
    return {
      schema: {
        name: db2.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray2(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray2(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range) {
    if (range.type === 3)
      return null;
    if (range.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys3, values, range }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length: length3 } = keys3 || values || { length: 1 };
        if (keys3 && values && keys3.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length3 === 0)
          return resolve2({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range.type === 4)
            return resolve2({ numFailures, failures, results: [], lastResult: void 0 });
          if (range.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys3] : [values, null] : [keys3, null];
          if (isAddOrPut) {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve2({
            numFailures,
            failures,
            results: type2 === "delete" ? keys3 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query2, reverse, unique }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const { index, range } = query2;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
        req.onerror = eventRejectHandler(reject2);
        req.onsuccess = wrap((ev) => {
          const cursor = req.result;
          if (!cursor) {
            resolve2(null);
            return;
          }
          cursor.___id = ++_id_counter;
          cursor.done = false;
          const _cursorContinue = cursor.continue.bind(cursor);
          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
          const _cursorAdvance = cursor.advance.bind(cursor);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject2);
          cursor.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;
              cursor.stop = (value) => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;
                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve2(cursor);
        }, reject2);
      });
    }
    function query(hasGetAll2) {
      return (request) => {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const { trans, values, limit, query: query2 } = request;
          const nonInfinitLimit = limit === Infinity ? void 0 : limit;
          const { index, range } = query2;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0)
            return resolve2({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve2({ result: event.target.result });
            req.onerror = eventRejectHandler(reject2);
          } else {
            let count2 = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor = req.result;
              if (!cursor)
                return resolve2({ result });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count2 === limit)
                return resolve2({ result });
              cursor.continue();
            };
            req.onerror = eventRejectHandler(reject2);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys3 }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const length3 = keys3.length;
          const result = new Array(length3);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve2(result);
          };
          const errorHandler = eventRejectHandler(reject2);
          for (let i = 0; i < length3; ++i) {
            const key = keys3[i];
            if (key != null) {
              req = store.get(keys3[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve2(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve2(event.target.result);
          req.onerror = eventRejectHandler(reject2);
        });
      },
      query: query(hasGetAll),
      openCursor: openCursor2,
      count({ query: query2, trans }) {
        const { index, range } = query2;
        return new Promise((resolve2, reject2) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve2(ev.target.result));
          req.onerror = eventRejectHandler(reject2);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create: create7 }) => ({ ...down, ...create7(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange: IDBKeyRange2, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach((table) => {
    const tableName = table.name;
    if (db.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db.core.table(tableName);
      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a, b) {
  return a._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject2) {
  const globalSchema = db._dbSchema;
  const trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject2);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys2(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v) => v._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys2(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }
  return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys2(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys2(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray2(keyPath), indexNum === 0);
  });
}
var Version = class {
  _parseStoresSpec(stores, outSchema) {
    keys2(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db._dbSchema = dbschema;
    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys2(dbschema), dbschema);
    db._storeNames = keys2(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop2, upgradeFunction);
    return this;
  }
};
function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange2) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange: IDBKeyRange2
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop2);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop2);
}
function vip(fn) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn();
  });
}
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve2) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve2);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db) {
  const state = db._state;
  const { indexedDB: indexedDB2 } = db._deps;
  if (state.isBeingOpened || db.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  const tryOpenDB = () => new DexiePromise((resolve2, reject2) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject2);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject2(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject2);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject2);
      }
    }, reject2);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db, tmpTrans);
        } catch (e) {
        }
      connections.push(db);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db._deps, dbName);
      resolve2();
    }, reject2);
  }).catch((err) => {
    if (err && err.name === "UnknownError" && state.PR1398_maxLoop > 0) {
      state.PR1398_maxLoop--;
      console.warn("Dexie: Workaround for Chrome UnknownError on open()");
      return tryOpenDB();
    } else {
      return DexiePromise.reject(err);
    }
  });
  return DexiePromise.race([
    openCanceller,
    (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
  ]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop2);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {
    }
    if (openCanceller === state.openCanceller) {
      db._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator) {
  var callNext = (result) => iterator.next(result), doThrow = (error) => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray2(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args2 = new Array(i - 1);
  while (--i)
    args2[i - 1] = arguments[i];
  scopeFunc = args2.pop();
  var tables = flatten(args2);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db._close();
          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a, value, count2) {
  const result = isArray2(a) ? a.slice() : [a];
  for (let i = 0; i < count2; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a, b) => a.keyTail - b.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }
            const virtualCursor = Object.create(cursor, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor) => cursor && createVirtualCursor(cursor));
        }
      };
      return result;
    }
  };
}
var virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys2(a).forEach((prop) => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a[prop], bp = b[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b[prop];
    }
  });
  keys2(b).forEach((prop) => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop2 && updating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys3 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys3)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys3 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys3).then((existingValues) => {
              const contexts = keys3.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys3.length; ++i) {
                  const primKey = results ? results[i] : keys3[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range, limit) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys3, cache, clone) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys3.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys3.length; ++i) {
      if (cmp(cache.keys[i], keys3[j]) !== 0)
        continue;
      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys3.length ? result : null;
  } catch (_a) {
    return null;
  }
}
var cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core) => {
    return {
      table: (tableName) => {
        const table = core.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node) {
  return !("from" in node);
}
var RangeSet2 = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet2();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet2.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys3) {
    keys3.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from2, to) {
  const diff = cmp(from2, to);
  if (isNaN(diff))
    return;
  if (diff > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from: from2, to, d: 1 });
  const left = target.l;
  const right = target.r;
  if (cmp(to, target.from) < 0) {
    left ? addRange(left, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.to) > 0) {
    right ? addRange(right, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.from) < 0) {
    target.from = from2;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }
  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left && !target.l) {
    mergeRanges(target, left);
  }
  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from: from2, to, l, r }) {
    addRange(target2, from2, to);
    if (l)
      _addRangeSet(target2, l);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
      return true;
    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
  }
  return false;
}
function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : { s: 0, n: node };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a, _b;
  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
  if (r) {
    const l = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
var observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core) => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
    return {
      ...core,
      table: (tableName) => {
        const table = core.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys3, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray2(keys3)) {
                if (type2 !== "delete")
                  keys3 = res.results;
                pkRangeSet.addKeys(keys3);
                const oldObjs = getFromTransactionCache(keys3, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys3);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys3) {
                const range = { from: keys3.lower, to: keys3.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range } }) => {
          var _a, _b;
          return [
            index,
            new RangeSet2((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet2(req.key)],
          getMany: (req) => [primaryKey, new RangeSet2().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys2(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet2());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray2(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);
      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = class {
  constructor(name, options) {
    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options = {
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options
    };
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const { addons } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop2,
      dbReadyPromise: null,
      cancelOpen: nop2,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop2] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe2) => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else {
            subscribe2(subscriber);
            const db = this;
            if (!bSticky)
              subscribe2(function unsubscribe2() {
                db.on.ready.unsubscribe(subscriber);
                db.on.ready.unsubscribe(unsubscribe2);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c) => c.name === this.name && c !== this && !c._state.vcFired).map((c) => c.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v) => v._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve2, reject2) => {
      if (this._state.openComplete) {
        return reject2(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject2(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop2);
      }
      this._state.dbReadyPromise.then(resolve2, reject2);
    }).then(fn);
  }
  use({ stack, create: create7, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create: create7, level: level == null ? 10 : level, name });
    middlewares.sort((a, b) => a.level - b.level);
    return this;
  }
  unuse({ stack, name, create: create7 }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create7 ? mw.create !== create7 : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve2, reject2) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve2();
        });
        req.onerror = eventRejectHandler(reject2);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys2(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args2 = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args2);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject2) => {
        reject2(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
};
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable2 = class {
  constructor(subscribe2) {
    this._subscribe = subscribe2;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
};
function extendObservabilitySet(target, newSet) {
  keys2(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet2());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  let hasValue = false;
  let currentValue = void 0;
  const observable = new Observable2((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening = false;
    function shouldNotify() {
      return keys2(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed)
        return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        hasValue = true;
        currentValue = result;
        querying = false;
        if (closed)
          return;
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        querying = false;
        hasValue = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };
    doQuery();
    return subscription;
  });
  observable.hasValue = () => hasValue;
  observable.getValue = () => currentValue;
  return observable;
}
var domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
var Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db = new Dexie(databaseName, { addons: [] });
    return db.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db) => {
      db.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args2, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n) => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  if (typeof bc.unref === "function") {
    bc.unref();
  }
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

// src/permanentShareStore.ts
var PermanentShareStoreIndexedDB = class {
  constructor(oid) {
    this.keepOpen = true;
    this.oid = oid;
    this.db = new Dexie$1("peerdraft_" + this.oid);
    this.db.version(2).stores({
      sharedDocs: "path,persistenceId,shareId",
      sharedFolders: "path,persistenceId,shareId"
    });
    this.db.on("close", () => {
      if (this.keepOpen) {
        this.db.open();
      }
    });
    this.documentTable = this.db._allTables["sharedDocs"];
    this.folderTable = this.db._allTables["sharedFolders"];
  }
  close() {
    this.keepOpen = false;
    this.db.close();
  }
  add(doc2) {
    if (doc2 instanceof SharedDocument) {
      return this.documentTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
    if (doc2 instanceof SharedFolder) {
      return this.folderTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
  }
  removeDoc(path4) {
    return this.documentTable.delete(path4);
  }
  async getDocByPath(path4) {
    return this.documentTable.get(path4);
  }
  getAllDocs() {
    return this.documentTable.toArray();
  }
  removeFolder(path4) {
    return this.folderTable.delete(path4);
  }
  getAllFolders() {
    return this.folderTable.toArray();
  }
  async getFolderByPath(path4) {
    return this.folderTable.get(path4);
  }
  async deleteDB() {
    window.indexedDB.deleteDatabase(this.folderTable.name);
    window.indexedDB.deleteDatabase(this.documentTable.name);
  }
};

// src/login.ts
var import_obsidian5 = require("obsidian");
var requestLoginCode = async (plugin, email) => {
  const url = new URL("/group/login/send-mail-with-code", plugin.settings.basePath).toString();
  const data = await (0, import_obsidian5.requestUrl)({
    url,
    method: "POST",
    contentType: "application/json",
    body: JSON.stringify({
      email
    })
  }).json;
  if (!data || !data.ok) {
    return;
  }
  return true;
};
var requestWebToken = async (plugin, email, token, longLived) => {
  const url = new URL("/group/login/verify-code", plugin.settings.basePath).toString();
  const data = await (0, import_obsidian5.requestUrl)({
    url,
    method: "POST",
    contentType: "application/json",
    body: JSON.stringify({
      email,
      token,
      longLived
    })
  }).json;
  if (!data || !data.jwt) {
    return;
  }
  return data.jwt;
};
var saveJWT = (oid, jwt) => {
  localStorage.setItem(oid + "-peerdraft-jwt", jwt);
};
var getJWT = (oid) => {
  return localStorage.getItem(oid + "-peerdraft-jwt");
};
var clearJWT = (oid) => {
  localStorage.removeItem(oid + "-peerdraft-jwt");
};
var logout = (plugin) => {
  return new Promise((resolve2) => {
    const server = plugin.serverSync;
    if (server.authenticated) {
      const handler = () => {
        clearJWT(plugin.settings.oid);
        server.jwt = void 0;
        server.off("connection-close", handler);
        showNotice("Logged out of Peerdraft");
        server.connect();
        resolve2();
      };
      server.on("connection-close", handler);
      server.disconnect();
    }
  });
};

// src/ui/login.ts
var import_obsidian6 = require("obsidian");
var LoginModal = class extends import_obsidian6.Modal {
  constructor(plugin, cb) {
    var _a;
    super(plugin.app);
    this.cbCalled = false;
    this.storeJWT = false;
    this.code = "";
    this.email = "";
    this.onClose = () => {
      if (!this.cbCalled) {
        this.cb(false);
        this.cbCalled = true;
      }
    };
    this.plugin = plugin;
    this.cb = cb;
    this.email = (_a = this.plugin.settings.plan.email) != null ? _a : "";
  }
  async onOpen() {
    this.contentEl.empty();
    const heading = this.plugin.settings.plan.email ? "Log in to your Peerdraft account" : "Log in or register with Peerdraft";
    const headerSetting = new import_obsidian6.Setting(this.contentEl).setName(heading);
    const headerDiv = headerSetting.descEl.createDiv();
    headerDiv.createSpan({ text: "To initiate new shared documents or folders you need to have a Peerdraft account. Collaborators can join without registration. If you need any help, " });
    headerDiv.createEl("a", {
      text: "get in touch",
      attr: {
        href: "mailto:dominik@peerdraft.app"
      }
    });
    headerDiv.createSpan({ text: "." });
    const emailSetting = new import_obsidian6.Setting(this.contentEl);
    emailSetting.setName("Your e-mail address");
    emailSetting.descEl.innerHTML = 'By signing up or logging in, you agree to <a href="https://www.peerdraft.app/terms">the Terms of Service</a> and the <a href="https://www.peerdraft.app/privacy">Privacy Policy</a>.';
    emailSetting.addText((text2) => {
      text2.inputEl.setAttr("type", "email");
      text2.setValue(this.email);
      text2.onChange((value) => {
        this.email = value;
      });
    });
    emailSetting.addButton((button) => {
      button.setButtonText("Send Login Code");
      button.onClick(async () => {
        if (!this.email.match(/^\S+@\S+\.\S+$/)) {
          showNotice("Please enter a valid email address.");
        } else {
          const code = await requestLoginCode(this.plugin, this.email);
          if (code) {
            showNotice("Code sent to " + this.email + ".");
          } else {
            showNotice("Something went wrong. Please try again or get in touch with peerdraft support.");
          }
        }
      });
    });
    const rememberSetting = new import_obsidian6.Setting(this.contentEl);
    rememberSetting.setName("Remember me");
    rememberSetting.setDesc("If disabled, you will be asked to log in on every restart of Obsidian.");
    rememberSetting.addToggle((toggl) => {
      toggl.setValue(this.storeJWT);
      toggl.onChange((value) => {
        this.storeJWT = value;
        this.onOpen();
      });
    });
    const codeSetting = new import_obsidian6.Setting(this.contentEl);
    codeSetting.setName("Login Code");
    codeSetting.setDesc("Enter the code you received via email.");
    codeSetting.addText((text2) => {
      text2.inputEl.setAttr("type", "password");
      text2.setValue(this.code);
      text2.onChange((value) => {
        this.code = value;
      });
    });
    codeSetting.addButton((button) => {
      const text2 = this.storeJWT ? "Log in and remember me" : "Log in for this session only";
      button.setButtonText(text2);
      button.onClick(async () => {
        if (!this.email.match(/^\S+@\S+\.\S+$/)) {
          showNotice("Please enter a valid email address.");
          return;
        }
        if (!this.code) {
          return;
        }
        const jwt = await requestWebToken(this.plugin, this.email, this.code, this.storeJWT);
        if (jwt) {
          this.plugin.settings.plan.email = this.email;
          saveSettings(this.plugin.settings, this.plugin);
          if (await this.plugin.serverSync.authenticate(jwt)) {
            if (this.storeJWT) {
              saveJWT(this.plugin.settings.oid, jwt);
            }
            this.cb(true);
            this.cbCalled = true;
            this.close();
          }
        } else {
          showNotice("Something went wrong. Please try again or get in touch with peerdraft support.");
        }
      });
    });
  }
};
var openLoginModal = (peerdraftPlugin) => {
  return new Promise((resolve2) => {
    new LoginModal(peerdraftPlugin, (cb) => {
      resolve2(cb);
    }).open();
  });
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives",
  name: "",
  root: "",
  plan: {
    type: "hobby",
    email: ""
  },
  duration: 0,
  debug: false,
  version: "",
  serverShares: {
    files: /* @__PURE__ */ new Map(),
    folders: /* @__PURE__ */ new Map()
  }
};
var FORCE_SETTINGS = {
  /*
    basePath: "http://localhost:5173",
    subscriptionAPI: "http://localhost:5173/subscription",
    connectAPI: "http://localhost:5173/subscription/connect",
    sessionAPI: "http://localhost:5173/session",
    sync: "ws://localhost:5173/sync",
    signaling: "ws://localhost:5173/signal",
    actives: "ws://localhost:5173/actives"
  */
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives"
};
var migrateSettings = async (plugin) => {
  var _a;
  const oldSettings = await getSettings(plugin);
  const newSettings = Object.assign({}, DEFAULT_SETTINGS, oldSettings, FORCE_SETTINGS, {
    version: plugin.manifest.version
  });
  newSettings.oid = (_a = oldSettings == null ? void 0 : oldSettings.oid) != null ? _a : plugin.app.appId;
  const files = newSettings.serverShares.files;
  for (const key of files.keys()) {
    if (key.contains("\\")) {
      files.set((0, import_obsidian7.normalizePath)(key), files.get(key));
      files.delete(key);
    }
  }
  const folders = newSettings.serverShares.folders;
  for (const key of folders.keys()) {
    if (key.contains("\\")) {
      folders.set((0, import_obsidian7.normalizePath)(key), folders.get(key));
      folders.delete(key);
    }
  }
  if ((oldSettings == null ? void 0 : oldSettings.oid) && newSettings.serverShares.files.size === 0 && newSettings.serverShares.folders.size === 0) {
    const db = new PermanentShareStoreIndexedDB(oldSettings.oid);
    const docs = await db.getAllDocs();
    docs.forEach((doc2) => {
      newSettings.serverShares.files.set((0, import_obsidian7.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    const folders2 = await db.getAllFolders();
    folders2.forEach((doc2) => {
      newSettings.serverShares.folders.set((0, import_obsidian7.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    saveSettings(newSettings, plugin);
    await db.deleteDB();
  }
  saveSettings(newSettings, plugin);
  if (oldSettings && oldSettings.version != newSettings.version) {
    showTextModal(plugin.app, "Peerdraft updated", "A new version of Peerdraft was installed. Please restart Obsidian before you use Peerdraft again.");
  }
  return newSettings;
};
var getSettings = async (plugin) => {
  var _a, _b;
  const settings = await plugin.loadData();
  if (settings) {
    settings.serverShares = {
      files: new Map((_a = settings.serverShares) == null ? void 0 : _a.files),
      folders: new Map((_b = settings.serverShares) == null ? void 0 : _b.folders)
    };
  }
  return settings;
};
var saveSettings = (0, import_obsidian7.debounce)(async (settings, plugin) => {
  const serialized = JSON.parse(JSON.stringify(settings));
  serialized.serverShares = {
    files: Array.from(settings.serverShares.files.entries()),
    folders: Array.from(settings.serverShares.folders.entries())
  };
  await plugin.saveData(serialized);
}, 1e3, true);
var renderSettings = async (el, plugin) => {
  el.empty();
  const settings = plugin.settings;
  el.createEl("h1", { text: "General" });
  new import_obsidian7.Setting(el).setName("Display Name").setDesc("This name will be shown to your collaborators").addText((text2) => {
    text2.setValue(settings.name);
    text2.onChange(async (value) => {
      settings.name = value;
      saveSettings(settings, plugin);
    });
  });
  const pathSetting = new import_obsidian7.Setting(el);
  pathSetting.setName("Root Folder");
  pathSetting.setDesc("When you import a share from someone else it will be created in this folder.");
  pathSetting.addText((text2) => {
    text2.setValue(settings.root);
    text2.onChange(async (value) => {
      settings.root = value;
      saveSettings(settings, plugin);
    });
    pathSetting.addExtraButton((button) => {
      button.setIcon("search");
      button.onClick(async () => {
        const folder = await promptForFolderSelection(plugin.app);
        if (folder) {
          text2.setValue(folder.path);
          settings.root = folder.path;
          saveSettings(settings, plugin);
        }
      });
    });
  });
  el.createEl("h1", { text: "Your Account" });
  if (plugin.serverSync.authenticated) {
    el.createEl("div", { text: `You are logged in as ${plugin.settings.plan.email}.` });
    el.createEl("p");
    const div2 = el.createEl("div");
    div2.createSpan({ text: "You are on the " }).createEl("b", { text: plugin.settings.plan.type });
    div2.createSpan({ text: " plan." });
    el.createEl("p");
    if (plugin.settings.plan.type === "hobby") {
      new import_obsidian7.Setting(el).setName("Manage your subscription").addButton((button) => {
        button.setButtonText("Upgrade to pro");
        button.setCta();
        button.onClick((e) => {
          window.open(`https://peerdraft.app/checkout?email=${plugin.settings.plan.email}`);
        });
      });
    }
    new import_obsidian7.Setting(el).setName("Log out").addButton((button) => {
      button.setButtonText("Log out");
      button.onClick(async (e) => {
        await logout(plugin);
        renderSettings(el, plugin);
      });
    });
  } else {
    el.createEl("div", { text: `You are not logged in.` });
    el.createEl("p");
    el.createEl("div", { text: `To initiate new shared documents or folders you need to log in to your Peerdraft account. If you only work on shared documents and folders created by others, you don't need an account.` });
    el.createEl("p");
    new import_obsidian7.Setting(el).setName("Log in or create account").addButton((button) => {
      button.setButtonText("Log in or create account");
      button.onClick(async (e) => {
        await openLoginModal(plugin);
        renderSettings(el, plugin);
      });
    });
  }
  el.createEl("h1", { text: "Help" });
  const div = el.createDiv();
  div.createSpan({ text: "If you need any help, " });
  div.createEl("a", {
    text: "get in touch",
    attr: {
      href: "mailto:dominik@peerdraft.app"
    }
  });
  div.createSpan({ text: "." });
};
var createSettingsTab = (plugin) => {
  return new class extends import_obsidian7.PluginSettingTab {
    async display() {
      await renderSettings(this.containerEl, plugin);
    }
  }(plugin.app, plugin);
};

// src/permanentShareStoreFS.ts
var import_obsidian8 = require("obsidian");
var add = async (doc2, plugin) => {
  if (doc2 instanceof SharedDocument) {
    plugin.settings.serverShares.files.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  if (doc2 instanceof SharedFolder) {
    plugin.settings.serverShares.folders.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  saveSettings(plugin.settings, plugin);
};
var removeDoc = async (path4, plugin) => {
  plugin.settings.serverShares.files.delete((0, import_obsidian8.normalizePath)(path4));
  saveSettings(plugin.settings, plugin);
};
var getDocByPath = (path4, plugin) => {
  return plugin.settings.serverShares.files.get(path4);
};
var moveDoc = async (oldPath, newPath, plugin) => {
  const files = plugin.settings.serverShares.files;
  const entry = files.get(oldPath);
  if (entry) {
    files.delete(oldPath);
    files.set(newPath, entry);
    saveSettings(plugin.settings, plugin);
  }
};
var removeFolder = async (path4, plugin) => {
  plugin.settings.serverShares.folders.delete(path4);
  saveSettings(plugin.settings, plugin);
};
var getFolderByPath = (path4, plugin) => {
  return plugin.settings.serverShares.folders.get(path4);
};
var moveFolder = async (oldPath, newPath, plugin) => {
  const oldPathNormalized = (0, import_obsidian8.normalizePath)(oldPath);
  const newPathNormalized = (0, import_obsidian8.normalizePath)(newPath);
  const files = plugin.settings.serverShares.folders;
  const entry = files.get(oldPathNormalized);
  if (entry) {
    files.delete(oldPathNormalized);
    files.set(newPathNormalized, entry);
    saveSettings(plugin.settings, plugin);
  }
};

// src/ui/folderOptions.ts
var import_obsidian9 = require("obsidian");
var SharedFolderOptionsModal = class extends import_obsidian9.Modal {
  constructor(app, folder) {
    super(app);
    this.folder = folder;
  }
  async onOpen() {
    new import_obsidian9.Setting(this.contentEl).setName(this.folder.getOriginalFolderName()).setHeading();
    const nameSetting = new import_obsidian9.Setting(this.contentEl);
    let tempName = this.folder.getOriginalFolderName();
    nameSetting.setName("Peerdraft folder name");
    nameSetting.addText((text2) => {
      text2.setValue(tempName);
      text2.onChange((value) => {
        tempName = value;
      });
    });
    nameSetting.addButton((button) => {
      button.setButtonText("Update");
      button.onClick(() => {
        if (tempName !== this.folder.getOriginalFolderName()) {
          this.folder.setOriginalFolderName(tempName);
          this.close();
          openFolderOptions(this.app, this.folder);
        }
      });
    });
    const prop = new import_obsidian9.Setting(this.contentEl);
    prop.setName("Auto add property with Peerdraft URL");
    prop.setDesc("Leave empty if no property should be added");
    let tempProp = this.folder.getAutoFillProperty();
    prop.addText((text2) => {
      text2.setValue(tempProp);
      text2.onChange((value) => {
        tempProp = value;
      });
    });
    prop.addButton((button) => {
      button.setButtonText("Update & Apply");
      button.onClick(async () => {
        const oldProperty = this.folder.getAutoFillProperty();
        if (tempProp !== oldProperty) {
          this.folder.setAutoFillProperty(tempProp);
        }
        const notice = showNotice("Updating URLs...");
        await this.folder.updatePropertiesOfAllDocuments(oldProperty);
        notice.hide();
        this.close();
        openFolderOptions(this.app, this.folder);
      });
    });
    const link = new import_obsidian9.Setting(this.contentEl);
    link.setName("Peerdraft URL");
    link.addButton((btn) => {
      btn.setButtonText("Copy Peerdraft URL to clipboard");
      btn.onClick(() => {
        navigator.clipboard.writeText(this.folder.getShareURL());
        showNotice("Link copied to clipboard.");
      });
    });
  }
};
var openFolderOptions = (app, folder) => {
  new SharedFolderOptionsModal(app, folder).open();
};

// src/sharedEntities/sharedFolder.ts
var handleUpdate = (ev, tx, folder, plugin) => {
  var _a;
  if (![plugin.serverSync, (_a = folder.webRTCProvider) == null ? void 0 : _a.room].includes(tx.origin))
    return;
  const changedKeys = ev.changes.keys;
  changedKeys.forEach(async (data, key) => {
    plugin.log("Action: " + data.action + "for " + key + " --> " + tx.doc.getMap("documents").get(key));
    if (data.action === "add") {
      const relativePath = tx.doc.getMap("documents").get(key);
      const absolutePath = path.join(folder.path, relativePath);
      const file = plugin.app.vault.getAbstractFileByPath(absolutePath);
      if (file) {
        const existingDoc = SharedDocument.findById(key);
        if (existingDoc) {
          if (existingDoc.file.path === file.path) {
            plugin.log("Received update, but FS is already in correct state");
          } else {
            showNotice("There is something wrong with your synced file " + file.path + ". Consider re-creating the synced folder from server.");
          }
        } else {
          showNotice("File " + file.path + " already exists. Renaming local file.");
          const alteredPath = path.join(path.dirname(relativePath), path.basename(relativePath, path.extname(relativePath)) + "_" + generateRandomString() + path.extname(relativePath));
          const alteredAbsolutePath = path.join(folder.root.path, alteredPath);
          plugin.app.fileManager.renameFile(file, alteredAbsolutePath);
          SharedDocument.fromIdAndPath(key, absolutePath, plugin);
        }
      } else {
        showNotice("Creating new shared document: " + absolutePath);
        await SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, plugin);
        await SharedDocument.fromIdAndPath(key, absolutePath, plugin);
      }
    } else if (data.action === "update") {
      const newPath = tx.doc.getMap("documents").get(key);
      const document2 = SharedDocument.findById(key);
      if (!document2) {
        showNotice("Document at " + newPath + " doesn't exist in your vault. Consider re-creating the synced folder from server.");
        return;
      }
      plugin.log("Update " + document2.path + "   " + key);
      const folder2 = SharedFolder.getSharedFolderForSubPath(document2.path);
      if (!folder2)
        return;
      let newAbsolutePath = path.join(folder2.root.path, newPath);
      await SharedFolder.getOrCreatePath(path.parse(newAbsolutePath).dir, plugin);
      const alreadyExists = SharedDocument.findByPath(newAbsolutePath);
      if (alreadyExists) {
        if (alreadyExists.shareId === key) {
          plugin.log("Received update, but FS is already in correct state.");
        } else {
          showNotice("File " + newPath + " already exists. Renaming local file.");
          const alteredPath = path.join(path.dirname(newPath), path.basename(newPath, path.extname(newPath)) + "_" + generateRandomString() + path.extname(newPath));
          const alteredAbsolutePath = path.join(folder2.root.path, alteredPath);
          plugin.app.fileManager.renameFile(alreadyExists.file, alteredAbsolutePath);
          SharedDocument.fromIdAndPath(key, alteredAbsolutePath, plugin);
        }
      } else {
        await plugin.app.fileManager.renameFile(document2.file, newAbsolutePath);
      }
    } else if (data.action === "delete") {
      const document2 = SharedDocument.findById(key);
      if (!document2)
        return;
      plugin.log("Delete " + document2.path + "   " + key);
      const file = plugin.app.vault.getAbstractFileByPath(document2.path);
      if (!file)
        return;
      plugin.app.vault.delete(file);
    }
  });
};
var _SharedFolder = class extends SharedEntity {
  constructor(root, plugin, ydoc) {
    super(plugin);
    this.root = root;
    this._path = root.path;
    this.yDoc = ydoc != null ? ydoc : new Doc();
    this.getDocsFragment().observe((ev, tx) => {
      handleUpdate(ev, tx, this, plugin);
    });
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.shareId) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedFolder._sharedEntites.push(this);
    addIsSharedClass(this.path, plugin);
  }
  static async fromTFolder(root, plugin) {
    showNotice(`Inititializing share for ${root.path}.`);
    const files = this.getAllFilesInFolder(root);
    for (const file of files) {
      if (SharedDocument.findByPath(file.path)) {
        showNotice("You can not share a directory that already has shared files in it (right now).");
        return;
      }
    }
    if (!plugin.serverSync.authenticated) {
      showNotice("Please log in to Peerdraft first.");
      const auth = await openLoginModal(plugin);
      if (!auth)
        return;
    }
    const docs = await Promise.all(files.map((file) => {
      return SharedDocument.fromTFile(file, {
        permanent: true
      }, plugin);
    }));
    const folder = new _SharedFolder(root, plugin);
    for (const doc2 of docs) {
      if (doc2) {
        folder.addDocument(doc2);
      }
    }
    folder.yDoc.getText("originalFoldername").insert(0, root.name);
    await folder.initServerYDoc();
    await add(folder, plugin);
    await folder.startIndexedDBSync();
    folder.startWebRTCSync();
    navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + folder.shareId);
    showNotice(`Folder ${folder.path} with ${docs.length} documents shared. URL copied to your clipboard.`, 0);
    openFolderOptions(plugin.app, folder);
    return folder;
  }
  getShareURL() {
    return this.plugin.settings.basePath + "/team/" + this.shareId;
  }
  static async recreate(folder, plugin) {
    const location2 = folder.root.path;
    await folder.unshare();
    await plugin.app.vault.delete(folder.root, true);
    return await this.fromShareURL(plugin.settings.basePath + "/team/" + folder.shareId, plugin, location2);
  }
  static async fromShareURL(url, plugin, location2) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    let folderPath = location2;
    const preFetchedDoc = await plugin.serverSync.requestDocument(id2);
    if (!folderPath) {
      let initialRootName = `_peerdraft_team_folder_${generateRandomString()}`;
      const docFoldername = preFetchedDoc.getText("originalFoldername").toString();
      if (docFoldername != "") {
        const folderExists = plugin.app.vault.getAbstractFileByPath(path.join(plugin.settings.root, docFoldername));
        if (!folderExists) {
          initialRootName = docFoldername;
        } else {
          initialRootName = `_peerdraft_${generateRandomString()}_${docFoldername}`;
        }
      }
      folderPath = path.join(plugin.settings.root, initialRootName);
    }
    const folder = await _SharedFolder.getOrCreatePath(folderPath, plugin);
    if (!folder) {
      showNotice("Could not create folder " + folderPath);
      return;
    }
    ;
    const paths = [];
    const documentMap = preFetchedDoc.getMap("documents");
    for (const entry of documentMap.entries()) {
      let docPath = entry[1];
      const absPath = path.join(folderPath, docPath);
      if (docPath && paths.includes((0, import_obsidian10.normalizePath)(docPath))) {
        const existingDoc = SharedDocument.findById(entry[0]);
        if (existingDoc) {
          if (existingDoc.path === absPath) {
            plugin.log("already synced");
          } else {
            plugin.app.fileManager.renameFile(existingDoc.file, absPath);
          }
        } else {
          docPath = (0, import_obsidian10.normalizePath)(path.join(path.dirname(docPath), path.basename(docPath, path.extname(docPath)) + "_" + generateRandomString() + path.extname(docPath)));
          documentMap.set(entry[0], docPath);
        }
      }
      await SharedDocument.fromIdAndPath(entry[0], absPath, plugin);
      paths.push((0, import_obsidian10.normalizePath)(docPath));
    }
    const sFolder = new _SharedFolder(folder, plugin, preFetchedDoc);
    sFolder._shareId = id2;
    await add(sFolder, plugin);
    await sFolder.startIndexedDBSync();
    if (sFolder.indexedDBProvider) {
      if (!sFolder.indexedDBProvider.synced)
        await sFolder.indexedDBProvider.whenSynced;
      sFolder.syncWithServer();
      sFolder.startWebRTCSync();
    }
    return sFolder;
  }
  static async fromPermanentShareFolder(psf, plugin) {
    if (this.findByPath(psf.path))
      return;
    let tFolder;
    tFolder = plugin.app.vault.getAbstractFileByPath(psf.path);
    if (tFolder instanceof import_obsidian10.TFile) {
      showNotice("Expected " + psf.path + " to be a folder, but it is a file?");
      return;
    }
    if (!(tFolder instanceof import_obsidian10.TFolder)) {
      showNotice("Shared folder " + psf.path + " not found. Creating it now.");
      tFolder = await this.getOrCreatePath(psf.path, plugin);
    }
    if (!(tFolder instanceof import_obsidian10.TFolder)) {
      showNotice("Could not create folder " + psf.path + ".");
      return;
    }
    const folder = new _SharedFolder(tFolder, plugin);
    folder._shareId = psf.shareId;
    const local = await folder.startIndexedDBSync();
    if (local) {
      if (local.synced || await local.whenSynced) {
        folder.syncWithServer();
        folder.startWebRTCSync();
      }
    }
    return folder;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  static getSharedFolderForSubPath(dir) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(dir);
    const folders = this.getAll();
    for (const folder of folders) {
      if (folder.root.path === normalizedPath)
        return;
      if (folder.isPathSubPath(normalizedPath))
        return folder;
    }
  }
  getDocsFragment() {
    return this.yDoc.getMap("documents");
  }
  getDocByRelativePath(dir) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(dir);
    for (const entry of this.getDocsFragment().entries()) {
      if (entry[1] === normalizedPath)
        return entry[0];
    }
  }
  updatePath(oldPath, newPath) {
    const oldPathRelative = path.relative(this.root.path, oldPath);
    const newPathRelative = path.relative(this.root.path, newPath);
    const id2 = this.getDocByRelativePath(oldPathRelative);
    if (id2) {
      this.getDocsFragment().set(id2, (0, import_obsidian10.normalizePath)(newPathRelative));
    }
    return id2;
  }
  calculateHash() {
    const serialized = serialize(Array.from(this.getDocsFragment()));
    return calculateHash(serialized);
  }
  getOriginalFolderName() {
    return this.yDoc.getText("originalFoldername").toString();
  }
  setOriginalFolderName(name) {
    const text2 = this.yDoc.getText("originalFoldername");
    text2.delete(0, text2.length);
    text2.insert(0, name);
  }
  getAutoFillProperty() {
    return this.yDoc.getText("autoFillProperty").toString();
  }
  setAutoFillProperty(property) {
    const prop = this.yDoc.getText("autoFillProperty");
    prop.delete(0, prop.length);
    prop.insert(0, property);
  }
  async updatePropertiesOfAllDocuments(oldPropertyName) {
    const prop = this.getAutoFillProperty();
    if (!prop || prop === "")
      return;
    const docs = this.getDocsFragment();
    for (const entry of docs) {
      const doc2 = SharedDocument.findById(entry[0]);
      if (!doc2)
        return;
      doc2.updateProperty(prop, doc2.getShareURL(), oldPropertyName);
    }
  }
  addDocument(doc2) {
    if (this.getDocsFragment().get(doc2.shareId))
      return;
    const relativePath = path.relative(this.root.path, doc2.path);
    if (relativePath.startsWith(".."))
      return;
    this.getDocsFragment().set(doc2.shareId, relativePath);
  }
  removeDocument(doc2) {
    this.getDocsFragment().delete(doc2.shareId);
    const deleted = this.yDoc.getArray("deleted");
    if (!deleted.toArray().includes(doc2.shareId)) {
      deleted.push([doc2.shareId]);
    }
  }
  isPathSubPath(folder) {
    const relativePath = path.relative(this.root.path, folder);
    return !relativePath.startsWith("..");
  }
  static getAllFilesInFolder(folder) {
    const files = folder.children.flatMap((child) => {
      if (child instanceof import_obsidian10.TFile) {
        if (child.extension === "md") {
          return child;
        }
      }
      if (child instanceof import_obsidian10.TFolder) {
        return this.getAllFilesInFolder(child);
      }
      return [];
    });
    return files;
  }
  async setNewFolderLocation(folder) {
    const oldPath = this._path;
    this.root = folder;
    this._path = (0, import_obsidian10.normalizePath)(folder.path);
    moveFolder(oldPath, folder.path, this.plugin);
  }
  async getOrCreateFile(relativePath) {
    const absolutePath = path.join(this.root.path, relativePath);
    let file = this.plugin.app.vault.getAbstractFileByPath(absolutePath);
    if (file && file instanceof import_obsidian10.TFile)
      return file;
    const folder = await _SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, this.plugin);
    if (!folder) {
      showNotice("Error creating shares");
      return;
    }
    return await this.plugin.app.vault.create(absolutePath, "");
  }
  static async getOrCreatePath(absolutePath, plugin) {
    let folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian10.normalizePath)(absolutePath));
    if (folder && folder instanceof import_obsidian10.TFolder)
      return folder;
    const segments = absolutePath.split(path.sep);
    for (let index = 0; index < segments.length; index++) {
      const subPath = segments.slice(0, index + 1).join(path.sep);
      folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian10.normalizePath)(subPath));
      if (!folder) {
        folder = await plugin.app.vault.createFolder((0, import_obsidian10.normalizePath)(subPath));
      }
    }
    return folder;
  }
  isFileInSyncObject(file) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(file.path);
    for (const value of this.getDocsFragment().values()) {
      if (normalizedPath === path.join(this.root.path, value))
        return true;
    }
    return false;
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      const handleTimeout = () => {
      };
      this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      provider.doc.on("update", async (update, origin, doc2, tr) => {
        if (this._webRTCTimeout != null) {
          window.clearTimeout(this._webRTCTimeout);
        }
        this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      });
    });
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getFolderByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    this._indexedDBProvider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    return this._indexedDBProvider;
  }
  async unshare() {
    const dbEntry = getFolderByPath(this.path, this.plugin);
    if (dbEntry) {
      removeFolder(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
      await this._indexedDBProvider.destroy();
    }
    this.getDocsFragment().forEach((path4, shareId) => {
      var _a;
      (_a = SharedDocument.findById(shareId)) == null ? void 0 : _a.unshare();
    });
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  destroy() {
    super.destroy();
    _SharedFolder._sharedEntites.splice(_SharedFolder._sharedEntites.indexOf(this), 1);
  }
};
var SharedFolder = _SharedFolder;
SharedFolder._sharedEntites = new Array();

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve2, reject2) => {
      const task2 = { resolve: resolve2, reject: reject2, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task2);
      } else {
        this._queue.splice(i + 1, 0, task2);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve2, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// node_modules/diff-match-patch-es/dist/index.mjs
var defaultOptions = /* @__PURE__ */ Object.freeze({
  diffTimeout: 1,
  diffEditCost: 4,
  matchThreshold: 0.5,
  matchDistance: 1e3,
  patchDeleteThreshold: 0.5,
  patchMargin: 4,
  matchMaxBits: 32
});
function resolveOptions(options) {
  if (options == null ? void 0 : options.__resolved)
    return options;
  const resolved = {
    ...defaultOptions,
    ...options
  };
  Object.defineProperty(resolved, "__resolved", { value: true, enumerable: false });
  return resolved;
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function createDiff(op, text2) {
  return [op, text2];
}
function diffMain(text1, text2, options, opt_checklines = true, opt_deadline) {
  const resolved = resolveOptions(options);
  if (typeof opt_deadline == "undefined") {
    if (resolved.diffTimeout <= 0)
      opt_deadline = Number.MAX_VALUE;
    else
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + resolved.diffTimeout * 1e3;
  }
  const deadline = opt_deadline;
  if (text1 == null || text2 == null)
    throw new Error("Null input. (diff_main)");
  if (text1 === text2) {
    if (text1)
      return [createDiff(DIFF_EQUAL, text1)];
    return [];
  }
  const checklines = opt_checklines;
  let commonlength = diffCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = diffCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  const diffs = diffCompute(text1, text2, resolved, checklines, deadline);
  if (commonprefix)
    diffs.unshift(createDiff(DIFF_EQUAL, commonprefix));
  if (commonsuffix)
    diffs.push(createDiff(DIFF_EQUAL, commonsuffix));
  diffCleanupMerge(diffs);
  return diffs;
}
function diffCompute(text1, text2, options, checklines, deadline) {
  let diffs;
  if (!text1) {
    return [createDiff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [createDiff(DIFF_DELETE, text1)];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [createDiff(DIFF_INSERT, longtext.substring(0, i)), createDiff(DIFF_EQUAL, shorttext), createDiff(DIFF_INSERT, longtext.substring(i + shorttext.length))];
    if (text1.length > text2.length)
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    return diffs;
  }
  if (shorttext.length === 1) {
    return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
  }
  const hm = diffHalfMatch(text1, text2, options);
  if (hm) {
    const text1_a = hm[0];
    const text1_b = hm[1];
    const text2_a = hm[2];
    const text2_b = hm[3];
    const mid_common = hm[4];
    const diffs_a = diffMain(text1_a, text2_a, options, checklines, deadline);
    const diffs_b = diffMain(text1_b, text2_b, options, checklines, deadline);
    return diffs_a.concat([createDiff(DIFF_EQUAL, mid_common)], diffs_b);
  }
  if (checklines && text1.length > 100 && text2.length > 100)
    return diffLineMode(text1, text2, options, deadline);
  return diffBisect(text1, text2, options, deadline);
}
function diffLineMode(text1, text2, options, deadline) {
  const a = diffLinesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  const diffs = diffMain(text1, text2, options, false, deadline);
  diffCharsToLines(diffs, linearray);
  diffCleanupSemantic(diffs);
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          const subDiff = diffMain(text_delete, text_insert, options, false, deadline);
          for (let j = subDiff.length - 1; j >= 0; j--)
            diffs.splice(pointer, 0, subDiff[j]);
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function diffBisect(text1, text2, options, deadline) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  const max_d = Math.ceil((text1_length + text2_length) / 2);
  const v_offset = max_d;
  const v_length = 2 * max_d;
  const v1 = new Array(v_length);
  const v2 = new Array(v_length);
  for (let x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  const delta = text1_length - text2_length;
  const front = delta % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < max_d; d++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline)
      break;
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1_offset = v_offset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])
        x1 = v1[k1_offset + 1];
      else
        x1 = v1[k1_offset - 1] + 1;
      let y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        const k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          const x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2_offset = v_offset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])
        x2 = v2[k2_offset + 1];
      else
        x2 = v2[k2_offset - 1] + 1;
      let y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        const k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          const x1 = v1[k1_offset];
          const y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
}
function diffBisectSplit(text1, text2, options, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = diffMain(text1a, text2a, options, false, deadline);
  const diffsb = diffMain(text1b, text2b, options, false, deadline);
  return diffs.concat(diffsb);
}
function diffLinesToChars(text1, text2) {
  const lineArray = [];
  const lineHash = {};
  let maxLines = 4e4;
  lineArray[0] = "";
  function diffLinesToCharsMunge(text3) {
    let chars = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text3.length - 1) {
      lineEnd = text3.indexOf("\n", lineStart);
      if (lineEnd === -1)
        lineEnd = text3.length - 1;
      let line = text3.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? Object.prototype.hasOwnProperty.call(lineHash, line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text3.substring(lineStart);
          lineEnd = text3.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  const chars1 = diffLinesToCharsMunge(text1);
  maxLines = 65535;
  const chars2 = diffLinesToCharsMunge(text2);
  return { chars1, chars2, lineArray };
}
function diffCharsToLines(diffs, lineArray) {
  for (let i = 0; i < diffs.length; i++) {
    const chars = diffs[i][1];
    const text2 = [];
    for (let j = 0; j < chars.length; j++)
      text2[j] = lineArray[chars.charCodeAt(j)];
    diffs[i][1] = text2.join("");
  }
}
function diffCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonOverlap(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  if (text1_length > text2_length)
    text1 = text1.substring(text1_length - text2_length);
  else if (text1_length < text2_length)
    text2 = text2.substring(0, text1_length);
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0;
  let length3 = 1;
  while (true) {
    const pattern = text1.substring(text_length - length3);
    const found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length3 += found;
    if (found === 0 || text1.substring(text_length - length3) === text2.substring(0, length3)) {
      best = length3;
      length3++;
    }
  }
}
function diffHalfMatch(text1, text2, options) {
  if (options.diffTimeout <= 0) {
    return null;
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length)
    return null;
  function diffHalfMatchI(longtext2, shorttext2, i) {
    const seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    let j = -1;
    let best_common = "";
    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
      const prefixLength = diffCommonPrefix(longtext2.substring(i), shorttext2.substring(j));
      const suffixLength = diffCommonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length)
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    else
      return null;
  }
  const hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
  const hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
  let hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  let text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  const mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}
function diffCleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT)
        length_insertions2 += diffs[pointer][1].length;
      else
        length_deletions2 += diffs[pointer][1].length;
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
  diffCleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlap_length1 = diffCommonOverlap(deletion, insertion);
      const overlap_length2 = diffCommonOverlap(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
}
var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diffCleanupSemanticLossless(diffs) {
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = diffCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
function diffCleanupEfficiency(diffs, options = {}) {
  const {
    diffEditCost = defaultOptions.diffEditCost
  } = options;
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let pre_ins = false;
  let pre_del = false;
  let post_ins = false;
  let post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].length < diffEditCost && (post_ins || post_del)) {
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {
      let booleanCount = function(...args2) {
        return args2.filter(Boolean).length;
      };
      if (diffs[pointer][0] === DIFF_DELETE)
        post_del = true;
      else
        post_ins = true;
      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < diffEditCost / 2 && booleanCount(pre_ins, pre_del, post_ins, post_del) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (pre_ins && pre_del) {
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}
function diffCleanupMerge(diffs) {
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diffCommonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, createDiff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diffCommonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "")
    diffs.pop();
  let changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}

// src/sharedEntities/sharedDocument.ts
var _SharedDocument = class extends SharedEntity {
  constructor(opts, plugin) {
    var _a;
    super(plugin);
    this.mutex = new Mutex();
    if (opts.path) {
      this._path = (0, import_obsidian11.normalizePath)(opts.path);
      const file = this.plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(opts.path));
      if (file instanceof import_obsidian11.TFile) {
        this._file = file;
      } else {
        showNotice("ERROR creating sharedDoc");
      }
    }
    if (opts.id) {
      this._shareId = opts.id;
    }
    this.yDoc = (_a = opts.yDoc) != null ? _a : new Doc();
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.isPermanent) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedDocument._sharedEntites.push(this);
    this._extensions = new PeerdraftRecord();
    this._extensions.on("delete", () => {
      if (this._extensions.size === 0 && this._webRTCProvider) {
        this._webRTCProvider.awareness.setLocalState({});
      }
    });
    this.getContentFragment().observe(async () => {
      if (this._file && this._extensions.size === 0) {
        (0, import_obsidian11.debounce)(() => {
          this.mutex.runExclusive(async () => {
            const yDocContent = this.getValue();
            const fileContent = await this.plugin.app.vault.read(this._file);
            if (yDocContent != fileContent) {
              this.lastUpdateTriggeredByDocChange = new Date().valueOf();
              await this.plugin.app.vault.modify(this._file, yDocContent, {
                mtime: this.lastUpdateTriggeredByDocChange
              });
            }
          });
        }, 1e3, true)();
      }
    });
    this.plugin.registerEvent(this.plugin.app.vault.on("modify", async (file) => {
      if (this.file === file && this._extensions.size === 0 && this.file.stat.mtime != this.lastUpdateTriggeredByDocChange) {
        this.mutex.runExclusive(async () => {
          const yDocContent = this.getValue();
          const fileContent = await this.plugin.app.vault.read(this._file);
          if (yDocContent != fileContent) {
            const diffs = diffMain(yDocContent, fileContent);
            diffCleanupEfficiency(diffs);
            const content = this.getContentFragment();
            let pos = 0;
            this.yDoc.transact(() => {
              for (const diff of diffs) {
                const text2 = diff[1];
                const length3 = text2.length;
                switch (diff[0]) {
                  case 0:
                    {
                      pos += length3;
                    }
                    break;
                  case -1:
                    {
                      content.delete(pos, length3);
                    }
                    break;
                  case 1:
                    {
                      content.insert(pos, text2);
                      pos += length3;
                    }
                    break;
                }
              }
            });
          }
        });
      }
    }));
    addIsSharedClass(this.path, this.plugin);
  }
  static async fromView(view, plugin, opts = { permanent: false }) {
    if (!view.file)
      return;
    if (this.findByPath(view.file.path))
      return;
    const doc2 = await this.fromTFile(view.file, opts, plugin);
    if (doc2) {
      doc2.startWebRTCSync();
      if (doc2.isPermanent && doc2._webRTCProvider) {
        doc2.getOwnerFragment().insert(0, doc2._webRTCProvider.awareness.clientID.toFixed(0));
      } else {
        doc2.addStatusBarEntry();
        pinLeaf(view.leaf);
      }
      navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + doc2.shareId);
      showNotice("Collaboration started for " + doc2.path + ". Link copied to Clipboard.");
    }
    return doc2;
  }
  static async fromPermanentShareDocument(pd, plugin) {
    if (this.findByPath(pd.path))
      return;
    const file = plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(pd.path));
    if (!file) {
      showNotice("File " + pd.path + " not found. Creating it now.");
      await SharedFolder.getOrCreatePath(path2.dirname(pd.path), plugin);
      const file2 = await plugin.app.vault.create(pd.path, "");
      if (!file2) {
        showNotice("Error creating file " + pd.path + ".");
        return;
      }
    }
    const doc2 = new _SharedDocument({
      path: pd.path
    }, plugin);
    doc2._isPermanent = true;
    doc2._shareId = pd.shareId;
    await doc2.startIndexedDBSync();
    doc2.syncWithServer();
    plugin.activeStreamClient.add([doc2.shareId]);
    return doc2;
  }
  static async fromShareURL(url, plugin) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    const isPermanent = await plugin.serverAPI.isSessionPermanent(id2);
    const yDoc = new Doc();
    showNotice("Trying to initiate sync...");
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc
    }, plugin);
    await new Promise((resolve2) => {
      doc2.startWebRTCSync();
      if (isPermanent) {
        doc2.syncWithServer();
      }
      yDoc.once("update", () => {
        resolve2();
      });
    });
    const docFilename = doc2.yDoc.getText("originalFilename").toString();
    let initialFileName = `_peerdraft_session_${id2}_${generateRandomString()}.md`;
    if (docFilename != "") {
      const fileExists = plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(docFilename));
      if (!fileExists) {
        initialFileName = docFilename;
      } else {
        initialFileName = `_peerdraft_${generateRandomString()}_${docFilename}`;
      }
    }
    const parent = plugin.settings.root || plugin.app.fileManager.getNewFileParent("", initialFileName).path;
    const filePath = path2.join(parent, initialFileName);
    const folder = await SharedFolder.getOrCreatePath(path2.dirname(filePath), plugin);
    const file = await plugin.app.vault.create(filePath, doc2.getValue());
    addIsSharedClass(file.path, plugin);
    doc2._file = file;
    doc2._path = file.path;
    if (isPermanent) {
      doc2._isPermanent = true;
      await add(doc2, plugin);
      await doc2.startIndexedDBSync();
      plugin.activeStreamClient.add([doc2.shareId]);
    }
    const leaf = await openFileInNewTab(file, plugin.app.workspace);
    doc2.addStatusBarEntry();
    doc2.addExtensionToLeaf(leaf.id);
    pinLeaf(leaf);
    showNotice("Joined Session in " + doc2.path + ".");
    return doc2;
  }
  static async fromIdAndPath(id2, location2, plugin) {
    const normalizedPath = (0, import_obsidian11.normalizePath)(location2);
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    await SharedFolder.getOrCreatePath(path2.dirname(normalizedPath), plugin);
    showNotice("Creating new synced file " + normalizedPath);
    const ydoc = await plugin.serverSync.requestDocument(id2);
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc: ydoc
    }, plugin);
    doc2._path = normalizedPath;
    const file = await plugin.app.vault.create(normalizedPath, ydoc.getText("content").toString());
    doc2._file = file;
    doc2.syncWithServer();
    await doc2.setPermanent();
    await doc2.startIndexedDBSync();
    addIsSharedClass(doc2.path, plugin);
  }
  static async fromTFile(file, opts, plugin) {
    var _a;
    if (!["md", "MD"].contains(file.extension))
      return;
    const existing = _SharedDocument.findByPath(file.path);
    if (existing)
      return existing;
    if (!(plugin.serverSync.authenticated || opts.folder)) {
      showNotice("Please log in to Peerdraft first.");
      const auth = await openLoginModal(plugin);
      if (!auth)
        return;
    }
    const doc2 = new _SharedDocument({ path: file.path }, plugin);
    const leafIds = getLeafIdsByPath(file.path, plugin.pws);
    if (leafIds.length > 0) {
      const content = ((_a = plugin.app.workspace.getLeafById(leafIds[0])) == null ? void 0 : _a.view).editor.getValue();
      doc2.getContentFragment().insert(0, content);
    } else {
      const content = await plugin.app.vault.read(file);
      doc2.getContentFragment().insert(0, content);
    }
    doc2.yDoc.getText("originalFilename").insert(0, file.name);
    if (opts.permanent) {
      await doc2.initServerYDoc();
      await doc2.setPermanent();
      doc2.startIndexedDBSync();
    } else {
      doc2._shareId = createRandomId();
    }
    for (const id2 of leafIds) {
      doc2.addExtensionToLeaf(id2);
    }
    showNotice(`Inititialized share for ${file.path}`);
    return doc2;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  get file() {
    return this._file;
  }
  calculateHash() {
    const text2 = this.getContentFragment().toString();
    return calculateHash(text2);
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      provider.awareness.setLocalStateField("user", {
        name: this.plugin.settings.name,
        color: _SharedDocument._userColor.dark,
        colorLight: _SharedDocument._userColor.light
      });
      provider.awareness.on("update", async (msg) => {
        var _a, _b, _c, _d;
        const removed = (_a = msg.removed) != null ? _a : [];
        if (removed && removed.length > 0) {
          const removedStrings = removed.map((id2) => {
            return id2.toFixed(0);
          });
          const owner = this.getOwnerFragment().toString();
          if (owner != provider.awareness.clientID.toString()) {
            if (removedStrings.includes(owner) && !this.isPermanent) {
              showNotice("Shared session for " + this.path + " stopped by owner");
              await this.unshare();
            }
          }
        }
        const added = (_b = msg.added) != null ? _b : [];
        if (added && added.length > 0) {
          const states = provider.awareness.getStates();
          for (const key of added) {
            const peer = states.get(key);
            if (peer && this.path && key != ((_c = this._webRTCProvider) == null ? void 0 : _c.awareness.clientID)) {
              showNotice(`${(_d = peer.user) == null ? void 0 : _d.name} is working on ${this.path}`, 1e4);
            }
          }
        }
      });
    });
  }
  async setNewFileLocation(file) {
    const oldPath = this._path;
    this._file = file;
    this._path = (0, import_obsidian11.normalizePath)(file.path);
    if (this.statusBarEntry) {
      this.removeStatusStatusBarEntry();
      this.addStatusBarEntry();
    }
    await moveDoc(oldPath, file.path, this.plugin);
    removeIsSharedClass(oldPath, this.plugin);
    addIsSharedClass(this.path, this.plugin);
  }
  async setPermanent() {
    if (!this._isPermanent) {
      this._isPermanent = true;
      await add(this, this.plugin);
      this.plugin.activeStreamClient.add([this.shareId]);
    }
  }
  get isPermanent() {
    return this._isPermanent;
  }
  getValue() {
    return this.getContentFragment().toString();
  }
  getContentFragment() {
    return this.yDoc.getText("content");
  }
  getOwnerFragment() {
    return this.yDoc.getText("owner");
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getDocByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    const provider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    this._indexedDBProvider = provider;
    if (!provider.synced)
      await provider.whenSynced;
    return this._indexedDBProvider;
  }
  addExtensionToLeaf(leafId) {
    const webRTCProvider = this.startWebRTCSync();
    if (!webRTCProvider)
      return;
    if (this._extensions.get(leafId))
      return;
    const pLeaf = this.plugin.pws.get(leafId);
    if (!pLeaf)
      return;
    if (pLeaf.path != this._path)
      return;
    if (pLeaf.isPreview) {
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
      return;
    }
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (!leaf)
      return;
    const view = leaf.view;
    const editor = view.editor;
    editor.setValue(this.getValue());
    const undoManager = new UndoManager(this.getContentFragment());
    const extension = yCollab(this.getContentFragment(), webRTCProvider.awareness, { undoManager });
    const compartment = new import_state.Compartment();
    const editorView = editor.cm;
    editorView.dispatch({
      effects: import_state2.StateEffect.appendConfig.of(compartment.of(extension))
    });
    this._extensions.set(leafId, compartment);
    pLeaf.once("changeIsPreview", () => {
      this.removeExtensionFromLeaf(leafId);
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
    });
    return import_state.Compartment;
  }
  removeExtensionFromLeaf(leafId) {
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (leaf) {
      try {
        const editor = leaf.view.editor;
        const editorView = editor.cm;
        const compartment = this._extensions.get(leafId);
        if (compartment) {
          editorView.dispatch({
            effects: compartment.reconfigure([])
          });
        }
      } catch (error) {
        this.plugin.log("editor already gone");
      }
    }
    this._extensions.delete(leafId);
  }
  addStatusBarEntry() {
    if (this.statusBarEntry)
      return;
    const menu = new import_obsidian11.Menu();
    menu.addItem((item) => {
      item.setTitle("Copy link");
      item.onClick(() => {
        navigator.clipboard.writeText(this.plugin.settings.basePath + "/cm/" + this.shareId);
        showNotice("Link copied to clipboard.");
      });
    });
    menu.addItem((item) => {
      item.setTitle("Stop shared session");
      item.onClick(async () => {
        await this.unshare();
      });
    });
    const status = this.plugin.addStatusBarItem();
    status.addClass("mod-clickable");
    status.createEl("span", { text: "Sharing '" + this.path + "'" });
    status.onClickEvent((event) => {
      menu.showAtMouseEvent(event);
    });
    this.statusBarEntry = status;
  }
  removeStatusStatusBarEntry() {
    if (!this.statusBarEntry)
      return;
    this.statusBarEntry.remove();
    this.statusBarEntry = void 0;
  }
  async unshare() {
    const dbEntry = getDocByPath(this.path, this.plugin);
    if (dbEntry) {
      removeDoc(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
    }
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  getShareURL() {
    return this.plugin.settings.basePath + "/cm/" + this.shareId;
  }
  updateProperty(name, value, oldProperty) {
    this.plugin.app.fileManager.processFrontMatter(this.file, (fm) => {
      if (oldProperty) {
        delete fm[oldProperty];
      }
      fm[name] = value;
    });
  }
  destroy() {
    if (!this.isPermanent) {
      showNotice("Stopping collaboration on " + this.path + ".");
    }
    for (const key of this._extensions.keys) {
      this.removeExtensionFromLeaf(key);
    }
    this._extensions.destroy();
    super.destroy();
    this.removeStatusStatusBarEntry();
    _SharedDocument._sharedEntites.splice(_SharedDocument._sharedEntites.indexOf(this), 1);
  }
};
var SharedDocument = _SharedDocument;
SharedDocument._userColor = usercolors[randomUint32() % usercolors.length];
SharedDocument._sharedEntites = new Array();

// src/activeStreamClient.ts
var handleMessage = (data) => {
  var _a, _b;
  const message = JSON.parse(data);
  for (const id2 of message.docs) {
    (_a = SharedDocument.findById(id2)) == null ? void 0 : _a.startWebRTCSync();
    (_b = SharedFolder.findById(id2)) == null ? void 0 : _b.startWebRTCSync();
  }
};
var setupWS2 = (client) => {
  if (client.shouldConnect && client.ws === null) {
    const websocket = new WebSocket(client.url);
    client.ws = websocket;
    client.wsconnecting = true;
    client.wsconnected = false;
    websocket.onmessage = (event) => {
      client.wsLastMessageReceived = getUnixTime();
      handleMessage(event.data);
    };
    websocket.onerror = (event) => {
      client.emit("connection-error", [event, client]);
    };
    websocket.onclose = (event) => {
      client.emit("connection-close", [event, client]);
      client.ws = null;
      client.wsconnecting = false;
      if (client.wsconnected) {
        client.wsconnected = false;
        client.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        client.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS2,
        min(
          pow(2, client.wsUnsuccessfulReconnects) * 100,
          client.maxBackoffTime
        ),
        client
      );
    };
    websocket.onopen = () => {
      client.wsLastMessageReceived = getUnixTime();
      client.wsconnecting = false;
      client.wsconnected = true;
      client.wsUnsuccessfulReconnects = 0;
      client.emit("status", [{
        status: "connected"
      }]);
      client.send(JSON.stringify({
        type: "full",
        docs: Array.from(client.docIds)
      }));
    };
    client.emit("status", [{
      status: "connecting"
    }]);
  }
};
var ActiveStreamClient = class extends ObservableV2 {
  constructor(url, opts = {
    connect: true,
    resyncInterval: -1,
    maxBackoffTime: 2500
  }) {
    super();
    this.maxBackoffTime = opts.maxBackoffTime;
    this.url = url;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.wsUnsuccessfulReconnects = 0;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = opts.connect;
    this._resyncInterval = 0;
    this.docIds = /* @__PURE__ */ new Set();
    if (opts.resyncInterval > 0) {
      this._resyncInterval = window.setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.send(JSON.stringify({
            type: "full",
            docs: Array.from(this.docIds)
          }));
        }
      }, opts.resyncInterval);
    }
    if (opts.connect) {
      this.connect();
    }
  }
  send(data) {
    var _a, _b;
    if (this.ws && this.ws.readyState !== this.ws.CONNECTING && this.ws.readyState !== this.ws.OPEN) {
      this.ws.close();
    }
    try {
      (_a = this.ws) == null ? void 0 : _a.send(data);
    } catch (e) {
      (_b = this.ws) == null ? void 0 : _b.close();
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS2(this);
    }
  }
  add(ids) {
    for (const id2 of ids) {
      this.docIds.add(id2);
    }
    this.send(JSON.stringify({
      type: "add",
      docs: ids
    }));
  }
  remove(ids) {
    for (const id2 of ids) {
      this.docIds.delete(id2);
    }
    this.send(JSON.stringify({
      type: "remove",
      docs: ids
    }));
  }
};

// src/cookie.ts
var import_obsidian12 = require("obsidian");
var import_remote = require("@electron/remote");
var prepareCommunication = async (plugin) => {
  if (import_obsidian12.Platform.isDesktopApp) {
    await import_remote.session.defaultSession.cookies.set({ url: "https://www.peerdraft.app", "name": "oid", "value": plugin.settings.oid, "domain": "www.peerdraft.app", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
    await import_remote.session.defaultSession.cookies.set({ url: "http://localhost:5173", "name": "oid", "value": plugin.settings.oid, "domain": "localhost", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
  } else if (import_obsidian12.Platform.isMobileApp) {
    const signalingURL = new URL(plugin.settings.signaling);
    signalingURL.searchParams.append("oid", plugin.settings.oid);
    plugin.settings.signaling = signalingURL.toString();
  }
};

// src/serverAPI.ts
var import_obsidian13 = require("obsidian");
var ServerAPI = class {
  constructor(opts) {
    this.opts = opts;
  }
  async createPermanentSession() {
    const data = await (0, import_obsidian13.requestUrl)({
      url: this.opts.permanentSessionUrl,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        oid: this.opts.oid
      })
    }).json;
    if (!data || !data.id) {
      showNotice("Error creating shared file");
      return;
    }
    return data;
  }
  async isSessionPermanent(id2) {
    const data = await (0, import_obsidian13.requestUrl)({
      url: this.opts.permanentSessionUrl + "/" + id2,
      method: "GET",
      contentType: "application/json"
    }).json;
    if (!data) {
      showNotice("Error creating shared file");
      return;
    }
    return !!data.permanent;
  }
};

// src/sharedEntities/sharedEntityFactory.ts
var fromShareURL = async (url, plugin) => {
  const splittedUrl = url.split("/");
  if (splittedUrl == null ? void 0 : splittedUrl.contains("cm")) {
    return SharedDocument.fromShareURL(url, plugin);
  }
  if (splittedUrl == null ? void 0 : splittedUrl.contains("team")) {
    return SharedFolder.fromShareURL(url, plugin);
  }
};

// src/ui/chooseSessionType.ts
var import_obsidian14 = require("obsidian");
var ChooseSessionTypeModal = class extends import_obsidian14.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  async onOpen() {
    new import_obsidian14.Setting(this.contentEl).setName("Start working together").setHeading();
    new import_obsidian14.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Start fleeting session");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: false
        });
      });
    }).setDesc("A fleeting session automatically closes when you close the document or disconnect.");
    new import_obsidian14.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Share permanently");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: true
        });
      });
    }).setDesc("The document will be shared permanently until you explicitely stop sharing. This is persisted even if you disconnect or close Obsidian.");
  }
};
var promptForSessionType = (app) => {
  return new Promise((resolve2) => {
    new ChooseSessionTypeModal(app, (result) => {
      resolve2(result);
    }).open();
  });
};

// src/ui/enterText.ts
var import_obsidian15 = require("obsidian");
var EnterTextModal = class extends import_obsidian15.Modal {
  constructor(app, opts, cb) {
    super(app);
    this.cb = cb;
    this.result = opts.initial;
    this.opts = opts;
  }
  async onOpen() {
    new import_obsidian15.Setting(this.contentEl).setName(this.opts.header).setHeading();
    new import_obsidian15.Setting(this.contentEl).addText((text2) => {
      text2.setValue(this.result.text), text2.onChange((value) => {
        this.result.text = value;
      });
      text2.inputEl.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          this.close();
          this.cb(this.result);
        }
      };
    }).setDesc(this.opts.description);
    const buttons = new import_obsidian15.Setting(this.contentEl);
    buttons.addButton((button) => {
      button.setButtonText("Cancel");
      button.onClick(() => {
        this.close();
      });
    });
    buttons.addButton((button) => {
      button.setButtonText("OK");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb(this.result);
      });
    });
  }
};
var promptForText = (app, opts) => {
  return new Promise((resolve2) => {
    new EnterTextModal(app, opts, (cb) => {
      resolve2(cb);
    }).open();
  });
};
var promptForURL = (app) => {
  return promptForText(app, {
    description: "Enter the URL you received to start working together.",
    header: "Enter your Peerdraft URL",
    initial: {
      text: ""
    }
  });
};
var promptForName = (app) => {
  return promptForText(app, {
    description: "This name will be shown to your collaborators",
    header: "What's your name?",
    initial: {
      text: ""
    }
  });
};

// src/peerdraftWebSocketProvider.ts
var MESSAGE_MULTIPLEX_SYNC = 4;
var SYNC_STEP_1 = 0;
var SYNC_STEP_2 = 1;
var UPDATE = 3;
var NEW_DOCUMENT = 4;
var NEW_DOCUMENT_CONFIRMED = 5;
var GET_DOCUMENT_AS_UPDATE = 6;
var SEND_DOCUMENT_AS_UPDATE = 7;
var MESSAGE_AUTHENTICATION_REQUEST = 5;
var MESSAGE_AUTHENTICATION_RESPONSE = 6;
var messageReconnectTimeout2 = 3e4;
var setupWS3 = (provider) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new WebSocket(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    websocket.onmessage = (event) => {
      var _a, _b;
      provider.wsLastMessageReceived = getUnixTime();
      const data = new Uint8Array(event.data);
      if (data.length == 0)
        return;
      const decoder = createDecoder(data);
      const messageType = readVarUint(decoder);
      if (messageType === MESSAGE_MULTIPLEX_SYNC) {
        const syncMessageType = readVarUint(decoder);
        switch (syncMessageType) {
          case NEW_DOCUMENT_CONFIRMED:
            {
              const tempId = readVarString(decoder);
              const id2 = readVarString(decoder);
              const checksum = readVarString(decoder);
              provider.emit("new-doc-confirmed", [tempId, id2, checksum]);
            }
            break;
          case SYNC_STEP_1:
            {
              const id2 = readVarString(decoder);
              const vector = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_a = SharedDocument.findById(id2)) != null ? _a : SharedFolder.findById(id2);
              if (doc2 && hash != doc2.calculateHash()) {
                provider.sendSyncStep2(doc2, vector);
              }
            }
            break;
          case SYNC_STEP_2:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_b = SharedDocument.findById(id2)) != null ? _b : SharedFolder.findById(id2);
              if (doc2) {
                applyUpdate(doc2.yDoc, update, provider);
                provider.emit("synced", [id2, hash]);
              }
            }
            break;
          case SEND_DOCUMENT_AS_UPDATE:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const checksum = readVarString(decoder);
              provider.emit("document-received", [id2, update, checksum]);
            }
            break;
          default:
            console.log("unreachable");
            break;
        }
      } else if (messageType === MESSAGE_AUTHENTICATION_RESPONSE) {
        const data2 = JSON.parse(readVarString(decoder));
        provider.authenticated = true;
        provider.emit("authenticated", [data2]);
      }
    };
    websocket.onerror = (event) => {
      provider.emit("connection-error", [event, provider]);
    };
    websocket.onclose = (event) => {
      provider.emit("connection-close", [event, provider]);
      if (provider.authenticated) {
        provider.authenticated = false;
      }
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS3,
        min(
          pow(2, provider.wsUnsuccessfulReconnects) * 100,
          provider.maxBackoffTime
        ),
        provider
      );
    };
    websocket.onopen = async () => {
      provider.wsLastMessageReceived = getUnixTime();
      provider.wsconnecting = false;
      provider.wsconnected = true;
      provider.wsUnsuccessfulReconnects = 0;
      provider.emit("status", [{
        status: "connected"
      }]);
      if (provider.jwt) {
        provider.authenticate(provider.jwt);
      }
      for (const folder of SharedFolder.getAll()) {
        if (folder.indexedDBProvider) {
          if (!folder.indexedDBProvider.synced)
            await folder.indexedDBProvider.whenSynced;
          folder.syncWithServer();
        }
      }
      for (const doc2 of SharedDocument.getAll()) {
        if (doc2.isPermanent && doc2.indexedDBProvider) {
          if (!doc2.indexedDBProvider.synced)
            await doc2.indexedDBProvider.whenSynced;
          doc2.syncWithServer();
        }
      }
    };
    provider.emit("status", [{
      status: "connecting"
    }]);
  }
};
var PeerdraftWebsocketProvider = class extends ObservableV2 {
  constructor(serverUrl, {
    connect = true,
    resyncInterval = -1,
    maxBackoffTime = 2500,
    jwt = void 0
  } = {}) {
    super();
    this.url = serverUrl;
    this.maxBackoffTime = maxBackoffTime;
    this.wsconnected = false;
    this.wsconnecting = false;
    this._resyncInterval = resyncInterval;
    this.wsUnsuccessfulReconnects = 0;
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    this.authenticated = false;
    this.jwt = jwt;
    this._checkInterval = window.setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout2 < getUnixTime() - this.wsLastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout2 / 10);
    if (connect) {
      this.connect();
    }
  }
  sendSyncStep1(doc2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_1);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateVector(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendSyncStep2(doc2, vector) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_2);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc, vector));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdate(doc2, update) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdateMessage(shareId, update, checksum) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, checksum);
    this.sendMessage(toUint8Array(encoder));
  }
  sendNewDocument(doc2, tempId) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, NEW_DOCUMENT);
    writeVarString(encoder, tempId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendGetDocumentAsUpdate(id2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, GET_DOCUMENT_AS_UPDATE), writeVarString(encoder, id2);
    this.sendMessage(toUint8Array(encoder));
  }
  sendAuthenicationRequest(jwt) {
    this.jwt = jwt;
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_AUTHENTICATION_REQUEST);
    writeVarString(encoder, jwt);
    this.sendMessage(toUint8Array(encoder));
  }
  authenticate(jwt) {
    return new Promise((resolve2) => {
      const handler = async (data) => {
        this.off("authenticated", handler);
        resolve2(data);
      };
      this.on("authenticated", handler);
      this.sendAuthenicationRequest(jwt);
    });
  }
  sendMessage(buf) {
    if (this.wsconnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(buf);
    }
  }
  requestDocument(docId) {
    return new Promise((resolve2) => {
      const handler = (serverId, update, checksum) => {
        if (docId === serverId) {
          this.off("document-received", handler);
          const doc2 = new Doc();
          applyUpdate(doc2, update);
          const docs = Array.from(doc2.getMap("documents"));
          if (docs.length > 0) {
            const serialized = serialize(Array.from(docs));
            const calculatedHash = calculateHash(serialized);
            if (calculatedHash != checksum) {
              this.sendUpdateMessage(docId, encodeStateAsUpdate(doc2), calculatedHash);
            }
          }
          resolve2(doc2);
        }
      };
      this.on("document-received", handler);
      this.sendGetDocumentAsUpdate(docId);
    });
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS3(this);
    }
  }
};

// src/peerdraftPlugin.ts
var path3 = __toESM(require("path"));
var PeerdraftPlugin = class extends import_obsidian16.Plugin {
  async onload() {
    const plugin = this;
    plugin.settings = await migrateSettings(plugin);
    await prepareCommunication(plugin);
    plugin.pws = new PeerdraftRecord();
    plugin.serverAPI = new ServerAPI({
      oid: plugin.settings.oid,
      permanentSessionUrl: plugin.settings.sessionAPI
    });
    plugin.activeStreamClient = new ActiveStreamClient(plugin.settings.actives, {
      maxBackoffTime: 3e5,
      connect: true,
      resyncInterval: -1
    });
    plugin.pws.on("add", (key, leaf) => {
      var _a;
      (_a = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a.addExtensionToLeaf(key);
      leaf.on("changePath", (oldPath) => {
        var _a2;
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          doc2.removeExtensionFromLeaf(key);
          const leafs = getLeafsByPath(oldPath, plugin.pws);
          if (leafs.length === 0 && !doc2.isPermanent) {
            doc2.unshare();
          }
        }
        (_a2 = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a2.addExtensionToLeaf(key);
      });
    });
    plugin.pws.on("delete", async (key, leaf) => {
      const doc2 = SharedDocument.findByPath(leaf.path);
      if (!doc2)
        return;
      doc2.removeExtensionFromLeaf(key);
      const leafs = getLeafsByPath(leaf.path, plugin.pws);
      if (leafs.length === 0) {
        if (doc2 && !doc2.isPermanent) {
          await doc2.unshare();
        }
      }
      leaf.destroy();
    });
    plugin.app.workspace.onLayoutReady(
      async () => {
        var _a;
        this.serverSync = new PeerdraftWebsocketProvider(this.settings.sync, { jwt: (_a = getJWT(plugin.settings.oid)) != null ? _a : void 0, connect: false });
        this.serverSync.on("authenticated", (data) => {
          showNotice("Logged in to Peerdraft");
          plugin.settings.plan.type = data.plan.type;
          saveSettings(plugin.settings, plugin);
        });
        this.serverSync.connect();
        for (const docs of plugin.settings.serverShares.files) {
          await SharedDocument.fromPermanentShareDocument({ path: docs[0], persistenceId: docs[1].persistenceId, shareId: docs[1].shareId }, plugin);
        }
        for (const folder of plugin.settings.serverShares.folders) {
          await SharedFolder.fromPermanentShareFolder({ path: folder[0], persistenceId: folder[1].persistenceId, shareId: folder[1].shareId }, plugin);
        }
        updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        plugin.registerEvent(plugin.app.workspace.on("layout-change", () => {
          updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        }));
      }
    );
    plugin.registerEvent(plugin.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian16.TFolder) {
        const sharedFolder = SharedFolder.findByPath(file.path);
        if (!sharedFolder) {
          if (!SharedFolder.getSharedFolderForSubPath(file.path) && plugin.settings.plan.type === "team") {
            menu.addItem((item) => {
              item.setTitle("Share Folder");
              item.setIcon("users");
              item.onClick(() => {
                SharedFolder.fromTFolder(file, plugin);
              });
            });
          }
        } else {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + sharedFolder.shareId);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Stop syncing this folder");
            item.setIcon("refresh-cw-off");
            item.onClick(async () => {
              await sharedFolder.unshare();
            });
          });
          menu.addItem((item) => {
            item.setTitle("Re-create sync from server");
            item.setIcon("refresh-cw");
            item.onClick(async () => {
              await SharedFolder.recreate(sharedFolder, plugin);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Show Peerdraft folder options");
            item.setIcon("cog");
            item.onClick(async () => {
              openFolderOptions(this.app, sharedFolder);
            });
          });
        }
      } else {
        const sharedDocument = SharedDocument.findByPath(file.path);
        const sharedFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (sharedDocument) {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + sharedDocument.shareId);
            });
          });
          if (sharedFolder) {
            menu.addItem((item) => {
              item.setTitle("Delete and remove from Shared Folder");
              item.setIcon("trash");
              item.onClick(async () => {
                sharedFolder.removeDocument(sharedDocument);
                sharedDocument.unshare();
                plugin.app.vault.delete(sharedDocument.file);
              });
            });
          } else {
            menu.addItem((item) => {
              item.setTitle("Stop syncing this document");
              item.setIcon("refresh-cw-off");
              item.onClick(async () => {
                await sharedDocument.unshare();
              });
            });
          }
        }
      }
    }));
    plugin.addCommand({
      id: "share",
      name: "Start working together on this document",
      checkCallback(checking) {
        const view = plugin.app.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
        if (!view)
          return false;
        const file = view.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (doc2)
          return false;
        if (checking)
          return true;
        if (plugin.settings.plan.type === "team") {
          promptForSessionType(plugin.app).then((result) => {
            if (!result)
              return;
            SharedDocument.fromView(view, plugin, { permanent: result.permanent }).then((doc3) => {
              if (!doc3) {
                return showNotice("ERROR creating sharedDoc");
              }
            });
          });
        } else {
          SharedDocument.fromView(view, plugin, { permanent: false }).then((doc3) => {
            if (!doc3) {
              return showNotice("ERROR creating sharedDoc");
            }
          });
        }
      }
    });
    plugin.addCommand({
      id: "stop-session-with-active-document",
      name: "Stop working together on this document",
      editorCheckCallback: (checking, editor, ctx) => {
        const file = ctx.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (!doc2 || doc2.isPermanent)
          return false;
        if (checking)
          return true;
        doc2.unshare().then(() => {
        });
      }
    });
    plugin.addCommand({
      id: "join",
      name: "Join session and add document from someone else",
      callback: async () => {
        const url = await promptForURL(plugin.app);
        if (url && url.text) {
          await fromShareURL(url.text, plugin);
        }
      }
    });
    if (plugin.settings.debug) {
      plugin.addCommand({
        id: "clearDatabase",
        name: "DEBUG: clear database (Nothing will be shared after this!)",
        callback: async () => {
          var _a;
          const dbs = await window.indexedDB.databases();
          for (const db of dbs) {
            if ((_a = db.name) == null ? void 0 : _a.startsWith("peerdraft_")) {
              window.indexedDB.deleteDatabase(db.name);
            }
          }
        }
      });
    }
    plugin.registerEvent(plugin.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian16.TFile) {
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          await doc2.setNewFileLocation(file);
        }
        const oldPathInFolder = SharedFolder.getSharedFolderForSubPath(oldPath);
        const newPathInFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (oldPathInFolder && newPathInFolder) {
          if (oldPathInFolder === newPathInFolder) {
            oldPathInFolder.updatePath(oldPath, file.path);
          } else {
            const newDoc = await SharedDocument.fromTFile(file, { permanent: true, folder: newPathInFolder.shareId }, plugin);
            if (newDoc) {
              newPathInFolder.addDocument(newDoc);
              const prop = newPathInFolder.getAutoFillProperty();
              if (prop)
                newDoc.updateProperty(prop, newDoc.getShareURL());
            }
            if (doc2) {
            }
          }
        } else if (oldPathInFolder && !newPathInFolder) {
          if (doc2) {
            showNotice("It is not possible to remove a document from a shared folder right now. Created a copy.");
            await SharedFolder.getOrCreatePath(path3.dirname(oldPath), plugin);
            const file2 = await plugin.app.vault.create(oldPath, "");
            if (!file2) {
              showNotice("Error creating file " + oldPath + ".");
              return;
            }
            doc2.setNewFileLocation(file2);
            doc2.syncWithServer();
          }
        } else if (!oldPathInFolder && newPathInFolder) {
          const doc3 = await SharedDocument.fromTFile(file, { permanent: true, folder: newPathInFolder.shareId }, plugin);
          if (doc3) {
            newPathInFolder.addDocument(doc3);
            const prop = newPathInFolder.getAutoFillProperty();
            if (prop)
              doc3.updateProperty(prop, doc3.getShareURL());
          }
        }
      } else if (file instanceof import_obsidian16.TFolder) {
        const folder = SharedFolder.findByPath(oldPath);
        if (folder) {
          await folder.setNewFolderLocation(file);
        }
      }
    }));
    plugin.registerEvent(plugin.app.vault.on("delete", async (file) => {
      plugin.log("register delete for " + file.path);
      if (file instanceof import_obsidian16.TFolder) {
        const folder = SharedFolder.findByPath(file.path);
        folder == null ? void 0 : folder.unshare();
        return;
      } else if (file instanceof import_obsidian16.TFile) {
        const folder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (!folder) {
          const doc2 = SharedDocument.findByPath(file.path);
          if (doc2) {
            await doc2.unshare();
          }
        }
      }
    }));
    plugin.app.workspace.onLayoutReady(
      () => {
        plugin.registerEvent(plugin.app.vault.on("create", async (file) => {
          if (!(file instanceof import_obsidian16.TFile))
            return;
          const folder = SharedFolder.getSharedFolderForSubPath(file.path);
          if (!folder)
            return;
          if (folder.isFileInSyncObject(file))
            return;
          if (SharedDocument.findByPath(file.path))
            return;
          if (plugin.settings.serverShares.files.has((0, import_obsidian16.normalizePath)(file.path)))
            return;
          const doc2 = await SharedDocument.fromTFile(file, {
            permanent: true,
            folder: folder.shareId
          }, plugin);
          if (doc2) {
            folder.addDocument(doc2);
            const prop = folder.getAutoFillProperty();
            if (prop)
              doc2.updateProperty(prop, doc2.getShareURL());
          }
        }));
      }
    );
    const settingsTab = createSettingsTab(plugin);
    if (!plugin.settings.name) {
      const name = await promptForName(plugin.app);
      if (name && name.text) {
        this.settings.name = name.text;
        saveSettings(this.settings, plugin);
      }
    }
    plugin.addSettingTab(settingsTab);
  }
  onunload() {
    SharedDocument.getAll().forEach((doc2) => {
      doc2.destroy();
    });
    SharedFolder.getAll().forEach((folder) => {
      folder.destroy();
    });
    this.activeStreamClient.destroy();
  }
  log(message) {
    if (this.settings.debug) {
      console.log(message);
    }
  }
};

// src/main.ts
var main_default = PeerdraftPlugin;
/*! Bundled license information:

simple-peer/simplepeer.min.js:
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <https://feross.org>
  * @license  MIT
  *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50MzIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50NjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoNjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3h4aGFzaGpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvc2ltcGxlcGVlci5taW4uanMiLCAiLi4vc3JjL21haW4udHMiLCAiLi4vc3JjL3BlZXJkcmFmdFBsdWdpbi50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3NldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9vYnNlcnZhYmxlLmpzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3N0cmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbmNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lcnJvci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC93ZWJjcnlwdG8uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9zdG9yYWdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9mdW5jdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbnZpcm9ubWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kb20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9zeW1ib2wuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5jb21tb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9pdGVyYXRvci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9BYnN0cmFjdENvbm5lY3Rvci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9EZWxldGVTZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvRG9jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1VwZGF0ZURlY29kZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVXBkYXRlRW5jb2Rlci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9lbmNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9FdmVudEhhbmRsZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvSUQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvaXNQYXJlbnRPZi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9sb2dnaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1Blcm1hbmVudFVzZXJEYXRhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1JlbGF0aXZlUG9zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvU25hcHNob3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvU3RydWN0U3RvcmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVHJhbnNhY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVW5kb01hbmFnZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvdXBkYXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9ZRXZlbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvQWJzdHJhY3RUeXBlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lBcnJheS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZTWFwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lUZXh0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lYbWxGcmFnbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZWG1sRWxlbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZWG1sRXZlbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbEhvb2suanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbFRleHQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9BYnN0cmFjdFN0cnVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0dDLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudEJpbmFyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnREZWxldGVkLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudERvYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRFbWJlZC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRGb3JtYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50SlNPTi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRBbnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50U3RyaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudFR5cGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9JdGVtLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvU2tpcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9pbmRleC5qcyIsICIuLi9zcmMvdG9vbHMudHMiLCAiLi4vc3JjL3VpLnRzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktY29kZW1pcnJvci5uZXh0L3NyYy95LXJhbmdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1zeW5jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1yZW1vdGUtc2VsZWN0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1jb2RlbWlycm9yLm5leHQvc3JjL3ktdW5kb21hbmFnZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanMiLCAiLi4vc3JjL3V0aWxzL3BlZXJkcmFmdFJlY29yZC50cyIsICIuLi9zcmMvd29ya3NwYWNlL3BlZXJkcmFmdExlYWYudHMiLCAiLi4vc3JjL3dvcmtzcGFjZS9wZWVyZHJhZnRXb3Jrc3BhY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvd2Vic29ja2V0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktd2VicnRjL3NyYy95LXdlYnJ0Yy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvc3luYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvYXdhcmVuZXNzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LXdlYnJ0Yy9zcmMvY3J5cHRvLmpzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvaW5kZXhlZGRiLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWluZGV4ZWRkYi9zcmMveS1pbmRleGVkZGIuanMiLCAiLi4vc3JjL3dvcmtzcGFjZS9leHBsb3JlclZpZXcudHMiLCAiLi4vc3JjL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlci50cyIsICIuLi9zcmMvc2V0dGluZ3MudHMiLCAiLi4vc3JjL3VpL3NlbGVjdEZvbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3V0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9kZWJ1Zy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Vycm9ycy9lcnJvcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9wcm9taXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3RlbXAtdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9nbG9iYWxzL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jb21iaW5lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2tleXJhbmdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RhYmxlL3RhYmxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9FdmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdGFibGUvdGFibGUtY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NtcC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9jb2xsZWN0aW9uL2NvbGxlY3Rpb24tY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY29tcGFyZS1mdW5jdGlvbnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtaGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9pbmRleC1zcGVjLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy90YWJsZS1zY2hlbWEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcXVpcmtzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1rZXktZXh0cmFjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2RiY29yZS1pbmRleGVkZGIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3ZlcnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdmlwLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9ub2RlX21vZHVsZXMvc2FmYXJpLTE0LWlkYi1maXgvZGlzdC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtb3Blbi50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMveWllbGQtc3VwcG9ydC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdHJhbnNhY3Rpb24taGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2RiY29yZS92aXJ0dWFsLWluZGV4LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUvY2FjaGUtZXhpc3RpbmctdmFsdWVzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Jhbmdlc2V0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9vYnNlcnZhYmlsaXR5LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2V4dGVuZC1vYnNlcnZhYmlsaXR5LXNldC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtZG9tLWRlcGVuZGVuY2llcy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtc3RhdGljLXByb3BzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9wcm9wYWdhdGUtbG9jYWxseS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvZW5hYmxlLWJyb2FkY2FzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9wZXJtYW5lbnRTaGFyZVN0b3JlLnRzIiwgIi4uL3NyYy9sb2dpbi50cyIsICIuLi9zcmMvdWkvbG9naW4udHMiLCAiLi4vc3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGUy50cyIsICIuLi9zcmMvdWkvZm9sZGVyT3B0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoLWVzL2Rpc3QvaW5kZXgubWpzIiwgIi4uL3NyYy9hY3RpdmVTdHJlYW1DbGllbnQudHMiLCAiLi4vc3JjL2Nvb2tpZS50cyIsICIuLi9zcmMvc2VydmVyQVBJLnRzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlGYWN0b3J5LnRzIiwgIi4uL3NyYy91aS9jaG9vc2VTZXNzaW9uVHlwZS50cyIsICIuLi9zcmMvdWkvZW50ZXJUZXh0LnRzIiwgIi4uL3NyYy9wZWVyZHJhZnRXZWJTb2NrZXRQcm92aWRlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG5cdEMtbGlrZSB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJzIGluIEphdmFzY3JpcHRcblx0Q29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cblx0TUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAocm9vdCkge1xuXG5cdC8vIExvY2FsIGNhY2hlIGZvciB0eXBpY2FsIHJhZGljZXNcblx0dmFyIHJhZGl4UG93ZXJDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKCBNYXRoLnBvdygzNiwgNSkgKVxuXHQsXHQxNjogVUlOVDMyKCBNYXRoLnBvdygxNiwgNykgKVxuXHQsXHQxMDogVUlOVDMyKCBNYXRoLnBvdygxMCwgOSkgKVxuXHQsXHQyOiAgVUlOVDMyKCBNYXRoLnBvdygyLCAzMCkgKVxuXHR9XG5cdHZhciByYWRpeENhY2hlID0ge1xuXHRcdDM2OiBVSU5UMzIoMzYpXG5cdCxcdDE2OiBVSU5UMzIoMTYpXG5cdCxcdDEwOiBVSU5UMzIoMTApXG5cdCxcdDI6ICBVSU5UMzIoMilcblx0fVxuXG5cdC8qKlxuXHQgKlx0UmVwcmVzZW50cyBhbiB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xOdW1iZXJ9IGxvdyBiaXRzICAgICB8IGludGVnZXIgYXMgYSBzdHJpbmcgXHRcdCB8IGludGVnZXIgYXMgYSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8TnVtYmVyfFVuZGVmaW5lZH0gaGlnaCBiaXRzIHwgcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDMyIChsLCBoKSB7XG5cdFx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBVSU5UMzIpIClcblx0XHRcdHJldHVybiBuZXcgVUlOVDMyKGwsIGgpXG5cblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHR0aGlzLnJlbWFpbmRlciA9IG51bGxcblx0XHRpZiAodHlwZW9mIGggPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGwpXG5cblx0XHRpZiAodHlwZW9mIGwgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGwsIGgpXG5cblx0XHRmcm9tQml0cy5jYWxsKHRoaXMsIGwsIGgpXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UMzJfIG9iamVjdCB3aXRoIGl0cyBsb3cgYW5kIGhpZ2ggYml0c1xuXHQgKiBAbWV0aG9kIGZyb21CaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChsLCBoKSB7XG5cdFx0dGhpcy5fbG93ID0gbCB8IDBcblx0XHR0aGlzLl9oaWdoID0gaCB8IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tQml0cyA9IGZyb21CaXRzXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIG51bWJlclxuXHQgKiBAbWV0aG9kIGZyb21OdW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tTnVtYmVyICh2YWx1ZSkge1xuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHR2YXIgdmFsdWUgPSBwYXJzZUludChzLCByYWRpeCB8fCAxMClcblxuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDMyXyB0byBhIG51bWJlclxuXHQgKiBAbWV0aG9kIHRvTnVtYmVyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbnZlcnRlZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9oaWdoICogNjU1MzYpICsgdGhpcy5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UMzJfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXggfHwgMTApXG5cdH1cblxuXHQvKipcblx0ICogQWRkIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3cgKyBvdGhlci5fbG93XG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRcdGExNiArPSB0aGlzLl9oaWdoICsgb3RoZXIuX2hpZ2hcblxuXHRcdHRoaXMuX2xvdyA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBhMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3QgdHdvIF9VSU5UMzJfLiBUaGUgY3VycmVudCBfVUlOVDMyXyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIHN1YnRyYWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdC8vVE9ETyBpbmxpbmVcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNlxuXHRcdFx0YiA9IGIwMCArIGIxNlxuXHRcdFx0YSpiID0gKGEwMCArIGExNikoYjAwICsgYjE2KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGExNmIwMCArIGExNmIxNlxuXG5cdFx0XHRhMTZiMTYgb3ZlcmZsb3dzIHRoZSAzMmJpdHNcblx0XHQgKi9cblx0XHR2YXIgYTE2ID0gdGhpcy5faGlnaFxuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3dcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2hpZ2hcblx0XHR2YXIgYjAwID0gb3RoZXIuX2xvd1xuXG4vKiBSZW1vdmVkIHRvIGluY3JlYXNlIHNwZWVkIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzIChpLmUuIG5vdCBtdWx0aXBseWluZyBieSAwIG9yIDEpXG5cdFx0Ly8gdGhpcyA9PSAwIG9yIG90aGVyID09IDE6IG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoKGEwMCA9PSAwICYmIGExNiA9PSAwKSB8fCAoYjAwID09IDEgJiYgYjE2ID09IDApKSByZXR1cm4gdGhpc1xuXG5cdFx0Ly8gb3RoZXIgPT0gMCBvciB0aGlzID09IDE6IHRoaXMgPSBvdGhlclxuXHRcdGlmICgoYjAwID09IDAgJiYgYjE2ID09IDApIHx8IChhMDAgPT0gMSAmJiBhMTYgPT0gMCkpIHtcblx0XHRcdHRoaXMuX2xvdyA9IG90aGVyLl9sb3dcblx0XHRcdHRoaXMuX2hpZ2ggPSBvdGhlci5faGlnaFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG4qL1xuXG5cdFx0dmFyIGMxNiwgYzAwXG5cdFx0YzAwID0gYTAwICogYjAwXG5cdFx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdFx0YzE2ICs9IGExNiAqIGIwMFxuXHRcdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblxuXHRcdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDMyXyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fbG93ID09IDApICYmIChvdGhlci5faGlnaCA9PSAwKSApIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcblxuXHRcdC8vIG90aGVyID09IDFcblx0XHRpZiAob3RoZXIuX2hpZ2ggPT0gMCAmJiBvdGhlci5fbG93ID09IDEpIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBvdGhlciA+IHRoaXM6IDBcblx0XHRpZiAoIG90aGVyLmd0KHRoaXMpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0dGhpcy5fbG93ID0gMVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2xvdyA9IDBcblx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9oaWdoIHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9sb3cgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2xvdyAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gKH50aGlzLl9oaWdoICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRXF1YWxzXG5cdCAqIEBtZXRob2QgZXFcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5lcXVhbHMgPSBVSU5UMzIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9sb3cgPT0gb3RoZXIuX2xvdykgJiYgKHRoaXMuX2hpZ2ggPT0gb3RoZXIuX2hpZ2gpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoIDwgb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPiBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoID4gb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPCBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBPUlxuXHQgKiBAbWV0aG9kIG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyB8PSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCB8PSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93ICY9IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoICY9IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbG93ID0gfnRoaXMuX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB+dGhpcy5faGlnaCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIFhPUlxuXHQgKiBAbWV0aG9kIHhvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93IF49IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoIF49IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgcmlnaHRcblx0ICogQG1ldGhvZCBzaGlmdFJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnNoaWZ0ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0aWYgKG4gPiAxNikge1xuXHRcdFx0dGhpcy5fbG93ID0gdGhpcy5faGlnaCA+PiAobiAtIDE2KVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2hcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPj4gbikgfCAoICh0aGlzLl9oaWdoIDw8ICgxNi1uKSkgJiAweEZGRkYgKVxuXHRcdFx0dGhpcy5faGlnaCA+Pj0gblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCBsZWZ0XG5cdCAqIEBtZXRob2Qgc2hpZnRMZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93IG92ZXJmbG93XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdGwgPSBmdW5jdGlvbiAobiwgYWxsb3dPdmVyZmxvdykge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3cgPDwgKG4gLSAxNilcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobiA9PSAxNikge1xuXHRcdFx0dGhpcy5faGlnaCA9IHRoaXMuX2xvd1xuXHRcdFx0dGhpcy5fbG93ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gKHRoaXMuX2hpZ2ggPDwgbikgfCAodGhpcy5fbG93ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPDwgbikgJiAweEZGRkZcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHQvLyBPdmVyZmxvdyBvbmx5IGFsbG93ZWQgb24gdGhlIGhpZ2ggYml0cy4uLlxuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UMzIucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2IDw8IG4pIHwgKHYgPj4+ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQzMi5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0dmFyIHYgPSAodGhpcy5faGlnaCA8PCAxNikgfCB0aGlzLl9sb3dcblx0XHR2ID0gKHYgPj4+IG4pIHwgKHYgPDwgKDMyIC0gbikpXG5cdFx0dGhpcy5fbG93ID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2ID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQzMih0aGlzLl9sb3csIHRoaXMuX2hpZ2gpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDMyXG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDMyXG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQzMiddID0gVUlOVDMyXG5cdH1cblxufSkodGhpcylcbiIsICIvKipcblx0Qy1saWtlIHVuc2lnbmVkIDY0IGJpdHMgaW50ZWdlcnMgaW4gSmF2YXNjcmlwdFxuXHRDb3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuXHRNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uIChyb290KSB7XG5cblx0Ly8gTG9jYWwgY2FjaGUgZm9yIHR5cGljYWwgcmFkaWNlc1xuXHR2YXIgcmFkaXhQb3dlckNhY2hlID0ge1xuXHRcdDE2OiBVSU5UNjQoIE1hdGgucG93KDE2LCA1KSApXG5cdCxcdDEwOiBVSU5UNjQoIE1hdGgucG93KDEwLCA1KSApXG5cdCxcdDI6ICBVSU5UNjQoIE1hdGgucG93KDIsIDUpIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQxNjogVUlOVDY0KDE2KVxuXHQsXHQxMDogVUlOVDY0KDEwKVxuXHQsXHQyOiAgVUlOVDY0KDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgNjQgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBoaWdoIGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgaGlnaCBiaXRzICg4KVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHMgKDMyKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzICgzMilcblx0ICogb3Jcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFVuZGVmaW5lZH0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDY0IChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIFVJTlQ2NCkgKVxuXHRcdFx0cmV0dXJuIG5ldyBVSU5UNjQoYTAwLCBhMTYsIGEzMiwgYTQ4KVxuXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBhMDAgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGEwMCwgYTE2KVxuXG5cdFx0aWYgKHR5cGVvZiBhMTYgPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGEwMClcblxuXHRcdGZyb21CaXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IHdpdGggaXRzIGxvdyBhbmQgaGlnaCBiaXRzXG5cdCAqIEBtZXRob2QgZnJvbUJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgaGlnaCBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGhpZ2ggYml0cyAoOClcblx0ICogb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzICgzMilcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0cyAoMzIpXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAodHlwZW9mIGEzMiA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSBhMDAgPj4+IDE2XG5cdFx0XHR0aGlzLl9hMzIgPSBhMTYgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9IGExNiA+Pj4gMTZcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0dGhpcy5fYTAwID0gYTAwIHwgMFxuXHRcdHRoaXMuX2ExNiA9IGExNiB8IDBcblx0XHR0aGlzLl9hMzIgPSBhMzIgfCAwXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4IHwgMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21CaXRzID0gZnJvbUJpdHNcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCBmcm9tIGEgbnVtYmVyXG5cdCAqIEBtZXRob2QgZnJvbU51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21OdW1iZXIgKHZhbHVlKSB7XG5cdFx0dGhpcy5fYTAwID0gdmFsdWUgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB2YWx1ZSA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cblx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0dGhpcy5fYTE2ID0gMFxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cblx0XHQvKlxuXHRcdFx0SW4gSmF2YXNjcmlwdCwgYml0d2lzZSBvcGVyYXRvcnMgb25seSBvcGVyYXRlIG9uIHRoZSBmaXJzdCAzMiBiaXRzIFxuXHRcdFx0b2YgYSBudW1iZXIsIGV2ZW4gdGhvdWdoIHBhcnNlSW50KCkgZW5jb2RlcyBudW1iZXJzIHdpdGggYSA1MyBiaXRzIFxuXHRcdFx0bWFudGlzc2EuXG5cdFx0XHRUaGVyZWZvcmUgVUlOVDY0KDxOdW1iZXI+KSBjYW4gb25seSB3b3JrIG9uIDMyIGJpdHMuXG5cdFx0XHRUaGUgcmFkaXggbWF4aW11bSB2YWx1ZSBpcyAzNiAoYXMgcGVyIEVDTUEgc3BlY3MpICgyNiBsZXR0ZXJzICsgMTAgZGlnaXRzKVxuXHRcdFx0bWF4aW11bSBpbnB1dCB2YWx1ZSBpcyBtID0gMzJiaXRzIGFzIDEgPSAyXjMyIC0gMVxuXHRcdFx0U28gdGhlIG1heGltdW0gc3Vic3RyaW5nIGxlbmd0aCBuIGlzOlxuXHRcdFx0MzZeKG4rMSkgLSAxID0gMl4zMiAtIDFcblx0XHRcdDM2XihuKzEpID0gMl4zMlxuXHRcdFx0KG4rMSlsbigzNikgPSAzMmxuKDIpXG5cdFx0XHRuID0gMzJsbigyKS9sbigzNikgLSAxXG5cdFx0XHRuID0gNS4xODk2NDQ5MTU2ODc2OTJcblx0XHRcdG4gPSA1XG5cdFx0ICovXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4UG93ZXJDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIDUpIClcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA1KSB7XG5cdFx0XHR2YXIgc2l6ZSA9IE1hdGgubWluKDUsIGxlbiAtIGkpXG5cdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludCggcy5zbGljZShpLCBpICsgc2l6ZSksIHJhZGl4IClcblx0XHRcdHRoaXMubXVsdGlwbHkoXG5cdFx0XHRcdFx0c2l6ZSA8IDVcblx0XHRcdFx0XHRcdD8gbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIHNpemUpIClcblx0XHRcdFx0XHRcdDogcmFkaXhVaW50XG5cdFx0XHRcdClcblx0XHRcdFx0LmFkZCggbmV3IFVJTlQ2NCh2YWx1ZSkgKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQ2NF8gdG8gYSBudW1iZXIgKGxhc3QgMzIgYml0cyBhcmUgZHJvcHBlZClcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDY0XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5fYTE2ICogNjU1MzYpICsgdGhpcy5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UNjRfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NChyYWRpeClcblxuXHRcdGlmICggIXRoaXMuZ3QocmFkaXhVaW50KSApIHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHR2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKVxuXHRcdHZhciByZXMgPSBuZXcgQXJyYXkoNjQpXG5cdFx0Zm9yICh2YXIgaSA9IDYzOyBpID49IDA7IGktLSkge1xuXHRcdFx0c2VsZi5kaXYocmFkaXhVaW50KVxuXHRcdFx0cmVzW2ldID0gc2VsZi5yZW1haW5kZXIudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblx0XHRcdGlmICggIXNlbGYuZ3QocmFkaXhVaW50KSApIGJyZWFrXG5cdFx0fVxuXHRcdHJlc1tpLTFdID0gc2VsZi50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0cmV0dXJuIHJlcy5qb2luKCcnKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwICsgb3RoZXIuX2EwMFxuXG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblx0XHRhMTYgKz0gdGhpcy5fYTE2ICsgb3RoZXIuX2ExNlxuXG5cdFx0dmFyIGEzMiA9IGExNiA+Pj4gMTZcblx0XHRhMzIgKz0gdGhpcy5fYTMyICsgb3RoZXIuX2EzMlxuXG5cdFx0dmFyIGE0OCA9IGEzMiA+Pj4gMTZcblx0XHRhNDggKz0gdGhpcy5fYTQ4ICsgb3RoZXIuX2E0OFxuXG5cdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNiArIGEzMiArIGE0OFxuXHRcdFx0YiA9IGIwMCArIGIxNiArIGIzMiArIGI0OFxuXHRcdFx0YSpiID0gKGEwMCArIGExNiArIGEzMiArIGE0OCkoYjAwICsgYjE2ICsgYjMyICsgYjQ4KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGEwMGIzMiArIGEwMGI0OFxuXHRcdFx0XHQrIGExNmIwMCArIGExNmIxNiArIGExNmIzMiArIGExNmI0OFxuXHRcdFx0XHQrIGEzMmIwMCArIGEzMmIxNiArIGEzMmIzMiArIGEzMmI0OFxuXHRcdFx0XHQrIGE0OGIwMCArIGE0OGIxNiArIGE0OGIzMiArIGE0OGI0OFxuXG5cdFx0XHRhMTZiNDgsIGEzMmIzMiwgYTQ4YjE2LCBhNDhiMzIgYW5kIGE0OGI0OCBvdmVyZmxvdyB0aGUgNjQgYml0c1xuXHRcdFx0c28gaXQgY29tZXMgZG93biB0bzpcblx0XHRcdGEqYlx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzJcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTZcblx0XHRcdFx0KyBhNDhiMDBcblx0XHRcdFx0PSBhMDBiMDBcblx0XHRcdFx0KyBhMDBiMTYgKyBhMTZiMDBcblx0XHRcdFx0KyBhMDBiMzIgKyBhMTZiMTYgKyBhMzJiMDBcblx0XHRcdFx0KyBhMDBiNDggKyBhMTZiMzIgKyBhMzJiMTYgKyBhNDhiMDBcblx0XHQgKi9cblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwXG5cdFx0dmFyIGExNiA9IHRoaXMuX2ExNlxuXHRcdHZhciBhMzIgPSB0aGlzLl9hMzJcblx0XHR2YXIgYTQ4ID0gdGhpcy5fYTQ4XG5cdFx0dmFyIGIwMCA9IG90aGVyLl9hMDBcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2ExNlxuXHRcdHZhciBiMzIgPSBvdGhlci5fYTMyXG5cdFx0dmFyIGI0OCA9IG90aGVyLl9hNDhcblxuXHRcdHZhciBjMDAgPSBhMDAgKiBiMDBcblxuXHRcdHZhciBjMTYgPSBjMDAgPj4+IDE2XG5cdFx0YzE2ICs9IGEwMCAqIGIxNlxuXHRcdHZhciBjMzIgPSBjMTYgPj4+IDE2XG5cdFx0YzE2ICY9IDB4RkZGRlxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblxuXHRcdGMzMiArPSBjMTYgPj4+IDE2XG5cdFx0YzMyICs9IGEwMCAqIGIzMlxuXHRcdHZhciBjNDggPSBjMzIgPj4+IDE2XG5cdFx0YzMyICY9IDB4RkZGRlxuXHRcdGMzMiArPSBhMTYgKiBiMTZcblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTMyICogYjAwXG5cblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGM0OCArPSBhMDAgKiBiNDhcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGExNiAqIGIzMlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTMyICogYjE2XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhNDggKiBiMDBcblxuXHRcdHRoaXMuX2EwMCA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGMxNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGMzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGM0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGUgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdC5cblx0ICogVGhlIHJlbWFpbmRlciBpcyBtYWRlIGF2YWlsYWJsZSBhcyB0aGUgX3JlbWFpbmRlcl8gcHJvcGVydHkgb25cblx0ICogdGhlIF9VSU5UNjRfIG9iamVjdC4gSXQgY2FuIGJlIG51bGwsIG1lYW5pbmcgdGhlcmUgYXJlIG5vIHJlbWFpbmRlci5cblx0ICogQG1ldGhvZCBkaXZcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICggKG90aGVyLl9hMTYgPT0gMCkgJiYgKG90aGVyLl9hMzIgPT0gMCkgJiYgKG90aGVyLl9hNDggPT0gMCkgKSB7XG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAwKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHRcdC8vIG90aGVyID09IDE6IHRoaXNcblx0XHRcdGlmIChvdGhlci5fYTAwID09IDEpIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIgPSBuZXcgVUlOVDY0KDApXG5cdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0dGhpcy5fYTAwID0gMVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBTaGlmdCB0aGUgZGl2aXNvciBsZWZ0IHVudGlsIGl0IGlzIGhpZ2hlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdHZhciBfb3RoZXIgPSBvdGhlci5jbG9uZSgpXG5cdFx0dmFyIGkgPSAtMVxuXHRcdHdoaWxlICggIXRoaXMubHQoX290aGVyKSApIHtcblx0XHRcdC8vIEhpZ2ggYml0IGNhbiBvdmVyZmxvdyB0aGUgZGVmYXVsdCAxNmJpdHNcblx0XHRcdC8vIEl0cyBvayBzaW5jZSB3ZSByaWdodCBzaGlmdCBhZnRlciB0aGlzIGxvb3Bcblx0XHRcdC8vIFRoZSBvdmVyZmxvd24gYml0IG11c3QgYmUga2VwdCB0aG91Z2hcblx0XHRcdF9vdGhlci5zaGlmdExlZnQoMSwgdHJ1ZSlcblx0XHRcdGkrK1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgcmVtYWluZGVyXG5cdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHQvLyBJbml0aWFsaXplIHRoZSBjdXJyZW50IHJlc3VsdCB0byAwXG5cdFx0dGhpcy5fYTAwID0gMFxuXHRcdHRoaXMuX2ExNiA9IDBcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gNDgpIHtcblx0XHRcdFx0XHR0aGlzLl9hNDggfD0gMSA8PCAoaSAtIDQ4KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMzIpIHtcblx0XHRcdFx0XHR0aGlzLl9hMzIgfD0gMSA8PCAoaSAtIDMyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9hMTYgfD0gMSA8PCAoaSAtIDE2KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2EwMCB8PSAxIDw8IGlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogTmVnYXRlIHRoZSBjdXJyZW50IF9VSU5UNjRfXG5cdCAqIEBtZXRob2QgbmVnYXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ID0gKCB+dGhpcy5fYTAwICYgMHhGRkZGICkgKyAxXG5cdFx0dGhpcy5fYTAwID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2ExNiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTE2ID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2EzMiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTMyID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9ICh+dGhpcy5fYTQ4ICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblxuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDY0LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fYTQ4ID09IG90aGVyLl9hNDgpICYmICh0aGlzLl9hMDAgPT0gb3RoZXIuX2EwMClcblx0XHRcdCAmJiAodGhpcy5fYTMyID09IG90aGVyLl9hMzIpICYmICh0aGlzLl9hMTYgPT0gb3RoZXIuX2ExNilcblx0fVxuXG5cdC8qKlxuXHQgKiBHcmVhdGVyIHRoYW4gKHN0cmljdClcblx0ICogQG1ldGhvZCBndFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gVUlOVDY0LnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICh0aGlzLl9hNDggPiBvdGhlci5fYTQ4KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hNDggPCBvdGhlci5fYTQ4KSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTMyID4gb3RoZXIuX2EzMikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTMyIDwgb3RoZXIuX2EzMikgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2ExNiA+IG90aGVyLl9hMTYpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2ExNiA8IG90aGVyLl9hMTYpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hMDAgPiBvdGhlci5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwIDwgb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgfD0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiB8PSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIHw9IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggfD0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwICY9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgJj0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiAmPSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4ICY9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCBePSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2IF49IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgXj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCBePSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYTAwID0gfnRoaXMuX2EwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IH50aGlzLl9hMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSB+dGhpcy5fYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gfnRoaXMuX2E0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDY0LnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA+PSA0OCkge1xuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTQ4ID4+IChuIC0gNDgpXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDMyKSB7XG5cdFx0XHRuIC09IDMyXG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMzIgPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2EwMCA+PiBuKSB8ICh0aGlzLl9hMTYgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPj4gbikgfCAodGhpcy5fYTMyIDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2EwMCA8PCAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTE2IDw8IG4pIHwgKHRoaXMuX2EwMCA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2E0OCA8PCBuKSB8ICh0aGlzLl9hMzIgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyIDw8IG4pIHwgKHRoaXMuX2ExNiA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0fVxuXHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0dGhpcy5fYTQ4ICY9IDB4RkZGRlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UNjQucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBCLkMuRC5BIHJvdGwoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdGwoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoIDw8IG4pIHwgKGxvdyA+Pj4gKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93IDw8IG4pIHwgKGhpZ2ggPj4+ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID09IDApIHJldHVybiB0aGlzXG5cdFx0aWYgKG4gPj0gMzIpIHtcblx0XHRcdC8vIEEuQi5DLkRcblx0XHRcdC8vIEQuQS5CLkMgcm90cigxNilcblx0XHRcdC8vIEMuRC5BLkIgcm90cigzMilcblx0XHRcdHZhciB2ID0gdGhpcy5fYTAwXG5cdFx0XHR0aGlzLl9hMDAgPSB0aGlzLl9hMzJcblx0XHRcdHRoaXMuX2EzMiA9IHZcblx0XHRcdHYgPSB0aGlzLl9hNDhcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2ExNlxuXHRcdFx0dGhpcy5fYTE2ID0gdlxuXHRcdFx0aWYgKG4gPT0gMzIpIHJldHVybiB0aGlzXG5cdFx0XHRuIC09IDMyXG5cdFx0fVxuXG5cdFx0dmFyIGhpZ2ggPSAodGhpcy5fYTQ4IDw8IDE2KSB8IHRoaXMuX2EzMlxuXHRcdHZhciBsb3cgPSAodGhpcy5fYTE2IDw8IDE2KSB8IHRoaXMuX2EwMFxuXG5cdFx0dmFyIF9oaWdoID0gKGhpZ2ggPj4+IG4pIHwgKGxvdyA8PCAoMzIgLSBuKSlcblx0XHR2YXIgX2xvdyA9IChsb3cgPj4+IG4pIHwgKGhpZ2ggPDwgKDMyIC0gbikpXG5cblx0XHR0aGlzLl9hMDAgPSBfbG93ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gX2xvdyA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSBfaGlnaCAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IF9oaWdoID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQ2NCh0aGlzLl9hMDAsIHRoaXMuX2ExNiwgdGhpcy5fYTMyLCB0aGlzLl9hNDgpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDY0XG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDY0XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQ2NCddID0gVUlOVDY0XG5cdH1cblxufSkodGhpcylcbiIsICJleHBvcnRzLlVJTlQzMiA9IHJlcXVpcmUoJy4vbGliL3VpbnQzMicpXG5leHBvcnRzLlVJTlQ2NCA9IHJlcXVpcmUoJy4vbGliL3VpbnQ2NCcpIiwgIi8qKlxueHhIYXNoIGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDMyID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UMzJcblxuLypcblx0TWVyZ2VkIHRoaXMgc2VxdWVuY2Ugb2YgbWV0aG9kIGNhbGxzIGFzIGl0IHNwZWVkcyB1cFxuXHR0aGUgY2FsY3VsYXRpb25zIGJ5IGEgZmFjdG9yIG9mIDJcbiAqL1xuLy8gdGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FMzJfMikgKS5yb3RsKDEzKS5tdWx0aXBseShQUklNRTMyXzEpO1xuVUlOVDMyLnByb3RvdHlwZS54eGhfdXBkYXRlID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuXHR2YXIgYjAwID0gUFJJTUUzMl8yLl9sb3dcblx0dmFyIGIxNiA9IFBSSU1FMzJfMi5faGlnaFxuXG5cdHZhciBjMTYsIGMwMFxuXHRjMDAgPSBsb3cgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBoaWdoICogYjAwXG5cdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRjMTYgKz0gbG93ICogYjE2XG5cblx0dmFyIGEwMCA9IHRoaXMuX2xvdyArIChjMDAgJiAweEZGRkYpXG5cdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0YTE2ICs9IHRoaXMuX2hpZ2ggKyAoYzE2ICYgMHhGRkZGKVxuXG5cdHZhciB2ID0gKGExNiA8PCAxNikgfCAoYTAwICYgMHhGRkZGKVxuXHR2ID0gKHYgPDwgMTMpIHwgKHYgPj4+IDE5KVxuXG5cdGEwMCA9IHYgJiAweEZGRkZcblx0YTE2ID0gdiA+Pj4gMTZcblxuXHRiMDAgPSBQUklNRTMyXzEuX2xvd1xuXHRiMTYgPSBQUklNRTMyXzEuX2hpZ2hcblxuXHRjMDAgPSBhMDAgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBhMTYgKiBiMDBcblx0YzE2ICY9IDB4RkZGRlx0XHQvLyBOb3QgcmVxdWlyZWQgYnV0IGltcHJvdmVzIHBlcmZvcm1hbmNlXG5cdGMxNiArPSBhMDAgKiBiMTZcblxuXHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0dGhpcy5faGlnaCA9IGMxNiAmIDB4RkZGRlxufVxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTMyXzEgPSBVSU5UMzIoICcyNjU0NDM1NzYxJyApXG52YXIgUFJJTUUzMl8yID0gVUlOVDMyKCAnMjI0NjgyMjUxOScgKVxudmFyIFBSSU1FMzJfMyA9IFVJTlQzMiggJzMyNjY0ODk5MTcnIClcbnZhciBQUklNRTMyXzQgPSBVSU5UMzIoICAnNjY4MjY1MjYzJyApXG52YXIgUFJJTUUzMl81ID0gVUlOVDMyKCAgJzM3NDc2MTM5MycgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSCBvYmplY3QgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIG9yIGEgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogb3JcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ8VUlOVDMyfSBzZWVkXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKiBvclxuICogQHJldHVybiB7VUlOVDMyfSB4eEhhc2hcbiAqL1xuZnVuY3Rpb24gWFhIICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEgpKVxuXHRcdHJldHVybiBuZXcgWFhIKCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhIIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDMyID8gc2VlZC5jbG9uZSgpIDogVUlOVDMyKHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUUzMl8xKS5hZGQoUFJJTUUzMl8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FMzJfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTMyXzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEgucHJvdG90eXBlLmluaXQgPSBpbml0XG5cbi8qKlxuICogQWRkIGRhdGEgdG8gYmUgY29tcHV0ZWQgZm9yIHRoZSBYWEggaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDE2KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMTYpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDE2KSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIGxlbilcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0XG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIGxlbiksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIDAsIGxlbiApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplICs9IGxlblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplID4gMCkgICAvLyBzb21lIGRhdGEgbGVmdCBmcm9tIHByZXZpb3VzIHVwZGF0ZVxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAxNiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMTYgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAxNiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHAzMiA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0fVxuXG5cdFx0cCArPSAxNiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAxNilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAxNlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdHAgKz0gNFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEggY29tcHV0YXRpb24uIFRoZSBYWEggaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQzMn0geHhIYXNoXG4gKi9cblhYSC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoMzIsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDMyXG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDE2KVxuXHR7XG5cdFx0aDMyID0gdGhpcy52MS5yb3RsKDEpLmFkZCggdGhpcy52Mi5yb3RsKDcpLmFkZCggdGhpcy52My5yb3RsKDEyKS5hZGQoIHRoaXMudjQucm90bCgxOCkgKSApIClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoMzIgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTMyXzUgKVxuXHR9XG5cblx0aDMyLmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDQpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0KVxuXHRcdH1cblx0XHRoMzJcblx0XHRcdC5hZGQoIHUubXVsdGlwbHkoUFJJTUUzMl8zKSApXG5cdFx0XHQucm90bCgxNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUUzMl80IClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCApXG5cdFx0aDMyXG5cdFx0XHQuYWRkKCB1Lm11bHRpcGx5KFBSSU1FMzJfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUUzMl8xKVxuXHR9XG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTUpXG5cdGgzMi54b3IoaCkubXVsdGlwbHkoUFJJTUUzMl8yKVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDEzKVxuXHRoMzIueG9yKGgpLm11bHRpcGx5KFBSSU1FMzJfMylcblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxNilcblx0aDMyLnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGgzMlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSFxuIiwgIi8qKlxueHhIYXNoNjQgaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxNiwgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UNjQgPSByZXF1aXJlKCdjdWludCcpLlVJTlQ2NFxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTY0XzEgPSBVSU5UNjQoICcxMTQwMDcxNDc4NTA3NDY5NDc5MScgKVxudmFyIFBSSU1FNjRfMiA9IFVJTlQ2NCggJzE0MDI5NDY3MzY2ODk3MDE5NzI3JyApXG52YXIgUFJJTUU2NF8zID0gVUlOVDY0KCAgJzE2MDk1ODc5MjkzOTI4MzkxNjEnIClcbnZhciBQUklNRTY0XzQgPSBVSU5UNjQoICAnOTY1MDAyOTI0MjI4NzgyODU3OScgKVxudmFyIFBSSU1FNjRfNSA9IFVJTlQ2NCggICcyODcwMTc3NDUwMDEyNjAwMjYxJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhINjQgb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQ2NH0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSDY0ICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSDY0KSlcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhINjQgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UNjQgPyBzZWVkLmNsb25lKCkgOiBVSU5UNjQoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTY0XzEpLmFkZChQUklNRTY0XzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FNjRfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSDY0LnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhINjQgaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEg2NC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigzMilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMzIpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSDY0X21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAzMiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMzIgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAzMiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHA2NCA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG90aGVyXG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fVxuXG5cdFx0cCArPSAzMiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAzMilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAzMlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dmFyIG90aGVyXG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH1cblx0XHRcdHAgKz0gOFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSDY0IGNvbXB1dGF0aW9uLiBUaGUgWFhINjQgaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cblhYSDY0LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGg2NCwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UNjRcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMzIpXG5cdHtcblx0XHRoNjQgPSB0aGlzLnYxLmNsb25lKCkucm90bCgxKVxuXHRcdGg2NC5hZGQoIHRoaXMudjIuY2xvbmUoKS5yb3RsKDcpIClcblx0XHRoNjQuYWRkKCB0aGlzLnYzLmNsb25lKCkucm90bCgxMikgKVxuXHRcdGg2NC5hZGQoIHRoaXMudjQuY2xvbmUoKS5yb3RsKDE4KSApXG5cblx0XHRoNjQueG9yKCB0aGlzLnYxLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjIubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52My5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnY0Lm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoNjQgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTY0XzUgKVxuXHR9XG5cblx0aDY0LmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDgpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzUpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzQpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdClcblx0XHR9XG5cdFx0dS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSlcblx0XHRoNjRcblx0XHRcdC54b3IodSlcblx0XHRcdC5yb3RsKDI3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzEgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF80IClcblx0XHRwICs9IDhcblx0fVxuXG5cdGlmIChwICsgNCA8PSBiRW5kKSB7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0MFxuXHRcdFx0LFx0MFxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9XG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdFx0LnJvdGwoMjMpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FNjRfMiApXG5cdFx0XHQuYWRkKCBQUklNRTY0XzMgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwLCAwLCAwIClcblx0XHRoNjRcblx0XHRcdC54b3IoIHUubXVsdGlwbHkoUFJJTUU2NF81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTY0XzEpXG5cdH1cblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMylcblx0aDY0LnhvcihoKS5tdWx0aXBseShQUklNRTY0XzIpXG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMjkpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8zKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDMyKVxuXHRoNjQueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDY0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhINjRcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHtcblx0aDMyOiByZXF1aXJlKFwiLi94eGhhc2hcIilcbixcdGg2NDogcmVxdWlyZShcIi4veHhoYXNoNjRcIilcbn1cbiIsICIoZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP3RoaXM6c2VsZjpnbG9iYWw6d2luZG93LHQuU2ltcGxlUGVlcj1lKCl9fSkoZnVuY3Rpb24oKXt2YXIgdD1NYXRoLmZsb29yLG49TWF0aC5hYnMscj1NYXRoLnBvdztyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBkKHMsZSxuKXtmdW5jdGlvbiB0KG8saSl7aWYoIWVbb10pe2lmKCFzW29dKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFpJiZsKXJldHVybiBsKG8sITApO2lmKHIpcmV0dXJuIHIobywhMCk7dmFyIGM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBjLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsY312YXIgYT1lW29dPXtleHBvcnRzOnt9fTtzW29dWzBdLmNhbGwoYS5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciByPXNbb11bMV1bZV07cmV0dXJuIHQocnx8ZSl9LGEsYS5leHBvcnRzLGQscyxlLG4pfXJldHVybiBlW29dLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsYT0wO2E8bi5sZW5ndGg7YSsrKXQoblthXSk7cmV0dXJuIHR9cmV0dXJuIGR9KCkoezE6W2Z1bmN0aW9uKGUsdCxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXt2YXIgdD1lLmxlbmd0aDtpZigwPHQlNCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciBuPWUuaW5kZXhPZihcIj1cIik7LTE9PT1uJiYobj10KTt2YXIgcj1uPT09dD8wOjQtbiU0O3JldHVybltuLHJdfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiAzKih0K24pLzQtbn1mdW5jdGlvbiBvKGUpe3ZhciB0LG4sbz1yKGUpLGQ9b1swXSxzPW9bMV0sbD1uZXcgcChhKGUsZCxzKSksYz0wLGY9MDxzP2QtNDpkO2ZvcihuPTA7bjxmO24rPTQpdD11W2UuY2hhckNvZGVBdChuKV08PDE4fHVbZS5jaGFyQ29kZUF0KG4rMSldPDwxMnx1W2UuY2hhckNvZGVBdChuKzIpXTw8Nnx1W2UuY2hhckNvZGVBdChuKzMpXSxsW2MrK109MjU1JnQ+PjE2LGxbYysrXT0yNTUmdD4+OCxsW2MrK109MjU1JnQ7cmV0dXJuIDI9PT1zJiYodD11W2UuY2hhckNvZGVBdChuKV08PDJ8dVtlLmNoYXJDb2RlQXQobisxKV0+PjQsbFtjKytdPTI1NSZ0KSwxPT09cyYmKHQ9dVtlLmNoYXJDb2RlQXQobildPDwxMHx1W2UuY2hhckNvZGVBdChuKzEpXTw8NHx1W2UuY2hhckNvZGVBdChuKzIpXT4+MixsW2MrK109MjU1JnQ+PjgsbFtjKytdPTI1NSZ0KSxsfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIGNbNjMmZT4+MThdK2NbNjMmZT4+MTJdK2NbNjMmZT4+Nl0rY1s2MyZlXX1mdW5jdGlvbiBzKGUsdCxuKXtmb3IodmFyIHIsYT1bXSxvPXQ7bzxuO28rPTMpcj0oMTY3MTE2ODAmZVtvXTw8MTYpKyg2NTI4MCZlW28rMV08PDgpKygyNTUmZVtvKzJdKSxhLnB1c2goZChyKSk7cmV0dXJuIGEuam9pbihcIlwiKX1mdW5jdGlvbiBsKGUpe2Zvcih2YXIgdCxuPWUubGVuZ3RoLHI9biUzLGE9W10sbz0xNjM4MyxkPTAsbD1uLXI7ZDxsO2QrPW8pYS5wdXNoKHMoZSxkLGQrbz5sP2w6ZCtvKSk7cmV0dXJuIDE9PT1yPyh0PWVbbi0xXSxhLnB1c2goY1t0Pj4yXStjWzYzJnQ8PDRdK1wiPT1cIikpOjI9PT1yJiYodD0oZVtuLTJdPDw4KStlW24tMV0sYS5wdXNoKGNbdD4+MTBdK2NbNjMmdD4+NF0rY1s2MyZ0PDwyXStcIj1cIikpLGEuam9pbihcIlwiKX1uLmJ5dGVMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9cihlKSxuPXRbMF0sYT10WzFdO3JldHVybiAzKihuK2EpLzQtYX0sbi50b0J5dGVBcnJheT1vLG4uZnJvbUJ5dGVBcnJheT1sO2Zvcih2YXIgYz1bXSx1PVtdLHA9XCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQ4QXJyYXk/QXJyYXk6VWludDhBcnJheSxmPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLGc9MCxfPWYubGVuZ3RoO2c8XzsrK2cpY1tnXT1mW2ddLHVbZi5jaGFyQ29kZUF0KGcpXT1nO3VbNDVdPTYyLHVbOTVdPTYzfSx7fV0sMjpbZnVuY3Rpb24oKXt9LHt9XSwzOltmdW5jdGlvbihlLHQsbil7KGZ1bmN0aW9uKCl7KGZ1bmN0aW9uKCl7LyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovJ3VzZSBzdHJpY3QnO3ZhciB0PVN0cmluZy5mcm9tQ2hhckNvZGUsbz1NYXRoLm1pbjtmdW5jdGlvbiBkKGUpe2lmKDIxNDc0ODM2NDc8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIrZStcIlxcXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFxcXCJzaXplXFxcIlwiKTt2YXIgdD1uZXcgVWludDhBcnJheShlKTtyZXR1cm4gdC5fX3Byb3RvX189cy5wcm90b3R5cGUsdH1mdW5jdGlvbiBzKGUsdCxuKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwic3RyaW5nXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlclwiKTtyZXR1cm4gcChlKX1yZXR1cm4gbChlLHQsbil9ZnVuY3Rpb24gbChlLHQsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGYoZSx0KTtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpcmV0dXJuIGcoZSk7aWYobnVsbD09ZSl0aHJvdyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSk7aWYoSyhlLEFycmF5QnVmZmVyKXx8ZSYmSyhlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpcmV0dXJuIF8oZSx0LG4pO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcInZhbHVlXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXJcIik7dmFyIHI9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihudWxsIT1yJiZyIT09ZSlyZXR1cm4gcy5mcm9tKHIsdCxuKTt2YXIgYT1oKGUpO2lmKGEpcmV0dXJuIGE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9U3ltYm9sLnRvUHJpbWl0aXZlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV0pcmV0dXJuIHMuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIiksdCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWZ1bmN0aW9uIGMoZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyXCIpO2Vsc2UgaWYoMD5lKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIFxcXCJcIitlK1wiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcInNpemVcXFwiXCIpfWZ1bmN0aW9uIHUoZSx0LG4pe3JldHVybiBjKGUpLDA+PWU/ZChlKTp2b2lkIDA9PT10P2QoZSk6XCJzdHJpbmdcIj09dHlwZW9mIG4/ZChlKS5maWxsKHQsbik6ZChlKS5maWxsKHQpfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGMoZSksZCgwPmU/MDowfG0oZSkpfWZ1bmN0aW9uIGYoZSx0KXtpZigoXCJzdHJpbmdcIiE9dHlwZW9mIHR8fFwiXCI9PT10KSYmKHQ9XCJ1dGY4XCIpLCFzLmlzRW5jb2RpbmcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3ZhciBuPTB8YihlLHQpLHI9ZChuKSxhPXIud3JpdGUoZSx0KTtyZXR1cm4gYSE9PW4mJihyPXIuc2xpY2UoMCxhKSkscn1mdW5jdGlvbiBnKGUpe2Zvcih2YXIgdD0wPmUubGVuZ3RoPzA6MHxtKGUubGVuZ3RoKSxuPWQodCkscj0wO3I8dDtyKz0xKW5bcl09MjU1JmVbcl07cmV0dXJuIG59ZnVuY3Rpb24gXyhlLHQsbil7aWYoMD50fHxlLmJ5dGVMZW5ndGg8dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlxcXCJvZmZzZXRcXFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc1wiKTtpZihlLmJ5dGVMZW5ndGg8dCsobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcXFwibGVuZ3RoXFxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIik7dmFyIHI7cmV0dXJuIHI9dm9pZCAwPT09dCYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUsdCk6bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLHIuX19wcm90b19fPXMucHJvdG90eXBlLHJ9ZnVuY3Rpb24gaChlKXtpZihzLmlzQnVmZmVyKGUpKXt2YXIgdD0wfG0oZS5sZW5ndGgpLG49ZCh0KTtyZXR1cm4gMD09PW4ubGVuZ3RoP246KGUuY29weShuLDAsMCx0KSxuKX1yZXR1cm4gdm9pZCAwPT09ZS5sZW5ndGg/XCJCdWZmZXJcIj09PWUudHlwZSYmQXJyYXkuaXNBcnJheShlLmRhdGEpP2coZS5kYXRhKTp2b2lkIDA6XCJudW1iZXJcIiE9dHlwZW9mIGUubGVuZ3RofHxYKGUubGVuZ3RoKT9kKDApOmcoZSl9ZnVuY3Rpb24gbShlKXtpZihlPj0yMTQ3NDgzNjQ3KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiKzIxNDc0ODM2NDcgLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHxlfWZ1bmN0aW9uIGIoZSx0KXtpZihzLmlzQnVmZmVyKGUpKXJldHVybiBlLmxlbmd0aDtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fEsoZSxBcnJheUJ1ZmZlcikpcmV0dXJuIGUuYnl0ZUxlbmd0aDtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJzdHJpbmdcXFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKTt2YXIgbj1lLmxlbmd0aCxyPTI8YXJndW1lbnRzLmxlbmd0aCYmITA9PT1hcmd1bWVudHNbMl07aWYoIXImJjA9PT1uKXJldHVybiAwO2Zvcih2YXIgYT0hMTs7KXN3aXRjaCh0KXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBuO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBIKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipuO2Nhc2VcImhleFwiOnJldHVybiBuPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4geihlKS5sZW5ndGg7ZGVmYXVsdDppZihhKXJldHVybiByPy0xOkgoZSkubGVuZ3RoO3Q9KFwiXCIrdCkudG9Mb3dlckNhc2UoKSxhPSEwO319ZnVuY3Rpb24geShlLHQsbil7dmFyIHI9ITE7aWYoKHZvaWQgMD09PXR8fDA+dCkmJih0PTApLHQ+dGhpcy5sZW5ndGgpcmV0dXJuXCJcIjtpZigodm9pZCAwPT09bnx8bj50aGlzLmxlbmd0aCkmJihuPXRoaXMubGVuZ3RoKSwwPj1uKXJldHVyblwiXCI7aWYobj4+Pj0wLHQ+Pj49MCxuPD10KXJldHVyblwiXCI7Zm9yKGV8fChlPVwidXRmOFwiKTs7KXN3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gUCh0aGlzLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHgodGhpcyx0LG4pO2Nhc2VcImFzY2lpXCI6cmV0dXJuIEQodGhpcyx0LG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBJKHRoaXMsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gQSh0aGlzLHQsbik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIE0odGhpcyx0LG4pO2RlZmF1bHQ6aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpLHI9ITA7fX1mdW5jdGlvbiBDKGUsdCxuKXt2YXIgcj1lW3RdO2VbdF09ZVtuXSxlW25dPXJ9ZnVuY3Rpb24gUihlLHQsbixyLGEpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4tMTtpZihcInN0cmluZ1wiPT10eXBlb2Ygbj8ocj1uLG49MCk6MjE0NzQ4MzY0NzxuP249MjE0NzQ4MzY0NzotMjE0NzQ4MzY0OD5uJiYobj0tMjE0NzQ4MzY0OCksbj0rbixYKG4pJiYobj1hPzA6ZS5sZW5ndGgtMSksMD5uJiYobj1lLmxlbmd0aCtuKSxuPj1lLmxlbmd0aCl7aWYoYSlyZXR1cm4tMTtuPWUubGVuZ3RoLTF9ZWxzZSBpZigwPm4paWYoYSluPTA7ZWxzZSByZXR1cm4tMTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9cy5mcm9tKHQscikpLHMuaXNCdWZmZXIodCkpcmV0dXJuIDA9PT10Lmxlbmd0aD8tMTpFKGUsdCxuLHIsYSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQmPTI1NSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP2E/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUsdCxuKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUsdCxuKTpFKGUsW3RdLG4scixhKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIEUoZSx0LG4scixhKXtmdW5jdGlvbiBvKGUsdCl7cmV0dXJuIDE9PT1kP2VbdF06ZS5yZWFkVUludDE2QkUodCpkKX12YXIgZD0xLHM9ZS5sZW5ndGgsbD10Lmxlbmd0aDtpZih2b2lkIDAhPT1yJiYocj0ocitcIlwiKS50b0xvd2VyQ2FzZSgpLFwidWNzMlwiPT09cnx8XCJ1Y3MtMlwiPT09cnx8XCJ1dGYxNmxlXCI9PT1yfHxcInV0Zi0xNmxlXCI9PT1yKSl7aWYoMj5lLmxlbmd0aHx8Mj50Lmxlbmd0aClyZXR1cm4tMTtkPTIscy89MixsLz0yLG4vPTJ9dmFyIGM7aWYoYSl7dmFyIHU9LTE7Zm9yKGM9bjtjPHM7YysrKWlmKG8oZSxjKSE9PW8odCwtMT09PXU/MDpjLXUpKS0xIT09dSYmKGMtPWMtdSksdT0tMTtlbHNlIGlmKC0xPT09dSYmKHU9YyksYy11KzE9PT1sKXJldHVybiB1KmR9ZWxzZSBmb3IobitsPnMmJihuPXMtbCksYz1uOzA8PWM7Yy0tKXtmb3IodmFyIHA9ITAsZj0wO2Y8bDtmKyspaWYobyhlLGMrZikhPT1vKHQsZikpe3A9ITE7YnJlYWt9aWYocClyZXR1cm4gY31yZXR1cm4tMX1mdW5jdGlvbiB3KGUsdCxuLHIpe249K258fDA7dmFyIGE9ZS5sZW5ndGgtbjtyPyhyPStyLHI+YSYmKHI9YSkpOnI9YTt2YXIgbz10Lmxlbmd0aDtyPm8vMiYmKHI9by8yKTtmb3IodmFyIGQscz0wO3M8cjsrK3Mpe2lmKGQ9cGFyc2VJbnQodC5zdWJzdHIoMipzLDIpLDE2KSxYKGQpKXJldHVybiBzO2VbbitzXT1kfXJldHVybiBzfWZ1bmN0aW9uIFMoZSx0LG4scil7cmV0dXJuIEcoSCh0LGUubGVuZ3RoLW4pLGUsbixyKX1mdW5jdGlvbiBUKGUsdCxuLHIpe3JldHVybiBHKFkodCksZSxuLHIpfWZ1bmN0aW9uIHYoZSx0LG4scil7cmV0dXJuIFQoZSx0LG4scil9ZnVuY3Rpb24gayhlLHQsbixyKXtyZXR1cm4gRyh6KHQpLGUsbixyKX1mdW5jdGlvbiBMKGUsdCxuLHIpe3JldHVybiBHKFYodCxlLmxlbmd0aC1uKSxlLG4scil9ZnVuY3Rpb24gQShlLHQsbil7cmV0dXJuIDA9PT10JiZuPT09ZS5sZW5ndGg/JC5mcm9tQnl0ZUFycmF5KGUpOiQuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHQsbikpfWZ1bmN0aW9uIHgoZSx0LG4pe249byhlLmxlbmd0aCxuKTtmb3IodmFyIHI9W10sYT10O2E8bjspe3ZhciBkPWVbYV0scz1udWxsLGw9MjM5PGQ/NDoyMjM8ZD8zOjE5MTxkPzI6MTtpZihhK2w8PW4pe3ZhciBjLHUscCxmOzE9PT1sPzEyOD5kJiYocz1kKToyPT09bD8oYz1lW2ErMV0sMTI4PT0oMTkyJmMpJiYoZj0oMzEmZCk8PDZ8NjMmYywxMjc8ZiYmKHM9ZikpKTozPT09bD8oYz1lW2ErMV0sdT1lW2ErMl0sMTI4PT0oMTkyJmMpJiYxMjg9PSgxOTImdSkmJihmPSgxNSZkKTw8MTJ8KDYzJmMpPDw2fDYzJnUsMjA0NzxmJiYoNTUyOTY+Znx8NTczNDM8ZikmJihzPWYpKSk6ND09PWw/KGM9ZVthKzFdLHU9ZVthKzJdLHA9ZVthKzNdLDEyOD09KDE5MiZjKSYmMTI4PT0oMTkyJnUpJiYxMjg9PSgxOTImcCkmJihmPSgxNSZkKTw8MTh8KDYzJmMpPDwxMnwoNjMmdSk8PDZ8NjMmcCw2NTUzNTxmJiYxMTE0MTEyPmYmJihzPWYpKSk6dm9pZCAwfW51bGw9PT1zPyhzPTY1NTMzLGw9MSk6NjU1MzU8cyYmKHMtPTY1NTM2LHIucHVzaCg1NTI5NnwxMDIzJnM+Pj4xMCkscz01NjMyMHwxMDIzJnMpLHIucHVzaChzKSxhKz1sfXJldHVybiBOKHIpfWZ1bmN0aW9uIE4oZSl7dmFyIG49ZS5sZW5ndGg7aWYobjw9NDA5NilyZXR1cm4gdC5hcHBseShTdHJpbmcsZSk7Zm9yKHZhciByPVwiXCIsYT0wO2E8bjspcis9dC5hcHBseShTdHJpbmcsZS5zbGljZShhLGErPTQwOTYpKTtyZXR1cm4gcn1mdW5jdGlvbiBEKGUsbixyKXt2YXIgYT1cIlwiO3I9byhlLmxlbmd0aCxyKTtmb3IodmFyIGQ9bjtkPHI7KytkKWErPXQoMTI3JmVbZF0pO3JldHVybiBhfWZ1bmN0aW9uIEkoZSxuLHIpe3ZhciBhPVwiXCI7cj1vKGUubGVuZ3RoLHIpO2Zvcih2YXIgZD1uO2Q8cjsrK2QpYSs9dChlW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiBQKGUsdCxuKXt2YXIgcj1lLmxlbmd0aDsoIXR8fDA+dCkmJih0PTApLCghbnx8MD5ufHxuPnIpJiYobj1yKTtmb3IodmFyIGE9XCJcIixvPXQ7bzxuOysrbylhKz1XKGVbb10pO3JldHVybiBhfWZ1bmN0aW9uIE0oZSxuLHIpe2Zvcih2YXIgYT1lLnNsaWNlKG4sciksbz1cIlwiLGQ9MDtkPGEubGVuZ3RoO2QrPTIpbys9dChhW2RdKzI1NiphW2QrMV0pO3JldHVybiBvfWZ1bmN0aW9uIE8oZSx0LG4pe2lmKDAhPWUlMXx8MD5lKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrdD5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1mdW5jdGlvbiBGKGUsdCxuLHIsYSxvKXtpZighcy5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcImJ1ZmZlclxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZVwiKTtpZih0PmF8fHQ8byl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlxcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihuK3I+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gQihlLHQsbixyKXtpZihuK3I+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoMD5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIFUoZSx0LG4scixhKXtyZXR1cm4gdD0rdCxuPj4+PTAsYXx8QihlLHQsbiw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMiksSi53cml0ZShlLHQsbixyLDIzLDQpLG4rNH1mdW5jdGlvbiBqKGUsdCxuLHIsYSl7cmV0dXJuIHQ9K3Qsbj4+Pj0wLGF8fEIoZSx0LG4sOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiksSi53cml0ZShlLHQsbixyLDUyLDgpLG4rOH1mdW5jdGlvbiBxKGUpe2lmKGU9ZS5zcGxpdChcIj1cIilbMF0sZT1lLnRyaW0oKS5yZXBsYWNlKFEsXCJcIiksMj5lLmxlbmd0aClyZXR1cm5cIlwiO2Zvcig7MCE9ZS5sZW5ndGglNDspZSs9XCI9XCI7cmV0dXJuIGV9ZnVuY3Rpb24gVyhlKXtyZXR1cm4gMTY+ZT9cIjBcIitlLnRvU3RyaW5nKDE2KTplLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiBIKGUsdCl7dD10fHwxLzA7Zm9yKHZhciBuLHI9ZS5sZW5ndGgsYT1udWxsLG89W10sZD0wO2Q8cjsrK2Qpe2lmKG49ZS5jaGFyQ29kZUF0KGQpLDU1Mjk1PG4mJjU3MzQ0Pm4pe2lmKCFhKXtpZig1NjMxOTxuKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihkKzE9PT1yKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9YT1uO2NvbnRpbnVlfWlmKDU2MzIwPm4pey0xPCh0LT0zKSYmby5wdXNoKDIzOSwxOTEsMTg5KSxhPW47Y29udGludWV9bj0oYS01NTI5Njw8MTB8bi01NjMyMCkrNjU1MzZ9ZWxzZSBhJiYtMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7aWYoYT1udWxsLDEyOD5uKXtpZigwPih0LT0xKSlicmVhaztvLnB1c2gobil9ZWxzZSBpZigyMDQ4Pm4pe2lmKDA+KHQtPTIpKWJyZWFrO28ucHVzaCgxOTJ8bj4+NiwxMjh8NjMmbil9ZWxzZSBpZig2NTUzNj5uKXtpZigwPih0LT0zKSlicmVhaztvLnB1c2goMjI0fG4+PjEyLDEyOHw2MyZuPj42LDEyOHw2MyZuKX1lbHNlIGlmKDExMTQxMTI+bil7aWYoMD4odC09NCkpYnJlYWs7by5wdXNoKDI0MHxuPj4xOCwxMjh8NjMmbj4+MTIsMTI4fDYzJm4+PjYsMTI4fDYzJm4pfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfXJldHVybiBvfWZ1bmN0aW9uIFkoZSl7Zm9yKHZhciB0PVtdLG49MDtuPGUubGVuZ3RoOysrbil0LnB1c2goMjU1JmUuY2hhckNvZGVBdChuKSk7cmV0dXJuIHR9ZnVuY3Rpb24gVihlLHQpe2Zvcih2YXIgbixyLGEsbz1bXSxkPTA7ZDxlLmxlbmd0aCYmISgwPih0LT0yKSk7KytkKW49ZS5jaGFyQ29kZUF0KGQpLHI9bj4+OCxhPW4lMjU2LG8ucHVzaChhKSxvLnB1c2gocik7cmV0dXJuIG99ZnVuY3Rpb24geihlKXtyZXR1cm4gJC50b0J5dGVBcnJheShxKGUpKX1mdW5jdGlvbiBHKGUsdCxuLHIpe2Zvcih2YXIgYT0wO2E8ciYmIShhK24+PXQubGVuZ3RofHxhPj1lLmxlbmd0aCk7KythKXRbYStuXT1lW2FdO3JldHVybiBhfWZ1bmN0aW9uIEsoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIHR8fG51bGwhPWUmJm51bGwhPWUuY29uc3RydWN0b3ImJm51bGwhPWUuY29uc3RydWN0b3IubmFtZSYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09dC5uYW1lfWZ1bmN0aW9uIFgoZSl7cmV0dXJuIGUhPT1lfXZhciAkPWUoXCJiYXNlNjQtanNcIiksSj1lKFwiaWVlZTc1NFwiKTtuLkJ1ZmZlcj1zLG4uU2xvd0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4rZSE9ZSYmKGU9MCkscy5hbGxvYygrZSl9LG4uSU5TUEVDVF9NQVhfQllURVM9NTA7bi5rTWF4TGVuZ3RoPTIxNDc0ODM2NDcscy5UWVBFRF9BUlJBWV9TVVBQT1JUPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiBlLl9fcHJvdG9fXz17X19wcm90b19fOlVpbnQ4QXJyYXkucHJvdG90eXBlLGZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19LDQyPT09ZS5mb28oKX1jYXRjaCh0KXtyZXR1cm4hMX19KCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUfHxcInVuZGVmaW5lZFwiPT10eXBlb2YgY29uc29sZXx8XCJmdW5jdGlvblwiIT10eXBlb2YgY29uc29sZS5lcnJvcnx8Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5pc0J1ZmZlcih0aGlzKT90aGlzLmJ1ZmZlcjp2b2lkIDB9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuaXNCdWZmZXIodGhpcyk/dGhpcy5ieXRlT2Zmc2V0OnZvaWQgMH19KSxcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZudWxsIT1TeW1ib2wuc3BlY2llcyYmc1tTeW1ib2wuc3BlY2llc109PT1zJiZPYmplY3QuZGVmaW5lUHJvcGVydHkocyxTeW1ib2wuc3BlY2llcyx7dmFsdWU6bnVsbCxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMX0pLHMucG9vbFNpemU9ODE5MixzLmZyb209ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBsKGUsdCxuKX0scy5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHMuX19wcm90b19fPVVpbnQ4QXJyYXkscy5hbGxvYz1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHUoZSx0LG4pfSxzLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBwKGUpfSxzLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gcChlKX0scy5pc0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmITA9PT1lLl9pc0J1ZmZlciYmZSE9PXMucHJvdG90eXBlfSxzLmNvbXBhcmU9ZnVuY3Rpb24oZSx0KXtpZihLKGUsVWludDhBcnJheSkmJihlPXMuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCkpLEsodCxVaW50OEFycmF5KSYmKHQ9cy5mcm9tKHQsdC5vZmZzZXQsdC5ieXRlTGVuZ3RoKSksIXMuaXNCdWZmZXIoZSl8fCFzLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImJ1ZjFcXFwiLCBcXFwiYnVmMlxcXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcIik7aWYoZT09PXQpcmV0dXJuIDA7Zm9yKHZhciBuPWUubGVuZ3RoLHI9dC5sZW5ndGgsZD0wLGw9byhuLHIpO2Q8bDsrK2QpaWYoZVtkXSE9PXRbZF0pe249ZVtkXSxyPXRbZF07YnJlYWt9cmV0dXJuIG48cj8tMTpyPG4/MTowfSxzLmlzRW5jb2Rpbmc9ZnVuY3Rpb24oZSl7c3dpdGNoKChlK1wiXCIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMTt9fSxzLmNvbmNhdD1mdW5jdGlvbihlLHQpe2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzXCIpO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gcy5hbGxvYygwKTt2YXIgbjtpZih0PT09dm9pZCAwKWZvcih0PTAsbj0wO248ZS5sZW5ndGg7KytuKXQrPWVbbl0ubGVuZ3RoO3ZhciByPXMuYWxsb2NVbnNhZmUodCksYT0wO2ZvcihuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBvPWVbbl07aWYoSyhvLFVpbnQ4QXJyYXkpJiYobz1zLmZyb20obykpLCFzLmlzQnVmZmVyKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzXCIpO28uY29weShyLGEpLGErPW8ubGVuZ3RofXJldHVybiByfSxzLmJ5dGVMZW5ndGg9YixzLnByb3RvdHlwZS5faXNCdWZmZXI9ITAscy5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoMCE9ZSUyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTIpQyh0aGlzLHQsdCsxKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoMCE9ZSU0KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTQpQyh0aGlzLHQsdCszKSxDKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKDAhPWUlOCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz04KUModGhpcyx0LHQrNyksQyh0aGlzLHQrMSx0KzYpLEModGhpcyx0KzIsdCs1KSxDKHRoaXMsdCszLHQrNCk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT1lP1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/eCh0aGlzLDAsZSk6eS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHMucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPXMucHJvdG90eXBlLnRvU3RyaW5nLHMucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtpZighcy5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PWV8fDA9PT1zLmNvbXBhcmUodGhpcyxlKX0scy5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBlPVwiXCIsdD1uLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiBlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKSx0aGlzLmxlbmd0aD50JiYoZSs9XCIgLi4uIFwiKSxcIjxCdWZmZXIgXCIrZStcIj5cIn0scy5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihlLHQsbixyLGEpe2lmKEsoZSxVaW50OEFycmF5KSYmKGU9cy5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKSksIXMuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwidGFyZ2V0XFxcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKTtpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj1lP2UubGVuZ3RoOjApLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PWEmJihhPXRoaXMubGVuZ3RoKSwwPnR8fG4+ZS5sZW5ndGh8fDA+cnx8YT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihyPj1hJiZ0Pj1uKXJldHVybiAwO2lmKHI+PWEpcmV0dXJuLTE7aWYodD49bilyZXR1cm4gMTtpZih0Pj4+PTAsbj4+Pj0wLHI+Pj49MCxhPj4+PTAsdGhpcz09PWUpcmV0dXJuIDA7Zm9yKHZhciBkPWEtcixsPW4tdCxjPW8oZCxsKSx1PXRoaXMuc2xpY2UocixhKSxwPWUuc2xpY2UodCxuKSxmPTA7ZjxjOysrZilpZih1W2ZdIT09cFtmXSl7ZD11W2ZdLGw9cFtmXTticmVha31yZXR1cm4gZDxsPy0xOmw8ZD8xOjB9LHMucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihlLHQsbil9LHMucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKHRoaXMsZSx0LG4sITApfSxzLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFIodGhpcyxlLHQsbiwhMSl9LHMucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKHZvaWQgMD09PXQpcj1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKHZvaWQgMD09PW4mJlwic3RyaW5nXCI9PXR5cGVvZiB0KXI9dCxuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKGlzRmluaXRlKHQpKXQ+Pj49MCxpc0Zpbml0ZShuKT8obj4+Pj0wLHZvaWQgMD09PXImJihyPVwidXRmOFwiKSk6KHI9bixuPXZvaWQgMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTt2YXIgYT10aGlzLmxlbmd0aC10O2lmKCh2b2lkIDA9PT1ufHxuPmEpJiYobj1hKSwwPGUubGVuZ3RoJiYoMD5ufHwwPnQpfHx0PnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7cnx8KHI9XCJ1dGY4XCIpO2Zvcih2YXIgbz0hMTs7KXN3aXRjaChyKXtjYXNlXCJoZXhcIjpyZXR1cm4gdyh0aGlzLGUsdCxuKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gUyh0aGlzLGUsdCxuKTtjYXNlXCJhc2NpaVwiOnJldHVybiBUKHRoaXMsZSx0LG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB2KHRoaXMsZSx0LG4pO2Nhc2VcImJhc2U2NFwiOnJldHVybiBrKHRoaXMsZSx0LG4pO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBMKHRoaXMsZSx0LG4pO2RlZmF1bHQ6aWYobyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpLG89ITA7fX0scy5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O3MucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5sZW5ndGg7ZT1+fmUsdD10PT09dm9pZCAwP246fn50LDA+ZT8oZSs9biwwPmUmJihlPTApKTplPm4mJihlPW4pLDA+dD8odCs9biwwPnQmJih0PTApKTp0Pm4mJih0PW4pLHQ8ZSYmKHQ9ZSk7dmFyIHI9dGhpcy5zdWJhcnJheShlLHQpO3JldHVybiByLl9fcHJvdG9fXz1zLnByb3RvdHlwZSxyfSxzLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIHI9dGhpc1tlXSxhPTEsbz0wOysrbzx0JiYoYSo9MjU2KTspcis9dGhpc1tlK29dKmE7cmV0dXJuIHJ9LHMucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24oZSx0LG4pe2U+Pj49MCx0Pj4+PTAsbnx8TyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW2UrLS10XSxhPTE7MDx0JiYoYSo9MjU2KTspcis9dGhpc1tlKy0tdF0qYTtyZXR1cm4gcn0scy5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsMSx0aGlzLmxlbmd0aCksdGhpc1tlXX0scy5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh9LHMucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDIsdGhpcy5sZW5ndGgpLHRoaXNbZV08PDh8dGhpc1tlKzFdfSxzLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSwodGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrMTY3NzcyMTYqdGhpc1tlKzNdfSxzLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW2VdKyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfSxzLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24oZSx0LG4pe2U+Pj49MCx0Pj4+PTAsbnx8TyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzW2VdLG89MSxkPTA7KytkPHQmJihvKj0yNTYpOylhKz10aGlzW2UrZF0qbztyZXR1cm4gbyo9MTI4LGE+PW8mJihhLT1yKDIsOCp0KSksYX0scy5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIGE9dCxvPTEsZD10aGlzW2UrLS1hXTswPGEmJihvKj0yNTYpOylkKz10aGlzW2UrLS1hXSpvO3JldHVybiBvKj0xMjgsZD49byYmKGQtPXIoMiw4KnQpKSxkfSxzLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW2VdPy0xKigyNTUtdGhpc1tlXSsxKTp0aGlzW2VdfSxzLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihlLHQpe2U+Pj49MCx0fHxPKGUsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LHMucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGUsdCl7ZT4+Pj0wLHR8fE8oZSwyLHRoaXMubGVuZ3RoKTt2YXIgbj10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gMzI3Njgmbj80Mjk0OTAxNzYwfG46bn0scy5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSx0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9LHMucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfSxzLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDQsdGhpcy5sZW5ndGgpLEoucmVhZCh0aGlzLGUsITAsMjMsNCl9LHMucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMSwyMyw0KX0scy5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsOCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMCw1Miw4KX0scy5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsOCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMSw1Miw4KX0scy5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsbj4+Pj0wLCFhKXt2YXIgbz1yKDIsOCpuKS0xO0YodGhpcyxlLHQsbixvLDApfXZhciBkPTEscz0wO2Zvcih0aGlzW3RdPTI1NSZlOysrczxuJiYoZCo9MjU2KTspdGhpc1t0K3NdPTI1NSZlL2Q7cmV0dXJuIHQrbn0scy5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsbj4+Pj0wLCFhKXt2YXIgbz1yKDIsOCpuKS0xO0YodGhpcyxlLHQsbixvLDApfXZhciBkPW4tMSxzPTE7Zm9yKHRoaXNbdCtkXT0yNTUmZTswPD0tLWQmJihzKj0yNTYpOyl0aGlzW3QrZF09MjU1JmUvcztyZXR1cm4gdCtufSxzLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwxLDI1NSwwKSx0aGlzW3RdPTI1NSZlLHQrMX0scy5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMiw2NTUzNSwwKSx0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0KzJ9LHMucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDIsNjU1MzUsMCksdGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUsdCsyfSxzLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCw0LDQyOTQ5NjcyOTUsMCksdGhpc1t0KzNdPWU+Pj4yNCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCsxXT1lPj4+OCx0aGlzW3RdPTI1NSZlLHQrNH0scy5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbdF09ZT4+PjI0LHRoaXNbdCsxXT1lPj4+MTYsdGhpc1t0KzJdPWU+Pj44LHRoaXNbdCszXT0yNTUmZSx0KzR9LHMucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsIWEpe3ZhciBvPXIoMiw4Km4tMSk7Rih0aGlzLGUsdCxuLG8tMSwtbyl9dmFyIGQ9MCxzPTEsbD0wO2Zvcih0aGlzW3RdPTI1NSZlOysrZDxuJiYocyo9MjU2KTspMD5lJiYwPT09bCYmMCE9PXRoaXNbdCtkLTFdJiYobD0xKSx0aGlzW3QrZF09MjU1JihlL3M+PjApLWw7cmV0dXJuIHQrbn0scy5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbihlLHQsbixhKXtpZihlPStlLHQ+Pj49MCwhYSl7dmFyIG89cigyLDgqbi0xKTtGKHRoaXMsZSx0LG4sby0xLC1vKX12YXIgZD1uLTEscz0xLGw9MDtmb3IodGhpc1t0K2RdPTI1NSZlOzA8PS0tZCYmKHMqPTI1Nik7KTA+ZSYmMD09PWwmJjAhPT10aGlzW3QrZCsxXSYmKGw9MSksdGhpc1t0K2RdPTI1NSYoZS9zPj4wKS1sO3JldHVybiB0K259LHMucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMSwxMjcsLTEyOCksMD5lJiYoZT0yNTUrZSsxKSx0aGlzW3RdPTI1NSZlLHQrMX0scy5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwyLDMyNzY3LC0zMjc2OCksdGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgsdCsyfSxzLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPWU+Pj44LHRoaXNbdCsxXT0yNTUmZSx0KzJ9LHMucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCszXT1lPj4+MjQsdCs0fSxzLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksMD5lJiYoZT00Mjk0OTY3Mjk1K2UrMSksdGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlLHQrNH0scy5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVSh0aGlzLGUsdCwhMCxuKX0scy5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVSh0aGlzLGUsdCwhMSxuKX0scy5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGoodGhpcyxlLHQsITAsbil9LHMucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBqKHRoaXMsZSx0LCExLG4pfSxzLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGUsdCxuLHIpe2lmKCFzLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYobnx8KG49MCkscnx8MD09PXJ8fChyPXRoaXMubGVuZ3RoKSx0Pj1lLmxlbmd0aCYmKHQ9ZS5sZW5ndGgpLHR8fCh0PTApLDA8ciYmcjxuJiYocj1uKSxyPT09bilyZXR1cm4gMDtpZigwPT09ZS5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZigwPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKDA+bnx8bj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoMD5yKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7cj50aGlzLmxlbmd0aCYmKHI9dGhpcy5sZW5ndGgpLGUubGVuZ3RoLXQ8ci1uJiYocj1lLmxlbmd0aC10K24pO3ZhciBhPXItbjtpZih0aGlzPT09ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbil0aGlzLmNvcHlXaXRoaW4odCxuLHIpO2Vsc2UgaWYodGhpcz09PWUmJm48dCYmdDxyKWZvcih2YXIgbz1hLTE7MDw9bzstLW8pZVtvK3RdPXRoaXNbbytuXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheShuLHIpLHQpO3JldHVybiBhfSxzLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdD8ocj10LHQ9MCxuPXRoaXMubGVuZ3RoKTpcInN0cmluZ1wiPT10eXBlb2YgbiYmKHI9bixuPXRoaXMubGVuZ3RoKSx2b2lkIDAhPT1yJiZcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgciYmIXMuaXNFbmNvZGluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7aWYoMT09PWUubGVuZ3RoKXt2YXIgYT1lLmNoYXJDb2RlQXQoMCk7KFwidXRmOFwiPT09ciYmMTI4PmF8fFwibGF0aW4xXCI9PT1yKSYmKGU9YSl9fWVsc2VcIm51bWJlclwiPT10eXBlb2YgZSYmKGUmPTI1NSk7aWYoMD50fHx0aGlzLmxlbmd0aDx0fHx0aGlzLmxlbmd0aDxuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKG48PXQpcmV0dXJuIHRoaXM7dD4+Pj0wLG49bj09PXZvaWQgMD90aGlzLmxlbmd0aDpuPj4+MCxlfHwoZT0wKTt2YXIgbztpZihcIm51bWJlclwiPT10eXBlb2YgZSlmb3Iobz10O288bjsrK28pdGhpc1tvXT1lO2Vsc2V7dmFyIGQ9cy5pc0J1ZmZlcihlKT9lOnMuZnJvbShlLHIpLGw9ZC5sZW5ndGg7aWYoMD09PWwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIrZStcIlxcXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXFxcInZhbHVlXFxcIlwiKTtmb3Iobz0wO288bi10Oysrbyl0aGlzW28rdF09ZFtvJWxdfXJldHVybiB0aGlzfTt2YXIgUT0vW14rLzAtOUEtWmEtei1fXS9nfSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcImJhc2U2NC1qc1wiOjEsYnVmZmVyOjMsaWVlZTc1NDo5fV0sNDpbZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihhKXsoZnVuY3Rpb24oKXtmdW5jdGlvbiByKCl7bGV0IGU7dHJ5e2U9bi5zdG9yYWdlLmdldEl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaChlKXt9cmV0dXJuIWUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhJiZcImVudlwiaW4gYSYmKGU9YS5lbnYuREVCVUcpLGV9bi5mb3JtYXRBcmdzPWZ1bmN0aW9uKGUpe2lmKGVbMF09KHRoaXMudXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodGhpcy51c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrZVswXSsodGhpcy51c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrdC5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZiksIXRoaXMudXNlQ29sb3JzKXJldHVybjtjb25zdCBuPVwiY29sb3I6IFwiK3RoaXMuY29sb3I7ZS5zcGxpY2UoMSwwLG4sXCJjb2xvcjogaW5oZXJpdFwiKTtsZXQgcj0wLGE9MDtlWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZyxlPT57XCIlJVwiPT09ZXx8KHIrKyxcIiVjXCI9PT1lJiYoYT1yKSl9KSxlLnNwbGljZShhLDAsbil9LG4uc2F2ZT1mdW5jdGlvbihlKXt0cnl7ZT9uLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsZSk6bi5zdG9yYWdlLnJlbW92ZUl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaChlKXt9fSxuLmxvYWQ9cixuLnVzZUNvbG9ycz1mdW5jdGlvbigpe3JldHVybiEhKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wcm9jZXNzJiYoXCJyZW5kZXJlclwiPT09d2luZG93LnByb2Nlc3MudHlwZXx8d2luZG93LnByb2Nlc3MuX19ud2pzKSl8fCEoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmZpcmVidWd8fHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiYmd2luZG93LmNvbnNvbGUudGFibGUpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmMzE8PXBhcnNlSW50KFJlZ0V4cC4kMSwxMCl8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSl9LG4uc3RvcmFnZT1mdW5jdGlvbigpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlfWNhdGNoKGUpe319KCksbi5kZXN0cm95PSgoKT0+e2xldCBlPSExO3JldHVybigpPT57ZXx8KGU9ITAsY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKSl9fSkoKSxuLmNvbG9ycz1bXCIjMDAwMENDXCIsXCIjMDAwMEZGXCIsXCIjMDAzM0NDXCIsXCIjMDAzM0ZGXCIsXCIjMDA2NkNDXCIsXCIjMDA2NkZGXCIsXCIjMDA5OUNDXCIsXCIjMDA5OUZGXCIsXCIjMDBDQzAwXCIsXCIjMDBDQzMzXCIsXCIjMDBDQzY2XCIsXCIjMDBDQzk5XCIsXCIjMDBDQ0NDXCIsXCIjMDBDQ0ZGXCIsXCIjMzMwMENDXCIsXCIjMzMwMEZGXCIsXCIjMzMzM0NDXCIsXCIjMzMzM0ZGXCIsXCIjMzM2NkNDXCIsXCIjMzM2NkZGXCIsXCIjMzM5OUNDXCIsXCIjMzM5OUZGXCIsXCIjMzNDQzAwXCIsXCIjMzNDQzMzXCIsXCIjMzNDQzY2XCIsXCIjMzNDQzk5XCIsXCIjMzNDQ0NDXCIsXCIjMzNDQ0ZGXCIsXCIjNjYwMENDXCIsXCIjNjYwMEZGXCIsXCIjNjYzM0NDXCIsXCIjNjYzM0ZGXCIsXCIjNjZDQzAwXCIsXCIjNjZDQzMzXCIsXCIjOTkwMENDXCIsXCIjOTkwMEZGXCIsXCIjOTkzM0NDXCIsXCIjOTkzM0ZGXCIsXCIjOTlDQzAwXCIsXCIjOTlDQzMzXCIsXCIjQ0MwMDAwXCIsXCIjQ0MwMDMzXCIsXCIjQ0MwMDY2XCIsXCIjQ0MwMDk5XCIsXCIjQ0MwMENDXCIsXCIjQ0MwMEZGXCIsXCIjQ0MzMzAwXCIsXCIjQ0MzMzMzXCIsXCIjQ0MzMzY2XCIsXCIjQ0MzMzk5XCIsXCIjQ0MzM0NDXCIsXCIjQ0MzM0ZGXCIsXCIjQ0M2NjAwXCIsXCIjQ0M2NjMzXCIsXCIjQ0M5OTAwXCIsXCIjQ0M5OTMzXCIsXCIjQ0NDQzAwXCIsXCIjQ0NDQzMzXCIsXCIjRkYwMDAwXCIsXCIjRkYwMDMzXCIsXCIjRkYwMDY2XCIsXCIjRkYwMDk5XCIsXCIjRkYwMENDXCIsXCIjRkYwMEZGXCIsXCIjRkYzMzAwXCIsXCIjRkYzMzMzXCIsXCIjRkYzMzY2XCIsXCIjRkYzMzk5XCIsXCIjRkYzM0NDXCIsXCIjRkYzM0ZGXCIsXCIjRkY2NjAwXCIsXCIjRkY2NjMzXCIsXCIjRkY5OTAwXCIsXCIjRkY5OTMzXCIsXCIjRkZDQzAwXCIsXCIjRkZDQzMzXCJdLG4ubG9nPWNvbnNvbGUuZGVidWd8fGNvbnNvbGUubG9nfHwoKCk9Pnt9KSx0LmV4cG9ydHM9ZShcIi4vY29tbW9uXCIpKG4pO2NvbnN0e2Zvcm1hdHRlcnM6b309dC5leHBvcnRzO28uaj1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpfWNhdGNoKGUpe3JldHVyblwiW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06IFwiK2UubWVzc2FnZX19fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIikpfSx7XCIuL2NvbW1vblwiOjUsX3Byb2Nlc3M6MTJ9XSw1OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiByKGUpe2Z1bmN0aW9uIHQoLi4uZSl7aWYoIXQuZW5hYmxlZClyZXR1cm47Y29uc3QgYT10LG89K25ldyBEYXRlLGk9by0obnx8byk7YS5kaWZmPWksYS5wcmV2PW4sYS5jdXJyPW8sbj1vLGVbMF09ci5jb2VyY2UoZVswXSksXCJzdHJpbmdcIiE9dHlwZW9mIGVbMF0mJmUudW5zaGlmdChcIiVPXCIpO2xldCBkPTA7ZVswXT1lWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCh0LG4pPT57aWYoXCIlJVwiPT09dClyZXR1cm5cIiVcIjtkKys7Y29uc3Qgbz1yLmZvcm1hdHRlcnNbbl07aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7Y29uc3Qgbj1lW2RdO3Q9by5jYWxsKGEsbiksZS5zcGxpY2UoZCwxKSxkLS19cmV0dXJuIHR9KSxyLmZvcm1hdEFyZ3MuY2FsbChhLGUpO2NvbnN0IHM9YS5sb2d8fHIubG9nO3MuYXBwbHkoYSxlKX1sZXQgbixvPW51bGw7cmV0dXJuIHQubmFtZXNwYWNlPWUsdC51c2VDb2xvcnM9ci51c2VDb2xvcnMoKSx0LmNvbG9yPXIuc2VsZWN0Q29sb3IoZSksdC5leHRlbmQ9YSx0LmRlc3Ryb3k9ci5kZXN0cm95LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZW5hYmxlZFwiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6KCk9Pm51bGw9PT1vP3IuZW5hYmxlZChlKTpvLHNldDplPT57bz1lfX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuaW5pdCYmci5pbml0KHQpLHR9ZnVuY3Rpb24gYShlLHQpe2NvbnN0IG49cih0aGlzLm5hbWVzcGFjZSsoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQ/XCI6XCI6dCkrZSk7cmV0dXJuIG4ubG9nPXRoaXMubG9nLG59ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZS50b1N0cmluZygpLnN1YnN0cmluZygyLGUudG9TdHJpbmcoKS5sZW5ndGgtMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sXCIqXCIpfXJldHVybiByLmRlYnVnPXIsci5kZWZhdWx0PXIsci5jb2VyY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvcj9lLnN0YWNrfHxlLm1lc3NhZ2U6ZX0sci5kaXNhYmxlPWZ1bmN0aW9uKCl7Y29uc3QgZT1bLi4uci5uYW1lcy5tYXAobyksLi4uci5za2lwcy5tYXAobykubWFwKGU9PlwiLVwiK2UpXS5qb2luKFwiLFwiKTtyZXR1cm4gci5lbmFibGUoXCJcIiksZX0sci5lbmFibGU9ZnVuY3Rpb24oZSl7ci5zYXZlKGUpLHIubmFtZXM9W10sci5za2lwcz1bXTtsZXQgdDtjb25zdCBuPShcInN0cmluZ1wiPT10eXBlb2YgZT9lOlwiXCIpLnNwbGl0KC9bXFxzLF0rLyksYT1uLmxlbmd0aDtmb3IodD0wO3Q8YTt0Kyspblt0XSYmKGU9blt0XS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKSxcIi1cIj09PWVbMF0/ci5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrZS5zdWJzdHIoMSkrXCIkXCIpKTpyLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIitlK1wiJFwiKSkpfSxyLmVuYWJsZWQ9ZnVuY3Rpb24oZSl7aWYoXCIqXCI9PT1lW2UubGVuZ3RoLTFdKXJldHVybiEwO2xldCB0LG47Zm9yKHQ9MCxuPXIuc2tpcHMubGVuZ3RoO3Q8bjt0KyspaWYoci5za2lwc1t0XS50ZXN0KGUpKXJldHVybiExO2Zvcih0PTAsbj1yLm5hbWVzLmxlbmd0aDt0PG47dCsrKWlmKHIubmFtZXNbdF0udGVzdChlKSlyZXR1cm4hMDtyZXR1cm4hMX0sci5odW1hbml6ZT1lKFwibXNcIiksci5kZXN0cm95PWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKX0sT2JqZWN0LmtleXModCkuZm9yRWFjaChlPT57cltlXT10W2VdfSksci5uYW1lcz1bXSxyLnNraXBzPVtdLHIuZm9ybWF0dGVycz17fSxyLnNlbGVjdENvbG9yPWZ1bmN0aW9uKGUpe2xldCB0PTA7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspdD0odDw8NSktdCtlLmNoYXJDb2RlQXQobiksdHw9MDtyZXR1cm4gci5jb2xvcnNbbih0KSVyLmNvbG9ycy5sZW5ndGhdfSxyLmVuYWJsZShyLmxvYWQoKSkscn19LHttczoxMX1dLDY6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXtmb3IoY29uc3QgbiBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se3ZhbHVlOnRbbl0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KTtyZXR1cm4gZX10LmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe2lmKCFlfHxcInN0cmluZ1wiPT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGxlYXNlIHBhc3MgYW4gRXJyb3IgdG8gZXJyLWNvZGVcIik7cnx8KHI9e30pLFwib2JqZWN0XCI9PXR5cGVvZiB0JiYocj10LHQ9XCJcIiksdCYmKHIuY29kZT10KTt0cnl7cmV0dXJuIG4oZSxyKX1jYXRjaCh0KXtyLm1lc3NhZ2U9ZS5tZXNzYWdlLHIuc3RhY2s9ZS5zdGFjaztjb25zdCBhPWZ1bmN0aW9uKCl7fTthLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSk7Y29uc3Qgbz1uKG5ldyBhLHIpO3JldHVybiBvfX19LHt9XSw3OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe2NvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGUpfWZ1bmN0aW9uIHIoKXtyLmluaXQuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gdm9pZCAwPT09ZS5fbWF4TGlzdGVuZXJzP3IuZGVmYXVsdE1heExpc3RlbmVyczplLl9tYXhMaXN0ZW5lcnN9ZnVuY3Rpb24gaShlLHQscixpKXt2YXIgZCxzLGw7aWYoYShyKSxzPWUuX2V2ZW50cyx2b2lkIDA9PT1zPyhzPWUuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLGUuX2V2ZW50c0NvdW50PTApOih2b2lkIDAhPT1zLm5ld0xpc3RlbmVyJiYoZS5lbWl0KFwibmV3TGlzdGVuZXJcIix0LHIubGlzdGVuZXI/ci5saXN0ZW5lcjpyKSxzPWUuX2V2ZW50cyksbD1zW3RdKSx2b2lkIDA9PT1sKWw9c1t0XT1yLCsrZS5fZXZlbnRzQ291bnQ7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2w9c1t0XT1pP1tyLGxdOltsLHJdOmk/bC51bnNoaWZ0KHIpOmwucHVzaChyKSxkPW8oZSksMDxkJiZsLmxlbmd0aD5kJiYhbC53YXJuZWQpe2wud2FybmVkPSEwO3ZhciBjPW5ldyBFcnJvcihcIlBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gXCIrbC5sZW5ndGgrXCIgXCIrKHQrXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKSk7Yy5uYW1lPVwiTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nXCIsYy5lbWl0dGVyPWUsYy50eXBlPXQsYy5jb3VudD1sLmxlbmd0aCxuKGMpfXJldHVybiBlfWZ1bmN0aW9uIGQoKXtpZighdGhpcy5maXJlZClyZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKSx0aGlzLmZpcmVkPSEwLDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk6dGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCxhcmd1bWVudHMpfWZ1bmN0aW9uIHMoZSx0LG4pe3ZhciByPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDplLHR5cGU6dCxsaXN0ZW5lcjpufSxhPWQuYmluZChyKTtyZXR1cm4gYS5saXN0ZW5lcj1uLHIud3JhcEZuPWEsYX1mdW5jdGlvbiBsKGUsdCxuKXt2YXIgcj1lLl9ldmVudHM7aWYocj09PXZvaWQgMClyZXR1cm5bXTt2YXIgYT1yW3RdO3JldHVybiB2b2lkIDA9PT1hP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIGE/bj9bYS5saXN0ZW5lcnx8YV06W2FdOm4/ZihhKTp1KGEsYS5sZW5ndGgpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9dGhpcy5fZXZlbnRzO2lmKHQhPT12b2lkIDApe3ZhciBuPXRbZV07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbilyZXR1cm4gMTtpZih2b2lkIDAhPT1uKXJldHVybiBuLmxlbmd0aH1yZXR1cm4gMH1mdW5jdGlvbiB1KGUsdCl7Zm9yKHZhciBuPUFycmF5KHQpLHI9MDtyPHQ7KytyKW5bcl09ZVtyXTtyZXR1cm4gbn1mdW5jdGlvbiBwKGUsdCl7Zm9yKDt0KzE8ZS5sZW5ndGg7dCsrKWVbdF09ZVt0KzFdO2UucG9wKCl9ZnVuY3Rpb24gZihlKXtmb3IodmFyIHQ9QXJyYXkoZS5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbil0W25dPWVbbl0ubGlzdGVuZXJ8fGVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gZyhlLHQsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbiYmXyhlLFwiZXJyb3JcIix0LG4pfWZ1bmN0aW9uIF8oZSx0LG4scil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbilyLm9uY2U/ZS5vbmNlKHQsbik6ZS5vbih0LG4pO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hZGRFdmVudExpc3RlbmVyKWUuYWRkRXZlbnRMaXN0ZW5lcih0LGZ1bmN0aW9uIGEobyl7ci5vbmNlJiZlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxhKSxuKG8pfSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJlbWl0dGVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgaCxtPVwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0P1JlZmxlY3Q6bnVsbCxiPW0mJlwiZnVuY3Rpb25cIj09dHlwZW9mIG0uYXBwbHk/bS5hcHBseTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGUsdCxuKX07aD1tJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBtLm93bktleXM/bS5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpKX06ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpfTt2YXIgeT1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKGUpe3JldHVybiBlIT09ZX07dC5leHBvcnRzPXIsdC5leHBvcnRzLm9uY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixyKXtmdW5jdGlvbiBhKG4pe2UucmVtb3ZlTGlzdGVuZXIodCxvKSxyKG4pfWZ1bmN0aW9uIG8oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJlbW92ZUxpc3RlbmVyJiZlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixhKSxuKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9XyhlLHQsbyx7b25jZTohMH0pLFwiZXJyb3JcIiE9PXQmJmcoZSxhLHtvbmNlOiEwfSl9KX0sci5FdmVudEVtaXR0ZXI9cixyLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQ9MCxyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMDt2YXIgQz0xMDtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQ30sc2V0OmZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHwwPmV8fHkoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgXFxcImRlZmF1bHRNYXhMaXN0ZW5lcnNcXFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkIFwiK2UrXCIuXCIpO0M9ZX19KSxyLmluaXQ9ZnVuY3Rpb24oKXsodGhpcy5fZXZlbnRzPT09dm9pZCAwfHx0aGlzLl9ldmVudHM9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykmJih0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LHIucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZXx8MD5lfHx5KGUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIFxcXCJuXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCBcIitlK1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPWUsdGhpc30sci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyl9LHIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXQucHVzaChhcmd1bWVudHNbbl0pO3ZhciByPVwiZXJyb3JcIj09PWUsYT10aGlzLl9ldmVudHM7aWYoYSE9PXZvaWQgMClyPXImJmEuZXJyb3I9PT12b2lkIDA7ZWxzZSBpZighcilyZXR1cm4hMTtpZihyKXt2YXIgbztpZigwPHQubGVuZ3RoJiYobz10WzBdKSxvIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgbzt2YXIgZD1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKG8/XCIgKFwiK28ubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgZC5jb250ZXh0PW8sZH12YXIgcz1hW2VdO2lmKHM9PT12b2lkIDApcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgcyliKHMsdGhpcyx0KTtlbHNlIGZvcih2YXIgbD1zLmxlbmd0aCxjPXUocyxsKSxuPTA7bjxsOysrbiliKGNbbl0sdGhpcyx0KTtyZXR1cm4hMH0sci5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaSh0aGlzLGUsdCwhMSl9LHIucHJvdG90eXBlLm9uPXIucHJvdG90eXBlLmFkZExpc3RlbmVyLHIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiBpKHRoaXMsZSx0LCEwKX0sci5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLHQpe3JldHVybiBhKHQpLHRoaXMub24oZSxzKHRoaXMsZSx0KSksdGhpc30sci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiBhKHQpLHRoaXMucHJlcGVuZExpc3RlbmVyKGUscyh0aGlzLGUsdCkpLHRoaXN9LHIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7dmFyIG4scixvLGQscztpZihhKHQpLHI9dGhpcy5fZXZlbnRzLHZvaWQgMD09PXIpcmV0dXJuIHRoaXM7aWYobj1yW2VdLHZvaWQgMD09PW4pcmV0dXJuIHRoaXM7aWYobj09PXR8fG4ubGlzdGVuZXI9PT10KTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSByW2VdLHIucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxuLmxpc3RlbmVyfHx0KSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXtmb3Iobz0tMSxkPW4ubGVuZ3RoLTE7MDw9ZDtkLS0paWYobltkXT09PXR8fG5bZF0ubGlzdGVuZXI9PT10KXtzPW5bZF0ubGlzdGVuZXIsbz1kO2JyZWFrfWlmKDA+bylyZXR1cm4gdGhpczswPT09bz9uLnNoaWZ0KCk6cChuLG8pLDE9PT1uLmxlbmd0aCYmKHJbZV09blswXSksdm9pZCAwIT09ci5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIixlLHN8fHQpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5vZmY9ci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0LG4scjtpZihuPXRoaXMuX2V2ZW50cyx2b2lkIDA9PT1uKXJldHVybiB0aGlzO2lmKHZvaWQgMD09PW4ucmVtb3ZlTGlzdGVuZXIpcmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKTp2b2lkIDAhPT1uW2VdJiYoMD09LS10aGlzLl9ldmVudHNDb3VudD90aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTpkZWxldGUgbltlXSksdGhpcztpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGEsbz1PYmplY3Qua2V5cyhuKTtmb3Iocj0wO3I8by5sZW5ndGg7KytyKWE9b1tyXSxcInJlbW92ZUxpc3RlbmVyXCIhPT1hJiZ0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhhKTtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKSx0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wLHRoaXN9aWYodD1uW2VdLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpdGhpcy5yZW1vdmVMaXN0ZW5lcihlLHQpO2Vsc2UgaWYodm9pZCAwIT09dClmb3Iocj10Lmxlbmd0aC0xOzA8PXI7ci0tKXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0W3JdKTtyZXR1cm4gdGhpc30sci5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMsZSwhMCl9LHIucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzLGUsITEpfSxyLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmxpc3RlbmVyQ291bnQ/ZS5saXN0ZW5lckNvdW50KHQpOmMuY2FsbChlLHQpfSxyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWMsci5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuX2V2ZW50c0NvdW50P2godGhpcy5fZXZlbnRzKTpbXX19LHt9XSw4OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBudWxsO3ZhciBlPXtSVENQZWVyQ29ubmVjdGlvbjpnbG9iYWxUaGlzLlJUQ1BlZXJDb25uZWN0aW9ufHxnbG9iYWxUaGlzLm1velJUQ1BlZXJDb25uZWN0aW9ufHxnbG9iYWxUaGlzLndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjpnbG9iYWxUaGlzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbnx8Z2xvYmFsVGhpcy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb258fGdsb2JhbFRoaXMud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFJUQ0ljZUNhbmRpZGF0ZTpnbG9iYWxUaGlzLlJUQ0ljZUNhbmRpZGF0ZXx8Z2xvYmFsVGhpcy5tb3pSVENJY2VDYW5kaWRhdGV8fGdsb2JhbFRoaXMud2Via2l0UlRDSWNlQ2FuZGlkYXRlfTtyZXR1cm4gZS5SVENQZWVyQ29ubmVjdGlvbj9lOm51bGx9fSx7fV0sOTpbZnVuY3Rpb24oZSxhLG8pey8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovby5yZWFkPWZ1bmN0aW9uKHQsbixhLG8sbCl7dmFyIGMsdSxwPTgqbC1vLTEsZj0oMTw8cCktMSxnPWY+PjEsXz0tNyxoPWE/bC0xOjAsYj1hPy0xOjEsZD10W24raF07Zm9yKGgrPWIsYz1kJigxPDwtXyktMSxkPj49LV8sXys9cDswPF87Yz0yNTYqYyt0W24raF0saCs9YixfLT04KTtmb3IodT1jJigxPDwtXyktMSxjPj49LV8sXys9bzswPF87dT0yNTYqdSt0W24raF0saCs9YixfLT04KTtpZigwPT09YyljPTEtZztlbHNle2lmKGM9PT1mKXJldHVybiB1P05hTjooZD8tMToxKSooMS8wKTt1Kz1yKDIsbyksYy09Z31yZXR1cm4oZD8tMToxKSp1KnIoMixjLW8pfSxvLndyaXRlPWZ1bmN0aW9uKGEsbyxsLHUscCxmKXt2YXIgaCxiLHksZz1NYXRoLkxOMixfPU1hdGgubG9nLEM9OCpmLXAtMSxSPSgxPDxDKS0xLEU9Uj4+MSx3PTIzPT09cD9yKDIsLTI0KS1yKDIsLTc3KTowLFM9dT8wOmYtMSxUPXU/MTotMSxkPTA+b3x8MD09PW8mJjA+MS9vPzE6MDtmb3Iobz1uKG8pLGlzTmFOKG8pfHxvPT09MS8wPyhiPWlzTmFOKG8pPzE6MCxoPVIpOihoPXQoXyhvKS9nKSwxPm8qKHk9cigyLC1oKSkmJihoLS0seSo9Miksbys9MTw9aCtFP3cveTp3KnIoMiwxLUUpLDI8PW8qeSYmKGgrKyx5Lz0yKSxoK0U+PVI/KGI9MCxoPVIpOjE8PWgrRT8oYj0obyp5LTEpKnIoMixwKSxoKz1FKTooYj1vKnIoMixFLTEpKnIoMixwKSxoPTApKTs4PD1wO2FbbCtTXT0yNTUmYixTKz1ULGIvPTI1NixwLT04KTtmb3IoaD1oPDxwfGIsQys9cDswPEM7YVtsK1NdPTI1NSZoLFMrPVQsaC89MjU2LEMtPTgpO2FbbCtTLVRdfD0xMjgqZH19LHt9XSwxMDpbZnVuY3Rpb24oZSx0KXt0LmV4cG9ydHM9XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe3QmJihlLnN1cGVyXz10LGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pKX06ZnVuY3Rpb24oZSx0KXtpZih0KXtlLnN1cGVyXz10O3ZhciBuPWZ1bmN0aW9uKCl7fTtuLnByb3RvdHlwZT10LnByb3RvdHlwZSxlLnByb3RvdHlwZT1uZXcgbixlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lfX19LHt9XSwxMTpbZnVuY3Rpb24oZSx0KXt2YXIgcj1NYXRoLnJvdW5kO2Z1bmN0aW9uIGEoZSl7aWYoZSs9XCJcIiwhKDEwMDxlLmxlbmd0aCkpe3ZhciB0PS9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhlKTtpZih0KXt2YXIgcj1wYXJzZUZsb2F0KHRbMV0pLG49KHRbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKTtyZXR1cm5cInllYXJzXCI9PT1ufHxcInllYXJcIj09PW58fFwieXJzXCI9PT1ufHxcInlyXCI9PT1ufHxcInlcIj09PW4/MzE1NTc2MDAwMDAqcjpcIndlZWtzXCI9PT1ufHxcIndlZWtcIj09PW58fFwid1wiPT09bj82MDQ4MDAwMDAqcjpcImRheXNcIj09PW58fFwiZGF5XCI9PT1ufHxcImRcIj09PW4/ODY0MDAwMDAqcjpcImhvdXJzXCI9PT1ufHxcImhvdXJcIj09PW58fFwiaHJzXCI9PT1ufHxcImhyXCI9PT1ufHxcImhcIj09PW4/MzYwMDAwMCpyOlwibWludXRlc1wiPT09bnx8XCJtaW51dGVcIj09PW58fFwibWluc1wiPT09bnx8XCJtaW5cIj09PW58fFwibVwiPT09bj82MDAwMCpyOlwic2Vjb25kc1wiPT09bnx8XCJzZWNvbmRcIj09PW58fFwic2Vjc1wiPT09bnx8XCJzZWNcIj09PW58fFwic1wiPT09bj8xMDAwKnI6XCJtaWxsaXNlY29uZHNcIj09PW58fFwibWlsbGlzZWNvbmRcIj09PW58fFwibXNlY3NcIj09PW58fFwibXNlY1wiPT09bnx8XCJtc1wiPT09bj9yOnZvaWQgMH19fWZ1bmN0aW9uIG8oZSl7dmFyIHQ9bihlKTtyZXR1cm4gODY0MDAwMDA8PXQ/cihlLzg2NDAwMDAwKStcImRcIjozNjAwMDAwPD10P3IoZS8zNjAwMDAwKStcImhcIjo2MDAwMDw9dD9yKGUvNjAwMDApK1wibVwiOjEwMDA8PXQ/cihlLzEwMDApK1wic1wiOmUrXCJtc1wifWZ1bmN0aW9uIGkoZSl7dmFyIHQ9bihlKTtyZXR1cm4gODY0MDAwMDA8PXQ/cyhlLHQsODY0MDAwMDAsXCJkYXlcIik6MzYwMDAwMDw9dD9zKGUsdCwzNjAwMDAwLFwiaG91clwiKTo2MDAwMDw9dD9zKGUsdCw2MDAwMCxcIm1pbnV0ZVwiKToxMDAwPD10P3MoZSx0LDEwMDAsXCJzZWNvbmRcIik6ZStcIiBtc1wifWZ1bmN0aW9uIHMoZSx0LGEsbil7cmV0dXJuIHIoZS9hKStcIiBcIituKyh0Pj0xLjUqYT9cInNcIjpcIlwiKX12YXIgbD0yNCooNjAqNjAwMDApO3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3Q9dHx8e307dmFyIG49dHlwZW9mIGU7aWYoXCJzdHJpbmdcIj09biYmMDxlLmxlbmd0aClyZXR1cm4gYShlKTtpZihcIm51bWJlclwiPT09biYmaXNGaW5pdGUoZSkpcmV0dXJuIHQubG9uZz9pKGUpOm8oZSk7dGhyb3cgbmV3IEVycm9yKFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIitKU09OLnN0cmluZ2lmeShlKSl9fSx7fV0sMTI6W2Z1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbigpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gcigpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBhKHQpe2lmKGM9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHQsMCk7aWYoKGM9PT1ufHwhYykmJnNldFRpbWVvdXQpcmV0dXJuIGM9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBjKHQsMCl9Y2F0Y2gobil7dHJ5e3JldHVybiBjLmNhbGwobnVsbCx0LDApfWNhdGNoKG4pe3JldHVybiBjLmNhbGwodGhpcyx0LDApfX19ZnVuY3Rpb24gbyh0KXtpZih1PT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQodCk7aWYoKHU9PT1yfHwhdSkmJmNsZWFyVGltZW91dClyZXR1cm4gdT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gdSh0KX1jYXRjaChuKXt0cnl7cmV0dXJuIHUuY2FsbChudWxsLHQpfWNhdGNoKG4pe3JldHVybiB1LmNhbGwodGhpcyx0KX19fWZ1bmN0aW9uIGkoKXtfJiZmJiYoXz0hMSxmLmxlbmd0aD9nPWYuY29uY2F0KGcpOmg9LTEsZy5sZW5ndGgmJmQoKSl9ZnVuY3Rpb24gZCgpe2lmKCFfKXt2YXIgZT1hKGkpO189ITA7Zm9yKHZhciB0PWcubGVuZ3RoO3Q7KXtmb3IoZj1nLGc9W107KytoPHQ7KWYmJmZbaF0ucnVuKCk7aD0tMSx0PWcubGVuZ3RofWY9bnVsbCxfPSExLG8oZSl9fWZ1bmN0aW9uIHMoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1mdW5jdGlvbiBsKCl7fXZhciBjLHUscD10LmV4cG9ydHM9e307KGZ1bmN0aW9uKCl7dHJ5e2M9XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0Om59Y2F0Y2godCl7Yz1ufXRyeXt1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6cn1jYXRjaCh0KXt1PXJ9fSkoKTt2YXIgZixnPVtdLF89ITEsaD0tMTtwLm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoMTxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtnLnB1c2gobmV3IHMoZSx0KSksMSE9PWcubGVuZ3RofHxffHxhKGQpfSxzLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxwLnRpdGxlPVwiYnJvd3NlclwiLHAuYnJvd3Nlcj0hMCxwLmVudj17fSxwLmFyZ3Y9W10scC52ZXJzaW9uPVwiXCIscC52ZXJzaW9ucz17fSxwLm9uPWwscC5hZGRMaXN0ZW5lcj1sLHAub25jZT1sLHAub2ZmPWwscC5yZW1vdmVMaXN0ZW5lcj1sLHAucmVtb3ZlQWxsTGlzdGVuZXJzPWwscC5lbWl0PWwscC5wcmVwZW5kTGlzdGVuZXI9bCxwLnByZXBlbmRPbmNlTGlzdGVuZXI9bCxwLmxpc3RlbmVycz1mdW5jdGlvbigpe3JldHVybltdfSxwLmJpbmRpbmc9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX0scC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn0scC5jaGRpcj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0scC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0se31dLDEzOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihlKXsoZnVuY3Rpb24oKXsvKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovbGV0IG47dC5leHBvcnRzPVwiZnVuY3Rpb25cIj09dHlwZW9mIHF1ZXVlTWljcm90YXNrP3F1ZXVlTWljcm90YXNrLmJpbmQoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9lOndpbmRvdyk6ZT0+KG58fChuPVByb21pc2UucmVzb2x2ZSgpKSkudGhlbihlKS5jYXRjaChlPT5zZXRUaW1lb3V0KCgpPT57dGhyb3cgZX0sMCkpfSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/e306d2luZG93OnNlbGY6Z2xvYmFsKX0se31dLDE0OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0Jzt2YXIgYT1lKFwic2FmZS1idWZmZXJcIikuQnVmZmVyLG89ci5jcnlwdG98fHIubXNDcnlwdG87dC5leHBvcnRzPW8mJm8uZ2V0UmFuZG9tVmFsdWVzP2Z1bmN0aW9uKGUsdCl7aWYoZT40Mjk0OTY3Mjk1KXRocm93IG5ldyBSYW5nZUVycm9yKFwicmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlc1wiKTt2YXIgcj1hLmFsbG9jVW5zYWZlKGUpO2lmKDA8ZSlpZig2NTUzNjxlKWZvcih2YXIgaT0wO2k8ZTtpKz02NTUzNilvLmdldFJhbmRvbVZhbHVlcyhyLnNsaWNlKGksaSs2NTUzNikpO2Vsc2Ugby5nZXRSYW5kb21WYWx1ZXMocik7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD9uLm5leHRUaWNrKGZ1bmN0aW9uKCl7dChudWxsLHIpfSk6cn06ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTFcIil9fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHtfcHJvY2VzczoxMixcInNhZmUtYnVmZmVyXCI6MzB9XSwxNTpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsZS5fX3Byb3RvX189dH1mdW5jdGlvbiByKGUsdCxyKXtmdW5jdGlvbiBhKGUsbixyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OnQoZSxuLHIpfXJ8fChyPUVycm9yKTt2YXIgbz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbixyKXtyZXR1cm4gZS5jYWxsKHRoaXMsYSh0LG4scikpfHx0aGlzfXJldHVybiBuKHQsZSksdH0ocik7by5wcm90b3R5cGUubmFtZT1yLm5hbWUsby5wcm90b3R5cGUuY29kZT1lLHNbZV09b31mdW5jdGlvbiBhKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG49ZS5sZW5ndGg7cmV0dXJuIGU9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUrXCJcIn0pLDI8bj9cIm9uZSBvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUuc2xpY2UoMCxuLTEpLmpvaW4oXCIsIFwiKSxcIiwgb3IgXCIpK2Vbbi0xXToyPT09bj9cIm9uZSBvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGVbMF0sXCIgb3IgXCIpLmNvbmNhdChlWzFdKTpcIm9mIFwiLmNvbmNhdCh0LFwiIFwiKS5jb25jYXQoZVswXSl9cmV0dXJuXCJvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUrXCJcIil9ZnVuY3Rpb24gbyhlLHQsbil7cmV0dXJuIGUuc3Vic3RyKCFufHwwPm4/MDorbix0Lmxlbmd0aCk9PT10fWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybih2b2lkIDA9PT1ufHxuPmUubGVuZ3RoKSYmKG49ZS5sZW5ndGgpLGUuc3Vic3RyaW5nKG4tdC5sZW5ndGgsbik9PT10fWZ1bmN0aW9uIGQoZSx0LG4pe3JldHVyblwibnVtYmVyXCIhPXR5cGVvZiBuJiYobj0wKSwhKG4rdC5sZW5ndGg+ZS5sZW5ndGgpJiYtMSE9PWUuaW5kZXhPZih0LG4pfXZhciBzPXt9O3IoXCJFUlJfSU5WQUxJRF9PUFRfVkFMVUVcIixmdW5jdGlvbihlLHQpe3JldHVyblwiVGhlIHZhbHVlIFxcXCJcIit0K1wiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcIlwiK2UrXCJcXFwiXCJ9LFR5cGVFcnJvcikscihcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsZnVuY3Rpb24oZSx0LG4pe3ZhciByO1wic3RyaW5nXCI9PXR5cGVvZiB0JiZvKHQsXCJub3QgXCIpPyhyPVwibXVzdCBub3QgYmVcIix0PXQucmVwbGFjZSgvXm5vdCAvLFwiXCIpKTpyPVwibXVzdCBiZVwiO3ZhciBzO2lmKGkoZSxcIiBhcmd1bWVudFwiKSlzPVwiVGhlIFwiLmNvbmNhdChlLFwiIFwiKS5jb25jYXQocixcIiBcIikuY29uY2F0KGEodCxcInR5cGVcIikpO2Vsc2V7dmFyIGw9ZChlLFwiLlwiKT9cInByb3BlcnR5XCI6XCJhcmd1bWVudFwiO3M9XCJUaGUgXFxcIlwiLmNvbmNhdChlLFwiXFxcIiBcIikuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChyLFwiIFwiKS5jb25jYXQoYSh0LFwidHlwZVwiKSl9cmV0dXJuIHMrPVwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2Ygbiksc30sVHlwZUVycm9yKSxyKFwiRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRlwiLFwic3RyZWFtLnB1c2goKSBhZnRlciBFT0ZcIikscihcIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEXCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJUaGUgXCIrZStcIiBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkXCJ9KSxyKFwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIixcIlByZW1hdHVyZSBjbG9zZVwiKSxyKFwiRVJSX1NUUkVBTV9ERVNUUk9ZRURcIixmdW5jdGlvbihlKXtyZXR1cm5cIkNhbm5vdCBjYWxsIFwiK2UrXCIgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZFwifSkscihcIkVSUl9NVUxUSVBMRV9DQUxMQkFDS1wiLFwiQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzXCIpLHIoXCJFUlJfU1RSRUFNX0NBTk5PVF9QSVBFXCIsXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpLHIoXCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORFwiLFwid3JpdGUgYWZ0ZXIgZW5kXCIpLHIoXCJFUlJfU1RSRUFNX05VTExfVkFMVUVTXCIsXCJNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbVwiLFR5cGVFcnJvcikscihcIkVSUl9VTktOT1dOX0VOQ09ESU5HXCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJVbmtub3duIGVuY29kaW5nOiBcIitlfSxUeXBlRXJyb3IpLHIoXCJFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UXCIsXCJzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudFwiKSx0LmV4cG9ydHMuY29kZXM9c30se31dLDE2OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHI/dm9pZChkLmNhbGwodGhpcyxlKSxzLmNhbGwodGhpcyxlKSx0aGlzLmFsbG93SGFsZk9wZW49ITAsZSYmKCExPT09ZS5yZWFkYWJsZSYmKHRoaXMucmVhZGFibGU9ITEpLCExPT09ZS53cml0YWJsZSYmKHRoaXMud3JpdGFibGU9ITEpLCExPT09ZS5hbGxvd0hhbGZPcGVuJiYodGhpcy5hbGxvd0hhbGZPcGVuPSExLHRoaXMub25jZShcImVuZFwiLGEpKSkpOm5ldyByKGUpfWZ1bmN0aW9uIGEoKXt0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkfHxuLm5leHRUaWNrKG8sdGhpcyl9ZnVuY3Rpb24gbyhlKXtlLmVuZCgpfXZhciBpPU9iamVjdC5rZXlzfHxmdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSl0LnB1c2gobik7cmV0dXJuIHR9O3QuZXhwb3J0cz1yO3ZhciBkPWUoXCIuL19zdHJlYW1fcmVhZGFibGVcIikscz1lKFwiLi9fc3RyZWFtX3dyaXRhYmxlXCIpO2UoXCJpbmhlcml0c1wiKShyLGQpO2Zvcih2YXIgbCxjPWkocy5wcm90b3R5cGUpLHU9MDt1PGMubGVuZ3RoO3UrKylsPWNbdV0sci5wcm90b3R5cGVbbF18fChyLnByb3RvdHlwZVtsXT1zLnByb3RvdHlwZVtsXSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsXCJ3cml0YWJsZUJ1ZmZlclwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSxcIndyaXRhYmxlTGVuZ3RoXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RofX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSxcImRlc3Ryb3llZFwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLl9yZWFkYWJsZVN0YXRlJiZ2b2lkIDAhPT10aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt2b2lkIDA9PT10aGlzLl9yZWFkYWJsZVN0YXRlfHx2b2lkIDA9PT10aGlzLl93cml0YWJsZVN0YXRlfHwodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSx0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1lKX19KX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpKX0se1wiLi9fc3RyZWFtX3JlYWRhYmxlXCI6MTgsXCIuL19zdHJlYW1fd3JpdGFibGVcIjoyMCxfcHJvY2VzczoxMixpbmhlcml0czoxMH1dLDE3OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbj92b2lkIHIuY2FsbCh0aGlzLGUpOm5ldyBuKGUpfXQuZXhwb3J0cz1uO3ZhciByPWUoXCIuL19zdHJlYW1fdHJhbnNmb3JtXCIpO2UoXCJpbmhlcml0c1wiKShuLHIpLG4ucHJvdG90eXBlLl90cmFuc2Zvcm09ZnVuY3Rpb24oZSx0LG4pe24obnVsbCxlKX19LHtcIi4vX3N0cmVhbV90cmFuc2Zvcm1cIjoxOSxpbmhlcml0czoxMH1dLDE4OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBhKGUpe3JldHVybiBQLmZyb20oZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gUC5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIE19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wcmVwZW5kTGlzdGVuZXI/ZS5wcmVwZW5kTGlzdGVuZXIodCxuKTp2b2lkKGUuX2V2ZW50cyYmZS5fZXZlbnRzW3RdP0FycmF5LmlzQXJyYXkoZS5fZXZlbnRzW3RdKT9lLl9ldmVudHNbdF0udW5zaGlmdChuKTplLl9ldmVudHNbdF09W24sZS5fZXZlbnRzW3RdXTplLm9uKHQsbikpfWZ1bmN0aW9uIGQodCxuLHIpe0E9QXx8ZShcIi4vX3N0cmVhbV9kdXBsZXhcIiksdD10fHx7fSxcImJvb2xlYW5cIiE9dHlwZW9mIHImJihyPW4gaW5zdGFuY2VvZiBBKSx0aGlzLm9iamVjdE1vZGU9ISF0Lm9iamVjdE1vZGUsciYmKHRoaXMub2JqZWN0TW9kZT10aGlzLm9iamVjdE1vZGV8fCEhdC5yZWFkYWJsZU9iamVjdE1vZGUpLHRoaXMuaGlnaFdhdGVyTWFyaz1IKHRoaXMsdCxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLHIpLHRoaXMuYnVmZmVyPW5ldyBqLHRoaXMubGVuZ3RoPTAsdGhpcy5waXBlcz1udWxsLHRoaXMucGlwZXNDb3VudD0wLHRoaXMuZmxvd2luZz1udWxsLHRoaXMuZW5kZWQ9ITEsdGhpcy5lbmRFbWl0dGVkPSExLHRoaXMucmVhZGluZz0hMSx0aGlzLnN5bmM9ITAsdGhpcy5uZWVkUmVhZGFibGU9ITEsdGhpcy5lbWl0dGVkUmVhZGFibGU9ITEsdGhpcy5yZWFkYWJsZUxpc3RlbmluZz0hMSx0aGlzLnJlc3VtZVNjaGVkdWxlZD0hMSx0aGlzLnBhdXNlZD0hMCx0aGlzLmVtaXRDbG9zZT0hMSE9PXQuZW1pdENsb3NlLHRoaXMuYXV0b0Rlc3Ryb3k9ISF0LmF1dG9EZXN0cm95LHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVmYXVsdEVuY29kaW5nPXQuZGVmYXVsdEVuY29kaW5nfHxcInV0ZjhcIix0aGlzLmF3YWl0RHJhaW49MCx0aGlzLnJlYWRpbmdNb3JlPSExLHRoaXMuZGVjb2Rlcj1udWxsLHRoaXMuZW5jb2Rpbmc9bnVsbCx0LmVuY29kaW5nJiYoIUYmJihGPWUoXCJzdHJpbmdfZGVjb2Rlci9cIikuU3RyaW5nRGVjb2RlciksdGhpcy5kZWNvZGVyPW5ldyBGKHQuZW5jb2RpbmcpLHRoaXMuZW5jb2Rpbmc9dC5lbmNvZGluZyl9ZnVuY3Rpb24gcyh0KXtpZihBPUF8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpLCEodGhpcyBpbnN0YW5jZW9mIHMpKXJldHVybiBuZXcgcyh0KTt2YXIgbj10aGlzIGluc3RhbmNlb2YgQTt0aGlzLl9yZWFkYWJsZVN0YXRlPW5ldyBkKHQsdGhpcyxuKSx0aGlzLnJlYWRhYmxlPSEwLHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnJlYWQmJih0aGlzLl9yZWFkPXQucmVhZCksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiYodGhpcy5fZGVzdHJveT10LmRlc3Ryb3kpKSxJLmNhbGwodGhpcyl9ZnVuY3Rpb24gbChlLHQsbixyLG8pe3goXCJyZWFkYWJsZUFkZENodW5rXCIsdCk7dmFyIGk9ZS5fcmVhZGFibGVTdGF0ZTtpZihudWxsPT09dClpLnJlYWRpbmc9ITEsZyhlLGkpO2Vsc2V7dmFyIGQ7aWYob3x8KGQ9dShpLHQpKSxkKVgoZSxkKTtlbHNlIGlmKCEoaS5vYmplY3RNb2RlfHx0JiYwPHQubGVuZ3RoKSlyfHwoaS5yZWFkaW5nPSExLG0oZSxpKSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgdHx8aS5vYmplY3RNb2RlfHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk9PT1QLnByb3RvdHlwZXx8KHQ9YSh0KSkscilpLmVuZEVtaXR0ZWQ/WChlLG5ldyBLKTpjKGUsaSx0LCEwKTtlbHNlIGlmKGkuZW5kZWQpWChlLG5ldyB6KTtlbHNle2lmKGkuZGVzdHJveWVkKXJldHVybiExO2kucmVhZGluZz0hMSxpLmRlY29kZXImJiFuPyh0PWkuZGVjb2Rlci53cml0ZSh0KSxpLm9iamVjdE1vZGV8fDAhPT10Lmxlbmd0aD9jKGUsaSx0LCExKTptKGUsaSkpOmMoZSxpLHQsITEpfX1yZXR1cm4haS5lbmRlZCYmKGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFya3x8MD09PWkubGVuZ3RoKX1mdW5jdGlvbiBjKGUsdCxuLHIpe3QuZmxvd2luZyYmMD09PXQubGVuZ3RoJiYhdC5zeW5jPyh0LmF3YWl0RHJhaW49MCxlLmVtaXQoXCJkYXRhXCIsbikpOih0Lmxlbmd0aCs9dC5vYmplY3RNb2RlPzE6bi5sZW5ndGgscj90LmJ1ZmZlci51bnNoaWZ0KG4pOnQuYnVmZmVyLnB1c2gobiksdC5uZWVkUmVhZGFibGUmJl8oZSkpLG0oZSx0KX1mdW5jdGlvbiB1KGUsdCl7dmFyIG47cmV0dXJuIG8odCl8fFwic3RyaW5nXCI9PXR5cGVvZiB0fHx2b2lkIDA9PT10fHxlLm9iamVjdE1vZGV8fChuPW5ldyBWKFwiY2h1bmtcIixbXCJzdHJpbmdcIixcIkJ1ZmZlclwiLFwiVWludDhBcnJheVwiXSx0KSksbn1mdW5jdGlvbiBwKGUpe3JldHVybiAxMDczNzQxODI0PD1lP2U9MTA3Mzc0MTgyNDooZS0tLGV8PWU+Pj4xLGV8PWU+Pj4yLGV8PWU+Pj40LGV8PWU+Pj44LGV8PWU+Pj4xNixlKyspLGV9ZnVuY3Rpb24gZihlLHQpe3JldHVybiAwPj1lfHwwPT09dC5sZW5ndGgmJnQuZW5kZWQ/MDp0Lm9iamVjdE1vZGU/MTplPT09ZT8oZT50LmhpZ2hXYXRlck1hcmsmJih0LmhpZ2hXYXRlck1hcms9cChlKSksZTw9dC5sZW5ndGg/ZTp0LmVuZGVkP3QubGVuZ3RoOih0Lm5lZWRSZWFkYWJsZT0hMCwwKSk6dC5mbG93aW5nJiZ0Lmxlbmd0aD90LmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoOnQubGVuZ3RofWZ1bmN0aW9uIGcoZSx0KXtpZih4KFwib25Fb2ZDaHVua1wiKSwhdC5lbmRlZCl7aWYodC5kZWNvZGVyKXt2YXIgbj10LmRlY29kZXIuZW5kKCk7biYmbi5sZW5ndGgmJih0LmJ1ZmZlci5wdXNoKG4pLHQubGVuZ3RoKz10Lm9iamVjdE1vZGU/MTpuLmxlbmd0aCl9dC5lbmRlZD0hMCx0LnN5bmM/XyhlKToodC5uZWVkUmVhZGFibGU9ITEsIXQuZW1pdHRlZFJlYWRhYmxlJiYodC5lbWl0dGVkUmVhZGFibGU9ITAsaChlKSkpfX1mdW5jdGlvbiBfKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7eChcImVtaXRSZWFkYWJsZVwiLHQubmVlZFJlYWRhYmxlLHQuZW1pdHRlZFJlYWRhYmxlKSx0Lm5lZWRSZWFkYWJsZT0hMSx0LmVtaXR0ZWRSZWFkYWJsZXx8KHgoXCJlbWl0UmVhZGFibGVcIix0LmZsb3dpbmcpLHQuZW1pdHRlZFJlYWRhYmxlPSEwLG4ubmV4dFRpY2soaCxlKSl9ZnVuY3Rpb24gaChlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJlbWl0UmVhZGFibGVfXCIsdC5kZXN0cm95ZWQsdC5sZW5ndGgsdC5lbmRlZCksIXQuZGVzdHJveWVkJiYodC5sZW5ndGh8fHQuZW5kZWQpJiYoZS5lbWl0KFwicmVhZGFibGVcIiksdC5lbWl0dGVkUmVhZGFibGU9ITEpLHQubmVlZFJlYWRhYmxlPSF0LmZsb3dpbmcmJiF0LmVuZGVkJiZ0Lmxlbmd0aDw9dC5oaWdoV2F0ZXJNYXJrLFMoZSl9ZnVuY3Rpb24gbShlLHQpe3QucmVhZGluZ01vcmV8fCh0LnJlYWRpbmdNb3JlPSEwLG4ubmV4dFRpY2soYixlLHQpKX1mdW5jdGlvbiBiKGUsdCl7Zm9yKDshdC5yZWFkaW5nJiYhdC5lbmRlZCYmKHQubGVuZ3RoPHQuaGlnaFdhdGVyTWFya3x8dC5mbG93aW5nJiYwPT09dC5sZW5ndGgpOyl7dmFyIG49dC5sZW5ndGg7aWYoeChcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpLGUucmVhZCgwKSxuPT09dC5sZW5ndGgpYnJlYWt9dC5yZWFkaW5nTW9yZT0hMX1mdW5jdGlvbiB5KGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7eChcInBpcGVPbkRyYWluXCIsdC5hd2FpdERyYWluKSx0LmF3YWl0RHJhaW4mJnQuYXdhaXREcmFpbi0tLDA9PT10LmF3YWl0RHJhaW4mJkQoZSxcImRhdGFcIikmJih0LmZsb3dpbmc9ITAsUyhlKSl9fWZ1bmN0aW9uIEMoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt0LnJlYWRhYmxlTGlzdGVuaW5nPTA8ZS5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIiksdC5yZXN1bWVTY2hlZHVsZWQmJiF0LnBhdXNlZD90LmZsb3dpbmc9ITA6MDxlLmxpc3RlbmVyQ291bnQoXCJkYXRhXCIpJiZlLnJlc3VtZSgpfWZ1bmN0aW9uIFIoZSl7eChcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKSxlLnJlYWQoMCl9ZnVuY3Rpb24gRShlLHQpe3QucmVzdW1lU2NoZWR1bGVkfHwodC5yZXN1bWVTY2hlZHVsZWQ9ITAsbi5uZXh0VGljayh3LGUsdCkpfWZ1bmN0aW9uIHcoZSx0KXt4KFwicmVzdW1lXCIsdC5yZWFkaW5nKSx0LnJlYWRpbmd8fGUucmVhZCgwKSx0LnJlc3VtZVNjaGVkdWxlZD0hMSxlLmVtaXQoXCJyZXN1bWVcIiksUyhlKSx0LmZsb3dpbmcmJiF0LnJlYWRpbmcmJmUucmVhZCgwKX1mdW5jdGlvbiBTKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7Zm9yKHgoXCJmbG93XCIsdC5mbG93aW5nKTt0LmZsb3dpbmcmJm51bGwhPT1lLnJlYWQoKTspO31mdW5jdGlvbiBUKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBuO3JldHVybiB0Lm9iamVjdE1vZGU/bj10LmJ1ZmZlci5zaGlmdCgpOiFlfHxlPj10Lmxlbmd0aD8obj10LmRlY29kZXI/dC5idWZmZXIuam9pbihcIlwiKToxPT09dC5idWZmZXIubGVuZ3RoP3QuYnVmZmVyLmZpcnN0KCk6dC5idWZmZXIuY29uY2F0KHQubGVuZ3RoKSx0LmJ1ZmZlci5jbGVhcigpKTpuPXQuYnVmZmVyLmNvbnN1bWUoZSx0LmRlY29kZXIpLG59ZnVuY3Rpb24gdihlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJlbmRSZWFkYWJsZVwiLHQuZW5kRW1pdHRlZCksdC5lbmRFbWl0dGVkfHwodC5lbmRlZD0hMCxuLm5leHRUaWNrKGssdCxlKSl9ZnVuY3Rpb24gayhlLHQpe2lmKHgoXCJlbmRSZWFkYWJsZU5UXCIsZS5lbmRFbWl0dGVkLGUubGVuZ3RoKSwhZS5lbmRFbWl0dGVkJiYwPT09ZS5sZW5ndGgmJihlLmVuZEVtaXR0ZWQ9ITAsdC5yZWFkYWJsZT0hMSx0LmVtaXQoXCJlbmRcIiksZS5hdXRvRGVzdHJveSkpe3ZhciBuPXQuX3dyaXRhYmxlU3RhdGU7KCFufHxuLmF1dG9EZXN0cm95JiZuLmZpbmlzaGVkKSYmdC5kZXN0cm95KCl9fWZ1bmN0aW9uIEwoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspaWYoZVtuXT09PXQpcmV0dXJuIG47cmV0dXJuLTF9dC5leHBvcnRzPXM7dmFyIEE7cy5SZWFkYWJsZVN0YXRlPWQ7dmFyIHgsTj1lKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcixEPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubGlzdGVuZXJzKHQpLmxlbmd0aH0sST1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiKSxQPWUoXCJidWZmZXJcIikuQnVmZmVyLE09ci5VaW50OEFycmF5fHxmdW5jdGlvbigpe30sTz1lKFwidXRpbFwiKTt4PU8mJk8uZGVidWdsb2c/Ty5kZWJ1Z2xvZyhcInN0cmVhbVwiKTpmdW5jdGlvbigpe307dmFyIEYsQixVLGo9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdFwiKSxxPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiKSxXPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvc3RhdGVcIiksSD1XLmdldEhpZ2hXYXRlck1hcmssWT1lKFwiLi4vZXJyb3JzXCIpLmNvZGVzLFY9WS5FUlJfSU5WQUxJRF9BUkdfVFlQRSx6PVkuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixHPVkuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsSz1ZLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7ZShcImluaGVyaXRzXCIpKHMsSSk7dmFyIFg9cS5lcnJvck9yRGVzdHJveSwkPVtcImVycm9yXCIsXCJjbG9zZVwiLFwiZGVzdHJveVwiLFwicGF1c2VcIixcInJlc3VtZVwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fcmVhZGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSl9fSkscy5wcm90b3R5cGUuZGVzdHJveT1xLmRlc3Ryb3kscy5wcm90b3R5cGUuX3VuZGVzdHJveT1xLnVuZGVzdHJveSxzLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbihlLHQpe3QoZSl9LHMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXt2YXIgbixyPXRoaXMuX3JlYWRhYmxlU3RhdGU7cmV0dXJuIHIub2JqZWN0TW9kZT9uPSEwOlwic3RyaW5nXCI9PXR5cGVvZiBlJiYodD10fHxyLmRlZmF1bHRFbmNvZGluZyx0IT09ci5lbmNvZGluZyYmKGU9UC5mcm9tKGUsdCksdD1cIlwiKSxuPSEwKSxsKHRoaXMsZSx0LCExLG4pfSxzLnByb3RvdHlwZS51bnNoaWZ0PWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMsZSxudWxsLCEwLCExKX0scy5wcm90b3R5cGUuaXNQYXVzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZ30scy5wcm90b3R5cGUuc2V0RW5jb2Rpbmc9ZnVuY3Rpb24odCl7Rnx8KEY9ZShcInN0cmluZ19kZWNvZGVyL1wiKS5TdHJpbmdEZWNvZGVyKTt2YXIgbj1uZXcgRih0KTt0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXI9bix0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nPXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZztmb3IodmFyIHI9dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZCxhPVwiXCI7bnVsbCE9PXI7KWErPW4ud3JpdGUoci5kYXRhKSxyPXIubmV4dDtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKSxcIlwiIT09YSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChhKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aD1hLmxlbmd0aCx0aGlzfTtzLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe3goXCJyZWFkXCIsZSksZT1wYXJzZUludChlLDEwKTt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlLHI9ZTtpZigwIT09ZSYmKHQuZW1pdHRlZFJlYWRhYmxlPSExKSwwPT09ZSYmdC5uZWVkUmVhZGFibGUmJigoMD09PXQuaGlnaFdhdGVyTWFyaz8wPHQubGVuZ3RoOnQubGVuZ3RoPj10LmhpZ2hXYXRlck1hcmspfHx0LmVuZGVkKSlyZXR1cm4geChcInJlYWQ6IGVtaXRSZWFkYWJsZVwiLHQubGVuZ3RoLHQuZW5kZWQpLDA9PT10Lmxlbmd0aCYmdC5lbmRlZD92KHRoaXMpOl8odGhpcyksbnVsbDtpZihlPWYoZSx0KSwwPT09ZSYmdC5lbmRlZClyZXR1cm4gMD09PXQubGVuZ3RoJiZ2KHRoaXMpLG51bGw7dmFyIGE9dC5uZWVkUmVhZGFibGU7eChcIm5lZWQgcmVhZGFibGVcIixhKSwoMD09PXQubGVuZ3RofHx0Lmxlbmd0aC1lPHQuaGlnaFdhdGVyTWFyaykmJihhPSEwLHgoXCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFya1wiLGEpKSx0LmVuZGVkfHx0LnJlYWRpbmc/KGE9ITEseChcInJlYWRpbmcgb3IgZW5kZWRcIixhKSk6YSYmKHgoXCJkbyByZWFkXCIpLHQucmVhZGluZz0hMCx0LnN5bmM9ITAsMD09PXQubGVuZ3RoJiYodC5uZWVkUmVhZGFibGU9ITApLHRoaXMuX3JlYWQodC5oaWdoV2F0ZXJNYXJrKSx0LnN5bmM9ITEsIXQucmVhZGluZyYmKGU9ZihyLHQpKSk7dmFyIG87cmV0dXJuIG89MDxlP1QoZSx0KTpudWxsLG51bGw9PT1vPyh0Lm5lZWRSZWFkYWJsZT10Lmxlbmd0aDw9dC5oaWdoV2F0ZXJNYXJrLGU9MCk6KHQubGVuZ3RoLT1lLHQuYXdhaXREcmFpbj0wKSwwPT09dC5sZW5ndGgmJighdC5lbmRlZCYmKHQubmVlZFJlYWRhYmxlPSEwKSxyIT09ZSYmdC5lbmRlZCYmdih0aGlzKSksbnVsbCE9PW8mJnRoaXMuZW1pdChcImRhdGFcIixvKSxvfSxzLnByb3RvdHlwZS5fcmVhZD1mdW5jdGlvbigpe1godGhpcyxuZXcgRyhcIl9yZWFkKClcIikpfSxzLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcihlLHQpe3goXCJvbnVucGlwZVwiKSxlPT09cCYmdCYmITE9PT10Lmhhc1VucGlwZWQmJih0Lmhhc1VucGlwZWQ9ITAsbygpKX1mdW5jdGlvbiBhKCl7eChcIm9uZW5kXCIpLGUuZW5kKCl9ZnVuY3Rpb24gbygpe3goXCJjbGVhbnVwXCIpLGUucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGwpLGUucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixjKSxlLnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixoKSxlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixzKSxlLnJlbW92ZUxpc3RlbmVyKFwidW5waXBlXCIscikscC5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGEpLHAucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIix1KSxwLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLGQpLG09ITAsZi5hd2FpdERyYWluJiYoIWUuX3dyaXRhYmxlU3RhdGV8fGUuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSYmaCgpfWZ1bmN0aW9uIGQodCl7eChcIm9uZGF0YVwiKTt2YXIgbj1lLndyaXRlKHQpO3goXCJkZXN0LndyaXRlXCIsbiksITE9PT1uJiYoKDE9PT1mLnBpcGVzQ291bnQmJmYucGlwZXM9PT1lfHwxPGYucGlwZXNDb3VudCYmLTEhPT1MKGYucGlwZXMsZSkpJiYhbSYmKHgoXCJmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2VcIixmLmF3YWl0RHJhaW4pLGYuYXdhaXREcmFpbisrKSxwLnBhdXNlKCkpfWZ1bmN0aW9uIHModCl7eChcIm9uZXJyb3JcIix0KSx1KCksZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIscyksMD09PUQoZSxcImVycm9yXCIpJiZYKGUsdCl9ZnVuY3Rpb24gbCgpe2UucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixjKSx1KCl9ZnVuY3Rpb24gYygpe3goXCJvbmZpbmlzaFwiKSxlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixsKSx1KCl9ZnVuY3Rpb24gdSgpe3goXCJ1bnBpcGVcIikscC51bnBpcGUoZSl9dmFyIHA9dGhpcyxmPXRoaXMuX3JlYWRhYmxlU3RhdGU7c3dpdGNoKGYucGlwZXNDb3VudCl7Y2FzZSAwOmYucGlwZXM9ZTticmVhaztjYXNlIDE6Zi5waXBlcz1bZi5waXBlcyxlXTticmVhaztkZWZhdWx0OmYucGlwZXMucHVzaChlKTt9Zi5waXBlc0NvdW50Kz0xLHgoXCJwaXBlIGNvdW50PSVkIG9wdHM9JWpcIixmLnBpcGVzQ291bnQsdCk7dmFyIGc9KCF0fHwhMSE9PXQuZW5kKSYmZSE9PW4uc3Rkb3V0JiZlIT09bi5zdGRlcnIsXz1nP2E6dTtmLmVuZEVtaXR0ZWQ/bi5uZXh0VGljayhfKTpwLm9uY2UoXCJlbmRcIixfKSxlLm9uKFwidW5waXBlXCIscik7dmFyIGg9eShwKTtlLm9uKFwiZHJhaW5cIixoKTt2YXIgbT0hMTtyZXR1cm4gcC5vbihcImRhdGFcIixkKSxpKGUsXCJlcnJvclwiLHMpLGUub25jZShcImNsb3NlXCIsbCksZS5vbmNlKFwiZmluaXNoXCIsYyksZS5lbWl0KFwicGlwZVwiLHApLGYuZmxvd2luZ3x8KHgoXCJwaXBlIHJlc3VtZVwiKSxwLnJlc3VtZSgpKSxlfSxzLnByb3RvdHlwZS51bnBpcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fcmVhZGFibGVTdGF0ZSxuPXtoYXNVbnBpcGVkOiExfTtpZigwPT09dC5waXBlc0NvdW50KXJldHVybiB0aGlzO2lmKDE9PT10LnBpcGVzQ291bnQpcmV0dXJuIGUmJmUhPT10LnBpcGVzP3RoaXM6KGV8fChlPXQucGlwZXMpLHQucGlwZXM9bnVsbCx0LnBpcGVzQ291bnQ9MCx0LmZsb3dpbmc9ITEsZSYmZS5lbWl0KFwidW5waXBlXCIsdGhpcyxuKSx0aGlzKTtpZighZSl7dmFyIHI9dC5waXBlcyxhPXQucGlwZXNDb3VudDt0LnBpcGVzPW51bGwsdC5waXBlc0NvdW50PTAsdC5mbG93aW5nPSExO2Zvcih2YXIgbz0wO288YTtvKyspcltvXS5lbWl0KFwidW5waXBlXCIsdGhpcyx7aGFzVW5waXBlZDohMX0pO3JldHVybiB0aGlzfXZhciBkPUwodC5waXBlcyxlKTtyZXR1cm4tMT09PWQ/dGhpczoodC5waXBlcy5zcGxpY2UoZCwxKSx0LnBpcGVzQ291bnQtPTEsMT09PXQucGlwZXNDb3VudCYmKHQucGlwZXM9dC5waXBlc1swXSksZS5lbWl0KFwidW5waXBlXCIsdGhpcyxuKSx0aGlzKX0scy5wcm90b3R5cGUub249ZnVuY3Rpb24oZSx0KXt2YXIgcj1JLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsZSx0KSxhPXRoaXMuX3JlYWRhYmxlU3RhdGU7cmV0dXJuXCJkYXRhXCI9PT1lPyhhLnJlYWRhYmxlTGlzdGVuaW5nPTA8dGhpcy5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIiksITEhPT1hLmZsb3dpbmcmJnRoaXMucmVzdW1lKCkpOlwicmVhZGFibGVcIj09ZSYmIWEuZW5kRW1pdHRlZCYmIWEucmVhZGFibGVMaXN0ZW5pbmcmJihhLnJlYWRhYmxlTGlzdGVuaW5nPWEubmVlZFJlYWRhYmxlPSEwLGEuZmxvd2luZz0hMSxhLmVtaXR0ZWRSZWFkYWJsZT0hMSx4KFwib24gcmVhZGFibGVcIixhLmxlbmd0aCxhLnJlYWRpbmcpLGEubGVuZ3RoP18odGhpcyk6IWEucmVhZGluZyYmbi5uZXh0VGljayhSLHRoaXMpKSxyfSxzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1zLnByb3RvdHlwZS5vbixzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3ZhciByPUkucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcyxlLHQpO3JldHVyblwicmVhZGFibGVcIj09PWUmJm4ubmV4dFRpY2soQyx0aGlzKSxyfSxzLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIHQ9SS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4oXCJyZWFkYWJsZVwiPT09ZXx8dm9pZCAwPT09ZSkmJm4ubmV4dFRpY2soQyx0aGlzKSx0fSxzLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiBlLmZsb3dpbmd8fCh4KFwicmVzdW1lXCIpLGUuZmxvd2luZz0hZS5yZWFkYWJsZUxpc3RlbmluZyxFKHRoaXMsZSkpLGUucGF1c2VkPSExLHRoaXN9LHMucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHgoXCJjYWxsIHBhdXNlIGZsb3dpbmc9JWpcIix0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpLCExIT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nJiYoeChcInBhdXNlXCIpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZz0hMSx0aGlzLmVtaXQoXCJwYXVzZVwiKSksdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQ9ITAsdGhpc30scy5wcm90b3R5cGUud3JhcD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9dGhpcy5fcmVhZGFibGVTdGF0ZSxhPSExO2Zvcih2YXIgbyBpbiBlLm9uKFwiZW5kXCIsZnVuY3Rpb24oKXtpZih4KFwid3JhcHBlZCBlbmRcIiksci5kZWNvZGVyJiYhci5lbmRlZCl7dmFyIGU9ci5kZWNvZGVyLmVuZCgpO2UmJmUubGVuZ3RoJiZ0LnB1c2goZSl9dC5wdXNoKG51bGwpfSksZS5vbihcImRhdGFcIixmdW5jdGlvbihuKXtpZigoeChcIndyYXBwZWQgZGF0YVwiKSxyLmRlY29kZXImJihuPXIuZGVjb2Rlci53cml0ZShuKSksIShyLm9iamVjdE1vZGUmJihudWxsPT09bnx8dm9pZCAwPT09bikpKSYmKHIub2JqZWN0TW9kZXx8biYmbi5sZW5ndGgpKXt2YXIgbz10LnB1c2gobik7b3x8KGE9ITAsZS5wYXVzZSgpKX19KSxlKXZvaWQgMD09PXRoaXNbb10mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGVbb10mJih0aGlzW29dPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlW3RdLmFwcGx5KGUsYXJndW1lbnRzKX19KG8pKTtmb3IodmFyIGk9MDtpPCQubGVuZ3RoO2krKyllLm9uKCRbaV0sdGhpcy5lbWl0LmJpbmQodGhpcywkW2ldKSk7cmV0dXJuIHRoaXMuX3JlYWQ9ZnVuY3Rpb24odCl7eChcIndyYXBwZWQgX3JlYWRcIix0KSxhJiYoYT0hMSxlLnJlc3VtZSgpKX0sdGhpc30sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYocy5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PUImJihCPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3JcIikpLEIodGhpcyl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcInJlYWRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcInJlYWRhYmxlRmxvd2luZ1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmd9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nPWUpfX0pLHMuX2Zyb21MaXN0PVQsT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwicmVhZGFibGVMZW5ndGhcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGh9fSksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYocy5mcm9tPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PVUmJihVPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvZnJvbVwiKSksVShzLHQsbil9KX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWw/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c6c2VsZjpnbG9iYWwpfSx7XCIuLi9lcnJvcnNcIjoxNSxcIi4vX3N0cmVhbV9kdXBsZXhcIjoxNixcIi4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvclwiOjIxLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0XCI6MjIsXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiOjIzLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb21cIjoyNSxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiOjI3LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjI4LF9wcm9jZXNzOjEyLGJ1ZmZlcjozLGV2ZW50czo3LGluaGVyaXRzOjEwLFwic3RyaW5nX2RlY29kZXIvXCI6MzEsdXRpbDoyfV0sMTk6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXt2YXIgbj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtuLnRyYW5zZm9ybWluZz0hMTt2YXIgcj1uLndyaXRlY2I7aWYobnVsbD09PXIpcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsbmV3IHMpO24ud3JpdGVjaHVuaz1udWxsLG4ud3JpdGVjYj1udWxsLG51bGwhPXQmJnRoaXMucHVzaCh0KSxyKGUpO3ZhciBhPXRoaXMuX3JlYWRhYmxlU3RhdGU7YS5yZWFkaW5nPSExLChhLm5lZWRSZWFkYWJsZXx8YS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrKSYmdGhpcy5fcmVhZChhLmhpZ2hXYXRlck1hcmspfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByP3ZvaWQodS5jYWxsKHRoaXMsZSksdGhpcy5fdHJhbnNmb3JtU3RhdGU9e2FmdGVyVHJhbnNmb3JtOm4uYmluZCh0aGlzKSxuZWVkVHJhbnNmb3JtOiExLHRyYW5zZm9ybWluZzohMSx3cml0ZWNiOm51bGwsd3JpdGVjaHVuazpudWxsLHdyaXRlZW5jb2Rpbmc6bnVsbH0sdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGU9ITAsdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jPSExLGUmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRyYW5zZm9ybSYmKHRoaXMuX3RyYW5zZm9ybT1lLnRyYW5zZm9ybSksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mbHVzaCYmKHRoaXMuX2ZsdXNoPWUuZmx1c2gpKSx0aGlzLm9uKFwicHJlZmluaXNoXCIsYSkpOm5ldyByKGUpfWZ1bmN0aW9uIGEoKXt2YXIgZT10aGlzO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMuX2ZsdXNofHx0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD9vKHRoaXMsbnVsbCxudWxsKTp0aGlzLl9mbHVzaChmdW5jdGlvbih0LG4pe28oZSx0LG4pfSl9ZnVuY3Rpb24gbyhlLHQsbil7aWYodClyZXR1cm4gZS5lbWl0KFwiZXJyb3JcIix0KTtpZihudWxsIT1uJiZlLnB1c2gobiksZS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpdGhyb3cgbmV3IGM7aWYoZS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKXRocm93IG5ldyBsO3JldHVybiBlLnB1c2gobnVsbCl9dC5leHBvcnRzPXI7dmFyIGk9ZShcIi4uL2Vycm9yc1wiKS5jb2RlcyxkPWkuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQscz1pLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxsPWkuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxjPWkuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wLHU9ZShcIi4vX3N0cmVhbV9kdXBsZXhcIik7ZShcImluaGVyaXRzXCIpKHIsdSksci5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtPSExLHUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLGUsdCl9LHIucHJvdG90eXBlLl90cmFuc2Zvcm09ZnVuY3Rpb24oZSx0LG4pe24obmV3IGQoXCJfdHJhbnNmb3JtKClcIikpfSxyLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMuX3RyYW5zZm9ybVN0YXRlO2lmKHIud3JpdGVjYj1uLHIud3JpdGVjaHVuaz1lLHIud3JpdGVlbmNvZGluZz10LCFyLnRyYW5zZm9ybWluZyl7dmFyIGE9dGhpcy5fcmVhZGFibGVTdGF0ZTsoci5uZWVkVHJhbnNmb3JtfHxhLm5lZWRSZWFkYWJsZXx8YS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrKSYmdGhpcy5fcmVhZChhLmhpZ2hXYXRlck1hcmspfX0sci5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl90cmFuc2Zvcm1TdGF0ZTtudWxsPT09ZS53cml0ZWNodW5rfHxlLnRyYW5zZm9ybWluZz9lLm5lZWRUcmFuc2Zvcm09ITA6KGUudHJhbnNmb3JtaW5nPSEwLHRoaXMuX3RyYW5zZm9ybShlLndyaXRlY2h1bmssZS53cml0ZWVuY29kaW5nLGUuYWZ0ZXJUcmFuc2Zvcm0pKX0sci5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt1LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsZSxmdW5jdGlvbihlKXt0KGUpfSl9fSx7XCIuLi9lcnJvcnNcIjoxNSxcIi4vX3N0cmVhbV9kdXBsZXhcIjoxNixpbmhlcml0czoxMH1dLDIwOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBhKGUpe3ZhciB0PXRoaXM7dGhpcy5uZXh0PW51bGwsdGhpcy5lbnRyeT1udWxsLHRoaXMuZmluaXNoPWZ1bmN0aW9uKCl7dih0LGUpfX1mdW5jdGlvbiBvKGUpe3JldHVybiB4LmZyb20oZSl9ZnVuY3Rpb24gaShlKXtyZXR1cm4geC5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIE59ZnVuY3Rpb24gZCgpe31mdW5jdGlvbiBzKHQsbixyKXtrPWt8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpLHQ9dHx8e30sXCJib29sZWFuXCIhPXR5cGVvZiByJiYocj1uIGluc3RhbmNlb2YgayksdGhpcy5vYmplY3RNb2RlPSEhdC5vYmplY3RNb2RlLHImJih0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIXQud3JpdGFibGVPYmplY3RNb2RlKSx0aGlzLmhpZ2hXYXRlck1hcms9UCh0aGlzLHQsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIixyKSx0aGlzLmZpbmFsQ2FsbGVkPSExLHRoaXMubmVlZERyYWluPSExLHRoaXMuZW5kaW5nPSExLHRoaXMuZW5kZWQ9ITEsdGhpcy5maW5pc2hlZD0hMSx0aGlzLmRlc3Ryb3llZD0hMTt2YXIgbz0hMT09PXQuZGVjb2RlU3RyaW5nczt0aGlzLmRlY29kZVN0cmluZ3M9IW8sdGhpcy5kZWZhdWx0RW5jb2Rpbmc9dC5kZWZhdWx0RW5jb2Rpbmd8fFwidXRmOFwiLHRoaXMubGVuZ3RoPTAsdGhpcy53cml0aW5nPSExLHRoaXMuY29ya2VkPTAsdGhpcy5zeW5jPSEwLHRoaXMuYnVmZmVyUHJvY2Vzc2luZz0hMSx0aGlzLm9ud3JpdGU9ZnVuY3Rpb24oZSl7bShuLGUpfSx0aGlzLndyaXRlY2I9bnVsbCx0aGlzLndyaXRlbGVuPTAsdGhpcy5idWZmZXJlZFJlcXVlc3Q9bnVsbCx0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCx0aGlzLnBlbmRpbmdjYj0wLHRoaXMucHJlZmluaXNoZWQ9ITEsdGhpcy5lcnJvckVtaXR0ZWQ9ITEsdGhpcy5lbWl0Q2xvc2U9ITEhPT10LmVtaXRDbG9zZSx0aGlzLmF1dG9EZXN0cm95PSEhdC5hdXRvRGVzdHJveSx0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50PTAsdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEodGhpcyl9ZnVuY3Rpb24gbCh0KXtrPWt8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpO3ZhciBuPXRoaXMgaW5zdGFuY2VvZiBrO3JldHVybiBufHxWLmNhbGwobCx0aGlzKT92b2lkKHRoaXMuX3dyaXRhYmxlU3RhdGU9bmV3IHModCx0aGlzLG4pLHRoaXMud3JpdGFibGU9ITAsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQud3JpdGUmJih0aGlzLl93cml0ZT10LndyaXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndyaXRldiYmKHRoaXMuX3dyaXRldj10LndyaXRldiksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiYodGhpcy5fZGVzdHJveT10LmRlc3Ryb3kpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZmluYWwmJih0aGlzLl9maW5hbD10LmZpbmFsKSksQS5jYWxsKHRoaXMpKTpuZXcgbCh0KX1mdW5jdGlvbiBjKGUsdCl7dmFyIHI9bmV3IFc7WShlLHIpLG4ubmV4dFRpY2sodCxyKX1mdW5jdGlvbiB1KGUsdCxyLGEpe3ZhciBvO3JldHVybiBudWxsPT09cj9vPW5ldyBxOlwic3RyaW5nXCIhPXR5cGVvZiByJiYhdC5vYmplY3RNb2RlJiYobz1uZXcgTyhcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIl0scikpLCFvfHwoWShlLG8pLG4ubmV4dFRpY2soYSxvKSwhMSl9ZnVuY3Rpb24gcChlLHQsbil7cmV0dXJuIGUub2JqZWN0TW9kZXx8ITE9PT1lLmRlY29kZVN0cmluZ3N8fFwic3RyaW5nXCIhPXR5cGVvZiB0fHwodD14LmZyb20odCxuKSksdH1mdW5jdGlvbiBmKGUsdCxuLHIsYSxvKXtpZighbil7dmFyIGk9cCh0LHIsYSk7ciE9PWkmJihuPSEwLGE9XCJidWZmZXJcIixyPWkpfXZhciBkPXQub2JqZWN0TW9kZT8xOnIubGVuZ3RoO3QubGVuZ3RoKz1kO3ZhciBzPXQubGVuZ3RoPHQuaGlnaFdhdGVyTWFyaztpZihzfHwodC5uZWVkRHJhaW49ITApLHQud3JpdGluZ3x8dC5jb3JrZWQpe3ZhciBsPXQubGFzdEJ1ZmZlcmVkUmVxdWVzdDt0Lmxhc3RCdWZmZXJlZFJlcXVlc3Q9e2NodW5rOnIsZW5jb2Rpbmc6YSxpc0J1ZjpuLGNhbGxiYWNrOm8sbmV4dDpudWxsfSxsP2wubmV4dD10Lmxhc3RCdWZmZXJlZFJlcXVlc3Q6dC5idWZmZXJlZFJlcXVlc3Q9dC5sYXN0QnVmZmVyZWRSZXF1ZXN0LHQuYnVmZmVyZWRSZXF1ZXN0Q291bnQrPTF9ZWxzZSBnKGUsdCwhMSxkLHIsYSxvKTtyZXR1cm4gc31mdW5jdGlvbiBnKGUsdCxuLHIsYSxvLGkpe3Qud3JpdGVsZW49cix0LndyaXRlY2I9aSx0LndyaXRpbmc9ITAsdC5zeW5jPSEwLHQuZGVzdHJveWVkP3Qub253cml0ZShuZXcgaihcIndyaXRlXCIpKTpuP2UuX3dyaXRldihhLHQub253cml0ZSk6ZS5fd3JpdGUoYSxvLHQub253cml0ZSksdC5zeW5jPSExfWZ1bmN0aW9uIF8oZSx0LHIsYSxvKXstLXQucGVuZGluZ2NiLHI/KG4ubmV4dFRpY2sobyxhKSxuLm5leHRUaWNrKFMsZSx0KSxlLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMCxZKGUsYSkpOihvKGEpLGUuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLFkoZSxhKSxTKGUsdCkpfWZ1bmN0aW9uIGgoZSl7ZS53cml0aW5nPSExLGUud3JpdGVjYj1udWxsLGUubGVuZ3RoLT1lLndyaXRlbGVuLGUud3JpdGVsZW49MH1mdW5jdGlvbiBtKGUsdCl7dmFyIHI9ZS5fd3JpdGFibGVTdGF0ZSxhPXIuc3luYyxvPXIud3JpdGVjYjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBvKXRocm93IG5ldyBCO2lmKGgociksdClfKGUscixhLHQsbyk7ZWxzZXt2YXIgaT1SKHIpfHxlLmRlc3Ryb3llZDtpfHxyLmNvcmtlZHx8ci5idWZmZXJQcm9jZXNzaW5nfHwhci5idWZmZXJlZFJlcXVlc3R8fEMoZSxyKSxhP24ubmV4dFRpY2soYixlLHIsaSxvKTpiKGUscixpLG8pfX1mdW5jdGlvbiBiKGUsdCxuLHIpe258fHkoZSx0KSx0LnBlbmRpbmdjYi0tLHIoKSxTKGUsdCl9ZnVuY3Rpb24geShlLHQpezA9PT10Lmxlbmd0aCYmdC5uZWVkRHJhaW4mJih0Lm5lZWREcmFpbj0hMSxlLmVtaXQoXCJkcmFpblwiKSl9ZnVuY3Rpb24gQyhlLHQpe3QuYnVmZmVyUHJvY2Vzc2luZz0hMDt2YXIgbj10LmJ1ZmZlcmVkUmVxdWVzdDtpZihlLl93cml0ZXYmJm4mJm4ubmV4dCl7dmFyIHI9dC5idWZmZXJlZFJlcXVlc3RDb3VudCxvPUFycmF5KHIpLGk9dC5jb3JrZWRSZXF1ZXN0c0ZyZWU7aS5lbnRyeT1uO2Zvcih2YXIgZD0wLHM9ITA7bjspb1tkXT1uLG4uaXNCdWZ8fChzPSExKSxuPW4ubmV4dCxkKz0xO28uYWxsQnVmZmVycz1zLGcoZSx0LCEwLHQubGVuZ3RoLG8sXCJcIixpLmZpbmlzaCksdC5wZW5kaW5nY2IrKyx0Lmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCxpLm5leHQ/KHQuY29ya2VkUmVxdWVzdHNGcmVlPWkubmV4dCxpLm5leHQ9bnVsbCk6dC5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEodCksdC5idWZmZXJlZFJlcXVlc3RDb3VudD0wfWVsc2V7Zm9yKDtuOyl7dmFyIGw9bi5jaHVuayxjPW4uZW5jb2RpbmcsdT1uLmNhbGxiYWNrLHA9dC5vYmplY3RNb2RlPzE6bC5sZW5ndGg7aWYoZyhlLHQsITEscCxsLGMsdSksbj1uLm5leHQsdC5idWZmZXJlZFJlcXVlc3RDb3VudC0tLHQud3JpdGluZylicmVha31udWxsPT09biYmKHQubGFzdEJ1ZmZlcmVkUmVxdWVzdD1udWxsKX10LmJ1ZmZlcmVkUmVxdWVzdD1uLHQuYnVmZmVyUHJvY2Vzc2luZz0hMX1mdW5jdGlvbiBSKGUpe3JldHVybiBlLmVuZGluZyYmMD09PWUubGVuZ3RoJiZudWxsPT09ZS5idWZmZXJlZFJlcXVlc3QmJiFlLmZpbmlzaGVkJiYhZS53cml0aW5nfWZ1bmN0aW9uIEUoZSx0KXtlLl9maW5hbChmdW5jdGlvbihuKXt0LnBlbmRpbmdjYi0tLG4mJlkoZSxuKSx0LnByZWZpbmlzaGVkPSEwLGUuZW1pdChcInByZWZpbmlzaFwiKSxTKGUsdCl9KX1mdW5jdGlvbiB3KGUsdCl7dC5wcmVmaW5pc2hlZHx8dC5maW5hbENhbGxlZHx8KFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUuX2ZpbmFsfHx0LmRlc3Ryb3llZD8odC5wcmVmaW5pc2hlZD0hMCxlLmVtaXQoXCJwcmVmaW5pc2hcIikpOih0LnBlbmRpbmdjYisrLHQuZmluYWxDYWxsZWQ9ITAsbi5uZXh0VGljayhFLGUsdCkpKX1mdW5jdGlvbiBTKGUsdCl7dmFyIG49Uih0KTtpZihuJiYodyhlLHQpLDA9PT10LnBlbmRpbmdjYiYmKHQuZmluaXNoZWQ9ITAsZS5lbWl0KFwiZmluaXNoXCIpLHQuYXV0b0Rlc3Ryb3kpKSl7dmFyIHI9ZS5fcmVhZGFibGVTdGF0ZTsoIXJ8fHIuYXV0b0Rlc3Ryb3kmJnIuZW5kRW1pdHRlZCkmJmUuZGVzdHJveSgpfXJldHVybiBufWZ1bmN0aW9uIFQoZSx0LHIpe3QuZW5kaW5nPSEwLFMoZSx0KSxyJiYodC5maW5pc2hlZD9uLm5leHRUaWNrKHIpOmUub25jZShcImZpbmlzaFwiLHIpKSx0LmVuZGVkPSEwLGUud3JpdGFibGU9ITF9ZnVuY3Rpb24gdihlLHQsbil7dmFyIHI9ZS5lbnRyeTtmb3IoZS5lbnRyeT1udWxsO3I7KXt2YXIgYT1yLmNhbGxiYWNrO3QucGVuZGluZ2NiLS0sYShuKSxyPXIubmV4dH10LmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0PWV9dC5leHBvcnRzPWw7dmFyIGs7bC5Xcml0YWJsZVN0YXRlPXM7dmFyIEw9e2RlcHJlY2F0ZTplKFwidXRpbC1kZXByZWNhdGVcIil9LEE9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIikseD1lKFwiYnVmZmVyXCIpLkJ1ZmZlcixOPXIuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9LEQ9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XCIpLEk9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiKSxQPUkuZ2V0SGlnaFdhdGVyTWFyayxNPWUoXCIuLi9lcnJvcnNcIikuY29kZXMsTz1NLkVSUl9JTlZBTElEX0FSR19UWVBFLEY9TS5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxCPU0uRVJSX01VTFRJUExFX0NBTExCQUNLLFU9TS5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLGo9TS5FUlJfU1RSRUFNX0RFU1RST1lFRCxxPU0uRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxXPU0uRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsSD1NLkVSUl9VTktOT1dOX0VOQ09ESU5HLFk9RC5lcnJvck9yRGVzdHJveTtlKFwiaW5oZXJpdHNcIikobCxBKSxzLnByb3RvdHlwZS5nZXRCdWZmZXI9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5idWZmZXJlZFJlcXVlc3QsdD1bXTtlOyl0LnB1c2goZSksZT1lLm5leHQ7cmV0dXJuIHR9LGZ1bmN0aW9uKCl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcImJ1ZmZlclwiLHtnZXQ6TC5kZXByZWNhdGUoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCdWZmZXIoKX0sXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBpbnN0ZWFkLlwiLFwiREVQMDAwM1wiKX0pfWNhdGNoKGUpe319KCk7dmFyIFY7XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaGFzSW5zdGFuY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdPyhWPUZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuISFWLmNhbGwodGhpcyxlKXx8ISh0aGlzIT09bCkmJmUmJmUuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBzfX0pKTpWPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgdGhpc30sbC5wcm90b3R5cGUucGlwZT1mdW5jdGlvbigpe1kodGhpcyxuZXcgVSl9LGwucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLl93cml0YWJsZVN0YXRlLGE9ITEscz0hci5vYmplY3RNb2RlJiZpKGUpO3JldHVybiBzJiYheC5pc0J1ZmZlcihlKSYmKGU9byhlKSksXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHM/dD1cImJ1ZmZlclwiOiF0JiYodD1yLmRlZmF1bHRFbmNvZGluZyksXCJmdW5jdGlvblwiIT10eXBlb2YgbiYmKG49ZCksci5lbmRpbmc/Yyh0aGlzLG4pOihzfHx1KHRoaXMscixlLG4pKSYmKHIucGVuZGluZ2NiKyssYT1mKHRoaXMscixzLGUsdCxuKSksYX0sbC5wcm90b3R5cGUuY29yaz1mdW5jdGlvbigpe3RoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKyt9LGwucHJvdG90eXBlLnVuY29yaz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3dyaXRhYmxlU3RhdGU7ZS5jb3JrZWQmJihlLmNvcmtlZC0tLCFlLndyaXRpbmcmJiFlLmNvcmtlZCYmIWUuYnVmZmVyUHJvY2Vzc2luZyYmZS5idWZmZXJlZFJlcXVlc3QmJkModGhpcyxlKSl9LGwucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZz1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZS50b0xvd2VyQ2FzZSgpKSwhKC0xPFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigoZStcIlwiKS50b0xvd2VyQ2FzZSgpKSkpdGhyb3cgbmV3IEgoZSk7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nPWUsdGhpc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVCdWZmZXJcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrfX0pLGwucHJvdG90eXBlLl93cml0ZT1mdW5jdGlvbihlLHQsbil7bihuZXcgRihcIl93cml0ZSgpXCIpKX0sbC5wcm90b3R5cGUuX3dyaXRldj1udWxsLGwucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5fd3JpdGFibGVTdGF0ZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlPyhuPWUsZT1udWxsLHQ9bnVsbCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLG51bGwhPT1lJiZ2b2lkIDAhPT1lJiZ0aGlzLndyaXRlKGUsdCksci5jb3JrZWQmJihyLmNvcmtlZD0xLHRoaXMudW5jb3JrKCkpLHIuZW5kaW5nfHxUKHRoaXMscixuKSx0aGlzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJ3cml0YWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt0aGlzLl93cml0YWJsZVN0YXRlJiYodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSl9fSksbC5wcm90b3R5cGUuZGVzdHJveT1ELmRlc3Ryb3ksbC5wcm90b3R5cGUuX3VuZGVzdHJveT1ELnVuZGVzdHJveSxsLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbihlLHQpe3QoZSl9fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHtcIi4uL2Vycm9yc1wiOjE1LFwiLi9fc3RyZWFtX2R1cGxleFwiOjE2LFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIjoyMyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiOjI3LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjI4LF9wcm9jZXNzOjEyLGJ1ZmZlcjozLGluaGVyaXRzOjEwLFwidXRpbC1kZXByZWNhdGVcIjozMn1dLDIxOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gYShlLHQpe3JldHVybnt2YWx1ZTplLGRvbmU6dH19ZnVuY3Rpb24gbyhlKXt2YXIgdD1lW2NdO2lmKG51bGwhPT10KXt2YXIgbj1lW2hdLnJlYWQoKTtudWxsIT09biYmKGVbZ109bnVsbCxlW2NdPW51bGwsZVt1XT1udWxsLHQoYShuLCExKSkpfX1mdW5jdGlvbiBpKGUpe24ubmV4dFRpY2sobyxlKX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4scil7ZS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHRbZl0/dm9pZCBuKGEodm9pZCAwLCEwKSk6dm9pZCB0W19dKG4scil9LHIpfX12YXIgcyxsPWUoXCIuL2VuZC1vZi1zdHJlYW1cIiksYz1TeW1ib2woXCJsYXN0UmVzb2x2ZVwiKSx1PVN5bWJvbChcImxhc3RSZWplY3RcIikscD1TeW1ib2woXCJlcnJvclwiKSxmPVN5bWJvbChcImVuZGVkXCIpLGc9U3ltYm9sKFwibGFzdFByb21pc2VcIiksXz1TeW1ib2woXCJoYW5kbGVQcm9taXNlXCIpLGg9U3ltYm9sKFwic3RyZWFtXCIpLG09T2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKCl7fSksYj1PYmplY3Quc2V0UHJvdG90eXBlT2YoKHM9e2dldCBzdHJlYW0oKXtyZXR1cm4gdGhpc1toXX0sbmV4dDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzW3BdO2lmKG51bGwhPT10KXJldHVybiBQcm9taXNlLnJlamVjdCh0KTtpZih0aGlzW2ZdKXJldHVybiBQcm9taXNlLnJlc29sdmUoYSh2b2lkIDAsITApKTtpZih0aGlzW2hdLmRlc3Ryb3llZClyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXtuLm5leHRUaWNrKGZ1bmN0aW9uKCl7ZVtwXT9yKGVbcF0pOnQoYSh2b2lkIDAsITApKX0pfSk7dmFyIHIsbz10aGlzW2ddO2lmKG8pcj1uZXcgUHJvbWlzZShkKG8sdGhpcykpO2Vsc2V7dmFyIGk9dGhpc1toXS5yZWFkKCk7aWYobnVsbCE9PWkpcmV0dXJuIFByb21pc2UucmVzb2x2ZShhKGksITEpKTtyPW5ldyBQcm9taXNlKHRoaXNbX10pfXJldHVybiB0aGlzW2ddPXIscn19LHIocyxTeW1ib2wuYXN5bmNJdGVyYXRvcixmdW5jdGlvbigpe3JldHVybiB0aGlzfSkscihzLFwicmV0dXJuXCIsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LG4pe2VbaF0uZGVzdHJveShudWxsLGZ1bmN0aW9uKGUpe3JldHVybiBlP3ZvaWQgbihlKTp2b2lkIHQoYSh2b2lkIDAsITApKX0pfSl9KSxzKSxtKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQsbj1PYmplY3QuY3JlYXRlKGIsKHQ9e30scih0LGgse3ZhbHVlOmUsd3JpdGFibGU6ITB9KSxyKHQsYyx7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pLHIodCx1LHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSkscih0LHAse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KSxyKHQsZix7dmFsdWU6ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLHdyaXRhYmxlOiEwfSkscih0LF8se3ZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bltoXS5yZWFkKCk7cj8obltnXT1udWxsLG5bY109bnVsbCxuW3VdPW51bGwsZShhKHIsITEpKSk6KG5bY109ZSxuW3VdPXQpfSx3cml0YWJsZTohMH0pLHQpKTtyZXR1cm4gbltnXT1udWxsLGwoZSxmdW5jdGlvbihlKXtpZihlJiZcIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIhPT1lLmNvZGUpe3ZhciB0PW5bdV07cmV0dXJuIG51bGwhPT10JiYobltnXT1udWxsLG5bY109bnVsbCxuW3VdPW51bGwsdChlKSksdm9pZChuW3BdPWUpfXZhciByPW5bY107bnVsbCE9PXImJihuW2ddPW51bGwsbltjXT1udWxsLG5bdV09bnVsbCxyKGEodm9pZCAwLCEwKSkpLG5bZl09ITB9KSxlLm9uKFwicmVhZGFibGVcIixpLmJpbmQobnVsbCxuKSksbn19KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSl9LHtcIi4vZW5kLW9mLXN0cmVhbVwiOjI0LF9wcm9jZXNzOjEyfV0sMjI6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihyPXIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiByKGUpe2Zvcih2YXIgdCxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0PW51bGw9PWFyZ3VtZW50c1tyXT97fTphcmd1bWVudHNbcl0sciUyP24oT2JqZWN0KHQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2EoZSxuLHRbbl0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSk6bihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbikpfSk7cmV0dXJuIGV9ZnVuY3Rpb24gYShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbixyPTA7cjx0Lmxlbmd0aDtyKyspbj10W3JdLG4uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX1mdW5jdGlvbiBkKGUsdCxuKXtyZXR1cm4gdCYmaShlLnByb3RvdHlwZSx0KSxuJiZpKGUsbiksZX1mdW5jdGlvbiBzKGUsdCxuKXt1LnByb3RvdHlwZS5jb3B5LmNhbGwoZSx0LG4pfXZhciBsPWUoXCJidWZmZXJcIiksdT1sLkJ1ZmZlcixwPWUoXCJ1dGlsXCIpLGY9cC5pbnNwZWN0LGc9ZiYmZi5jdXN0b218fFwiaW5zcGVjdFwiO3QuZXhwb3J0cz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtvKHRoaXMsZSksdGhpcy5oZWFkPW51bGwsdGhpcy50YWlsPW51bGwsdGhpcy5sZW5ndGg9MH1yZXR1cm4gZChlLFt7a2V5OlwicHVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXtkYXRhOmUsbmV4dDpudWxsfTswPHRoaXMubGVuZ3RoP3RoaXMudGFpbC5uZXh0PXQ6dGhpcy5oZWFkPXQsdGhpcy50YWlsPXQsKyt0aGlzLmxlbmd0aH19LHtrZXk6XCJ1bnNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e2RhdGE6ZSxuZXh0OnRoaXMuaGVhZH07MD09PXRoaXMubGVuZ3RoJiYodGhpcy50YWlsPXQpLHRoaXMuaGVhZD10LCsrdGhpcy5sZW5ndGh9fSx7a2V5Olwic2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKDAhPT10aGlzLmxlbmd0aCl7dmFyIGU9dGhpcy5oZWFkLmRhdGE7cmV0dXJuIHRoaXMuaGVhZD0xPT09dGhpcy5sZW5ndGg/dGhpcy50YWlsPW51bGw6dGhpcy5oZWFkLm5leHQsLS10aGlzLmxlbmd0aCxlfX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsLHRoaXMubGVuZ3RoPTB9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm5cIlwiO2Zvcih2YXIgdD10aGlzLmhlYWQsbj1cIlwiK3QuZGF0YTt0PXQubmV4dDspbis9ZSt0LmRhdGE7cmV0dXJuIG59fSx7a2V5OlwiY29uY2F0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoMD09PXRoaXMubGVuZ3RoKXJldHVybiB1LmFsbG9jKDApO2Zvcih2YXIgdD11LmFsbG9jVW5zYWZlKGU+Pj4wKSxuPXRoaXMuaGVhZCxyPTA7bjspcyhuLmRhdGEsdCxyKSxyKz1uLmRhdGEubGVuZ3RoLG49bi5uZXh0O3JldHVybiB0fX0se2tleTpcImNvbnN1bWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuO3JldHVybiBlPHRoaXMuaGVhZC5kYXRhLmxlbmd0aD8obj10aGlzLmhlYWQuZGF0YS5zbGljZSgwLGUpLHRoaXMuaGVhZC5kYXRhPXRoaXMuaGVhZC5kYXRhLnNsaWNlKGUpKTplPT09dGhpcy5oZWFkLmRhdGEubGVuZ3RoP249dGhpcy5zaGlmdCgpOm49dD90aGlzLl9nZXRTdHJpbmcoZSk6dGhpcy5fZ2V0QnVmZmVyKGUpLG59fSx7a2V5OlwiZmlyc3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQuZGF0YX19LHtrZXk6XCJfZ2V0U3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5oZWFkLHI9MSxhPXQuZGF0YTtmb3IoZS09YS5sZW5ndGg7dD10Lm5leHQ7KXt2YXIgbz10LmRhdGEsaT1lPm8ubGVuZ3RoP28ubGVuZ3RoOmU7aWYoYSs9aT09PW8ubGVuZ3RoP286by5zbGljZSgwLGUpLGUtPWksMD09PWUpe2k9PT1vLmxlbmd0aD8oKytyLHRoaXMuaGVhZD10Lm5leHQ/dC5uZXh0OnRoaXMudGFpbD1udWxsKToodGhpcy5oZWFkPXQsdC5kYXRhPW8uc2xpY2UoaSkpO2JyZWFrfSsrcn1yZXR1cm4gdGhpcy5sZW5ndGgtPXIsYX19LHtrZXk6XCJfZ2V0QnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dS5hbGxvY1Vuc2FmZShlKSxyPXRoaXMuaGVhZCxhPTE7Zm9yKHIuZGF0YS5jb3B5KHQpLGUtPXIuZGF0YS5sZW5ndGg7cj1yLm5leHQ7KXt2YXIgbz1yLmRhdGEsaT1lPm8ubGVuZ3RoP28ubGVuZ3RoOmU7aWYoby5jb3B5KHQsdC5sZW5ndGgtZSwwLGkpLGUtPWksMD09PWUpe2k9PT1vLmxlbmd0aD8oKythLHRoaXMuaGVhZD1yLm5leHQ/ci5uZXh0OnRoaXMudGFpbD1udWxsKToodGhpcy5oZWFkPXIsci5kYXRhPW8uc2xpY2UoaSkpO2JyZWFrfSsrYX1yZXR1cm4gdGhpcy5sZW5ndGgtPWEsdH19LHtrZXk6Zyx2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBmKHRoaXMscih7fSx0LHtkZXB0aDowLGN1c3RvbUluc3BlY3Q6ITF9KSl9fV0pLGV9KCl9LHtidWZmZXI6Myx1dGlsOjJ9XSwyMzpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXthKGUsdCkscihlKX1mdW5jdGlvbiByKGUpe2UuX3dyaXRhYmxlU3RhdGUmJiFlLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZXx8ZS5fcmVhZGFibGVTdGF0ZSYmIWUuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlfHxlLmVtaXQoXCJjbG9zZVwiKX1mdW5jdGlvbiBhKGUsdCl7ZS5lbWl0KFwiZXJyb3JcIix0KX10LmV4cG9ydHM9e2Rlc3Ryb3k6ZnVuY3Rpb24odCxvKXt2YXIgaT10aGlzLGQ9dGhpcy5fcmVhZGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQscz10aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtyZXR1cm4gZHx8cz8obz9vKHQpOnQmJih0aGlzLl93cml0YWJsZVN0YXRlPyF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLGUubmV4dFRpY2soYSx0aGlzLHQpKTplLm5leHRUaWNrKGEsdGhpcyx0KSksdGhpcyk6KHRoaXMuX3JlYWRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD0hMCksdGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPSEwKSx0aGlzLl9kZXN0cm95KHR8fG51bGwsZnVuY3Rpb24odCl7IW8mJnQ/aS5fd3JpdGFibGVTdGF0ZT9pLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD9lLm5leHRUaWNrKHIsaSk6KGkuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLGUubmV4dFRpY2sobixpLHQpKTplLm5leHRUaWNrKG4saSx0KTpvPyhlLm5leHRUaWNrKHIsaSksbyh0KSk6ZS5uZXh0VGljayhyLGkpfSksdGhpcyl9LHVuZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuX3JlYWRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmc9ITEsdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZD0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ9ITEpLHRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSExKX0sZXJyb3JPckRlc3Ryb3k6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLl9yZWFkYWJsZVN0YXRlLHI9ZS5fd3JpdGFibGVTdGF0ZTtuJiZuLmF1dG9EZXN0cm95fHxyJiZyLmF1dG9EZXN0cm95P2UuZGVzdHJveSh0KTplLmVtaXQoXCJlcnJvclwiLHQpfX19KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSl9LHtfcHJvY2VzczoxMn1dLDI0OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3ZhciB0PSExO3JldHVybiBmdW5jdGlvbigpe2lmKCF0KXt0PSEwO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9QXJyYXkobiksYT0wO2E8bjthKyspclthXT1hcmd1bWVudHNbYV07ZS5hcHBseSh0aGlzLHIpfX19ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBhKGUpe3JldHVybiBlLnNldEhlYWRlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hYm9ydH1mdW5jdGlvbiBvKGUsdCxkKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXJldHVybiBvKGUsbnVsbCx0KTt0fHwodD17fSksZD1uKGR8fHIpO3ZhciBzPXQucmVhZGFibGV8fCExIT09dC5yZWFkYWJsZSYmZS5yZWFkYWJsZSxsPXQud3JpdGFibGV8fCExIT09dC53cml0YWJsZSYmZS53cml0YWJsZSxjPWZ1bmN0aW9uKCl7ZS53cml0YWJsZXx8cCgpfSx1PWUuX3dyaXRhYmxlU3RhdGUmJmUuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQscD1mdW5jdGlvbigpe2w9ITEsdT0hMCxzfHxkLmNhbGwoZSl9LGY9ZS5fcmVhZGFibGVTdGF0ZSYmZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLGc9ZnVuY3Rpb24oKXtzPSExLGY9ITAsbHx8ZC5jYWxsKGUpfSxfPWZ1bmN0aW9uKHQpe2QuY2FsbChlLHQpfSxoPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHMmJiFmPyhlLl9yZWFkYWJsZVN0YXRlJiZlLl9yZWFkYWJsZVN0YXRlLmVuZGVkfHwodD1uZXcgaSksZC5jYWxsKGUsdCkpOmwmJiF1PyhlLl93cml0YWJsZVN0YXRlJiZlLl93cml0YWJsZVN0YXRlLmVuZGVkfHwodD1uZXcgaSksZC5jYWxsKGUsdCkpOnZvaWQgMH0sbT1mdW5jdGlvbigpe2UucmVxLm9uKFwiZmluaXNoXCIscCl9O3JldHVybiBhKGUpPyhlLm9uKFwiY29tcGxldGVcIixwKSxlLm9uKFwiYWJvcnRcIixoKSxlLnJlcT9tKCk6ZS5vbihcInJlcXVlc3RcIixtKSk6bCYmIWUuX3dyaXRhYmxlU3RhdGUmJihlLm9uKFwiZW5kXCIsYyksZS5vbihcImNsb3NlXCIsYykpLGUub24oXCJlbmRcIixnKSxlLm9uKFwiZmluaXNoXCIscCksITEhPT10LmVycm9yJiZlLm9uKFwiZXJyb3JcIixfKSxlLm9uKFwiY2xvc2VcIixoKSxmdW5jdGlvbigpe2UucmVtb3ZlTGlzdGVuZXIoXCJjb21wbGV0ZVwiLHApLGUucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLGgpLGUucmVtb3ZlTGlzdGVuZXIoXCJyZXF1ZXN0XCIsbSksZS5yZXEmJmUucmVxLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIscCksZS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGMpLGUucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGMpLGUucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixwKSxlLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsZyksZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsXyksZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsaCl9fXZhciBpPWUoXCIuLi8uLi8uLi9lcnJvcnNcIikuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7dC5leHBvcnRzPW99LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1fV0sMjU6W2Z1bmN0aW9uKGUsdCl7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyXCIpfX0se31dLDI2OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3ZhciB0PSExO3JldHVybiBmdW5jdGlvbigpe3R8fCh0PSEwLGUuYXBwbHkodm9pZCAwLGFyZ3VtZW50cykpfX1mdW5jdGlvbiByKGUpe2lmKGUpdGhyb3cgZX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLnNldEhlYWRlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hYm9ydH1mdW5jdGlvbiBvKHQscixvLGkpe2k9bihpKTt2YXIgZD0hMTt0Lm9uKFwiY2xvc2VcIixmdW5jdGlvbigpe2Q9ITB9KSxsPT09dm9pZCAwJiYobD1lKFwiLi9lbmQtb2Ytc3RyZWFtXCIpKSxsKHQse3JlYWRhYmxlOnIsd3JpdGFibGU6b30sZnVuY3Rpb24oZSl7cmV0dXJuIGU/aShlKTp2b2lkKGQ9ITAsaSgpKX0pO3ZhciBzPSExO3JldHVybiBmdW5jdGlvbihlKXtpZighZClyZXR1cm4gcz92b2lkIDA6KHM9ITAsYSh0KT90LmFib3J0KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95P3QuZGVzdHJveSgpOnZvaWQgaShlfHxuZXcgcChcInBpcGVcIikpKX19ZnVuY3Rpb24gaShlKXtlKCl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBlLnBpcGUodCl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5sZW5ndGg/XCJmdW5jdGlvblwiPT10eXBlb2YgZVtlLmxlbmd0aC0xXT9lLnBvcCgpOnI6cn12YXIgbCxjPWUoXCIuLi8uLi8uLi9lcnJvcnNcIikuY29kZXMsdT1jLkVSUl9NSVNTSU5HX0FSR1MscD1jLkVSUl9TVFJFQU1fREVTVFJPWUVEO3QuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkoZSksbj0wO248ZTtuKyspdFtuXT1hcmd1bWVudHNbbl07dmFyIHI9cyh0KTtpZihBcnJheS5pc0FycmF5KHRbMF0pJiYodD10WzBdKSwyPnQubGVuZ3RoKXRocm93IG5ldyB1KFwic3RyZWFtc1wiKTt2YXIgYSxsPXQubWFwKGZ1bmN0aW9uKGUsbil7dmFyIGQ9bjx0Lmxlbmd0aC0xO3JldHVybiBvKGUsZCwwPG4sZnVuY3Rpb24oZSl7YXx8KGE9ZSksZSYmbC5mb3JFYWNoKGkpLGR8fChsLmZvckVhY2goaSkscihhKSl9KX0pO3JldHVybiB0LnJlZHVjZShkKX19LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1LFwiLi9lbmQtb2Ytc3RyZWFtXCI6MjR9XSwyNzpbZnVuY3Rpb24oZSxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlLHQsbil7cmV0dXJuIG51bGw9PWUuaGlnaFdhdGVyTWFyaz90P2Vbbl06bnVsbDplLmhpZ2hXYXRlck1hcmt9dmFyIGE9ZShcIi4uLy4uLy4uL2Vycm9yc1wiKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7bi5leHBvcnRzPXtnZXRIaWdoV2F0ZXJNYXJrOmZ1bmN0aW9uKGUsbixvLGkpe3ZhciBkPXIobixpLG8pO2lmKG51bGwhPWQpe2lmKCEoaXNGaW5pdGUoZCkmJnQoZCk9PT1kKXx8MD5kKXt2YXIgcz1pP286XCJoaWdoV2F0ZXJNYXJrXCI7dGhyb3cgbmV3IGEocyxkKX1yZXR1cm4gdChkKX1yZXR1cm4gZS5vYmplY3RNb2RlPzE2OjE2Mzg0fX19LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1fV0sMjg6W2Z1bmN0aW9uKGUsdCl7dC5leHBvcnRzPWUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyfSx7ZXZlbnRzOjd9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe249dC5leHBvcnRzPWUoXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXCIpLG4uU3RyZWFtPW4sbi5SZWFkYWJsZT1uLG4uV3JpdGFibGU9ZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIiksbi5EdXBsZXg9ZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpLG4uVHJhbnNmb3JtPWUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKSxuLlBhc3NUaHJvdWdoPWUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpLG4uZmluaXNoZWQ9ZShcIi4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qc1wiKSxuLnBpcGVsaW5lPWUoXCIuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzXCIpfSx7XCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiOjE2LFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiOjE3LFwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1wiOjE4LFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIjoxOSxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIjoyMCxcIi4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qc1wiOjI0LFwiLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qc1wiOjI2fV0sMzA6W2Z1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiBpKGUsdCxuKX0vKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi92YXIgbz1lKFwiYnVmZmVyXCIpLGk9by5CdWZmZXI7aS5mcm9tJiZpLmFsbG9jJiZpLmFsbG9jVW5zYWZlJiZpLmFsbG9jVW5zYWZlU2xvdz90LmV4cG9ydHM9bzoocihvLG4pLG4uQnVmZmVyPWEpLGEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLHIoaSxhKSxhLmZyb209ZnVuY3Rpb24oZSx0LG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gaShlLHQsbil9LGEuYWxsb2M9ZnVuY3Rpb24oZSx0LG4pe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3ZhciByPWkoZSk7cmV0dXJuIHZvaWQgMD09PXQ/ci5maWxsKDApOlwic3RyaW5nXCI9PXR5cGVvZiBuP3IuZmlsbCh0LG4pOnIuZmlsbCh0KSxyfSxhLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3JldHVybiBpKGUpfSxhLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gby5TbG93QnVmZmVyKGUpfX0se2J1ZmZlcjozfV0sMzE6W2Z1bmN0aW9uKGUsdCxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXtpZighZSlyZXR1cm5cInV0ZjhcIjtmb3IodmFyIHQ7Oylzd2l0Y2goZSl7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiBlO2RlZmF1bHQ6aWYodClyZXR1cm47ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpLHQ9ITA7fX1mdW5jdGlvbiBhKGUpe3ZhciB0PXIoZSk7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihtLmlzRW5jb2Rpbmc9PT1ifHwhYihlKSkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7cmV0dXJuIHR8fGV9ZnVuY3Rpb24gbyhlKXt0aGlzLmVuY29kaW5nPWEoZSk7dmFyIHQ7c3dpdGNoKHRoaXMuZW5jb2Rpbmcpe2Nhc2VcInV0ZjE2bGVcIjp0aGlzLnRleHQ9dSx0aGlzLmVuZD1wLHQ9NDticmVhaztjYXNlXCJ1dGY4XCI6dGhpcy5maWxsTGFzdD1jLHQ9NDticmVhaztjYXNlXCJiYXNlNjRcIjp0aGlzLnRleHQ9Zix0aGlzLmVuZD1nLHQ9MzticmVhaztkZWZhdWx0OnJldHVybiB0aGlzLndyaXRlPV8sdm9pZCh0aGlzLmVuZD1oKTt9dGhpcy5sYXN0TmVlZD0wLHRoaXMubGFzdFRvdGFsPTAsdGhpcy5sYXN0Q2hhcj1tLmFsbG9jVW5zYWZlKHQpfWZ1bmN0aW9uIGQoZSl7aWYoMTI3Pj1lKXJldHVybiAwO3JldHVybiA2PT1lPj41PzI6MTQ9PWU+PjQ/MzozMD09ZT4+Mz80OjI9PWU+PjY/LTE6LTJ9ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9dC5sZW5ndGgtMTtpZihyPG4pcmV0dXJuIDA7dmFyIGE9ZCh0W3JdKTtyZXR1cm4gMDw9YT8oMDxhJiYoZS5sYXN0TmVlZD1hLTEpLGEpOi0tcjxufHwtMj09PWE/MDooYT1kKHRbcl0pLDA8PWEpPygwPGEmJihlLmxhc3ROZWVkPWEtMiksYSk6LS1yPG58fC0yPT09YT8wOihhPWQodFtyXSksMDw9YT8oMDxhJiYoMj09PWE/YT0wOmUubGFzdE5lZWQ9YS0zKSxhKTowKX1mdW5jdGlvbiBsKGUsdCl7aWYoMTI4IT0oMTkyJnRbMF0pKXJldHVybiBlLmxhc3ROZWVkPTAsXCJcXHVGRkZEXCI7aWYoMTxlLmxhc3ROZWVkJiYxPHQubGVuZ3RoKXtpZigxMjghPSgxOTImdFsxXSkpcmV0dXJuIGUubGFzdE5lZWQ9MSxcIlxcdUZGRkRcIjtpZigyPGUubGFzdE5lZWQmJjI8dC5sZW5ndGgmJjEyOCE9KDE5MiZ0WzJdKSlyZXR1cm4gZS5sYXN0TmVlZD0yLFwiXFx1RkZGRFwifX1mdW5jdGlvbiBjKGUpe3ZhciB0PXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsbj1sKHRoaXMsZSx0KTtyZXR1cm4gdm9pZCAwPT09bj90aGlzLmxhc3ROZWVkPD1lLmxlbmd0aD8oZS5jb3B5KHRoaXMubGFzdENoYXIsdCwwLHRoaXMubGFzdE5lZWQpLHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKSk6dm9pZChlLmNvcHkodGhpcy5sYXN0Q2hhcix0LDAsZS5sZW5ndGgpLHRoaXMubGFzdE5lZWQtPWUubGVuZ3RoKTpufWZ1bmN0aW9uIHUoZSx0KXtpZigwPT0oZS5sZW5ndGgtdCklMil7dmFyIG49ZS50b1N0cmluZyhcInV0ZjE2bGVcIix0KTtpZihuKXt2YXIgcj1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSk7aWYoNTUyOTY8PXImJjU2MzE5Pj1yKXJldHVybiB0aGlzLmxhc3ROZWVkPTIsdGhpcy5sYXN0VG90YWw9NCx0aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT1lW2UubGVuZ3RoLTFdLG4uc2xpY2UoMCwtMSl9cmV0dXJuIG59cmV0dXJuIHRoaXMubGFzdE5lZWQ9MSx0aGlzLmxhc3RUb3RhbD0yLHRoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0xXSxlLnRvU3RyaW5nKFwidXRmMTZsZVwiLHQsZS5sZW5ndGgtMSl9ZnVuY3Rpb24gcChlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7aWYodGhpcy5sYXN0TmVlZCl7dmFyIG49dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDtyZXR1cm4gdCt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwidXRmMTZsZVwiLDAsbil9cmV0dXJuIHR9ZnVuY3Rpb24gZihlLHQpe3ZhciByPShlLmxlbmd0aC10KSUzO3JldHVybiAwPT1yP2UudG9TdHJpbmcoXCJiYXNlNjRcIix0KToodGhpcy5sYXN0TmVlZD0zLXIsdGhpcy5sYXN0VG90YWw9MywxPT1yP3RoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0xXToodGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTJdLHRoaXMubGFzdENoYXJbMV09ZVtlLmxlbmd0aC0xXSksZS50b1N0cmluZyhcImJhc2U2NFwiLHQsZS5sZW5ndGgtcikpfWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwiO3JldHVybiB0aGlzLmxhc3ROZWVkP3QrdGhpcy5sYXN0Q2hhci50b1N0cmluZyhcImJhc2U2NFwiLDAsMy10aGlzLmxhc3ROZWVkKTp0fWZ1bmN0aW9uIF8oZSl7cmV0dXJuIGUudG9TdHJpbmcodGhpcy5lbmNvZGluZyl9ZnVuY3Rpb24gaChlKXtyZXR1cm4gZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwifXZhciBtPWUoXCJzYWZlLWJ1ZmZlclwiKS5CdWZmZXIsYj1tLmlzRW5jb2Rpbmd8fGZ1bmN0aW9uKGUpe3N3aXRjaChlPVwiXCIrZSxlJiZlLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6Y2FzZVwicmF3XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMTt9fTtuLlN0cmluZ0RlY29kZXI9byxvLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjt2YXIgdCxuO2lmKHRoaXMubGFzdE5lZWQpe2lmKHQ9dGhpcy5maWxsTGFzdChlKSx2b2lkIDA9PT10KXJldHVyblwiXCI7bj10aGlzLmxhc3ROZWVkLHRoaXMubGFzdE5lZWQ9MH1lbHNlIG49MDtyZXR1cm4gbjxlLmxlbmd0aD90P3QrdGhpcy50ZXh0KGUsbik6dGhpcy50ZXh0KGUsbik6dHx8XCJcIn0sby5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUubGVuZ3RoP3RoaXMud3JpdGUoZSk6XCJcIjtyZXR1cm4gdGhpcy5sYXN0TmVlZD90K1wiXFx1RkZGRFwiOnR9LG8ucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1zKHRoaXMsZSx0KTtpZighdGhpcy5sYXN0TmVlZClyZXR1cm4gZS50b1N0cmluZyhcInV0ZjhcIix0KTt0aGlzLmxhc3RUb3RhbD1uO3ZhciByPWUubGVuZ3RoLShuLXRoaXMubGFzdE5lZWQpO3JldHVybiBlLmNvcHkodGhpcy5sYXN0Q2hhciwwLHIpLGUudG9TdHJpbmcoXCJ1dGY4XCIsdCxyKX0sby5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdE5lZWQ8PWUubGVuZ3RoPyhlLmNvcHkodGhpcy5sYXN0Q2hhcix0aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLDAsdGhpcy5sYXN0TmVlZCksdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLDAsdGhpcy5sYXN0VG90YWwpKTp2b2lkKGUuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCxlLmxlbmd0aCksdGhpcy5sYXN0TmVlZC09ZS5sZW5ndGgpfX0se1wic2FmZS1idWZmZXJcIjozMH1dLDMyOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihlKXsoZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHQpe3RyeXtpZighZS5sb2NhbFN0b3JhZ2UpcmV0dXJuITF9Y2F0Y2goZSl7cmV0dXJuITF9dmFyIG49ZS5sb2NhbFN0b3JhZ2VbdF07cmV0dXJuIG51bGwhPW4mJlwidHJ1ZVwiPT09KG4rXCJcIikudG9Mb3dlckNhc2UoKX10LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7aWYoIWEpe2lmKG4oXCJ0aHJvd0RlcHJlY2F0aW9uXCIpKXRocm93IG5ldyBFcnJvcih0KTtlbHNlIG4oXCJ0cmFjZURlcHJlY2F0aW9uXCIpP2NvbnNvbGUudHJhY2UodCk6Y29uc29sZS53YXJuKHQpO2E9ITB9cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWlmKG4oXCJub0RlcHJlY2F0aW9uXCIpKXJldHVybiBlO3ZhciBhPSExO3JldHVybiByfX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHt9XSxcIi9cIjpbZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiBlLnJlcGxhY2UoL2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcc1xcbi9nLFwiXCIpfWZ1bmN0aW9uIHIoZSl7Y29uc29sZS53YXJuKGUpfS8qISBzaW1wbGUtcGVlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL2NvbnN0IGE9ZShcImRlYnVnXCIpKFwic2ltcGxlLXBlZXJcIiksbz1lKFwiZ2V0LWJyb3dzZXItcnRjXCIpLGk9ZShcInJhbmRvbWJ5dGVzXCIpLGQ9ZShcInJlYWRhYmxlLXN0cmVhbVwiKSxzPWUoXCJxdWV1ZS1taWNyb3Rhc2tcIiksbD1lKFwiZXJyLWNvZGVcIikse0J1ZmZlcjpjfT1lKFwiYnVmZmVyXCIpLHU9NjU1MzY7Y2xhc3MgcCBleHRlbmRzIGQuRHVwbGV4e2NvbnN0cnVjdG9yKGUpe2lmKGU9T2JqZWN0LmFzc2lnbih7YWxsb3dIYWxmT3BlbjohMX0sZSksc3VwZXIoZSksdGhpcy5faWQ9aSg0KS50b1N0cmluZyhcImhleFwiKS5zbGljZSgwLDcpLHRoaXMuX2RlYnVnKFwibmV3IHBlZXIgJW9cIixlKSx0aGlzLmNoYW5uZWxOYW1lPWUuaW5pdGlhdG9yP2UuY2hhbm5lbE5hbWV8fGkoMjApLnRvU3RyaW5nKFwiaGV4XCIpOm51bGwsdGhpcy5pbml0aWF0b3I9ZS5pbml0aWF0b3J8fCExLHRoaXMuY2hhbm5lbENvbmZpZz1lLmNoYW5uZWxDb25maWd8fHAuY2hhbm5lbENvbmZpZyx0aGlzLmNoYW5uZWxOZWdvdGlhdGVkPXRoaXMuY2hhbm5lbENvbmZpZy5uZWdvdGlhdGVkLHRoaXMuY29uZmlnPU9iamVjdC5hc3NpZ24oe30scC5jb25maWcsZS5jb25maWcpLHRoaXMub2ZmZXJPcHRpb25zPWUub2ZmZXJPcHRpb25zfHx7fSx0aGlzLmFuc3dlck9wdGlvbnM9ZS5hbnN3ZXJPcHRpb25zfHx7fSx0aGlzLnNkcFRyYW5zZm9ybT1lLnNkcFRyYW5zZm9ybXx8KGU9PmUpLHRoaXMuc3RyZWFtcz1lLnN0cmVhbXN8fChlLnN0cmVhbT9bZS5zdHJlYW1dOltdKSx0aGlzLnRyaWNrbGU9dm9pZCAwPT09ZS50cmlja2xlfHxlLnRyaWNrbGUsdGhpcy5hbGxvd0hhbGZUcmlja2xlPXZvaWQgMCE9PWUuYWxsb3dIYWxmVHJpY2tsZSYmZS5hbGxvd0hhbGZUcmlja2xlLHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0PWUuaWNlQ29tcGxldGVUaW1lb3V0fHw1MDAwLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVzdHJveWluZz0hMSx0aGlzLl9jb25uZWN0ZWQ9ITEsdGhpcy5yZW1vdGVBZGRyZXNzPXZvaWQgMCx0aGlzLnJlbW90ZUZhbWlseT12b2lkIDAsdGhpcy5yZW1vdGVQb3J0PXZvaWQgMCx0aGlzLmxvY2FsQWRkcmVzcz12b2lkIDAsdGhpcy5sb2NhbEZhbWlseT12b2lkIDAsdGhpcy5sb2NhbFBvcnQ9dm9pZCAwLHRoaXMuX3dydGM9ZS53cnRjJiZcIm9iamVjdFwiPT10eXBlb2YgZS53cnRjP2Uud3J0YzpvKCksIXRoaXMuX3dydGMpaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyl0aHJvdyBsKG5ldyBFcnJvcihcIk5vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50XCIpLFwiRVJSX1dFQlJUQ19TVVBQT1JUXCIpO2Vsc2UgdGhyb3cgbChuZXcgRXJyb3IoXCJObyBXZWJSVEMgc3VwcG9ydDogTm90IGEgc3VwcG9ydGVkIGJyb3dzZXJcIiksXCJFUlJfV0VCUlRDX1NVUFBPUlRcIik7dGhpcy5fcGNSZWFkeT0hMSx0aGlzLl9jaGFubmVsUmVhZHk9ITEsdGhpcy5faWNlQ29tcGxldGU9ITEsdGhpcy5faWNlQ29tcGxldGVUaW1lcj1udWxsLHRoaXMuX2NoYW5uZWw9bnVsbCx0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcz1bXSx0aGlzLl9pc05lZ290aWF0aW5nPSExLHRoaXMuX2ZpcnN0TmVnb3RpYXRpb249ITAsdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uPSExLHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPSExLHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZT1bXSx0aGlzLl9zZW5kZXJNYXA9bmV3IE1hcCx0aGlzLl9jbG9zaW5nSW50ZXJ2YWw9bnVsbCx0aGlzLl9yZW1vdGVUcmFja3M9W10sdGhpcy5fcmVtb3RlU3RyZWFtcz1bXSx0aGlzLl9jaHVuaz1udWxsLHRoaXMuX2NiPW51bGwsdGhpcy5faW50ZXJ2YWw9bnVsbDt0cnl7dGhpcy5fcGM9bmV3IHRoaXMuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpfWNhdGNoKGUpe3JldHVybiB2b2lkIHRoaXMuZGVzdHJveShsKGUsXCJFUlJfUENfQ09OU1RSVUNUT1JcIikpfXRoaXMuX2lzUmVhY3ROYXRpdmVXZWJydGM9XCJudW1iZXJcIj09dHlwZW9mIHRoaXMuX3BjLl9wZWVyQ29ubmVjdGlvbklkLHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlPSgpPT57dGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlPSgpPT57dGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZT0oKT0+e3RoaXMuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKCl9LHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2U9KCk9Pnt0aGlzLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKCl9LHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlPWU9Pnt0aGlzLl9vbkljZUNhbmRpZGF0ZShlKX0sXCJvYmplY3RcIj09dHlwZW9mIHRoaXMuX3BjLnBlZXJJZGVudGl0eSYmdGhpcy5fcGMucGVlcklkZW50aXR5LmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1BDX1BFRVJfSURFTlRJVFlcIikpfSksdGhpcy5pbml0aWF0b3J8fHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQ/dGhpcy5fc2V0dXBEYXRhKHtjaGFubmVsOnRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWUsdGhpcy5jaGFubmVsQ29uZmlnKX0pOnRoaXMuX3BjLm9uZGF0YWNoYW5uZWw9ZT0+e3RoaXMuX3NldHVwRGF0YShlKX0sdGhpcy5zdHJlYW1zJiZ0aGlzLnN0cmVhbXMuZm9yRWFjaChlPT57dGhpcy5hZGRTdHJlYW0oZSl9KSx0aGlzLl9wYy5vbnRyYWNrPWU9Pnt0aGlzLl9vblRyYWNrKGUpfSx0aGlzLl9kZWJ1ZyhcImluaXRpYWwgbmVnb3RpYXRpb25cIiksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpLHRoaXMuX29uRmluaXNoQm91bmQ9KCk9Pnt0aGlzLl9vbkZpbmlzaCgpfSx0aGlzLm9uY2UoXCJmaW5pc2hcIix0aGlzLl9vbkZpbmlzaEJvdW5kKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzLl9jaGFubmVsJiZ0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50fHwwfWdldCBjb25uZWN0ZWQoKXtyZXR1cm4gdGhpcy5fY29ubmVjdGVkJiZcIm9wZW5cIj09PXRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZX1hZGRyZXNzKCl7cmV0dXJue3BvcnQ6dGhpcy5sb2NhbFBvcnQsZmFtaWx5OnRoaXMubG9jYWxGYW1pbHksYWRkcmVzczp0aGlzLmxvY2FsQWRkcmVzc319c2lnbmFsKGUpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdHJ5e2U9SlNPTi5wYXJzZShlKX1jYXRjaCh0KXtlPXt9fXRoaXMuX2RlYnVnKFwic2lnbmFsKClcIiksZS5yZW5lZ290aWF0ZSYmdGhpcy5pbml0aWF0b3ImJih0aGlzLl9kZWJ1ZyhcImdvdCByZXF1ZXN0IHRvIHJlbmVnb3RpYXRlXCIpLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKSksZS50cmFuc2NlaXZlclJlcXVlc3QmJnRoaXMuaW5pdGlhdG9yJiYodGhpcy5fZGVidWcoXCJnb3QgcmVxdWVzdCBmb3IgdHJhbnNjZWl2ZXJcIiksdGhpcy5hZGRUcmFuc2NlaXZlcihlLnRyYW5zY2VpdmVyUmVxdWVzdC5raW5kLGUudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpKSxlLmNhbmRpZGF0ZSYmKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uJiZ0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlP3RoaXMuX2FkZEljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSk6dGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChlLmNhbmRpZGF0ZSkpLGUuc2RwJiZ0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgdGhpcy5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24oZSkpLnRoZW4oKCk9Pnt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goZT0+e3RoaXMuX2FkZEljZUNhbmRpZGF0ZShlKX0pLHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzPVtdLFwib2ZmZXJcIj09PXRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUmJnRoaXMuX2NyZWF0ZUFuc3dlcigpKX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1NFVF9SRU1PVEVfREVTQ1JJUFRJT05cIikpfSksZS5zZHB8fGUuY2FuZGlkYXRlfHxlLnJlbmVnb3RpYXRlfHxlLnRyYW5zY2VpdmVyUmVxdWVzdHx8dGhpcy5kZXN0cm95KGwobmV3IEVycm9yKFwic2lnbmFsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBzaWduYWwgZGF0YVwiKSxcIkVSUl9TSUdOQUxJTkdcIikpfX1fYWRkSWNlQ2FuZGlkYXRlKGUpe2NvbnN0IHQ9bmV3IHRoaXMuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGUpO3RoaXMuX3BjLmFkZEljZUNhbmRpZGF0ZSh0KS5jYXRjaChlPT57IXQuYWRkcmVzc3x8dC5hZGRyZXNzLmVuZHNXaXRoKFwiLmxvY2FsXCIpP3IoXCJJZ25vcmluZyB1bnN1cHBvcnRlZCBJQ0UgY2FuZGlkYXRlLlwiKTp0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0FERF9JQ0VfQ0FORElEQVRFXCIpKX0pfXNlbmQoZSl7aWYoIXRoaXMuZGVzdHJveWluZyl7aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3Qgc2VuZCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fY2hhbm5lbC5zZW5kKGUpfX1hZGRUcmFuc2NlaXZlcihlLHQpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IGFkZFRyYW5zY2VpdmVyIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTtpZih0aGlzLl9kZWJ1ZyhcImFkZFRyYW5zY2VpdmVyKClcIiksdGhpcy5pbml0aWF0b3IpdHJ5e3RoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKGUsdCksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpfWNhdGNoKGUpe3RoaXMuZGVzdHJveShsKGUsXCJFUlJfQUREX1RSQU5TQ0VJVkVSXCIpKX1lbHNlIHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwidHJhbnNjZWl2ZXJSZXF1ZXN0XCIsdHJhbnNjZWl2ZXJSZXF1ZXN0OntraW5kOmUsaW5pdDp0fX0pfX1hZGRTdHJlYW0oZSl7aWYoIXRoaXMuZGVzdHJveWluZyl7aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgYWRkU3RyZWFtIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTt0aGlzLl9kZWJ1ZyhcImFkZFN0cmVhbSgpXCIpLGUuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0PT57dGhpcy5hZGRUcmFjayh0LGUpfSl9fWFkZFRyYWNrKGUsdCl7aWYodGhpcy5kZXN0cm95aW5nKXJldHVybjtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCBhZGRUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJhZGRUcmFjaygpXCIpO2NvbnN0IG49dGhpcy5fc2VuZGVyTWFwLmdldChlKXx8bmV3IE1hcDtsZXQgcj1uLmdldCh0KTtpZighcilyPXRoaXMuX3BjLmFkZFRyYWNrKGUsdCksbi5zZXQodCxyKSx0aGlzLl9zZW5kZXJNYXAuc2V0KGUsbiksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpO2Vsc2UgaWYoci5yZW1vdmVkKXRocm93IGwobmV3IEVycm9yKFwiVHJhY2sgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IHNob3VsZCBlbmFibGUvZGlzYWJsZSB0cmFja3MgdGhhdCB5b3Ugd2FudCB0byByZS1hZGQuXCIpLFwiRVJSX1NFTkRFUl9SRU1PVkVEXCIpO2Vsc2UgdGhyb3cgbChuZXcgRXJyb3IoXCJUcmFjayBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoYXQgc3RyZWFtLlwiKSxcIkVSUl9TRU5ERVJfQUxSRUFEWV9BRERFRFwiKX1yZXBsYWNlVHJhY2soZSx0LG4pe2lmKHRoaXMuZGVzdHJveWluZylyZXR1cm47aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgcmVwbGFjZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTt0aGlzLl9kZWJ1ZyhcInJlcGxhY2VUcmFjaygpXCIpO2NvbnN0IHI9dGhpcy5fc2VuZGVyTWFwLmdldChlKSxhPXI/ci5nZXQobik6bnVsbDtpZighYSl0aHJvdyBsKG5ldyBFcnJvcihcIkNhbm5vdCByZXBsYWNlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLlwiKSxcIkVSUl9UUkFDS19OT1RfQURERURcIik7dCYmdGhpcy5fc2VuZGVyTWFwLnNldCh0LHIpLG51bGw9PWEucmVwbGFjZVRyYWNrP3RoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcInJlcGxhY2VUcmFjayBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKSxcIkVSUl9VTlNVUFBPUlRFRF9SRVBMQUNFVFJBQ0tcIikpOmEucmVwbGFjZVRyYWNrKHQpfXJlbW92ZVRyYWNrKGUsdCl7aWYodGhpcy5kZXN0cm95aW5nKXJldHVybjtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCByZW1vdmVUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJyZW1vdmVTZW5kZXIoKVwiKTtjb25zdCBuPXRoaXMuX3NlbmRlck1hcC5nZXQoZSkscj1uP24uZ2V0KHQpOm51bGw7aWYoIXIpdGhyb3cgbChuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLlwiKSxcIkVSUl9UUkFDS19OT1RfQURERURcIik7dHJ5e3IucmVtb3ZlZD0hMCx0aGlzLl9wYy5yZW1vdmVUcmFjayhyKX1jYXRjaChlKXtcIk5TX0VSUk9SX1VORVhQRUNURURcIj09PWUubmFtZT90aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUucHVzaChyKTp0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1JFTU9WRV9UUkFDS1wiKSl9dGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpfXJlbW92ZVN0cmVhbShlKXtpZighdGhpcy5kZXN0cm95aW5nKXtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCByZW1vdmVTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuX2RlYnVnKFwicmVtb3ZlU2VuZGVycygpXCIpLGUuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0PT57dGhpcy5yZW1vdmVUcmFjayh0LGUpfSl9fV9uZWVkc05lZ290aWF0aW9uKCl7dGhpcy5fZGVidWcoXCJfbmVlZHNOZWdvdGlhdGlvblwiKSx0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb258fCh0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb249ITAscygoKT0+e3RoaXMuX2JhdGNoZWROZWdvdGlhdGlvbj0hMSx0aGlzLmluaXRpYXRvcnx8IXRoaXMuX2ZpcnN0TmVnb3RpYXRpb24/KHRoaXMuX2RlYnVnKFwic3RhcnRpbmcgYmF0Y2hlZCBuZWdvdGlhdGlvblwiKSx0aGlzLm5lZ290aWF0ZSgpKTp0aGlzLl9kZWJ1ZyhcIm5vbi1pbml0aWF0b3IgaW5pdGlhbCBuZWdvdGlhdGlvbiByZXF1ZXN0IGRpc2NhcmRlZFwiKSx0aGlzLl9maXJzdE5lZ290aWF0aW9uPSExfSkpfW5lZ290aWF0ZSgpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IG5lZ290aWF0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5pbml0aWF0b3I/dGhpcy5faXNOZWdvdGlhdGluZz8odGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITAsdGhpcy5fZGVidWcoXCJhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZ1wiKSk6KHRoaXMuX2RlYnVnKFwic3RhcnQgbmVnb3RpYXRpb25cIiksc2V0VGltZW91dCgoKT0+e3RoaXMuX2NyZWF0ZU9mZmVyKCl9LDApKTp0aGlzLl9pc05lZ290aWF0aW5nPyh0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbj0hMCx0aGlzLl9kZWJ1ZyhcImFscmVhZHkgbmVnb3RpYXRpbmcsIHF1ZXVlaW5nXCIpKToodGhpcy5fZGVidWcoXCJyZXF1ZXN0aW5nIG5lZ290aWF0aW9uIGZyb20gaW5pdGlhdG9yXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwicmVuZWdvdGlhdGVcIixyZW5lZ290aWF0ZTohMH0pKSx0aGlzLl9pc05lZ290aWF0aW5nPSEwfX1kZXN0cm95KGUpe3RoaXMuX2Rlc3Ryb3koZSwoKT0+e30pfV9kZXN0cm95KGUsdCl7dGhpcy5kZXN0cm95ZWR8fHRoaXMuZGVzdHJveWluZ3x8KHRoaXMuZGVzdHJveWluZz0hMCx0aGlzLl9kZWJ1ZyhcImRlc3Ryb3lpbmcgKGVycm9yOiAlcylcIixlJiYoZS5tZXNzYWdlfHxlKSkscygoKT0+e2lmKHRoaXMuZGVzdHJveWVkPSEwLHRoaXMuZGVzdHJveWluZz0hMSx0aGlzLl9kZWJ1ZyhcImRlc3Ryb3kgKGVycm9yOiAlcylcIixlJiYoZS5tZXNzYWdlfHxlKSksdGhpcy5yZWFkYWJsZT10aGlzLndyaXRhYmxlPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWR8fHRoaXMucHVzaChudWxsKSx0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkfHx0aGlzLmVuZCgpLHRoaXMuX2Nvbm5lY3RlZD0hMSx0aGlzLl9wY1JlYWR5PSExLHRoaXMuX2NoYW5uZWxSZWFkeT0hMSx0aGlzLl9yZW1vdGVUcmFja3M9bnVsbCx0aGlzLl9yZW1vdGVTdHJlYW1zPW51bGwsdGhpcy5fc2VuZGVyTWFwPW51bGwsY2xlYXJJbnRlcnZhbCh0aGlzLl9jbG9zaW5nSW50ZXJ2YWwpLHRoaXMuX2Nsb3NpbmdJbnRlcnZhbD1udWxsLGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5fY2h1bms9bnVsbCx0aGlzLl9jYj1udWxsLHRoaXMuX29uRmluaXNoQm91bmQmJnRoaXMucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIix0aGlzLl9vbkZpbmlzaEJvdW5kKSx0aGlzLl9vbkZpbmlzaEJvdW5kPW51bGwsdGhpcy5fY2hhbm5lbCl7dHJ5e3RoaXMuX2NoYW5uZWwuY2xvc2UoKX1jYXRjaChlKXt9dGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2U9bnVsbCx0aGlzLl9jaGFubmVsLm9ub3Blbj1udWxsLHRoaXMuX2NoYW5uZWwub25jbG9zZT1udWxsLHRoaXMuX2NoYW5uZWwub25lcnJvcj1udWxsfWlmKHRoaXMuX3BjKXt0cnl7dGhpcy5fcGMuY2xvc2UoKX1jYXRjaChlKXt9dGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2U9bnVsbCx0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlPW51bGwsdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZT1udWxsLHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlPW51bGwsdGhpcy5fcGMub250cmFjaz1udWxsLHRoaXMuX3BjLm9uZGF0YWNoYW5uZWw9bnVsbH10aGlzLl9wYz1udWxsLHRoaXMuX2NoYW5uZWw9bnVsbCxlJiZ0aGlzLmVtaXQoXCJlcnJvclwiLGUpLHRoaXMuZW1pdChcImNsb3NlXCIpLHQoKX0pKX1fc2V0dXBEYXRhKGUpe2lmKCFlLmNoYW5uZWwpcmV0dXJuIHRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkRhdGEgY2hhbm5lbCBldmVudCBpcyBtaXNzaW5nIGBjaGFubmVsYCBwcm9wZXJ0eVwiKSxcIkVSUl9EQVRBX0NIQU5ORUxcIikpO3RoaXMuX2NoYW5uZWw9ZS5jaGFubmVsLHRoaXMuX2NoYW5uZWwuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCIsXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQmJih0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkPXUpLHRoaXMuY2hhbm5lbE5hbWU9dGhpcy5fY2hhbm5lbC5sYWJlbCx0aGlzLl9jaGFubmVsLm9ubWVzc2FnZT1lPT57dGhpcy5fb25DaGFubmVsTWVzc2FnZShlKX0sdGhpcy5fY2hhbm5lbC5vbmJ1ZmZlcmVkYW1vdW50bG93PSgpPT57dGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKX0sdGhpcy5fY2hhbm5lbC5vbm9wZW49KCk9Pnt0aGlzLl9vbkNoYW5uZWxPcGVuKCl9LHRoaXMuX2NoYW5uZWwub25jbG9zZT0oKT0+e3RoaXMuX29uQ2hhbm5lbENsb3NlKCl9LHRoaXMuX2NoYW5uZWwub25lcnJvcj1lPT57Y29uc3QgdD1lLmVycm9yIGluc3RhbmNlb2YgRXJyb3I/ZS5lcnJvcjpuZXcgRXJyb3IoYERhdGFjaGFubmVsIGVycm9yOiAke2UubWVzc2FnZX0gJHtlLmZpbGVuYW1lfToke2UubGluZW5vfToke2UuY29sbm99YCk7dGhpcy5kZXN0cm95KGwodCxcIkVSUl9EQVRBX0NIQU5ORUxcIikpfTtsZXQgdD0hMTt0aGlzLl9jbG9zaW5nSW50ZXJ2YWw9c2V0SW50ZXJ2YWwoKCk9Pnt0aGlzLl9jaGFubmVsJiZcImNsb3NpbmdcIj09PXRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZT8odCYmdGhpcy5fb25DaGFubmVsQ2xvc2UoKSx0PSEwKTp0PSExfSw1MDAwKX1fcmVhZCgpe31fd3JpdGUoZSx0LG4pe2lmKHRoaXMuZGVzdHJveWVkKXJldHVybiBuKGwobmV3IEVycm9yKFwiY2Fubm90IHdyaXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSk7aWYodGhpcy5fY29ubmVjdGVkKXt0cnl7dGhpcy5zZW5kKGUpfWNhdGNoKGUpe3JldHVybiB0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSl9dGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudD51Pyh0aGlzLl9kZWJ1ZyhcInN0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWRcIix0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSx0aGlzLl9jYj1uKTpuKG51bGwpfWVsc2UgdGhpcy5fZGVidWcoXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiKSx0aGlzLl9jaHVuaz1lLHRoaXMuX2NiPW59X29uRmluaXNoKCl7aWYoIXRoaXMuZGVzdHJveWVkKXtjb25zdCBlPSgpPT57c2V0VGltZW91dCgoKT0+dGhpcy5kZXN0cm95KCksMWUzKX07dGhpcy5fY29ubmVjdGVkP2UoKTp0aGlzLm9uY2UoXCJjb25uZWN0XCIsZSl9fV9zdGFydEljZUNvbXBsZXRlVGltZW91dCgpe3RoaXMuZGVzdHJveWVkfHx0aGlzLl9pY2VDb21wbGV0ZVRpbWVyfHwodGhpcy5fZGVidWcoXCJzdGFydGVkIGljZUNvbXBsZXRlIHRpbWVvdXRcIiksdGhpcy5faWNlQ29tcGxldGVUaW1lcj1zZXRUaW1lb3V0KCgpPT57dGhpcy5faWNlQ29tcGxldGV8fCh0aGlzLl9pY2VDb21wbGV0ZT0hMCx0aGlzLl9kZWJ1ZyhcImljZUNvbXBsZXRlIHRpbWVvdXQgY29tcGxldGVkXCIpLHRoaXMuZW1pdChcImljZVRpbWVvdXRcIiksdGhpcy5lbWl0KFwiX2ljZUNvbXBsZXRlXCIpKX0sdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQpKX1fY3JlYXRlT2ZmZXIoKXt0aGlzLmRlc3Ryb3llZHx8dGhpcy5fcGMuY3JlYXRlT2ZmZXIodGhpcy5vZmZlck9wdGlvbnMpLnRoZW4oZT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0aGlzLnRyaWNrbGV8fHRoaXMuYWxsb3dIYWxmVHJpY2tsZXx8KGUuc2RwPW4oZS5zZHApKSxlLnNkcD10aGlzLnNkcFRyYW5zZm9ybShlLnNkcCk7Y29uc3QgdD0oKT0+e2lmKCF0aGlzLmRlc3Ryb3llZCl7Y29uc3QgdD10aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9ufHxlO3RoaXMuX2RlYnVnKFwic2lnbmFsXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOnQudHlwZSxzZHA6dC5zZHB9KX19O3RoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oZSkudGhlbigoKT0+e3RoaXMuX2RlYnVnKFwiY3JlYXRlT2ZmZXIgc3VjY2Vzc1wiKSx0aGlzLmRlc3Ryb3llZHx8KHRoaXMudHJpY2tsZXx8dGhpcy5faWNlQ29tcGxldGU/dCgpOnRoaXMub25jZShcIl9pY2VDb21wbGV0ZVwiLHQpKX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTlwiKSl9KX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0NSRUFURV9PRkZFUlwiKSl9KX1fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKXt0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMmJnRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpLmZvckVhY2goZT0+e2UubWlkfHwhZS5zZW5kZXIudHJhY2t8fGUucmVxdWVzdGVkfHwoZS5yZXF1ZXN0ZWQ9ITAsdGhpcy5hZGRUcmFuc2NlaXZlcihlLnNlbmRlci50cmFjay5raW5kKSl9KX1fY3JlYXRlQW5zd2VyKCl7dGhpcy5kZXN0cm95ZWR8fHRoaXMuX3BjLmNyZWF0ZUFuc3dlcih0aGlzLmFuc3dlck9wdGlvbnMpLnRoZW4oZT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0aGlzLnRyaWNrbGV8fHRoaXMuYWxsb3dIYWxmVHJpY2tsZXx8KGUuc2RwPW4oZS5zZHApKSxlLnNkcD10aGlzLnNkcFRyYW5zZm9ybShlLnNkcCk7Y29uc3QgdD0oKT0+e2lmKCF0aGlzLmRlc3Ryb3llZCl7Y29uc3QgdD10aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9ufHxlO3RoaXMuX2RlYnVnKFwic2lnbmFsXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOnQudHlwZSxzZHA6dC5zZHB9KSx0aGlzLmluaXRpYXRvcnx8dGhpcy5fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKX19O3RoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oZSkudGhlbigoKT0+e3RoaXMuZGVzdHJveWVkfHwodGhpcy50cmlja2xlfHx0aGlzLl9pY2VDb21wbGV0ZT90KCk6dGhpcy5vbmNlKFwiX2ljZUNvbXBsZXRlXCIsdCkpfSkuY2F0Y2goZT0+e3RoaXMuZGVzdHJveShsKGUsXCJFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OXCIpKX0pfSkuY2F0Y2goZT0+e3RoaXMuZGVzdHJveShsKGUsXCJFUlJfQ1JFQVRFX0FOU1dFUlwiKSl9KX1fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UoKXt0aGlzLmRlc3Ryb3llZHx8XCJmYWlsZWRcIj09PXRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSYmdGhpcy5kZXN0cm95KGwobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBmYWlsZWQuXCIpLFwiRVJSX0NPTk5FQ1RJT05fRkFJTFVSRVwiKSl9X29uSWNlU3RhdGVDaGFuZ2UoKXtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47Y29uc3QgZT10aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUsdD10aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZTt0aGlzLl9kZWJ1ZyhcImljZVN0YXRlQ2hhbmdlIChjb25uZWN0aW9uOiAlcykgKGdhdGhlcmluZzogJXMpXCIsZSx0KSx0aGlzLmVtaXQoXCJpY2VTdGF0ZUNoYW5nZVwiLGUsdCksKFwiY29ubmVjdGVkXCI9PT1lfHxcImNvbXBsZXRlZFwiPT09ZSkmJih0aGlzLl9wY1JlYWR5PSEwLHRoaXMuX21heWJlUmVhZHkoKSksXCJmYWlsZWRcIj09PWUmJnRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkljZSBjb25uZWN0aW9uIGZhaWxlZC5cIiksXCJFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRVwiKSksXCJjbG9zZWRcIj09PWUmJnRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkljZSBjb25uZWN0aW9uIGNsb3NlZC5cIiksXCJFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEXCIpKX1nZXRTdGF0cyhlKXtjb25zdCB0PWU9PihcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS52YWx1ZXMpJiZlLnZhbHVlcy5mb3JFYWNoKHQ9PntPYmplY3QuYXNzaWduKGUsdCl9KSxlKTswPT09dGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RofHx0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjP3RoaXMuX3BjLmdldFN0YXRzKCkudGhlbihuPT57Y29uc3Qgcj1bXTtuLmZvckVhY2goZT0+e3IucHVzaCh0KGUpKX0pLGUobnVsbCxyKX0sdD0+ZSh0KSk6MDx0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGg/dGhpcy5fcGMuZ2V0U3RhdHMobj0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjtjb25zdCByPVtdO24ucmVzdWx0KCkuZm9yRWFjaChlPT57Y29uc3Qgbj17fTtlLm5hbWVzKCkuZm9yRWFjaCh0PT57blt0XT1lLnN0YXQodCl9KSxuLmlkPWUuaWQsbi50eXBlPWUudHlwZSxuLnRpbWVzdGFtcD1lLnRpbWVzdGFtcCxyLnB1c2godChuKSl9KSxlKG51bGwscil9LHQ9PmUodCkpOmUobnVsbCxbXSl9X21heWJlUmVhZHkoKXtpZih0aGlzLl9kZWJ1ZyhcIm1heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlc1wiLHRoaXMuX3BjUmVhZHksdGhpcy5fY2hhbm5lbFJlYWR5KSx0aGlzLl9jb25uZWN0ZWR8fHRoaXMuX2Nvbm5lY3Rpbmd8fCF0aGlzLl9wY1JlYWR5fHwhdGhpcy5fY2hhbm5lbFJlYWR5KXJldHVybjt0aGlzLl9jb25uZWN0aW5nPSEwO2NvbnN0IGU9KCk9Pnt0aGlzLmRlc3Ryb3llZHx8dGhpcy5nZXRTdGF0cygodCxuKT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0JiYobj1bXSk7Y29uc3Qgcj17fSxhPXt9LG89e307bGV0IGk9ITE7bi5mb3JFYWNoKGU9PnsoXCJyZW1vdGVjYW5kaWRhdGVcIj09PWUudHlwZXx8XCJyZW1vdGUtY2FuZGlkYXRlXCI9PT1lLnR5cGUpJiYocltlLmlkXT1lKSwoXCJsb2NhbGNhbmRpZGF0ZVwiPT09ZS50eXBlfHxcImxvY2FsLWNhbmRpZGF0ZVwiPT09ZS50eXBlKSYmKGFbZS5pZF09ZSksKFwiY2FuZGlkYXRlcGFpclwiPT09ZS50eXBlfHxcImNhbmRpZGF0ZS1wYWlyXCI9PT1lLnR5cGUpJiYob1tlLmlkXT1lKX0pO2NvbnN0IGQ9ZT0+e2k9ITA7bGV0IHQ9YVtlLmxvY2FsQ2FuZGlkYXRlSWRdO3QmJih0LmlwfHx0LmFkZHJlc3MpPyh0aGlzLmxvY2FsQWRkcmVzcz10LmlwfHx0LmFkZHJlc3MsdGhpcy5sb2NhbFBvcnQ9K3QucG9ydCk6dCYmdC5pcEFkZHJlc3M/KHRoaXMubG9jYWxBZGRyZXNzPXQuaXBBZGRyZXNzLHRoaXMubG9jYWxQb3J0PSt0LnBvcnROdW1iZXIpOlwic3RyaW5nXCI9PXR5cGVvZiBlLmdvb2dMb2NhbEFkZHJlc3MmJih0PWUuZ29vZ0xvY2FsQWRkcmVzcy5zcGxpdChcIjpcIiksdGhpcy5sb2NhbEFkZHJlc3M9dFswXSx0aGlzLmxvY2FsUG9ydD0rdFsxXSksdGhpcy5sb2NhbEFkZHJlc3MmJih0aGlzLmxvY2FsRmFtaWx5PXRoaXMubG9jYWxBZGRyZXNzLmluY2x1ZGVzKFwiOlwiKT9cIklQdjZcIjpcIklQdjRcIik7bGV0IG49cltlLnJlbW90ZUNhbmRpZGF0ZUlkXTtuJiYobi5pcHx8bi5hZGRyZXNzKT8odGhpcy5yZW1vdGVBZGRyZXNzPW4uaXB8fG4uYWRkcmVzcyx0aGlzLnJlbW90ZVBvcnQ9K24ucG9ydCk6biYmbi5pcEFkZHJlc3M/KHRoaXMucmVtb3RlQWRkcmVzcz1uLmlwQWRkcmVzcyx0aGlzLnJlbW90ZVBvcnQ9K24ucG9ydE51bWJlcik6XCJzdHJpbmdcIj09dHlwZW9mIGUuZ29vZ1JlbW90ZUFkZHJlc3MmJihuPWUuZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoXCI6XCIpLHRoaXMucmVtb3RlQWRkcmVzcz1uWzBdLHRoaXMucmVtb3RlUG9ydD0rblsxXSksdGhpcy5yZW1vdGVBZGRyZXNzJiYodGhpcy5yZW1vdGVGYW1pbHk9dGhpcy5yZW1vdGVBZGRyZXNzLmluY2x1ZGVzKFwiOlwiKT9cIklQdjZcIjpcIklQdjRcIiksdGhpcy5fZGVidWcoXCJjb25uZWN0IGxvY2FsOiAlczolcyByZW1vdGU6ICVzOiVzXCIsdGhpcy5sb2NhbEFkZHJlc3MsdGhpcy5sb2NhbFBvcnQsdGhpcy5yZW1vdGVBZGRyZXNzLHRoaXMucmVtb3RlUG9ydCl9O2lmKG4uZm9yRWFjaChlPT57XCJ0cmFuc3BvcnRcIj09PWUudHlwZSYmZS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCYmZChvW2Uuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWRdKSwoXCJnb29nQ2FuZGlkYXRlUGFpclwiPT09ZS50eXBlJiZcInRydWVcIj09PWUuZ29vZ0FjdGl2ZUNvbm5lY3Rpb258fChcImNhbmRpZGF0ZXBhaXJcIj09PWUudHlwZXx8XCJjYW5kaWRhdGUtcGFpclwiPT09ZS50eXBlKSYmZS5zZWxlY3RlZCkmJmQoZSl9KSwhaSYmKCFPYmplY3Qua2V5cyhvKS5sZW5ndGh8fE9iamVjdC5rZXlzKGEpLmxlbmd0aCkpcmV0dXJuIHZvaWQgc2V0VGltZW91dChlLDEwMCk7aWYodGhpcy5fY29ubmVjdGluZz0hMSx0aGlzLl9jb25uZWN0ZWQ9ITAsdGhpcy5fY2h1bmspe3RyeXt0aGlzLnNlbmQodGhpcy5fY2h1bmspfWNhdGNoKGUpe3JldHVybiB0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSl9dGhpcy5fY2h1bms9bnVsbCx0aGlzLl9kZWJ1ZyhcInNlbnQgY2h1bmsgZnJvbSBcXFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcXFwiXCIpO2NvbnN0IGU9dGhpcy5fY2I7dGhpcy5fY2I9bnVsbCxlKG51bGwpfVwibnVtYmVyXCIhPXR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkJiYodGhpcy5faW50ZXJ2YWw9c2V0SW50ZXJ2YWwoKCk9PnRoaXMuX29uSW50ZXJ2YWwoKSwxNTApLHRoaXMuX2ludGVydmFsLnVucmVmJiZ0aGlzLl9pbnRlcnZhbC51bnJlZigpKSx0aGlzLl9kZWJ1ZyhcImNvbm5lY3RcIiksdGhpcy5lbWl0KFwiY29ubmVjdFwiKX0pfTtlKCl9X29uSW50ZXJ2YWwoKXt0aGlzLl9jYiYmdGhpcy5fY2hhbm5lbCYmISh0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50PnUpJiZ0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpfV9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKCl7dGhpcy5kZXN0cm95ZWR8fChcInN0YWJsZVwiPT09dGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUmJih0aGlzLl9pc05lZ290aWF0aW5nPSExLHRoaXMuX2RlYnVnKFwiZmx1c2hpbmcgc2VuZGVyIHF1ZXVlXCIsdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlKSx0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUuZm9yRWFjaChlPT57dGhpcy5fcGMucmVtb3ZlVHJhY2soZSksdGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITB9KSx0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGU9W10sdGhpcy5fcXVldWVkTmVnb3RpYXRpb24/KHRoaXMuX2RlYnVnKFwiZmx1c2hpbmcgbmVnb3RpYXRpb24gcXVldWVcIiksdGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITEsdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpKToodGhpcy5fZGVidWcoXCJuZWdvdGlhdGVkXCIpLHRoaXMuZW1pdChcIm5lZ290aWF0ZWRcIikpKSx0aGlzLl9kZWJ1ZyhcInNpZ25hbGluZ1N0YXRlQ2hhbmdlICVzXCIsdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpLHRoaXMuZW1pdChcInNpZ25hbGluZ1N0YXRlQ2hhbmdlXCIsdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpKX1fb25JY2VDYW5kaWRhdGUoZSl7dGhpcy5kZXN0cm95ZWR8fChlLmNhbmRpZGF0ZSYmdGhpcy50cmlja2xlP3RoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwiY2FuZGlkYXRlXCIsY2FuZGlkYXRlOntjYW5kaWRhdGU6ZS5jYW5kaWRhdGUuY2FuZGlkYXRlLHNkcE1MaW5lSW5kZXg6ZS5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxzZHBNaWQ6ZS5jYW5kaWRhdGUuc2RwTWlkfX0pOiFlLmNhbmRpZGF0ZSYmIXRoaXMuX2ljZUNvbXBsZXRlJiYodGhpcy5faWNlQ29tcGxldGU9ITAsdGhpcy5lbWl0KFwiX2ljZUNvbXBsZXRlXCIpKSxlLmNhbmRpZGF0ZSYmdGhpcy5fc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQoKSl9X29uQ2hhbm5lbE1lc3NhZ2UoZSl7aWYodGhpcy5kZXN0cm95ZWQpcmV0dXJuO2xldCB0PWUuZGF0YTt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih0PWMuZnJvbSh0KSksdGhpcy5wdXNoKHQpfV9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpe2lmKCF0aGlzLmRlc3Ryb3llZCYmdGhpcy5fY2Ipe3RoaXMuX2RlYnVnKFwiZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWRcIix0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KTtjb25zdCBlPXRoaXMuX2NiO3RoaXMuX2NiPW51bGwsZShudWxsKX19X29uQ2hhbm5lbE9wZW4oKXt0aGlzLl9jb25uZWN0ZWR8fHRoaXMuZGVzdHJveWVkfHwodGhpcy5fZGVidWcoXCJvbiBjaGFubmVsIG9wZW5cIiksdGhpcy5fY2hhbm5lbFJlYWR5PSEwLHRoaXMuX21heWJlUmVhZHkoKSl9X29uQ2hhbm5lbENsb3NlKCl7dGhpcy5kZXN0cm95ZWR8fCh0aGlzLl9kZWJ1ZyhcIm9uIGNoYW5uZWwgY2xvc2VcIiksdGhpcy5kZXN0cm95KCkpfV9vblRyYWNrKGUpe3RoaXMuZGVzdHJveWVkfHxlLnN0cmVhbXMuZm9yRWFjaCh0PT57dGhpcy5fZGVidWcoXCJvbiB0cmFja1wiKSx0aGlzLmVtaXQoXCJ0cmFja1wiLGUudHJhY2ssdCksdGhpcy5fcmVtb3RlVHJhY2tzLnB1c2goe3RyYWNrOmUudHJhY2ssc3RyZWFtOnR9KSx0aGlzLl9yZW1vdGVTdHJlYW1zLnNvbWUoZT0+ZS5pZD09PXQuaWQpfHwodGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKHQpLHMoKCk9Pnt0aGlzLl9kZWJ1ZyhcIm9uIHN0cmVhbVwiKSx0aGlzLmVtaXQoXCJzdHJlYW1cIix0KX0pKX0pfV9kZWJ1Zygpe2NvbnN0IGU9W10uc2xpY2UuY2FsbChhcmd1bWVudHMpO2VbMF09XCJbXCIrdGhpcy5faWQrXCJdIFwiK2VbMF0sYS5hcHBseShudWxsLGUpfX1wLldFQlJUQ19TVVBQT1JUPSEhbygpLHAuY29uZmlnPXtpY2VTZXJ2ZXJzOlt7dXJsczpbXCJzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyXCIsXCJzdHVuOmdsb2JhbC5zdHVuLnR3aWxpby5jb206MzQ3OFwiXX1dLHNkcFNlbWFudGljczpcInVuaWZpZWQtcGxhblwifSxwLmNoYW5uZWxDb25maWc9e30sdC5leHBvcnRzPXB9LHtidWZmZXI6MyxkZWJ1Zzo0LFwiZXJyLWNvZGVcIjo2LFwiZ2V0LWJyb3dzZXItcnRjXCI6OCxcInF1ZXVlLW1pY3JvdGFza1wiOjEzLHJhbmRvbWJ5dGVzOjE0LFwicmVhZGFibGUtc3RyZWFtXCI6Mjl9XX0se30sW10pKFwiL1wiKX0pOyIsICJpbXBvcnQgUGVlcmRyYWZ0UGx1Z2luIGZyb20gJy4vcGVlcmRyYWZ0UGx1Z2luJztcblxuZXhwb3J0IGRlZmF1bHQgUGVlcmRyYWZ0UGx1Z2luIiwgImltcG9ydCB7IE1hcmtkb3duVmlldywgUGx1Z2luLCBURmlsZSwgVEZvbGRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBBY3RpdmVTdHJlYW1DbGllbnQgfSBmcm9tIFwiLi9hY3RpdmVTdHJlYW1DbGllbnRcIlxuaW1wb3J0IHsgcHJlcGFyZUNvbW11bmljYXRpb24gfSBmcm9tIFwiLi9jb29raWVcIlxuaW1wb3J0IHsgU2VydmVyQVBJIH0gZnJvbSBcIi4vc2VydmVyQVBJXCJcbmltcG9ydCB7IFNldHRpbmdzLCBjcmVhdGVTZXR0aW5nc1RhYiwgZ2V0U2V0dGluZ3MsIG1pZ3JhdGVTZXR0aW5ncywgc2F2ZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIlxuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudFwiXG5pbXBvcnQgeyBmcm9tU2hhcmVVUkwgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlGYWN0b3J5XCJcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gXCIuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlclwiXG5pbXBvcnQgeyBzaG93Tm90aWNlIH0gZnJvbSBcIi4vdWlcIlxuaW1wb3J0IHsgcHJvbXB0Rm9yU2Vzc2lvblR5cGUgfSBmcm9tIFwiLi91aS9jaG9vc2VTZXNzaW9uVHlwZVwiXG5pbXBvcnQgeyBwcm9tcHRGb3JOYW1lLCBwcm9tcHRGb3JVUkwgfSBmcm9tIFwiLi91aS9lbnRlclRleHRcIlxuaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSBcIi4vdXRpbHMvcGVlcmRyYWZ0UmVjb3JkXCJcbmltcG9ydCB7IFBlZXJkcmFmdExlYWYgfSBmcm9tIFwiLi93b3Jrc3BhY2UvcGVlcmRyYWZ0TGVhZlwiXG5pbXBvcnQgeyBnZXRMZWFmc0J5UGF0aCwgdXBkYXRlUGVlcmRyYWZ0V29ya3NwYWNlIH0gZnJvbSBcIi4vd29ya3NwYWNlL3BlZXJkcmFmdFdvcmtzcGFjZVwiXG5pbXBvcnQgeyBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3BlZXJkcmFmdFdlYlNvY2tldFByb3ZpZGVyXCJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIlxuaW1wb3J0IHsgb3BlbkZvbGRlck9wdGlvbnMgfSBmcm9tIFwiLi91aS9mb2xkZXJPcHRpb25zXCJcbmltcG9ydCB7IGdldEpXVCB9IGZyb20gXCIuL2xvZ2luXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVlcmRyYWZ0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblxuXHRzZXR0aW5nczogU2V0dGluZ3Ncblx0cHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj5cblx0c2VydmVyQVBJOiBTZXJ2ZXJBUElcblx0YWN0aXZlU3RyZWFtQ2xpZW50OiBBY3RpdmVTdHJlYW1DbGllbnRcblx0c2VydmVyU3luYzogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXJcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cblx0XHRjb25zdCBwbHVnaW4gPSB0aGlzXG5cblx0XHRwbHVnaW4uc2V0dGluZ3MgPSBhd2FpdCBtaWdyYXRlU2V0dGluZ3MocGx1Z2luKVxuXG5cdFx0YXdhaXQgcHJlcGFyZUNvbW11bmljYXRpb24ocGx1Z2luKVxuXG5cdFx0cGx1Z2luLnB3cyA9IG5ldyBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4oKVxuXHRcdHBsdWdpbi5zZXJ2ZXJBUEkgPSBuZXcgU2VydmVyQVBJKHtcblx0XHRcdG9pZDogcGx1Z2luLnNldHRpbmdzLm9pZCxcblx0XHRcdHBlcm1hbmVudFNlc3Npb25Vcmw6IHBsdWdpbi5zZXR0aW5ncy5zZXNzaW9uQVBJXG5cdFx0fSlcblxuXHRcdHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQgPSBuZXcgQWN0aXZlU3RyZWFtQ2xpZW50KHBsdWdpbi5zZXR0aW5ncy5hY3RpdmVzLCB7XG5cdFx0XHRtYXhCYWNrb2ZmVGltZTogMzAwMDAwLFxuXHRcdFx0Y29ubmVjdDogdHJ1ZSxcblx0XHRcdHJlc3luY0ludGVydmFsOiAtMVxuXHRcdH0pXG5cblx0XHRwbHVnaW4ucHdzLm9uKCdhZGQnLCAoa2V5LCBsZWFmKSA9PiB7XG5cdFx0XHRTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGxlYWYucGF0aCk/LmFkZEV4dGVuc2lvblRvTGVhZihrZXkpXG5cdFx0XHRsZWFmLm9uKFwiY2hhbmdlUGF0aFwiLCAob2xkUGF0aCkgPT4ge1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0XHRcdGNvbnN0IGxlYWZzID0gZ2V0TGVhZnNCeVBhdGgob2xkUGF0aCwgcGx1Z2luLnB3cylcblx0XHRcdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwICYmICFkb2MuaXNQZXJtYW5lbnQpIHtcblx0XHRcdFx0XHRcdGRvYy51bnNoYXJlKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0U2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpPy5hZGRFeHRlbnNpb25Ub0xlYWYoa2V5KVxuXHRcdFx0fSlcblx0XHR9KVxuXG5cdFx0cGx1Z2luLnB3cy5vbignZGVsZXRlJywgYXN5bmMgKGtleSwgbGVhZikgPT4ge1xuXHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpXG5cdFx0XHRpZiAoIWRvYykgcmV0dXJuXG5cdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0Y29uc3QgbGVhZnMgPSBnZXRMZWFmc0J5UGF0aChsZWFmLnBhdGgsIHBsdWdpbi5wd3MpXG5cdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGlmIChkb2MgJiYgIWRvYy5pc1Blcm1hbmVudCkge1xuXHRcdFx0XHRcdGF3YWl0IGRvYy51bnNoYXJlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGVhZi5kZXN0cm95KClcblx0XHR9KVxuXG5cdFx0cGx1Z2luLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeShcblx0XHRcdGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5zZXJ2ZXJTeW5jID0gbmV3IFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyKHRoaXMuc2V0dGluZ3Muc3luYywgeyBqd3Q6IGdldEpXVChwbHVnaW4uc2V0dGluZ3Mub2lkKSA/PyB1bmRlZmluZWQsIGNvbm5lY3Q6IGZhbHNlIH0pXG5cdFx0XHRcdHRoaXMuc2VydmVyU3luYy5vbihcImF1dGhlbnRpY2F0ZWRcIiwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRzaG93Tm90aWNlKFwiTG9nZ2VkIGluIHRvIFBlZXJkcmFmdFwiKVxuXHRcdFx0XHRcdHBsdWdpbi5zZXR0aW5ncy5wbGFuLnR5cGUgPSBkYXRhLnBsYW4udHlwZVxuXHRcdFx0XHRcdHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcblx0XHRcdFx0fSlcblxuXHRcdFx0XHR0aGlzLnNlcnZlclN5bmMuY29ubmVjdCgpXG5cblx0XHRcdFx0Zm9yIChjb25zdCBkb2NzIG9mIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMpIHtcblx0XHRcdFx0XHRhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tUGVybWFuZW50U2hhcmVEb2N1bWVudCh7IHBhdGg6IGRvY3NbMF0sIHBlcnNpc3RlbmNlSWQ6IGRvY3NbMV0ucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZG9jc1sxXS5zaGFyZUlkIH0sIHBsdWdpbilcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGNvbnN0IGZvbGRlciBvZiBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMpIHtcblx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIuZnJvbVBlcm1hbmVudFNoYXJlRm9sZGVyKHsgcGF0aDogZm9sZGVyWzBdLCBwZXJzaXN0ZW5jZUlkOiBmb2xkZXJbMV0ucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZm9sZGVyWzFdLnNoYXJlSWQgfSwgcGx1Z2luKVxuXHRcdFx0XHR9XG5cdFx0XHRcdHVwZGF0ZVBlZXJkcmFmdFdvcmtzcGFjZShwbHVnaW4uYXBwLndvcmtzcGFjZSwgcGx1Z2luLnB3cylcblx0XHRcdFx0cGx1Z2luLnJlZ2lzdGVyRXZlbnQocGx1Z2luLmFwcC53b3Jrc3BhY2Uub24oXCJsYXlvdXQtY2hhbmdlXCIsICgpID0+IHtcblx0XHRcdFx0XHR1cGRhdGVQZWVyZHJhZnRXb3Jrc3BhY2UocGx1Z2luLmFwcC53b3Jrc3BhY2UsIHBsdWdpbi5wd3MpXG5cdFx0XHRcdH0pKVxuXHRcdFx0fVxuXHRcdClcblxuXHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KHBsdWdpbi5hcHAud29ya3NwYWNlLm9uKCdmaWxlLW1lbnUnLCAobWVudSwgZmlsZSkgPT4ge1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdC8vIE5vdCBzaGFyZWQgZm9sZGVyICYmIG5vdCB3aXRoaW4gc2hhcmVkIGZvbGRlclxuXHRcdFx0XHRjb25zdCBzaGFyZWRGb2xkZXIgPSBTaGFyZWRGb2xkZXIuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGlmICghc2hhcmVkRm9sZGVyKSB7XG5cdFx0XHRcdFx0aWYgKCFTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpICYmIHBsdWdpbi5zZXR0aW5ncy5wbGFuLnR5cGUgPT09IFwidGVhbVwiKSB7XG5cdFx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnU2hhcmUgRm9sZGVyJylcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCd1c2VycycpXG5cdFx0XHRcdFx0XHRcdGl0ZW0ub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0U2hhcmVkRm9sZGVyLmZyb21URm9sZGVyKGZpbGUsIHBsdWdpbilcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ0NvcHkgUGVlcmRyYWZ0IFVSTCcpXG5cdFx0XHRcdFx0XHRpdGVtLnNldEljb24oJ3VzZXJzJylcblx0XHRcdFx0XHRcdGl0ZW0ub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCArICcvdGVhbS8nICsgc2hhcmVkRm9sZGVyLnNoYXJlSWQpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnU3RvcCBzeW5jaW5nIHRoaXMgZm9sZGVyJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdy1vZmYnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgc2hhcmVkRm9sZGVyLnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1JlLWNyZWF0ZSBzeW5jIGZyb20gc2VydmVyJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdycpXG5cdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIucmVjcmVhdGUoc2hhcmVkRm9sZGVyLCBwbHVnaW4pXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnU2hvdyBQZWVyZHJhZnQgZm9sZGVyIG9wdGlvbnMnKVxuXHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCdjb2cnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0b3BlbkZvbGRlck9wdGlvbnModGhpcy5hcHAsIHNoYXJlZEZvbGRlcilcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgc2hhcmVkRG9jdW1lbnQgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0Y29uc3Qgc2hhcmVkRm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoc2hhcmVkRG9jdW1lbnQpIHtcblx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRpdGVtLnNldFRpdGxlKCdDb3B5IFBlZXJkcmFmdCBVUkwnKVxuXHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCd1c2VycycpXG5cdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyAnL2NtLycgKyBzaGFyZWREb2N1bWVudC5zaGFyZUlkKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGlmIChzaGFyZWRGb2xkZXIpIHtcblx0XHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnRGVsZXRlIGFuZCByZW1vdmUgZnJvbSBTaGFyZWQgRm9sZGVyJylcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCd0cmFzaCcpXG5cdFx0XHRcdFx0XHRcdGl0ZW0ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0c2hhcmVkRm9sZGVyLnJlbW92ZURvY3VtZW50KHNoYXJlZERvY3VtZW50KVxuXHRcdFx0XHRcdFx0XHRcdHNoYXJlZERvY3VtZW50LnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0XHRcdHBsdWdpbi5hcHAudmF1bHQuZGVsZXRlKHNoYXJlZERvY3VtZW50LmZpbGUpXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1N0b3Agc3luY2luZyB0aGlzIGRvY3VtZW50Jylcblx0XHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCdyZWZyZXNoLWN3LW9mZicpXG5cdFx0XHRcdFx0XHRcdGl0ZW0ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgc2hhcmVkRG9jdW1lbnQudW5zaGFyZSgpXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pKVxuXG5cdFx0cGx1Z2luLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwic2hhcmVcIixcblx0XHRcdG5hbWU6IFwiU3RhcnQgd29ya2luZyB0b2dldGhlciBvbiB0aGlzIGRvY3VtZW50XCIsXG5cdFx0XHRjaGVja0NhbGxiYWNrKGNoZWNraW5nKSB7XG5cdFx0XHRcdGNvbnN0IHZpZXcgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldylcblx0XHRcdFx0aWYgKCF2aWV3KSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSB2aWV3LmZpbGVcblx0XHRcdFx0aWYgKCFmaWxlKSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHJldHVybiBmYWxzZVxuXHRcdFx0XHRpZiAoY2hlY2tpbmcpIHJldHVybiB0cnVlXG5cdFx0XHRcdC8vIGRvIGl0XG5cdFx0XHRcdGlmIChwbHVnaW4uc2V0dGluZ3MucGxhbi50eXBlID09PSBcInRlYW1cIikge1xuXHRcdFx0XHRcdHByb21wdEZvclNlc3Npb25UeXBlKHBsdWdpbi5hcHApLnRoZW4ocmVzdWx0ID0+IHtcblx0XHRcdFx0XHRcdGlmICghcmVzdWx0KSByZXR1cm5cblx0XHRcdFx0XHRcdFNoYXJlZERvY3VtZW50LmZyb21WaWV3KHZpZXcsIHBsdWdpbiwgeyBwZXJtYW5lbnQ6IHJlc3VsdC5wZXJtYW5lbnQgfSkudGhlbihkb2MgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoIWRvYykge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzaG93Tm90aWNlKFwiRVJST1IgY3JlYXRpbmcgc2hhcmVkRG9jXCIpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRTaGFyZWREb2N1bWVudC5mcm9tVmlldyh2aWV3LCBwbHVnaW4sIHsgcGVybWFuZW50OiBmYWxzZSB9KS50aGVuKGRvYyA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvYykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2hvd05vdGljZShcIkVSUk9SIGNyZWF0aW5nIHNoYXJlZERvY1wiKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cGx1Z2luLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdzdG9wLXNlc3Npb24td2l0aC1hY3RpdmUtZG9jdW1lbnQnLFxuXHRcdFx0bmFtZTogJ1N0b3Agd29ya2luZyB0b2dldGhlciBvbiB0aGlzIGRvY3VtZW50Jyxcblx0XHRcdGVkaXRvckNoZWNrQ2FsbGJhY2s6IChjaGVja2luZywgZWRpdG9yLCBjdHgpID0+IHtcblx0XHRcdFx0Y29uc3QgZmlsZSA9IGN0eC5maWxlXG5cdFx0XHRcdGlmICghZmlsZSkgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoIWRvYyB8fCBkb2MuaXNQZXJtYW5lbnQpIHJldHVybiBmYWxzZVxuXHRcdFx0XHRpZiAoY2hlY2tpbmcpIHJldHVybiB0cnVlXG5cdFx0XHRcdGRvYy51bnNoYXJlKCkudGhlbigoKSA9PiB7IH0pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRwbHVnaW4uYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJqb2luXCIsXG5cdFx0XHRuYW1lOiBcIkpvaW4gc2Vzc2lvbiBhbmQgYWRkIGRvY3VtZW50IGZyb20gc29tZW9uZSBlbHNlXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB1cmwgPSBhd2FpdCBwcm9tcHRGb3JVUkwocGx1Z2luLmFwcClcblx0XHRcdFx0aWYgKHVybCAmJiB1cmwudGV4dCkge1xuXHRcdFx0XHRcdGF3YWl0IGZyb21TaGFyZVVSTCh1cmwudGV4dCwgcGx1Z2luKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdGlmIChwbHVnaW4uc2V0dGluZ3MuZGVidWcpIHtcblx0XHRcdHBsdWdpbi5hZGRDb21tYW5kKHtcblx0XHRcdFx0aWQ6IFwiY2xlYXJEYXRhYmFzZVwiLFxuXHRcdFx0XHRuYW1lOiBcIkRFQlVHOiBjbGVhciBkYXRhYmFzZSAoTm90aGluZyB3aWxsIGJlIHNoYXJlZCBhZnRlciB0aGlzISlcIixcblx0XHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBkYnMgPSBhd2FpdCB3aW5kb3cuaW5kZXhlZERCLmRhdGFiYXNlcygpXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBkYiBvZiBkYnMpIHtcblx0XHRcdFx0XHRcdGlmIChkYi5uYW1lPy5zdGFydHNXaXRoKFwicGVlcmRyYWZ0X1wiKSkge1xuXHRcdFx0XHRcdFx0XHR3aW5kb3cuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKGRiLm5hbWUpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KHBsdWdpbi5hcHAudmF1bHQub24oJ3JlbmFtZScsIGFzeW5jIChmaWxlLCBvbGRQYXRoKSA9PiB7XG5cdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgob2xkUGF0aClcblx0XHRcdFx0aWYgKGRvYykge1xuXHRcdFx0XHRcdGF3YWl0IGRvYy5zZXROZXdGaWxlTG9jYXRpb24oZmlsZSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IG9sZFBhdGhJbkZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGNvbnN0IG5ld1BhdGhJbkZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblxuXHRcdFx0XHRpZiAob2xkUGF0aEluRm9sZGVyICYmIG5ld1BhdGhJbkZvbGRlcikge1xuXHRcdFx0XHRcdGlmIChvbGRQYXRoSW5Gb2xkZXIgPT09IG5ld1BhdGhJbkZvbGRlcikge1xuXHRcdFx0XHRcdFx0b2xkUGF0aEluRm9sZGVyLnVwZGF0ZVBhdGgob2xkUGF0aCwgZmlsZS5wYXRoKVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXdEb2MgPSBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tVEZpbGUoZmlsZSwgeyBwZXJtYW5lbnQ6IHRydWUsIGZvbGRlcjogbmV3UGF0aEluRm9sZGVyLnNoYXJlSWQgfSwgcGx1Z2luKVxuXHRcdFx0XHRcdFx0aWYgKG5ld0RvYykge1xuXHRcdFx0XHRcdFx0XHRuZXdQYXRoSW5Gb2xkZXIuYWRkRG9jdW1lbnQobmV3RG9jKVxuXHRcdFx0XHRcdFx0XHRjb25zdCBwcm9wID0gbmV3UGF0aEluRm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuXHRcdFx0XHRcdFx0XHRpZiAocHJvcCkgbmV3RG9jLnVwZGF0ZVByb3BlcnR5KHByb3AsIG5ld0RvYy5nZXRTaGFyZVVSTCgpKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGRvYykge1xuXHRcdFx0XHRcdFx0XHQvLyBvbGRQYXRoSW5Gb2xkZXIucmVtb3ZlRG9jdW1lbnQoZG9jKVxuXHRcdFx0XHRcdFx0XHQvLyBkb2MudW5zaGFyZSgpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9sZFBhdGhJbkZvbGRlciAmJiAhbmV3UGF0aEluRm9sZGVyKSB7XG5cdFx0XHRcdFx0aWYgKGRvYykge1xuXHRcdFx0XHRcdFx0c2hvd05vdGljZShcIkl0IGlzIG5vdCBwb3NzaWJsZSB0byByZW1vdmUgYSBkb2N1bWVudCBmcm9tIGEgc2hhcmVkIGZvbGRlciByaWdodCBub3cuIENyZWF0ZWQgYSBjb3B5LlwiKVxuXHRcdFx0XHRcdFx0Ly8gb2xkUGF0aEluRm9sZGVyLnJlbW92ZURvY3VtZW50KGRvYylcblx0XHRcdFx0XHRcdGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5kaXJuYW1lKG9sZFBhdGgpLCBwbHVnaW4pXG5cdFx0XHRcdFx0XHRjb25zdCBmaWxlID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGUob2xkUGF0aCwgJycpXG5cdFx0XHRcdFx0XHRpZiAoIWZpbGUpIHtcblx0XHRcdFx0XHRcdFx0c2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIGZpbGUgXCIgKyBvbGRQYXRoICsgXCIuXCIpXG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZG9jLnNldE5ld0ZpbGVMb2NhdGlvbihmaWxlKVxuXHRcdFx0XHRcdFx0ZG9jLnN5bmNXaXRoU2VydmVyKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIW9sZFBhdGhJbkZvbGRlciAmJiBuZXdQYXRoSW5Gb2xkZXIpIHtcblx0XHRcdFx0XHRjb25zdCBkb2MgPSBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tVEZpbGUoZmlsZSwgeyBwZXJtYW5lbnQ6IHRydWUsIGZvbGRlcjogbmV3UGF0aEluRm9sZGVyLnNoYXJlSWQgfSwgcGx1Z2luKVxuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdG5ld1BhdGhJbkZvbGRlci5hZGREb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0XHRjb25zdCBwcm9wID0gbmV3UGF0aEluRm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuXHRcdFx0XHRcdFx0aWYgKHByb3ApIGRvYy51cGRhdGVQcm9wZXJ0eShwcm9wLCBkb2MuZ2V0U2hhcmVVUkwoKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcblx0XHRcdFx0Y29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmZpbmRCeVBhdGgob2xkUGF0aClcblx0XHRcdFx0aWYgKGZvbGRlcikge1xuXHRcdFx0XHRcdGF3YWl0IGZvbGRlci5zZXROZXdGb2xkZXJMb2NhdGlvbihmaWxlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSkpXG5cblx0XHRwbHVnaW4ucmVnaXN0ZXJFdmVudChwbHVnaW4uYXBwLnZhdWx0Lm9uKCdkZWxldGUnLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0cGx1Z2luLmxvZyhcInJlZ2lzdGVyIGRlbGV0ZSBmb3IgXCIgKyBmaWxlLnBhdGgpXG5cdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcblx0XHRcdFx0Y29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRmb2xkZXI/LnVuc2hhcmUoKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRcdGNvbnN0IGZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKCFmb2xkZXIpIHtcblx0XHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0XHRpZiAoZG9jKSB7XG5cdFx0XHRcdFx0XHRhd2FpdCBkb2MudW5zaGFyZSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKiBEbyBuZXQgZGVsZXRlIG9uIGRlbGV0ZSBmaWxlcyBmcm9tIFNoYXJlZCBGb2xkZXJzIGp1c3QgeWV0Li4uXG5cdFx0XHQvLyBJZiB5b3UgcmVhbGx5IHdhbnQgdG8gcmVtb3ZlIGEgZmlsZSwgeW91IGNhbiBtb3ZlXG5cdFx0XHRpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKXtcblx0XHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRhd2FpdCBkb2MudW5zaGFyZSgpXG5cdFx0XHRcdFx0aWYgKGZvbGRlcikge1xuXHRcdFx0XHRcdFx0Zm9sZGVyLnJlbW92ZURvY3VtZW50KGRvYylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGb2xkZXIpIHtcblx0XHRcdFx0Y29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmIChmb2xkZXIpIHtcblx0XHRcdFx0XHRcdGZvbGRlci51bnNoYXJlKClcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQqL1xuXHRcdH0pKVxuXG5cdFx0cGx1Z2luLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeShcblx0XHRcdCgpID0+IHtcblx0XHRcdFx0cGx1Z2luLnJlZ2lzdGVyRXZlbnQoKHBsdWdpbi5hcHAudmF1bHQub24oXCJjcmVhdGVcIiwgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdFx0XHRpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm5cblx0XHRcdFx0XHRjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdFx0aWYgKCFmb2xkZXIpIHJldHVyblxuXHRcdFx0XHRcdGlmIChmb2xkZXIuaXNGaWxlSW5TeW5jT2JqZWN0KGZpbGUpKSByZXR1cm5cblx0XHRcdFx0XHRpZiAoU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpKSByZXR1cm5cblxuXHRcdFx0XHRcdGlmIChwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLmhhcyhub3JtYWxpemVQYXRoKGZpbGUucGF0aCkpKSByZXR1cm5cblxuXHRcdFx0XHRcdGNvbnN0IGRvYyA9IGF3YWl0IFNoYXJlZERvY3VtZW50LmZyb21URmlsZShmaWxlLCB7XG5cdFx0XHRcdFx0XHRwZXJtYW5lbnQ6IHRydWUsXG5cdFx0XHRcdFx0XHRmb2xkZXI6IGZvbGRlci5zaGFyZUlkXG5cdFx0XHRcdFx0fSwgcGx1Z2luKVxuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdGZvbGRlci5hZGREb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0XHRjb25zdCBwcm9wID0gZm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuXHRcdFx0XHRcdFx0aWYgKHByb3ApIGRvYy51cGRhdGVQcm9wZXJ0eShwcm9wLCBkb2MuZ2V0U2hhcmVVUkwoKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKSlcblx0XHRcdH1cblx0XHQpXG5cblx0XHRjb25zdCBzZXR0aW5nc1RhYiA9IGNyZWF0ZVNldHRpbmdzVGFiKHBsdWdpbilcblxuXHRcdGlmICghcGx1Z2luLnNldHRpbmdzLm5hbWUpIHtcblx0XHRcdGNvbnN0IG5hbWUgPSBhd2FpdCBwcm9tcHRGb3JOYW1lKHBsdWdpbi5hcHApXG5cdFx0XHRpZiAobmFtZSAmJiBuYW1lLnRleHQpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5uYW1lID0gbmFtZS50ZXh0XG5cdFx0XHRcdHNhdmVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLCBwbHVnaW4pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHBsdWdpbi5hZGRTZXR0aW5nVGFiKHNldHRpbmdzVGFiKVxuXHR9XG5cblx0b251bmxvYWQoKSB7XG5cdFx0U2hhcmVkRG9jdW1lbnQuZ2V0QWxsKCkuZm9yRWFjaCgoZG9jKSA9PiB7XG5cdFx0XHRkb2MuZGVzdHJveSgpXG5cdFx0fSlcblx0XHRTaGFyZWRGb2xkZXIuZ2V0QWxsKCkuZm9yRWFjaChmb2xkZXIgPT4ge1xuXHRcdFx0Zm9sZGVyLmRlc3Ryb3koKVxuXHRcdH0pXG5cdFx0dGhpcy5hY3RpdmVTdHJlYW1DbGllbnQuZGVzdHJveSgpXG5cdH1cblxuXHRsb2cobWVzc2FnZTogc3RyaW5nKSB7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpXG5cdFx0fVxuXHR9XG5cbn1cblxuIiwgIi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZsb29yID0gTWF0aC5mbG9vclxuZXhwb3J0IGNvbnN0IGNlaWwgPSBNYXRoLmNlaWxcbmV4cG9ydCBjb25zdCBhYnMgPSBNYXRoLmFic1xuZXhwb3J0IGNvbnN0IGltdWwgPSBNYXRoLmltdWxcbmV4cG9ydCBjb25zdCByb3VuZCA9IE1hdGgucm91bmRcbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTBcbmV4cG9ydCBjb25zdCBsb2cyID0gTWF0aC5sb2cyXG5leHBvcnQgY29uc3QgbG9nID0gTWF0aC5sb2dcbmV4cG9ydCBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHN1bSBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAoYSwgYikgPT4gYSArIGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpZ2dlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiXG5cbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuXG5leHBvcnQgY29uc3QgcG93ID0gTWF0aC5wb3dcbi8qKlxuICogQmFzZSAxMCBleHBvbmVudGlhbCBmdW5jdGlvbi4gUmV0dXJucyB0aGUgdmFsdWUgb2YgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiBwb3cuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZXhwMTAgPSBleHAgPT4gTWF0aC5wb3coMTAsIGV4cClcblxuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ25cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2V0aGVyIG4gaXMgbmVnYXRpdmUuIFRoaXMgZnVuY3Rpb24gYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIC0wIGFuZCArMFxuICovXG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBuID0+IG4gIT09IDAgPyBuIDwgMCA6IDEgLyBuIDwgMFxuIiwgIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRpbWUuXG4gKlxuICogQG1vZHVsZSB0aW1lXG4gKi9cblxuaW1wb3J0ICogYXMgbWV0cmljIGZyb20gJy4vbWV0cmljLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtEYXRlfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RGF0ZSA9ICgpID0+IG5ldyBEYXRlKClcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB1bml4IHRpbWUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VW5peFRpbWUgPSBEYXRlLm5vd1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aW1lIChpbiBtcykgdG8gYSBodW1hbiByZWFkYWJsZSBmb3JtYXQuIEUuZy4gMTEwMCA9PiAxLjFzLiA2MHMgPT4gMW1pbi4gLjAwMSA9PiAxMFx1MDNCQ3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGh1bWFuaXplZCBhcHByb3hpbWF0aW9uIG9mIHRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGh1bWFuaXplRHVyYXRpb24gPSBkID0+IHtcbiAgaWYgKGQgPCA2MDAwMCkge1xuICAgIGNvbnN0IHAgPSBtZXRyaWMucHJlZml4KGQsIC0xKVxuICAgIHJldHVybiBtYXRoLnJvdW5kKHAubiAqIDEwMCkgLyAxMDAgKyBwLnByZWZpeCArICdzJ1xuICB9XG4gIGQgPSBtYXRoLmZsb29yKGQgLyAxMDAwKVxuICBjb25zdCBzZWNvbmRzID0gZCAlIDYwXG4gIGNvbnN0IG1pbnV0ZXMgPSBtYXRoLmZsb29yKGQgLyA2MCkgJSA2MFxuICBjb25zdCBob3VycyA9IG1hdGguZmxvb3IoZCAvIDM2MDApICUgMjRcbiAgY29uc3QgZGF5cyA9IG1hdGguZmxvb3IoZCAvIDg2NDAwKVxuICBpZiAoZGF5cyA+IDApIHtcbiAgICByZXR1cm4gZGF5cyArICdkJyArICgoaG91cnMgPiAwIHx8IG1pbnV0ZXMgPiAzMCkgPyAnICcgKyAobWludXRlcyA+IDMwID8gaG91cnMgKyAxIDogaG91cnMpICsgJ2gnIDogJycpXG4gIH1cbiAgaWYgKGhvdXJzID4gMCkge1xuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGhvdXJzICsgJ2gnICsgKChtaW51dGVzID4gMCB8fCBzZWNvbmRzID4gMzApID8gJyAnICsgKHNlY29uZHMgPiAzMCA/IG1pbnV0ZXMgKyAxIDogbWludXRlcykgKyAnbWluJyA6ICcnKVxuICB9XG4gIHJldHVybiBtaW51dGVzICsgJ21pbicgKyAoc2Vjb25kcyA+IDAgPyAnICcgKyBzZWNvbmRzICsgJ3MnIDogJycpXG59XG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGgga2V5LXZhbHVlIHN0b3Jlcy5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtNYXA8YW55LCBhbnk+fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKCkgPT4gbmV3IE1hcCgpXG5cbi8qKlxuICogQ29weSBhIE1hcCBvYmplY3QgaW50byBhIGZyZXNoIE1hcCBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgSyxWXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcmV0dXJuIHtNYXA8SyxWPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSBtID0+IHtcbiAgY29uc3QgciA9IGNyZWF0ZSgpXG4gIG0uZm9yRWFjaCgodiwgaykgPT4geyByLnNldChrLCB2KSB9KVxuICByZXR1cm4gclxufVxuXG4vKipcbiAqIEdldCBtYXAgcHJvcGVydHkuIENyZWF0ZSBUIGlmIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBhbmQgc2V0IFQgb24gbWFwLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ZW5lcnMgPSBtYXAuc2V0SWZVbmRlZmluZWQoZXZlbnRzLCAnZXZlbnROYW1lJywgc2V0LmNyZWF0ZSlcbiAqIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gTUFQXG4gKiBAdGVtcGxhdGUge01BUCBleHRlbmRzIE1hcDxhbnksaW5mZXIgVj4gPyBmdW5jdGlvbigpOlYgOiB1bmtub3dufSBDRlxuICogQHBhcmFtIHtNQVB9IG1hcFxuICogQHBhcmFtIHtNQVAgZXh0ZW5kcyBNYXA8aW5mZXIgSyxhbnk+ID8gSyA6IHVua25vd259IGtleVxuICogQHBhcmFtIHtDRn0gY3JlYXRlVFxuICogQHJldHVybiB7UmV0dXJuVHlwZTxDRj59XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpXG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpXG4gIH1cbiAgcmV0dXJuIHNldFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQXJyYXkgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIHRoZSBjb250ZW50IG9mIGFsbCBrZXktdmFsdWUgcGFpcnMgdXNpbmcgdGhlIGBmKHZhbHVlLCBrZXkpYCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIFJcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChtLCBmKSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICByZXMucHVzaChmKHZhbHVlLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFueSBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQHRvZG8gc2hvdWxkIHJlbmFtZSB0byBzb21lIC0gc2ltaWxhcmx5IHRvIEFycmF5LnNvbWVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbnkgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKGYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYWxsIGtleS12YWx1ZSBwYWlycyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IGBmKHZhbHVlLCBrZXkpYC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKCFmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U2V0PFQ+fSBzZXRcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmaXJzdCA9IHNldCA9PlxuICBzZXQudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IHVuZGVmaW5lZFxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBlbnRyaWVzXG4gKiBAcmV0dXJuIHtTZXQ8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gZW50cmllcyA9PiBuZXcgU2V0KGVudHJpZXMpXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggQXJyYXlzLlxuICpcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFRoZSBlbGVtZW50IG11c3QgZXhpc3RcbiAqXG4gKiBAdGVtcGxhdGUgTFxuICogQHBhcmFtIHtBcnJheUxpa2U8TD59IGFyclxuICogQHJldHVybiB7TH1cbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3QgPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBDXG4gKiBAcmV0dXJuIHtBcnJheTxDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8Qz59ICovIChbXSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgRFxuICogQHBhcmFtIHtBcnJheTxEPn0gYVxuICogQHJldHVybiB7QXJyYXk8RD59XG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gYSA9PiAvKiogQHR5cGUge0FycmF5PEQ+fSAqLyAoYS5zbGljZSgpKVxuXG4vKipcbiAqIEFwcGVuZCBlbGVtZW50cyBmcm9tIHNyYyB0byBkZXN0XG4gKlxuICogQHRlbXBsYXRlIE1cbiAqIEBwYXJhbSB7QXJyYXk8TT59IGRlc3RcbiAqIEBwYXJhbSB7QXJyYXk8TT59IHNyY1xuICovXG5leHBvcnQgY29uc3QgYXBwZW5kVG8gPSAoZGVzdCwgc3JjKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdC5wdXNoKHNyY1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgc29tZXRoaW5nIGFycmF5LWxpa2UgdG8gYW4gYWN0dWFsIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPFQ+fEl0ZXJhYmxlPFQ+fSBhcnJheWxpa2VcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gQXJyYXkuZnJvbVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBldmVyeSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBJVEVNXG4gKiBAdGVtcGxhdGUge0FycmF5TGlrZTxJVEVNPn0gQVJSXG4gKlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihJVEVNLCBudW1iZXIsIEFSUik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBzb21lIGVsZW1lbnQgaW4gdGhlIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFNcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPFM+fSBBUlJcbiAqIEBwYXJhbSB7QVJSfSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUywgbnVtYmVyLCBBUlIpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxFTEVNPn0gYVxuICogQHBhcmFtIHtBcnJheUxpa2U8RUxFTT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGV2ZXJ5KGEsIChpdGVtLCBpbmRleCkgPT4gaXRlbSA9PT0gYltpbmRleF0pXG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RUxFTT4+fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5PEVMRU0+fVxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IGFyciA9PiBmb2xkKGFyciwgLyoqIEB0eXBlIHtBcnJheTxFTEVNPn0gKi8gKFtdKSwgKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBBcnJheTxUPik6VH0gZlxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmZvbGQgPSAobGVuLCBmKSA9PiB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5W2ldID0gZihpLCBhcnJheSlcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFJFU1VMVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcGFyYW0ge1JFU1VMVH0gc2VlZFxuICogQHBhcmFtIHtmdW5jdGlvbihSRVNVTFQsIFQsIG51bWJlcik6UkVTVUxUfSBmb2xkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZvbGQgPSAoYXJyLCBzZWVkLCBmb2xkZXIpID0+IGFyci5yZWR1Y2UoZm9sZGVyLCBzZWVkKVxuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXF1ZSA9IGFyciA9PiBmcm9tKHNldC5mcm9tKGFycikpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmlxdWVCeSA9IChhcnIsIG1hcHBlcikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1NldDxNPn1cbiAgICovXG4gIGNvbnN0IGhhcHBlbmVkID0gc2V0LmNyZWF0ZSgpXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8VD59XG4gICAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gYXJyW2ldXG4gICAgY29uc3QgbWFwcGVkID0gbWFwcGVyKGVsKVxuICAgIGlmICghaGFwcGVuZWQuaGFzKG1hcHBlZCkpIHtcbiAgICAgIGhhcHBlbmVkLmFkZChtYXBwZWQpXG4gICAgICByZXN1bHQucHVzaChlbClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPGFueT59IEFSUlxuICogQHRlbXBsYXRlIHtmdW5jdGlvbihBUlIgZXh0ZW5kcyBBcnJheUxpa2U8aW5mZXIgVD4gPyBUIDogbmV2ZXIsIG51bWJlciwgQVJSKTphbnl9IE1BUFBFUlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtNQVBQRVJ9IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8TUFQUEVSIGV4dGVuZHMgZnVuY3Rpb24oLi4uYW55KTogaW5mZXIgTSA/IE0gOiBuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBtYXBwZXIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0gQXJyYXkoYXJyLmxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbaV0gPSBtYXBwZXIoLyoqIEB0eXBlIHthbnl9ICovIChhcnJbaV0pLCBpLCAvKiogQHR5cGUge2FueX0gKi8gKGFycikpXG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAocmVzKVxufVxuIiwgIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqIEBleHBlcmltZW50YWxcbiAqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBhIChiZXR0ZXIgdHlwZWQpIGR1cGxpY2F0ZSBvZiBPYnNlcnZhYmxlLCB3aGljaCB3aWxsIHJlcGxhY2UgT2JzZXJ2YWJsZSBpbiB0aGVcbiAqIG5leHQgcmVsZWFzZS5cbiAqXG4gKiBAdGVtcGxhdGUge3tba2V5IGluIGtleW9mIEVWRU5UU106IGZ1bmN0aW9uKC4uLmFueSk6dm9pZH19IEVWRU5UU1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZVYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFNvbWUgZGVzYy5cbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgU2V0PGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKG5hbWUpLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgICByZXR1cm4gZlxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb2ZmIChuYW1lLCBmKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKVxuICAgIGlmIChvYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKVxuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBFVkVOVFMgJiBzdHJpbmd9IE5BTUVcbiAgICogQHBhcmFtIHtOQU1FfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8RVZFTlRTW05BTUVdPn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHRlbXBsYXRlIE5cbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogU29tZSBkZXNjLlxuICAgICAqIEB0eXBlIHtNYXA8TiwgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBtYXAuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIF9mKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpXG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpXG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgZW5kICovXG4iLCAiaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBNZW51LCBURmlsZSwgZGVib3VuY2UsIG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgY2FsY3VsYXRlSGFzaCwgY3JlYXRlUmFuZG9tSWQsIGdlbmVyYXRlUmFuZG9tU3RyaW5nLCByYW5kb21VaW50MzIgfSBmcm9tICcuLi90b29scydcbmltcG9ydCB7IENvbXBhcnRtZW50IH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5pbXBvcnQgUGVlckRyYWZ0UGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgb3BlbkZpbGVJbk5ld1RhYiwgcGluTGVhZiwgc2hvd05vdGljZSwgdXNlcmNvbG9ycyB9IGZyb20gJy4uL3VpJztcbmltcG9ydCB7IHlDb2xsYWIgfSBmcm9tICd5LWNvZGVtaXJyb3IubmV4dCc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xuaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSAnLi4vdXRpbHMvcGVlcmRyYWZ0UmVjb3JkJztcbmltcG9ydCB7IFBlcm1hbmVudFNoYXJlRG9jdW1lbnQgfSBmcm9tICcuLi9wZXJtYW5lbnRTaGFyZVN0b3JlJztcbmltcG9ydCB7IGdldExlYWZJZHNCeVBhdGggfSBmcm9tICcuLi93b3Jrc3BhY2UvcGVlcmRyYWZ0V29ya3NwYWNlJztcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gJy4vc2hhcmVkRW50aXR5JztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gJ3ktaW5kZXhlZGRiJztcbmltcG9ydCB7IGFkZElzU2hhcmVkQ2xhc3MsIHJlbW92ZUlzU2hhcmVkQ2xhc3MgfSBmcm9tICdzcmMvd29ya3NwYWNlL2V4cGxvcmVyVmlldyc7XG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tICcuL3NoYXJlZEZvbGRlcic7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2FzeW5jLW11dGV4JztcbmltcG9ydCB7IGRpZmYsIGRpZmZDbGVhbnVwRWZmaWNpZW5jeSB9IGZyb20gJ2RpZmYtbWF0Y2gtcGF0Y2gtZXMnXG5pbXBvcnQgeyBhZGQsIGdldERvY0J5UGF0aCwgbW92ZURvYywgcmVtb3ZlRG9jIH0gZnJvbSAnc3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGUyc7XG5pbXBvcnQgeyBvcGVuTG9naW5Nb2RhbCB9IGZyb20gJ3NyYy91aS9sb2dpbic7XG5cbmV4cG9ydCBjbGFzcyBTaGFyZWREb2N1bWVudCBleHRlbmRzIFNoYXJlZEVudGl0eSB7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3VzZXJDb2xvciA9IHVzZXJjb2xvcnNbcmFuZG9tVWludDMyKCkgJSB1c2VyY29sb3JzLmxlbmd0aF1cblxuICBwcml2YXRlIF9pc1Blcm1hbmVudDogYm9vbGVhblxuICBwcml2YXRlIF9maWxlOiBURmlsZVxuXG4gIHByaXZhdGUgX2V4dGVuc2lvbnM6IFBlZXJkcmFmdFJlY29yZDxDb21wYXJ0bWVudD5cblxuICBwcml2YXRlIHN0YXR1c0JhckVudHJ5PzogSFRNTEVsZW1lbnRcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWREb2N1bWVudD4gPSBuZXcgQXJyYXk8U2hhcmVkRG9jdW1lbnQ+KClcblxuICBwcml2YXRlIG11dGV4ID0gbmV3IE11dGV4XG4gIHByaXZhdGUgbGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlOiBudW1iZXJcblxuICBzdGF0aWMgYXN5bmMgZnJvbVZpZXcodmlldzogTWFya2Rvd25WaWV3LCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbiwgb3B0cyA9IHsgcGVybWFuZW50OiBmYWxzZSB9KSB7XG4gICAgaWYgKCF2aWV3LmZpbGUpIHJldHVyblxuICAgIGlmICh0aGlzLmZpbmRCeVBhdGgodmlldy5maWxlLnBhdGgpKSByZXR1cm5cbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmZyb21URmlsZSh2aWV3LmZpbGUsIG9wdHMsIHBsdWdpbilcbiAgICBpZiAoZG9jKSB7XG4gICAgICBkb2Muc3RhcnRXZWJSVENTeW5jKClcbiAgICAgIGlmIChkb2MuaXNQZXJtYW5lbnQgJiYgZG9jLl93ZWJSVENQcm92aWRlcikge1xuICAgICAgICBkb2MuZ2V0T3duZXJGcmFnbWVudCgpLmluc2VydCgwLCBkb2MuX3dlYlJUQ1Byb3ZpZGVyLmF3YXJlbmVzcy5jbGllbnRJRC50b0ZpeGVkKDApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAgICAgcGluTGVhZih2aWV3LmxlYWYpXG4gICAgICB9XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi9jbS9cIiArIGRvYy5zaGFyZUlkKVxuICAgICAgc2hvd05vdGljZShcIkNvbGxhYm9yYXRpb24gc3RhcnRlZCBmb3IgXCIgKyBkb2MucGF0aCArIFwiLiBMaW5rIGNvcGllZCB0byBDbGlwYm9hcmQuXCIpXG4gICAgfVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tUGVybWFuZW50U2hhcmVEb2N1bWVudChwZDogUGVybWFuZW50U2hhcmVEb2N1bWVudCwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBpZiAodGhpcy5maW5kQnlQYXRoKHBkLnBhdGgpKSByZXR1cm5cbiAgICAvL2xldCBmaWxlQWxyZWFkeVRoZXJlID0gZmFsc2VcbiAgICAvLyBjaGVjayBpZiBwYXRoIGV4aXN0c1xuICAgIGNvbnN0IGZpbGUgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKHBkLnBhdGgpKVxuICAgIGlmICghZmlsZSkge1xuICAgICAgc2hvd05vdGljZShcIkZpbGUgXCIgKyBwZC5wYXRoICsgXCIgbm90IGZvdW5kLiBDcmVhdGluZyBpdCBub3cuXCIpXG4gICAgICBhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKHBhdGguZGlybmFtZShwZC5wYXRoKSwgcGx1Z2luKVxuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKHBkLnBhdGgsICcnKVxuICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBmaWxlIFwiICsgcGQucGF0aCArIFwiLlwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vZmlsZUFscmVhZHlUaGVyZSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBkb2MgPSBuZXcgU2hhcmVkRG9jdW1lbnQoe1xuICAgICAgcGF0aDogcGQucGF0aFxuICAgIH0sIHBsdWdpbilcbiAgICBkb2MuX2lzUGVybWFuZW50ID0gdHJ1ZVxuICAgIGRvYy5fc2hhcmVJZCA9IHBkLnNoYXJlSWRcbiAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAvL2lmIChmaWxlQWxyZWFkeVRoZXJlKSB7XG4gICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAvL31cbiAgICBwbHVnaW4uYWN0aXZlU3RyZWFtQ2xpZW50LmFkZChbZG9jLnNoYXJlSWRdKVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmVVUkwodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKTogUHJvbWlzZTxTaGFyZWREb2N1bWVudCB8IHZvaWQ+IHtcbiAgICBjb25zdCBpZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpXG4gICAgaWYgKCFpZCB8fCAhaWQubWF0Y2goJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kJykpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJObyB2YWxpZCBwZWVyZHJhZnQgbGlua1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1Blcm1hbmVudCA9IGF3YWl0IHBsdWdpbi5zZXJ2ZXJBUEkuaXNTZXNzaW9uUGVybWFuZW50KGlkKVxuXG4gICAgY29uc3QgeURvYyA9IG5ldyBZLkRvYygpXG5cbiAgICBzaG93Tm90aWNlKFwiVHJ5aW5nIHRvIGluaXRpYXRlIHN5bmMuLi5cIilcblxuICAgIGNvbnN0IGRvYyA9IG5ldyBTaGFyZWREb2N1bWVudCh7XG4gICAgICBpZCxcbiAgICAgIHlEb2NcbiAgICB9LCBwbHVnaW4pXG5cbiAgICAvLyB3YWl0IGZvciBmaXJzdCB1cGRhdGUgdG8gbWFrZSBzdXJlIGl0IHdvcmtzIGFuZCB0byBnZXQgdGhlIGZpbGVuYW1lXG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgZG9jLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAgIH1cbiAgICAgIHlEb2Mub25jZShcInVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgZG9jRmlsZW5hbWUgPSBkb2MueURvYy5nZXRUZXh0KFwib3JpZ2luYWxGaWxlbmFtZVwiKS50b1N0cmluZygpXG4gICAgbGV0IGluaXRpYWxGaWxlTmFtZSA9IGBfcGVlcmRyYWZ0X3Nlc3Npb25fJHtpZH1fJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfS5tZGBcbiAgICBpZiAoZG9jRmlsZW5hbWUgIT0gJycpIHtcbiAgICAgIGNvbnN0IGZpbGVFeGlzdHMgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKGRvY0ZpbGVuYW1lKSlcbiAgICAgIGlmICghZmlsZUV4aXN0cykge1xuICAgICAgICBpbml0aWFsRmlsZU5hbWUgPSBkb2NGaWxlbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbEZpbGVOYW1lID0gYF9wZWVyZHJhZnRfJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfV8ke2RvY0ZpbGVuYW1lfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBwbHVnaW4uc2V0dGluZ3Mucm9vdCB8fCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLmdldE5ld0ZpbGVQYXJlbnQoJycsIGluaXRpYWxGaWxlTmFtZSkucGF0aFxuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHBhcmVudCwgaW5pdGlhbEZpbGVOYW1lKVxuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSwgcGx1Z2luKVxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgZG9jLmdldFZhbHVlKCkpXG4gICAgYWRkSXNTaGFyZWRDbGFzcyhmaWxlLnBhdGgsIHBsdWdpbilcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG4gICAgZG9jLl9wYXRoID0gZmlsZS5wYXRoXG5cbiAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgIGRvYy5faXNQZXJtYW5lbnQgPSB0cnVlXG4gICAgICBhd2FpdCBhZGQoZG9jLCBwbHVnaW4pXG4gICAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAgIHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQuYWRkKFtkb2Muc2hhcmVJZF0pXG4gICAgfVxuXG4gICAgY29uc3QgbGVhZiA9IGF3YWl0IG9wZW5GaWxlSW5OZXdUYWIoZmlsZSwgcGx1Z2luLmFwcC53b3Jrc3BhY2UpXG4gICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZG9jLmFkZEV4dGVuc2lvblRvTGVhZihsZWFmLmlkKVxuICAgIHBpbkxlYWYobGVhZilcbiAgICBzaG93Tm90aWNlKFwiSm9pbmVkIFNlc3Npb24gaW4gXCIgKyBkb2MucGF0aCArIFwiLlwiKVxuICAgIHJldHVybiBkb2NcblxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21JZEFuZFBhdGgoaWQ6IHN0cmluZywgbG9jYXRpb246IHN0cmluZywgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgobG9jYXRpb24pXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLmRpcm5hbWUobm9ybWFsaXplZFBhdGgpLCBwbHVnaW4pXG4gICAgc2hvd05vdGljZShcIkNyZWF0aW5nIG5ldyBzeW5jZWQgZmlsZSBcIiArIG5vcm1hbGl6ZWRQYXRoKVxuICAgIGNvbnN0IHlkb2MgPSBhd2FpdCBwbHVnaW4uc2VydmVyU3luYy5yZXF1ZXN0RG9jdW1lbnQoaWQpXG4gICAgY29uc3QgZG9jID0gbmV3IFNoYXJlZERvY3VtZW50KHtcbiAgICAgIGlkLCB5RG9jOiB5ZG9jXG4gICAgfSwgcGx1Z2luKVxuICAgIGRvYy5fcGF0aCA9IG5vcm1hbGl6ZWRQYXRoXG5cbiAgICBjb25zdCBmaWxlID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGUobm9ybWFsaXplZFBhdGgsIHlkb2MuZ2V0VGV4dChcImNvbnRlbnRcIikudG9TdHJpbmcoKSlcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG5cbiAgICBkb2Muc3luY1dpdGhTZXJ2ZXIoKVxuICAgIGF3YWl0IGRvYy5zZXRQZXJtYW5lbnQoKVxuICAgIGF3YWl0IGRvYy5zdGFydEluZGV4ZWREQlN5bmMoKVxuICAgIGFkZElzU2hhcmVkQ2xhc3MoZG9jLnBhdGgsIHBsdWdpbilcbiAgfVxuXG5cbiAgc3RhdGljIGFzeW5jIGZyb21URmlsZShmaWxlOiBURmlsZSwgb3B0czogeyBwZXJtYW5lbnQ/OiBib29sZWFuLCBmb2xkZXI/OiBzdHJpbmcgfSwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBpZiAoIVsnbWQnLCAnTUQnXS5jb250YWlucyhmaWxlLmV4dGVuc2lvbikpIHJldHVyblxuICAgIGNvbnN0IGV4aXN0aW5nID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG4gICAgaWYgKGV4aXN0aW5nKSByZXR1cm4gZXhpc3RpbmdcblxuICAgIGlmICghKHBsdWdpbi5zZXJ2ZXJTeW5jLmF1dGhlbnRpY2F0ZWQgfHwgb3B0cy5mb2xkZXIpKSB7XG4gICAgICBzaG93Tm90aWNlKFwiUGxlYXNlIGxvZyBpbiB0byBQZWVyZHJhZnQgZmlyc3QuXCIpXG4gICAgICBjb25zdCBhdXRoID0gYXdhaXQgb3BlbkxvZ2luTW9kYWwocGx1Z2luKVxuICAgICAgaWYgKCFhdXRoKSByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkb2MgPSBuZXcgU2hhcmVkRG9jdW1lbnQoeyBwYXRoOiBmaWxlLnBhdGggfSwgcGx1Z2luKVxuICAgIGNvbnN0IGxlYWZJZHMgPSBnZXRMZWFmSWRzQnlQYXRoKGZpbGUucGF0aCwgcGx1Z2luLnB3cylcblxuICAgIGlmIChsZWFmSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAocGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZkJ5SWQobGVhZklkc1swXSk/LnZpZXcgYXMgTWFya2Rvd25WaWV3KS5lZGl0b3IuZ2V0VmFsdWUoKVxuICAgICAgZG9jLmdldENvbnRlbnRGcmFnbWVudCgpLmluc2VydCgwLCBjb250ZW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5yZWFkKGZpbGUpXG4gICAgICBkb2MuZ2V0Q29udGVudEZyYWdtZW50KCkuaW5zZXJ0KDAsIGNvbnRlbnQpXG4gICAgfVxuXG4gICAgZG9jLnlEb2MuZ2V0VGV4dChcIm9yaWdpbmFsRmlsZW5hbWVcIikuaW5zZXJ0KDAsIGZpbGUubmFtZSlcblxuICAgIGlmIChvcHRzLnBlcm1hbmVudCkge1xuICAgICAgYXdhaXQgZG9jLmluaXRTZXJ2ZXJZRG9jKClcbiAgICAgIGF3YWl0IGRvYy5zZXRQZXJtYW5lbnQoKVxuICAgICAgLy8gZG9jLnN0YXJ0V2ViU29ja2V0U3luYygpXG4gICAgICBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jLl9zaGFyZUlkID0gY3JlYXRlUmFuZG9tSWQoKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgaWQgb2YgbGVhZklkcykge1xuICAgICAgZG9jLmFkZEV4dGVuc2lvblRvTGVhZihpZClcbiAgICB9XG5cbiAgICBzaG93Tm90aWNlKGBJbml0aXRpYWxpemVkIHNoYXJlIGZvciAke2ZpbGUucGF0aH1gKVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBzdXBlci5maW5kQnlQYXRoKHBhdGgpIGFzIFNoYXJlZERvY3VtZW50IHwgdW5kZWZpbmVkXG4gIH1cblxuICBzdGF0aWMgZmluZEJ5SWQoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiBzdXBlci5maW5kQnlJZChpZCkgYXMgU2hhcmVkRG9jdW1lbnQgfCB1bmRlZmluZWRcbiAgfVxuXG4gIHN0YXRpYyBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldEFsbCgpIGFzIEFycmF5PFNoYXJlZERvY3VtZW50PlxuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihvcHRzOiB7XG4gICAgcGF0aD86IHN0cmluZyxcbiAgICBpZD86IHN0cmluZyxcbiAgICB5RG9jPzogWS5Eb2NcbiAgfSwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBzdXBlcihwbHVnaW4pXG4gICAgaWYgKG9wdHMucGF0aCkge1xuICAgICAgdGhpcy5fcGF0aCA9IG5vcm1hbGl6ZVBhdGgob3B0cy5wYXRoKVxuICAgICAgY29uc3QgZmlsZSA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm9ybWFsaXplUGF0aChvcHRzLnBhdGgpKVxuICAgICAgaWYgKChmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSB7XG4gICAgICAgIHRoaXMuX2ZpbGUgPSBmaWxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG93Tm90aWNlKFwiRVJST1IgY3JlYXRpbmcgc2hhcmVkRG9jXCIpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmlkKSB7XG4gICAgICB0aGlzLl9zaGFyZUlkID0gb3B0cy5pZFxuICAgIH1cblxuXG4gICAgdGhpcy55RG9jID0gb3B0cy55RG9jID8/IG5ldyBZLkRvYygpXG4gICAgdGhpcy55RG9jLm9uKFwidXBkYXRlXCIsICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55LCB5RG9jOiBZLkRvYywgdHI6IFkuVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0ci5sb2NhbCAmJiB0aGlzLmlzUGVybWFuZW50KSB7XG4gICAgICAgIHBsdWdpbi5zZXJ2ZXJTeW5jLnNlbmRVcGRhdGUodGhpcywgdXBkYXRlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBTaGFyZWREb2N1bWVudC5fc2hhcmVkRW50aXRlcy5wdXNoKHRoaXMpXG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG5ldyBQZWVyZHJhZnRSZWNvcmQ8Q29tcGFydG1lbnQ+KClcbiAgICB0aGlzLl9leHRlbnNpb25zLm9uKFwiZGVsZXRlXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9leHRlbnNpb25zLnNpemUgPT09IDAgJiYgdGhpcy5fd2ViUlRDUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5fd2ViUlRDUHJvdmlkZXIuYXdhcmVuZXNzLnNldExvY2FsU3RhdGUoe30pXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KCkub2JzZXJ2ZShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZmlsZSAmJiB0aGlzLl9leHRlbnNpb25zLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVib3VuY2UoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHlEb2NDb250ZW50ID0gdGhpcy5nZXRWYWx1ZSgpXG4gICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKHRoaXMuX2ZpbGUpXG4gICAgICAgICAgICBpZiAoeURvY0NvbnRlbnQgIT0gZmlsZUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5sYXN0VXBkYXRlVHJpZ2dlcmVkQnlEb2NDaGFuZ2UgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKVxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQubW9kaWZ5KHRoaXMuX2ZpbGUsIHlEb2NDb250ZW50LCB7XG4gICAgICAgICAgICAgICAgbXRpbWU6IHRoaXMubGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSwgMTAwMCwgdHJ1ZSkoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KHRoaXMucGx1Z2luLmFwcC52YXVsdC5vbihcIm1vZGlmeVwiLCBhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgLy8gb25seSByZWFjdCB0byBjaGFuZ2VzIG9mIHRoaXMgZmlsZSwgYW5kIG9ubHkgaWYgaXQgZGlkbid0IGhhcHBlbiB3aXRoaW4gdGhlIGVkaXRvci5cbiAgICAgIC8vIFRoZSBlZGl0b3IgZXh0ZW5zaW9uIHRha2VzIGNhcmUgb2YgdXBkYXRlcyBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAodGhpcy5maWxlID09PSBmaWxlICYmIHRoaXMuX2V4dGVuc2lvbnMuc2l6ZSA9PT0gMCAmJiB0aGlzLmZpbGUuc3RhdC5tdGltZSAhPSB0aGlzLmxhc3RVcGRhdGVUcmlnZ2VyZWRCeURvY0NoYW5nZSkge1xuICAgICAgICAvLyBjaGVjayBpZiBkb2N1bWVudCBhbmQgY29udGVudCBhY3R1YWxseSBhcmUgb3V0IG9mIHN5bmNcbiAgICAgICAgdGhpcy5tdXRleC5ydW5FeGNsdXNpdmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHlEb2NDb250ZW50ID0gdGhpcy5nZXRWYWx1ZSgpXG4gICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZCh0aGlzLl9maWxlKVxuICAgICAgICAgIGlmICh5RG9jQ29udGVudCAhPSBmaWxlQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgZGlmZnMgPSBkaWZmKHlEb2NDb250ZW50LCBmaWxlQ29udGVudClcbiAgICAgICAgICAgIGRpZmZDbGVhbnVwRWZmaWNpZW5jeShkaWZmcylcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpXG4gICAgICAgICAgICBsZXQgcG9zID0gMFxuICAgICAgICAgICAgdGhpcy55RG9jLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkaWZmIG9mIGRpZmZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRpZmZbMV0gYXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gdGV4dC5sZW5ndGhcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpZmZbMF0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIGtlZXBcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZVxuICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuZGVsZXRlKHBvcywgbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgLy8gYWRkXG4gICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50Lmluc2VydChwb3MsIHRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSkpXG5cbiAgICBhZGRJc1NoYXJlZENsYXNzKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gIH1cblxuICBnZXQgZmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZVxuICB9XG5cbiAgY2FsY3VsYXRlSGFzaCgpIHtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKS50b1N0cmluZygpXG4gICAgcmV0dXJuIGNhbGN1bGF0ZUhhc2godGV4dClcbiAgfVxuXG4gIHN0YXJ0V2ViUlRDU3luYygpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RhcnRXZWJSVENTeW5jKChwcm92aWRlcikgPT4ge1xuXG4gICAgICBwcm92aWRlci5hd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCd1c2VyJywge1xuICAgICAgICBuYW1lOiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5uYW1lLFxuICAgICAgICBjb2xvcjogU2hhcmVkRG9jdW1lbnQuX3VzZXJDb2xvci5kYXJrLFxuICAgICAgICBjb2xvckxpZ2h0OiBTaGFyZWREb2N1bWVudC5fdXNlckNvbG9yLmxpZ2h0XG4gICAgICB9KVxuXG5cbiAgICAgIHByb3ZpZGVyLmF3YXJlbmVzcy5vbihcInVwZGF0ZVwiLCBhc3luYyAobXNnOiB7IGFkZGVkOiBBcnJheTxudW1iZXI+LCByZW1vdmVkOiBBcnJheTxudW1iZXI+IH0pID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG1zZy5yZW1vdmVkID8/IFtdO1xuICAgICAgICBpZiAocmVtb3ZlZCAmJiByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkU3RyaW5ncyA9IHJlbW92ZWQubWFwKChpZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlkLnRvRml4ZWQoMCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb25zdCBvd25lciA9IHRoaXMuZ2V0T3duZXJGcmFnbWVudCgpLnRvU3RyaW5nKClcbiAgICAgICAgICBpZiAob3duZXIgIT0gcHJvdmlkZXIuYXdhcmVuZXNzLmNsaWVudElELnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkU3RyaW5ncy5pbmNsdWRlcyhvd25lcikgJiYgIXRoaXMuaXNQZXJtYW5lbnQpIHtcbiAgICAgICAgICAgICAgc2hvd05vdGljZShcIlNoYXJlZCBzZXNzaW9uIGZvciBcIiArIHRoaXMucGF0aCArIFwiIHN0b3BwZWQgYnkgb3duZXJcIilcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy51bnNoYXJlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IGFkZGVkID0gbXNnLmFkZGVkID8/IFtdO1xuICAgICAgICBpZiAoYWRkZWQgJiYgYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHN0YXRlcyA9IHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFkZGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwZWVyID0gc3RhdGVzLmdldChrZXkpXG4gICAgICAgICAgICBpZiAocGVlciAmJiB0aGlzLnBhdGggJiYga2V5ICE9IHRoaXMuX3dlYlJUQ1Byb3ZpZGVyPy5hd2FyZW5lc3MuY2xpZW50SUQpIHtcbiAgICAgICAgICAgICAgc2hvd05vdGljZShgJHtwZWVyLnVzZXI/Lm5hbWV9IGlzIHdvcmtpbmcgb24gJHt0aGlzLnBhdGh9YCwgMTAwMDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuXG5cbiAgICAgIC8qXG4gICAgICBpZiAoIXRoaXMuX3dlYlJUQ1RpbWVvdXQpIHtcblxuICAgICAgICBjb25zdCBoYW5kbGVUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9leHRlbnNpb25zLnNpemUgPiAwIHx8IGdldExlYWZJZHNCeVBhdGgodGhpcy5wYXRoLCB0aGlzLnBsdWdpbi5wd3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3dlYlJUQ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCA2MDAwMClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9wV2ViUlRDU3luYygpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2ViUlRDVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIDYwMDAwKVxuXG4gICAgICAgIHByb3ZpZGVyLmRvYy5vbigndXBkYXRlJywgYXN5bmMgKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiBhbnksIGRvYzogWS5Eb2MsIHRyOiBZLlRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX3dlYlJUQ1RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl93ZWJSVENUaW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl93ZWJSVENUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlVGltZW91dCwgNjAwMDApXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgfSlcblxuICB9XG5cbiAgYXN5bmMgc2V0TmV3RmlsZUxvY2F0aW9uKGZpbGU6IFRGaWxlKSB7XG4gICAgY29uc3Qgb2xkUGF0aCA9IHRoaXMuX3BhdGhcbiAgICB0aGlzLl9maWxlID0gZmlsZVxuICAgIHRoaXMuX3BhdGggPSBub3JtYWxpemVQYXRoKGZpbGUucGF0aClcbiAgICBpZiAodGhpcy5zdGF0dXNCYXJFbnRyeSkge1xuICAgICAgdGhpcy5yZW1vdmVTdGF0dXNTdGF0dXNCYXJFbnRyeSgpXG4gICAgICB0aGlzLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICB9XG4gICAgYXdhaXQgbW92ZURvYyhvbGRQYXRoLCBmaWxlLnBhdGgsIHRoaXMucGx1Z2luKVxuICAgIHJlbW92ZUlzU2hhcmVkQ2xhc3Mob2xkUGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgYWRkSXNTaGFyZWRDbGFzcyh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICB9XG5cbiAgYXN5bmMgc2V0UGVybWFuZW50KCkge1xuICAgIGlmICghdGhpcy5faXNQZXJtYW5lbnQpIHtcbiAgICAgIHRoaXMuX2lzUGVybWFuZW50ID0gdHJ1ZVxuICAgICAgYXdhaXQgYWRkKHRoaXMsIHRoaXMucGx1Z2luKVxuICAgICAgdGhpcy5wbHVnaW4uYWN0aXZlU3RyZWFtQ2xpZW50LmFkZChbdGhpcy5zaGFyZUlkXSlcbiAgICB9XG4gIH1cblxuICBnZXQgaXNQZXJtYW5lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUGVybWFuZW50XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKS50b1N0cmluZygpXG4gIH1cblxuICBnZXRDb250ZW50RnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueURvYy5nZXRUZXh0KFwiY29udGVudFwiKVxuICB9XG5cbiAgZ2V0T3duZXJGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy55RG9jLmdldFRleHQoXCJvd25lclwiKVxuICB9XG5cbiAgYXN5bmMgc3RhcnRJbmRleGVkREJTeW5jKCkge1xuICAgIGlmICh0aGlzLl9pbmRleGVkREJQcm92aWRlcikgcmV0dXJuIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyXG4gICAgY29uc3QgaWQgPSAoZ2V0RG9jQnlQYXRoKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pKT8ucGVyc2lzdGVuY2VJZFxuICAgIGlmICghaWQpIHJldHVyblxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IEluZGV4ZWRkYlBlcnNpc3RlbmNlKFNoYXJlZEVudGl0eS5EQl9QRVJTSVNURU5DRV9QUkVGSVggKyBpZCwgdGhpcy55RG9jKVxuICAgIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICBpZiAoIXByb3ZpZGVyLnN5bmNlZCkgYXdhaXQgcHJvdmlkZXIud2hlblN5bmNlZFxuXG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyXG4gIH1cblxuICBhZGRFeHRlbnNpb25Ub0xlYWYobGVhZklkOiBzdHJpbmcpIHtcbiAgICAvLyBvbmx5IG1ha2VzIHNlbnNlIGlmIHdlIGhhdmUgYSB3ZWJyY3QgcHJvdmlkZXIgdG8gc3luYyB3aXRoXG4gICAgY29uc3Qgd2ViUlRDUHJvdmlkZXIgPSB0aGlzLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgaWYgKCF3ZWJSVENQcm92aWRlcikgcmV0dXJuXG4gICAgLy8gYWxyZWFkeSB0aGVyZVxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zLmdldChsZWFmSWQpKSByZXR1cm5cbiAgICAvLyBuZWVkIGEgcGxlYWZcbiAgICBjb25zdCBwTGVhZiA9IHRoaXMucGx1Z2luLnB3cy5nZXQobGVhZklkKVxuICAgIGlmICghcExlYWYpIHJldHVyblxuXG4gICAgLy8gcGF0aCBuZWVkcyB0byBtYXRjaFxuXG4gICAgaWYgKHBMZWFmLnBhdGggIT0gdGhpcy5fcGF0aCkgcmV0dXJuXG4gICAgaWYgKHBMZWFmLmlzUHJldmlldykge1xuICAgICAgcExlYWYub25jZShcImNoYW5nZUlzUHJldmlld1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkRXh0ZW5zaW9uVG9MZWFmKGxlYWZJZClcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBsZWFmID0gdGhpcy5wbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWFmQnlJZChsZWFmSWQpXG4gICAgaWYgKCFsZWFmKSByZXR1cm5cbiAgICBjb25zdCB2aWV3ID0gbGVhZi52aWV3IGFzIE1hcmtkb3duVmlld1xuICAgIGNvbnN0IGVkaXRvciA9IHZpZXcuZWRpdG9yXG5cbiAgICBlZGl0b3Iuc2V0VmFsdWUodGhpcy5nZXRWYWx1ZSgpKVxuXG4gICAgY29uc3QgdW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcih0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpKVxuXG4gICAgY29uc3QgZXh0ZW5zaW9uID0geUNvbGxhYih0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpLCB3ZWJSVENQcm92aWRlci5hd2FyZW5lc3MsIHsgdW5kb01hbmFnZXIgfSlcbiAgICBjb25zdCBjb21wYXJ0bWVudCA9IG5ldyBDb21wYXJ0bWVudCgpXG5cbiAgICBjb25zdCBlZGl0b3JWaWV3ID0gKGVkaXRvciBhcyBhbnkpLmNtIGFzIEVkaXRvclZpZXc7XG4gICAgZWRpdG9yVmlldy5kaXNwYXRjaCh7XG4gICAgICBlZmZlY3RzOiBTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoY29tcGFydG1lbnQub2YoZXh0ZW5zaW9uKSlcbiAgICB9KVxuXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5zZXQobGVhZklkLCBjb21wYXJ0bWVudClcblxuICAgIC8vIHJlbW92ZSBpZiBzd2l0Y2ggdG8gcHJldmlld1xuICAgIHBMZWFmLm9uY2UoXCJjaGFuZ2VJc1ByZXZpZXdcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVFeHRlbnNpb25Gcm9tTGVhZihsZWFmSWQpXG4gICAgICAvLyBhZGQgYWdhaW4gaWYgc3dpdGNoZWQgYmFja1xuICAgICAgcExlYWYub25jZShcImNoYW5nZUlzUHJldmlld1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkRXh0ZW5zaW9uVG9MZWFmKGxlYWZJZClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHJldHVybiBDb21wYXJ0bWVudFxuICB9XG5cbiAgcmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYobGVhZklkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBsZWFmID0gdGhpcy5wbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWFmQnlJZChsZWFmSWQpXG4gICAgaWYgKGxlYWYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IChsZWFmLnZpZXcgYXMgTWFya2Rvd25WaWV3KS5lZGl0b3JcbiAgICAgICAgY29uc3QgZWRpdG9yVmlldyA9IChlZGl0b3IgYXMgYW55KS5jbSBhcyBFZGl0b3JWaWV3O1xuICAgICAgICBjb25zdCBjb21wYXJ0bWVudCA9IHRoaXMuX2V4dGVuc2lvbnMuZ2V0KGxlYWZJZClcbiAgICAgICAgaWYgKGNvbXBhcnRtZW50KSB7XG4gICAgICAgICAgZWRpdG9yVmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBlZmZlY3RzOiBjb21wYXJ0bWVudC5yZWNvbmZpZ3VyZShbXSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnBsdWdpbi5sb2coXCJlZGl0b3IgYWxyZWFkeSBnb25lXCIpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2V4dGVuc2lvbnMuZGVsZXRlKGxlYWZJZClcbiAgfVxuXG4gIGFkZFN0YXR1c0JhckVudHJ5KCkge1xuICAgIGlmICh0aGlzLnN0YXR1c0JhckVudHJ5KSByZXR1cm5cbiAgICBjb25zdCBtZW51ID0gbmV3IE1lbnUoKVxuICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5zZXRUaXRsZShcIkNvcHkgbGlua1wiKVxuICAgICAgaXRlbS5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi9jbS9cIiArIHRoaXMuc2hhcmVJZClcbiAgICAgICAgc2hvd05vdGljZShcIkxpbmsgY29waWVkIHRvIGNsaXBib2FyZC5cIilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIG1lbnUuYWRkSXRlbSgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5zZXRUaXRsZShcIlN0b3Agc2hhcmVkIHNlc3Npb25cIilcbiAgICAgIGl0ZW0ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMudW5zaGFyZSgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnBsdWdpbi5hZGRTdGF0dXNCYXJJdGVtKCk7XG4gICAgc3RhdHVzLmFkZENsYXNzKCdtb2QtY2xpY2thYmxlJylcbiAgICBzdGF0dXMuY3JlYXRlRWwoXCJzcGFuXCIsIHsgdGV4dDogXCJTaGFyaW5nICdcIiArIHRoaXMucGF0aCArIFwiJ1wiIH0pXG4gICAgc3RhdHVzLm9uQ2xpY2tFdmVudCgoZXZlbnQpID0+IHtcbiAgICAgIG1lbnUuc2hvd0F0TW91c2VFdmVudChldmVudCk7XG4gICAgfSlcbiAgICB0aGlzLnN0YXR1c0JhckVudHJ5ID0gc3RhdHVzXG4gIH1cblxuICByZW1vdmVTdGF0dXNTdGF0dXNCYXJFbnRyeSgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdHVzQmFyRW50cnkpIHJldHVyblxuICAgIHRoaXMuc3RhdHVzQmFyRW50cnkucmVtb3ZlKClcbiAgICB0aGlzLnN0YXR1c0JhckVudHJ5ID0gdW5kZWZpbmVkXG4gIH1cblxuICBhc3luYyB1bnNoYXJlKCkge1xuICAgIGNvbnN0IGRiRW50cnkgPSBnZXREb2NCeVBhdGgodGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgICBpZiAoZGJFbnRyeSkge1xuICAgICAgcmVtb3ZlRG9jKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgfVxuICAgIGlmICh0aGlzLl9pbmRleGVkREJQcm92aWRlcikge1xuICAgICAgYXdhaXQgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIuY2xlYXJEYXRhKClcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICByZW1vdmVJc1NoYXJlZENsYXNzKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gIH1cblxuICBnZXRTaGFyZVVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi9jbS9cIiArIHRoaXMuc2hhcmVJZFxuICB9XG5cbiAgdXBkYXRlUHJvcGVydHkobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBvbGRQcm9wZXJ0eT86IHN0cmluZykge1xuICAgIHRoaXMucGx1Z2luLmFwcC5maWxlTWFuYWdlci5wcm9jZXNzRnJvbnRNYXR0ZXIodGhpcy5maWxlLCAoZm0pID0+IHtcbiAgICAgIGlmIChvbGRQcm9wZXJ0eSkge1xuICAgICAgICBkZWxldGUgZm1bb2xkUHJvcGVydHldXG4gICAgICB9XG4gICAgICBmbVtuYW1lXSA9IHZhbHVlXG4gICAgfSlcbiAgfVxuXG5cblxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5pc1Blcm1hbmVudCkge1xuICAgICAgc2hvd05vdGljZShcIlN0b3BwaW5nIGNvbGxhYm9yYXRpb24gb24gXCIgKyB0aGlzLnBhdGggKyBcIi5cIilcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5fZXh0ZW5zaW9ucy5rZXlzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV4dGVuc2lvbkZyb21MZWFmKGtleSlcbiAgICB9XG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5kZXN0cm95KClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgICB0aGlzLnJlbW92ZVN0YXR1c1N0YXR1c0JhckVudHJ5KClcbiAgICBTaGFyZWREb2N1bWVudC5fc2hhcmVkRW50aXRlcy5zcGxpY2UoU2hhcmVkRG9jdW1lbnQuX3NoYXJlZEVudGl0ZXMuaW5kZXhPZih0aGlzKSwgMSlcbiAgfVxufSIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBCaW5hcnkgZGF0YSBjb25zdGFudHMuXG4gKlxuICogQG1vZHVsZSBiaW5hcnlcbiAqL1xuXG4vKipcbiAqIG4tdGggYml0IGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUMSA9IDFcbmV4cG9ydCBjb25zdCBCSVQyID0gMlxuZXhwb3J0IGNvbnN0IEJJVDMgPSA0XG5leHBvcnQgY29uc3QgQklUNCA9IDhcbmV4cG9ydCBjb25zdCBCSVQ1ID0gMTZcbmV4cG9ydCBjb25zdCBCSVQ2ID0gMzJcbmV4cG9ydCBjb25zdCBCSVQ3ID0gNjRcbmV4cG9ydCBjb25zdCBCSVQ4ID0gMTI4XG5leHBvcnQgY29uc3QgQklUOSA9IDI1NlxuZXhwb3J0IGNvbnN0IEJJVDEwID0gNTEyXG5leHBvcnQgY29uc3QgQklUMTEgPSAxMDI0XG5leHBvcnQgY29uc3QgQklUMTIgPSAyMDQ4XG5leHBvcnQgY29uc3QgQklUMTMgPSA0MDk2XG5leHBvcnQgY29uc3QgQklUMTQgPSA4MTkyXG5leHBvcnQgY29uc3QgQklUMTUgPSAxNjM4NFxuZXhwb3J0IGNvbnN0IEJJVDE2ID0gMzI3NjhcbmV4cG9ydCBjb25zdCBCSVQxNyA9IDY1NTM2XG5leHBvcnQgY29uc3QgQklUMTggPSAxIDw8IDE3XG5leHBvcnQgY29uc3QgQklUMTkgPSAxIDw8IDE4XG5leHBvcnQgY29uc3QgQklUMjAgPSAxIDw8IDE5XG5leHBvcnQgY29uc3QgQklUMjEgPSAxIDw8IDIwXG5leHBvcnQgY29uc3QgQklUMjIgPSAxIDw8IDIxXG5leHBvcnQgY29uc3QgQklUMjMgPSAxIDw8IDIyXG5leHBvcnQgY29uc3QgQklUMjQgPSAxIDw8IDIzXG5leHBvcnQgY29uc3QgQklUMjUgPSAxIDw8IDI0XG5leHBvcnQgY29uc3QgQklUMjYgPSAxIDw8IDI1XG5leHBvcnQgY29uc3QgQklUMjcgPSAxIDw8IDI2XG5leHBvcnQgY29uc3QgQklUMjggPSAxIDw8IDI3XG5leHBvcnQgY29uc3QgQklUMjkgPSAxIDw8IDI4XG5leHBvcnQgY29uc3QgQklUMzAgPSAxIDw8IDI5XG5leHBvcnQgY29uc3QgQklUMzEgPSAxIDw8IDMwXG5leHBvcnQgY29uc3QgQklUMzIgPSAxIDw8IDMxXG5cbi8qKlxuICogRmlyc3QgbiBiaXRzIGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzAgPSAwXG5leHBvcnQgY29uc3QgQklUUzEgPSAxXG5leHBvcnQgY29uc3QgQklUUzIgPSAzXG5leHBvcnQgY29uc3QgQklUUzMgPSA3XG5leHBvcnQgY29uc3QgQklUUzQgPSAxNVxuZXhwb3J0IGNvbnN0IEJJVFM1ID0gMzFcbmV4cG9ydCBjb25zdCBCSVRTNiA9IDYzXG5leHBvcnQgY29uc3QgQklUUzcgPSAxMjdcbmV4cG9ydCBjb25zdCBCSVRTOCA9IDI1NVxuZXhwb3J0IGNvbnN0IEJJVFM5ID0gNTExXG5leHBvcnQgY29uc3QgQklUUzEwID0gMTAyM1xuZXhwb3J0IGNvbnN0IEJJVFMxMSA9IDIwNDdcbmV4cG9ydCBjb25zdCBCSVRTMTIgPSA0MDk1XG5leHBvcnQgY29uc3QgQklUUzEzID0gODE5MVxuZXhwb3J0IGNvbnN0IEJJVFMxNCA9IDE2MzgzXG5leHBvcnQgY29uc3QgQklUUzE1ID0gMzI3NjdcbmV4cG9ydCBjb25zdCBCSVRTMTYgPSA2NTUzNVxuZXhwb3J0IGNvbnN0IEJJVFMxNyA9IEJJVDE4IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMxOCA9IEJJVDE5IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMxOSA9IEJJVDIwIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMCA9IEJJVDIxIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMSA9IEJJVDIyIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMiA9IEJJVDIzIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyMyA9IEJJVDI0IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNCA9IEJJVDI1IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNSA9IEJJVDI2IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNiA9IEJJVDI3IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyNyA9IEJJVDI4IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyOCA9IEJJVDI5IC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyOSA9IEJJVDMwIC0gMVxuZXhwb3J0IGNvbnN0IEJJVFMzMCA9IEJJVDMxIC0gMVxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzMxID0gMHg3RkZGRkZGRlxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgQklUUzMyID0gMHhGRkZGRkZGRlxuIiwgIi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggbnVtYmVycy5cbiAqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5leHBvcnQgY29uc3QgTUlOX1NBRkVfSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG5cbmV4cG9ydCBjb25zdCBMT1dFU1RfSU5UMzIgPSAxIDw8IDMxXG5leHBvcnQgY29uc3QgSElHSEVTVF9JTlQzMiA9IGJpbmFyeS5CSVRTMzFcbmV4cG9ydCBjb25zdCBISUdIRVNUX1VJTlQzMiA9IGJpbmFyeS5CSVRTMzJcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IChudW0gPT4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKSAmJiBtYXRoLmZsb29yKG51bSkgPT09IG51bSlcbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuZXhwb3J0IGNvbnN0IHBhcnNlSW50ID0gTnVtYmVyLnBhcnNlSW50XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBcIjFcIiBiaXRzIGluIGFuIHVuc2lnbmVkIDMyYml0IG51bWJlci5cbiAqXG4gKiBTdXBlciBmdW4gYml0Y291bnQgYWxnb3JpdGhtIGJ5IEJyaWFuIEtlcm5pZ2hhbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICovXG5leHBvcnQgY29uc3QgY291bnRCaXRzID0gbiA9PiB7XG4gIG4gJj0gYmluYXJ5LkJJVFMzMlxuICBsZXQgY291bnQgPSAwXG4gIHdoaWxlIChuKSB7XG4gICAgbiAmPSAobiAtIDEpXG4gICAgY291bnQrK1xuICB9XG4gIHJldHVybiBjb3VudFxufVxuIiwgImltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHN0cmluZ3MuXG4gKlxuICogQG1vZHVsZSBzdHJpbmdcbiAqL1xuXG5leHBvcnQgY29uc3QgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZVxuZXhwb3J0IGNvbnN0IGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludFxuXG4vKipcbiAqIFRoZSBsYXJnZXN0IHV0ZjE2IGNoYXJhY3Rlci5cbiAqIENvcnJlc3BvbmRzIHRvIFVpbnQ4QXJyYXkoWzI1NSwgMjU1XSkgb3IgY2hhcmNvZGVvZigyeDJeOClcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9VVEYxNl9DSEFSQUNURVIgPSBmcm9tQ2hhckNvZGUoNjU1MzUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9Mb3dlckNhc2UgPSBzID0+IHMudG9Mb3dlckNhc2UoKVxuXG5jb25zdCB0cmltTGVmdFJlZ2V4ID0gL15cXHMqL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdHJpbUxlZnQgPSBzID0+IHMucmVwbGFjZSh0cmltTGVmdFJlZ2V4LCAnJylcblxuY29uc3QgZnJvbUNhbWVsQ2FzZVJlZ2V4ID0gLyhbQS1aXSkvZ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQ2FtZWxDYXNlID0gKHMsIHNlcGFyYXRvcikgPT4gdHJpbUxlZnQocy5yZXBsYWNlKGZyb21DYW1lbENhc2VSZWdleCwgbWF0Y2ggPT4gYCR7c2VwYXJhdG9yfSR7dG9Mb3dlckNhc2UobWF0Y2gpfWApKVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHV0ZjhCeXRlTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4Qnl0ZUxlbmd0aCA9IHN0ciA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpXG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSlcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOFBvbHlmaWxsID0gYnVmID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IGJ1Zi5sZW5ndGhcbiAgbGV0IGVuY29kZWRTdHJpbmcgPSAnJ1xuICBsZXQgYnVmUG9zID0gMFxuICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgY29uc3QgYnl0ZXMgPSBidWYuc3ViYXJyYXkoYnVmUG9zLCBidWZQb3MgKyBuZXh0TGVuKVxuICAgIGJ1ZlBvcyArPSBuZXh0TGVuXG4gICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gIH1cbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgbGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOE5hdGl2ZSA9IGJ1ZiA9PiAvKiogQHR5cGUge1RleHREZWNvZGVyfSAqLyAodXRmOFRleHREZWNvZGVyKS5kZWNvZGUoYnVmKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZGVjb2RlVXRmOCA9IHV0ZjhUZXh0RGVjb2RlciA/IF9kZWNvZGVVdGY4TmF0aXZlIDogX2RlY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGluaXRpYWwgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggU3RhcnRpbmcgcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmUgTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5zZXJ0IE5ldyBjb250ZW50IHRvIGluc2VydFxuICovXG5leHBvcnQgY29uc3Qgc3BsaWNlID0gKHN0ciwgaW5kZXgsIHJlbW92ZSwgaW5zZXJ0ID0gJycpID0+IHN0ci5zbGljZSgwLCBpbmRleCkgKyBpbnNlcnQgKyBzdHIuc2xpY2UoaW5kZXggKyByZW1vdmUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGVhdCA9IChzb3VyY2UsIG4pID0+IGFycmF5LnVuZm9sZChuLCAoKSA9PiBzb3VyY2UpLmpvaW4oJycpXG4iLCAiLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gJy4vbnVtYmVyLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMFxuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VWludDhBcnJheT59XG4gICAgICovXG4gICAgdGhpcy5idWZzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVuY29kZXIgPSAoKSA9PiBuZXcgRW5jb2RlcigpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyKTp2b2lkfSBmXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAoZikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpXG4gIGYoZW5jb2RlcilcbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBlbmNvZGVyID0+IHtcbiAgbGV0IGxlbiA9IGVuY29kZXIuY3Bvc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGxlbiArPSBlbmNvZGVyLmJ1ZnNbaV0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGxlblxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgZW5jb2RlciBpcyBlbXB0eS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbnRlbnQgPSBlbmNvZGVyID0+IGVuY29kZXIuY3BvcyA+IDAgfHwgZW5jb2Rlci5idWZzLmxlbmd0aCA+IDBcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdG8gVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGNyZWF0ZWQgQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXkgPSBlbmNvZGVyID0+IHtcbiAgY29uc3QgdWludDhhcnIgPSBuZXcgVWludDhBcnJheShsZW5ndGgoZW5jb2RlcikpXG4gIGxldCBjdXJQb3MgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXVxuICAgIHVpbnQ4YXJyLnNldChkLCBjdXJQb3MpXG4gICAgY3VyUG9zICs9IGQubGVuZ3RoXG4gIH1cbiAgdWludDhhcnIuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcyksIGN1clBvcylcbiAgcmV0dXJuIHVpbnQ4YXJyXG59XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgaXQgaXMgcG9zc2libGUgdG8gd3JpdGUgYGxlbmAgYnl0ZXMgd3RpaG91dCBjaGVja2luZy4gSWZcbiAqIG5lY2Vzc2FyeSwgYSBuZXcgQnVmZmVyIHdpdGggdGhlIHJlcXVpcmVkIGxlbmd0aCBpcyBhdHRhY2hlZC5cbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcmlmeUxlbiA9IChlbmNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBpZiAoYnVmZmVyTGVuIC0gZW5jb2Rlci5jcG9zIDwgbGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZW5jb2Rlci5jYnVmLmJ1ZmZlciwgMCwgZW5jb2Rlci5jcG9zKSlcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShtYXRoLm1heChidWZmZXJMZW4sIGxlbikgKiAyKVxuICAgIGVuY29kZXIuY3BvcyA9IDBcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBieXRlIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoXG4gIGlmIChlbmNvZGVyLmNwb3MgPT09IGJ1ZmZlckxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1ZilcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW4gKiAyKVxuICAgIGVuY29kZXIuY3BvcyA9IDBcbiAgfVxuICBlbmNvZGVyLmNidWZbZW5jb2Rlci5jcG9zKytdID0gbnVtXG59XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXQgYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAqIFBvc2l0aW9uIG11c3QgYWxyZWFkeSBiZSB3cml0dGVuIChpLmUuIGVuY29kZXIubGVuZ3RoID4gcG9zKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFBvc2l0aW9uIHRvIHdoaWNoIHRvIHdyaXRlIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICovXG5leHBvcnQgY29uc3Qgc2V0ID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIGxldCBidWZmZXIgPSBudWxsXG4gIC8vIGl0ZXJhdGUgYWxsIGJ1ZmZlcnMgYW5kIGFkanVzdCBwb3NpdGlvblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGggJiYgYnVmZmVyID09PSBudWxsOyBpKyspIHtcbiAgICBjb25zdCBiID0gZW5jb2Rlci5idWZzW2ldXG4gICAgaWYgKHBvcyA8IGIubGVuZ3RoKSB7XG4gICAgICBidWZmZXIgPSBiIC8vIGZvdW5kIGJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgLT0gYi5sZW5ndGhcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkge1xuICAgIC8vIHVzZSBjdXJyZW50IGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGVuY29kZXIuY2J1ZlxuICB9XG4gIGJ1ZmZlcltwb3NdID0gbnVtXG59XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDggPSB3cml0ZVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIEludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVpbnQ4ID0gc2V0XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQxNiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgd3JpdGUoZW5jb2RlciwgbnVtICYgYmluYXJ5LkJJVFM4KVxuICB3cml0ZShlbmNvZGVyLCAobnVtID4+PiA4KSAmIGJpbmFyeS5CSVRTOClcbn1cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVpbnQxNiA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBzZXQoZW5jb2RlciwgcG9zLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gIHNldChlbmNvZGVyLCBwb3MgKyAxLCAobnVtID4+PiA4KSAmIGJpbmFyeS5CSVRTOClcbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlclxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50MzIgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgbnVtICYgYmluYXJ5LkJJVFM4KVxuICAgIG51bSA+Pj49IDhcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGJpZyBlbmRpYW4gb3JkZXIuXG4gKiAobW9zdCBzaWduaWZpY2FudCBieXRlIGZpcnN0KVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50MzJCaWdFbmRpYW4gPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPj4+ICg4ICogaSkpICYgYmluYXJ5LkJJVFM4KVxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVpbnQzMiA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHNldChlbmNvZGVyLCBwb3MgKyBpLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gICAgbnVtID4+Pj0gOFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggdW5zaWduZWQgaW50ZWdlci4gTWF4IGVuY29kYWJsZSBpbnRlZ2VyIGlzIDJeNTMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBiaW5hcnkuQklUUzcpIHtcbiAgICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUOCB8IChiaW5hcnkuQklUUzcgJiBudW0pKVxuICAgIG51bSA9IG1hdGguZmxvb3IobnVtIC8gMTI4KSAvLyBzaGlmdCA+Pj4gN1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIGJpbmFyeS5CSVRTNyAmIG51bSlcbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyLlxuICpcbiAqIFdlIHVzZSB0aGUgN3RoIGJpdCBpbnN0ZWFkIGZvciBzaWduYWxpbmcgdGhhdCB0aGlzIGlzIGEgbmVnYXRpdmUgbnVtYmVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJJbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGlzTmVnYXRpdmUgPSBtYXRoLmlzTmVnYXRpdmVaZXJvKG51bSlcbiAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICBudW0gPSAtbnVtXG4gIH1cbiAgLy8gICAgICAgICAgICAgfC0gd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nICAgICAgICAgfC0gd2hldGhlciBpcyBuZWdhdGl2ZSAgICAgfC0gbnVtYmVyXG4gIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzYgPyBiaW5hcnkuQklUOCA6IDApIHwgKGlzTmVnYXRpdmUgPyBiaW5hcnkuQklUNyA6IDApIHwgKGJpbmFyeS5CSVRTNiAmIG51bSkpXG4gIG51bSA9IG1hdGguZmxvb3IobnVtIC8gNjQpIC8vIHNoaWZ0ID4+PiA2XG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbnVtID09PSAwIHNvIHdlIGNhbiB1c2UgYSBkaWZmZXJlbnRcbiAgLy8gcGF0dGVybiBoZXJlIHRoYW4gYWJvdmUuXG4gIHdoaWxlIChudW0gPiAwKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgKG51bSA+IGJpbmFyeS5CSVRTNyA/IGJpbmFyeS5CSVQ4IDogMCkgfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPSBtYXRoLmZsb29yKG51bSAvIDEyOCkgLy8gc2hpZnQgPj4+IDdcbiAgfVxufVxuXG4vKipcbiAqIEEgY2FjaGUgdG8gc3RvcmUgc3RyaW5ncyB0ZW1wb3JhcmlseVxuICovXG5jb25zdCBfc3RyQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMzAwMDApXG5jb25zdCBfbWF4U3RyQlNpemUgPSBfc3RyQnVmZmVyLmxlbmd0aCAvIDNcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGlmIChzdHIubGVuZ3RoIDwgX21heFN0ckJTaXplKSB7XG4gICAgLy8gV2UgY2FuIGVuY29kZSB0aGUgc3RyaW5nIGludG8gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3Qgd3JpdHRlbiA9IHN0cmluZy51dGY4VGV4dEVuY29kZXIuZW5jb2RlSW50byhzdHIsIF9zdHJCdWZmZXIpLndyaXR0ZW4gfHwgMFxuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCB3cml0dGVuKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdHRlbjsgaSsrKSB7XG4gICAgICB3cml0ZShlbmNvZGVyLCBfc3RyQnVmZmVyW2ldKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2Rlciwgc3RyaW5nLmVuY29kZVV0Zjgoc3RyKSlcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpXG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoXG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpKVxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFyU3RyaW5nID0gKHN0cmluZy51dGY4VGV4dEVuY29kZXIgJiYgLyoqIEB0eXBlIHthbnl9ICovIChzdHJpbmcudXRmOFRleHRFbmNvZGVyKS5lbmNvZGVJbnRvKSA/IF93cml0ZVZhclN0cmluZ05hdGl2ZSA6IF93cml0ZVZhclN0cmluZ1BvbHlmaWxsXG5cbi8qKlxuICogV3JpdGUgYSBzdHJpbmcgdGVybWluYXRlZCBieSBhIHNwZWNpYWwgYnl0ZSBzZXF1ZW5jZS4gVGhpcyBpcyBub3QgdmVyeSBwZXJmb3JtYW50IGFuZCBpc1xuICogZ2VuZXJhbGx5IGRpc2NvdXJhZ2VkLiBIb3dldmVyLCB0aGUgcmVzdWx0aW5nIGJ5dGUgYXJyYXlzIGFyZSBsZXhpb2dyYXBoaWNhbGx5IG9yZGVyZWQgd2hpY2hcbiAqIG1ha2VzIHRoaXMgYSBuaWNlIGZlYXR1cmUgZm9yIGRhdGFiYXNlcy5cbiAqXG4gKiBUaGUgc3RyaW5nIHdpbGwgYmUgZW5jb2RlZCB1c2luZyB1dGY4IGFuZCB0aGVuIHRlcm1pbmF0ZWQgYW5kIGVzY2FwZWQgdXNpbmcgd3JpdGVUZXJtaW5hdGluZ1VpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVRlcm1pbmF0ZWRTdHJpbmcgPSAoZW5jb2Rlciwgc3RyKSA9PlxuICB3cml0ZVRlcm1pbmF0ZWRVaW50OEFycmF5KGVuY29kZXIsIHN0cmluZy5lbmNvZGVVdGY4KHN0cikpXG5cbi8qKlxuICogV3JpdGUgYSB0ZXJtaW5hdGluZyBVaW50OEFycmF5LiBOb3RlIHRoYXQgdGhpcyBpcyBub3QgcGVyZm9ybWFudCBhbmQgaXMgZ2VuZXJhbGx5XG4gKiBkaXNjb3VyYWdlZC4gVGhlcmUgYXJlIGZldyBzaXR1YXRpb25zIHdoZW4gdGhpcyBpcyBuZWVkZWQuXG4gKlxuICogV2UgdXNlIDB4MCBhcyBhIHRlcm1pbmF0aW5nIGNoYXJhY3Rlci4gMHgxIHNlcnZlcyBhcyBhbiBlc2NhcGUgY2hhcmFjdGVyIGZvciAweDAgYW5kIDB4MS5cbiAqXG4gKiBFeGFtcGxlOiBbMCwxLDJdIGlzIGVuY29kZWQgdG8gWzEsMCwxLDEsMiwwXS4gMHgwLCBhbmQgMHgxIG5lZWRlZCB0byBiZSBlc2NhcGVkIHVzaW5nIDB4MS4gVGhlblxuICogdGhlIHJlc3VsdCBpcyB0ZXJtaW5hdGVkIHVzaW5nIHRoZSAweDAgY2hhcmFjdGVyLlxuICpcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGhvdyBtYW55IHN5c3RlbXMgaW1wbGVtZW50IG51bGwgdGVybWluYXRlZCBzdHJpbmdzLiBIb3dldmVyLCB3ZSB1c2UgYW4gZXNjYXBlXG4gKiBjaGFyYWN0ZXIgMHgxIHRvIGF2b2lkIGlzc3VlcyBhbmQgcG90ZW5pYWwgYXR0YWNrcyBvbiBvdXIgZGF0YWJhc2UgKGlmIHRoaXMgaXMgdXNlZCBhcyBhIGtleVxuICogZW5jb2RlciBmb3IgTm9TcWwgZGF0YWJhc2VzKS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVRlcm1pbmF0ZWRVaW50OEFycmF5ID0gKGVuY29kZXIsIGJ1ZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGIgPSBidWZbaV1cbiAgICBpZiAoYiA9PT0gMCB8fCBiID09PSAxKSB7XG4gICAgICB3cml0ZShlbmNvZGVyLCAxKVxuICAgIH1cbiAgICB3cml0ZShlbmNvZGVyLCBidWZbaV0pXG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgMClcbn1cblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudCBvZiBhbm90aGVyIEVuY29kZXIuXG4gKlxuICogQFRPRE86IGNhbiBiZSBpbXByb3ZlZCFcbiAqICAgICAgICAtIE5vdGU6IFNob3VsZCBjb25zaWRlciB0aGF0IHdoZW4gYXBwZW5kaW5nIGEgbG90IG9mIHNtYWxsIEVuY29kZXJzLCB3ZSBzaG91bGQgcmF0aGVyIGNsb25lIHRoYW4gcmVmZXJlbmNpbmcgdGhlIG9sZCBzdHJ1Y3R1cmUuXG4gKiAgICAgICAgICAgICAgICBFbmNvZGVycyBzdGFydCB3aXRoIGEgcmF0aGVyIGJpZyBpbml0aWFsIGJ1ZmZlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5VaW50OEFyclxuICogQHBhcmFtIHtFbmNvZGVyfSBhcHBlbmQgVGhlIEJpbmFyeUVuY29kZXIgdG8gYmUgd3JpdHRlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmluYXJ5RW5jb2RlciA9IChlbmNvZGVyLCBhcHBlbmQpID0+IHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkoYXBwZW5kKSlcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zXG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWF0aC5taW4oYnVmZmVyTGVuIC0gY3BvcywgdWludDhBcnJheS5sZW5ndGgpXG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW5cbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3BvcylcbiAgZW5jb2Rlci5jcG9zICs9IGxlZnRDb3B5TGVuXG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1ZilcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSlcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSlcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW5cbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIERhdGFWaWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzLiBVc2UgaXQgdG8gd3JpdGUgZGF0YSBhZnRlclxuICogY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiAvLyB3cml0ZSBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuc2V0RmxvYXQzMigwLCAxLjEpXG4gKiAvLyByZWFkIGZsb2F0MzIgdXNpbmcgRGF0YVZpZXdcbiAqIGNvbnN0IGR2ID0gcmVhZEZyb21EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuZ2V0RmxvYXQzMigwKSAvLyA9PiAxLjEwMDAwMDAyMzg0MTg1OCAobGVhdmluZyBpdCB0byB0aGUgcmVhZGVyIHRvIGZpbmQgb3V0IHdoeSB0aGlzIGlzIHRoZSBjb3JyZWN0IHJlc3VsdClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZU9uRGF0YVZpZXcgPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIHZlcmlmeUxlbihlbmNvZGVyLCBsZW4pXG4gIGNvbnN0IGR2aWV3ID0gbmV3IERhdGFWaWV3KGVuY29kZXIuY2J1Zi5idWZmZXIsIGVuY29kZXIuY3BvcywgbGVuKVxuICBlbmNvZGVyLmNwb3MgKz0gbGVuXG4gIHJldHVybiBkdmlld1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDMyID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpLnNldEZsb2F0MzIoMCwgbnVtLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRmxvYXQ2NCA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KS5zZXRGbG9hdDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ0ludDY0ID0gKGVuY29kZXIsIG51bSkgPT4gLyoqIEB0eXBlIHthbnl9ICovICh3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkpLnNldEJpZ0ludDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ1VpbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdVaW50NjQoMCwgbnVtLCBmYWxzZSlcblxuY29uc3QgZmxvYXRUZXN0QmVkID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig0KSlcbi8qKlxuICogQ2hlY2sgaWYgYSBudW1iZXIgY2FuIGJlIGVuY29kZWQgYXMgYSAzMiBiaXQgZmxvYXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNGbG9hdDMyID0gbnVtID0+IHtcbiAgZmxvYXRUZXN0QmVkLnNldEZsb2F0MzIoMCwgbnVtKVxuICByZXR1cm4gZmxvYXRUZXN0QmVkLmdldEZsb2F0MzIoMCkgPT09IG51bVxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggZWZmaWNpZW50IGJpbmFyeSBmb3JtYXQuXG4gKlxuICogRGlmZmVyZW5jZXMgdG8gSlNPTjpcbiAqIFx1MjAyMiBUcmFuc2Zvcm1zIGRhdGEgdG8gYSBiaW5hcnkgZm9ybWF0IChub3QgdG8gYSBzdHJpbmcpXG4gKiBcdTIwMjIgRW5jb2RlcyB1bmRlZmluZWQsIE5hTiwgYW5kIEFycmF5QnVmZmVyICh0aGVzZSBjYW4ndCBiZSByZXByZXNlbnRlZCBpbiBKU09OKVxuICogXHUyMDIyIE51bWJlcnMgYXJlIGVmZmljaWVudGx5IGVuY29kZWQgZWl0aGVyIGFzIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIsIGFzIGFcbiAqICAgMzIgYml0IGZsb2F0LCBhcyBhIDY0IGJpdCBmbG9hdCwgb3IgYXMgYSA2NCBiaXQgYmlnaW50LlxuICpcbiAqIEVuY29kaW5nIHRhYmxlOlxuICpcbiAqIHwgRGF0YSBUeXBlICAgICAgICAgICB8IFByZWZpeCAgIHwgRW5jb2RpbmcgTWV0aG9kICAgIHwgQ29tbWVudCB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0gfFxuICogfCB1bmRlZmluZWQgICAgICAgICAgIHwgMTI3ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBGdW5jdGlvbnMsIHN5bWJvbCwgYW5kIGV2ZXJ5dGhpbmcgdGhhdCBjYW5ub3QgYmUgaWRlbnRpZmllZCBpcyBlbmNvZGVkIGFzIHVuZGVmaW5lZCB8XG4gKiB8IG51bGwgICAgICAgICAgICAgICAgfCAxMjYgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IHxcbiAqIHwgaW50ZWdlciAgICAgICAgICAgICB8IDEyNSAgICAgIHwgd3JpdGVWYXJJbnQgICAgICAgIHwgT25seSBlbmNvZGVzIDMyIGJpdCBzaWduZWQgaW50ZWdlcnMgfFxuICogfCBmbG9hdDMyICAgICAgICAgICAgIHwgMTI0ICAgICAgfCB3cml0ZUZsb2F0MzIgICAgICAgfCB8XG4gKiB8IGZsb2F0NjQgICAgICAgICAgICAgfCAxMjMgICAgICB8IHdyaXRlRmxvYXQ2NCAgICAgICB8IHxcbiAqIHwgYmlnaW50ICAgICAgICAgICAgICB8IDEyMiAgICAgIHwgd3JpdGVCaWdJbnQ2NCAgICAgIHwgfFxuICogfCBib29sZWFuIChmYWxzZSkgICAgIHwgMTIxICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBUcnVlIGFuZCBmYWxzZSBhcmUgZGlmZmVyZW50IGRhdGEgdHlwZXMgc28gd2Ugc2F2ZSB0aGUgZm9sbG93aW5nIGJ5dGUgfFxuICogfCBib29sZWFuICh0cnVlKSAgICAgIHwgMTIwICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCAtIDBiMDExMTEwMDAgc28gdGhlIGxhc3QgYml0IGRldGVybWluZXMgd2hldGhlciB0cnVlIG9yIGZhbHNlIHxcbiAqIHwgc3RyaW5nICAgICAgICAgICAgICB8IDExOSAgICAgIHwgd3JpdGVWYXJTdHJpbmcgICAgIHwgfFxuICogfCBvYmplY3Q8c3RyaW5nLGFueT4gIHwgMTE4ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBrZXktdmFsdWUgcGFpcnMgfFxuICogfCBhcnJheTxhbnk+ICAgICAgICAgIHwgMTE3ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBqc29uIHZhbHVlcyB8XG4gKiB8IFVpbnQ4QXJyYXkgICAgICAgICAgfCAxMTYgICAgICB8IHdyaXRlVmFyVWludDhBcnJheSB8IFdlIHVzZSBVaW50OEFycmF5IGZvciBhbnkga2luZCBvZiBiaW5hcnkgZGF0YSB8XG4gKlxuICogUmVhc29ucyBmb3IgdGhlIGRlY3JlYXNpbmcgcHJlZml4OlxuICogV2UgbmVlZCB0aGUgZmlyc3QgYml0IGZvciBleHRlbmRhYmlsaXR5IChsYXRlciB3ZSBtYXkgd2FudCB0byBlbmNvZGUgdGhlXG4gKiBwcmVmaXggd2l0aCB3cml0ZVZhclVpbnQpLiBUaGUgcmVtYWluaW5nIDcgYml0cyBhcmUgZGl2aWRlZCBhcyBmb2xsb3dzOlxuICogWzAtMzBdICAgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBjdXN0b20gcHVycG9zZXNcbiAqICAgICAgICAgIChkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5KVxuICogWzMxLTEyN10gdGhlIGVuZCBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBkYXRhIGVuY29kaW5nIGJ5XG4gKiAgICAgICAgICBsaWIwL2VuY29kaW5nLmpzXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfG51bWJlcnxiaWdpbnR8Ym9vbGVhbnxzdHJpbmd8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58VWludDhBcnJheX0gZGF0YVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVBbnkgPSAoZW5jb2RlciwgZGF0YSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFRZUEUgMTE5OiBTVFJJTkdcbiAgICAgIHdyaXRlKGVuY29kZXIsIDExOSlcbiAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVyLmlzSW50ZWdlcihkYXRhKSAmJiBtYXRoLmFicyhkYXRhKSA8PSBiaW5hcnkuQklUUzMxKSB7XG4gICAgICAgIC8vIFRZUEUgMTI1OiBJTlRFR0VSXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNSlcbiAgICAgICAgd3JpdGVWYXJJbnQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSBpZiAoaXNGbG9hdDMyKGRhdGEpKSB7XG4gICAgICAgIC8vIFRZUEUgMTI0OiBGTE9BVDMyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNClcbiAgICAgICAgd3JpdGVGbG9hdDMyKGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUWVBFIDEyMzogRkxPQVQ2NFxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjMpXG4gICAgICAgIHdyaXRlRmxvYXQ2NChlbmNvZGVyLCBkYXRhKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgLy8gVFlQRSAxMjI6IEJpZ0ludFxuICAgICAgd3JpdGUoZW5jb2RlciwgMTIyKVxuICAgICAgd3JpdGVCaWdJbnQ2NChlbmNvZGVyLCBkYXRhKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVFlQRSAxMjY6IG51bGxcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTI2KVxuICAgICAgfSBlbHNlIGlmIChhcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIC8vIFRZUEUgMTE3OiBBcnJheVxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTcpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVBbnkoZW5jb2RlciwgZGF0YVtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNjogQXJyYXlCdWZmZXJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE2KVxuICAgICAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTE4OiBPYmplY3RcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE4KVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGtleXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwga2V5KVxuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFba2V5XSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIFRZUEUgMTIwLzEyMTogYm9vbGVhbiAodHJ1ZS9mYWxzZSlcbiAgICAgIHdyaXRlKGVuY29kZXIsIGRhdGEgPyAxMjAgOiAxMjEpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUWVBFIDEyNzogdW5kZWZpbmVkXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjcpXG4gIH1cbn1cblxuLyoqXG4gKiBOb3cgY29tZSBhIGZldyBzdGF0ZWZ1bCBlbmNvZGVyIHRoYXQgaGF2ZSB0aGVpciBvd24gY2xhc3Nlcy5cbiAqL1xuXG4vKipcbiAqIEJhc2ljIFJ1biBMZW5ndGggRW5jb2RlciAtIGEgYmFzaWMgY29tcHJlc3Npb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogRW5jb2RlcyBbMSwxLDEsN10gdG8gWzEsMyw3LDFdICgzIHRpbWVzIDEsIDEgdGltZSA3KS4gVGhpcyBlbmNvZGVyIG1pZ2h0IGRvIG1vcmUgaGFybSB0aGFuIGdvb2QgaWYgdGhlcmUgYXJlIGEgbG90IG9mIHZhbHVlcyB0aGF0IGFyZSBub3QgcmVwZWF0ZWQuXG4gKlxuICogSXQgd2FzIG9yaWdpbmFsbHkgdXNlZCBmb3IgaW1hZ2UgY29tcHJlc3Npb24uIENvb2wgLi4gYXJ0aWNsZSBodHRwOi8vY3NicnVjZS5jb20vY2JtL3RyYW5zYWN0b3IvcGRmcy90cmFuc192N19pMDYucGRmXG4gKlxuICogQG5vdGUgVCBtdXN0IG5vdCBiZSBudWxsIVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVuY29kZXIsIFQpOnZvaWR9IHdyaXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdyaXRlcikge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBUaGUgd3JpdGVyXG4gICAgICovXG4gICAgdGhpcy53ID0gd3JpdGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgdGhpcy53KHRoaXMsIHYpXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzaWMgZGlmZiBkZWNvZGVyIHVzaW5nIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzMsIDExMDAsIDExMDEsIDEwNTAsIDBdIHRvIFszLCAxMDk3LCAxLCAtNTEsIC0xMDUwXSB1c2luZyB3cml0ZVZhckludC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIHdyaXRlVmFySW50KHRoaXMsIHYgLSB0aGlzLnMpXG4gICAgdGhpcy5zID0gdlxuICB9XG59XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBJbnREaWZmRW5jb2RlciBhbmQgUmxlRW5jb2Rlci5cbiAqXG4gKiBCYXNpY2FsbHkgZmlyc3Qgd3JpdGVzIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlbiBjb3VudHMgZHVwbGljYXRlIGRpZmZzIHVzaW5nIFJsZUVuY29kaW5nLlxuICpcbiAqIEVuY29kZXMgdGhlIHZhbHVlcyBbMSwxLDEsMiwzLDQsNSw2XSBhcyBbMSwxLDAsMiwxLDVdIChSTEUoWzEsMCwwLDEsMSwxLDEsMV0pIFx1MjFEMiBSbGVJbnREaWZmWzEsMSwwLDIsMSw1XSlcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZUludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdiAmJiB0aGlzLmNvdW50ID4gMCkge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMsIHRoaXMuY291bnQgLSAxKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAwLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgICAgfVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludE9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hVaW50T3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBzaWduIHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IHNpZ24gdG8gbmVnYXRpdmUgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhIGxlbmd0aCBjb21pbmdcbiAgICB3cml0ZVZhckludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgPT09IDEgPyBlbmNvZGVyLnMgOiAtZW5jb2Rlci5zKVxuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFJsZSBlbmNvZGVyIHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb20gdGhlIG1lbnRpb25lZCBwcm9ibGVtIG9mIHRoZSBiYXNpYyBSbGUgZW5jb2Rlci5cbiAqXG4gKiBJbnRlcm5hbGx5IHVzZXMgVmFySW50IGVuY29kZXIgdG8gd3JpdGUgdW5zaWduZWQgaW50ZWdlcnMuIElmIHRoZSBpbnB1dCBvY2N1cnMgbXVsdGlwbGUgdGltZXMsIHdlIHdyaXRlXG4gKiB3cml0ZSBpdCBhcyBhIG5lZ2F0aXZlIG51bWJlci4gVGhlIFVpbnRPcHRSbGVEZWNvZGVyIHRoZW4gdW5kZXJzdGFuZHMgdGhhdCBpdCBuZWVkcyB0byByZWFkIGEgY291bnQuXG4gKlxuICogRW5jb2RlcyBbMSwyLDMsMywzXSBhcyBbMSwyLC0zLDNdIChvbmNlIDEsIG9uY2UgMiwgdGhyZWUgdGltZXMgMylcbiAqL1xuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZW5jb2RlZCBzdGF0ZSBhbmQgdHJhbnNmb3JtIHRoaXMgdG8gYSBVaW50OEFycmF5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZS5cbiAgICovXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogSW5jcmVhc2luZyBVaW50IE9wdGltaXplZCBSTEUgRW5jb2RlclxuICpcbiAqIFRoZSBSTEUgZW5jb2RlciBjb3VudHMgdGhlIG51bWJlciBvZiBzYW1lIG9jY3VyZW5jZXMgb2YgdGhlIHNhbWUgdmFsdWUuXG4gKiBUaGUgSW5jVWludE9wdFJsZSBlbmNvZGVyIGNvdW50cyBpZiB0aGUgdmFsdWUgaW5jcmVhc2VzLlxuICogSS5lLiA3LCA4LCA5LCAxMCB3aWxsIGJlIGVuY29kZWQgYXMgWy03LCA0XS4gMSwgMywgNSB3aWxsIGJlIGVuY29kZWRcbiAqIGFzIFsxLCAzLCA1XS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgKyB0aGlzLmNvdW50ID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggdGhlIGVuY29kZWQgc3RhdGUgYW5kIHRyYW5zZm9ybSB0aGlzIHRvIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW50RGlmZk9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyAgICAgICAgICAzMSBiaXQgbWFraW5nIHVwIHRoZSBkaWZmIHwgd2V0aGVyIHRvIHdyaXRlIHRoZSBjb3VudGVyXG4gICAgLy8gY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgPDwgMSB8IChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgKiAyICsgKGVuY29kZXIuY291bnQgPT09IDEgPyAwIDogMSlcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBmaXJzdCBiaXQgdG8gcG9zaXRpdmVcbiAgICAvLyBjYXNlIDI6IHdyaXRlIHNldmVyYWwgdmFsdWVzLiBzZXQgZmlyc3QgYml0IHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVkRGlmZilcbiAgICBpZiAoZW5jb2Rlci5jb3VudCA+IDEpIHtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgLSAyKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgdGhlIEludERpZmZFbmNvZGVyIGFuZCB0aGUgVWludE9wdFJsZUVuY29kZXIuXG4gKlxuICogVGhlIGNvdW50IGFwcHJvYWNoIGlzIHNpbWlsYXIgdG8gdGhlIFVpbnREaWZmT3B0UmxlRW5jb2RlciwgYnV0IGluc3RlYWQgb2YgdXNpbmcgdGhlIG5lZ2F0aXZlIGJpdGZsYWcsIGl0IGVuY29kZXNcbiAqIGluIHRoZSBMU0Igd2hldGhlciBhIGNvdW50IGlzIHRvIGJlIHJlYWQuIFRoZXJlZm9yZSB0aGlzIEVuY29kZXIgb25seSBzdXBwb3J0cyAzMSBiaXQgaW50ZWdlcnMhXG4gKlxuICogRW5jb2RlcyBbMSwgMiwgMywgMl0gYXMgWzMsIDEsIDYsIC0xXSAobW9yZSBzcGVjaWZpY2FsbHkgWygxIDw8IDEpIHwgMSwgKDMgPDwgMCkgfCAwLCAtMV0pXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy4gQ29udHJhcnkgdG8gbm9ybWFsIFVpbnRWYXIgZW5jb2RpbmcsIHRoZSBmaXJzdCBieXRlIGNvbnRhaW5zOlxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGUgbmV4dCB2YWx1ZSBpcyBhIGNvdW50IChMU0IpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgbmVnYXRpdmUgKE1TQiAtIDEpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgdGhlIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyIChNU0IpXG4gKlxuICogVGhlcmVmb3JlLCBvbmx5IGZpdmUgYml0cyByZW1haW4gdG8gZW5jb2RlIGRpZmYgcmFuZ2VzLlxuICpcbiAqIFVzZSB0aGlzIEVuY29kZXIgb25seSB3aGVuIGFwcHJvcHJpYXRlLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIHByb2JhYmx5IGEgYmFkIGlkZWEuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMuZGlmZiA9PT0gdiAtIHRoaXMucykge1xuICAgICAgdGhpcy5zID0gdlxuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIodGhpcylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICB0aGlzLmRpZmYgPSB2IC0gdGhpcy5zXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHRoZSBlbmNvZGVkIHN0YXRlIGFuZCB0cmFuc2Zvcm0gdGhpcyB0byBhIFVpbnQ4QXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICAgKi9cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpbWl6ZWQgU3RyaW5nIEVuY29kZXIuXG4gKlxuICogRW5jb2RpbmcgbWFueSBzbWFsbCBzdHJpbmdzIGluIGEgc2ltcGxlIEVuY29kZXIgaXMgbm90IHZlcnkgZWZmaWNpZW50LiBUaGUgZnVuY3Rpb24gY2FsbCB0byBkZWNvZGUgYSBzdHJpbmcgdGFrZXMgc29tZSB0aW1lIGFuZCBjcmVhdGVzIHJlZmVyZW5jZXMgdGhhdCBtdXN0IGJlIGV2ZW50dWFsbHkgZGVsZXRlZC5cbiAqIEluIHByYWN0aWNlLCB3aGVuIGRlY29kaW5nIHNldmVyYWwgbWlsbGlvbiBzbWFsbCBzdHJpbmdzLCB0aGUgR0Mgd2lsbCBraWNrIGluIG1vcmUgYW5kIG1vcmUgb2Z0ZW4gdG8gY29sbGVjdCBvcnBoYW5lZCBzdHJpbmcgb2JqZWN0cyAob3IgbWF5YmUgdGhlcmUgaXMgYW5vdGhlciByZWFzb24/KS5cbiAqXG4gKiBUaGlzIHN0cmluZyBlbmNvZGVyIHNvbHZlcyB0aGUgYWJvdmUgcHJvYmxlbS4gQWxsIHN0cmluZ3MgYXJlIGNvbmNhdGVuYXRlZCBhbmQgd3JpdHRlbiBhcyBhIHNpbmdsZSBzdHJpbmcgdXNpbmcgYSBzaW5nbGUgZW5jb2RpbmcgY2FsbC5cbiAqXG4gKiBUaGUgbGVuZ3RocyBhcmUgZW5jb2RlZCB1c2luZyBhIFVpbnRPcHRSbGVFbmNvZGVyLlxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnNhcnIgPSBbXVxuICAgIHRoaXMucyA9ICcnXG4gICAgdGhpcy5sZW5zRSA9IG5ldyBVaW50T3B0UmxlRW5jb2RlcigpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKi9cbiAgd3JpdGUgKHN0cmluZykge1xuICAgIHRoaXMucyArPSBzdHJpbmdcbiAgICBpZiAodGhpcy5zLmxlbmd0aCA+IDE5KSB7XG4gICAgICB0aGlzLnNhcnIucHVzaCh0aGlzLnMpXG4gICAgICB0aGlzLnMgPSAnJ1xuICAgIH1cbiAgICB0aGlzLmxlbnNFLndyaXRlKHN0cmluZy5sZW5ndGgpXG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgIHRoaXMucyA9ICcnXG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgdGhpcy5zYXJyLmpvaW4oJycpKVxuICAgIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlbnNFLnRvVWludDhBcnJheSgpKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxufVxuIiwgIi8qKlxuICogRXJyb3IgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gcyA9PiBuZXcgRXJyb3IocylcblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG5leHBvcnQgY29uc3QgbWV0aG9kVW5pbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgdGhyb3cgY3JlYXRlKCdNZXRob2QgdW5pbXBsZW1lbnRlZCcpXG59XG5cbi8qKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJuIHtuZXZlcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMyAqL1xuZXhwb3J0IGNvbnN0IHVuZXhwZWN0ZWRDYXNlID0gKCkgPT4ge1xuICB0aHJvdyBjcmVhdGUoJ1VuZXhwZWN0ZWQgY2FzZScpXG59XG4iLCAiLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGRlY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9kZWNvZGluZ10gd2l0aCBbbGliMC9lbmNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBkZWNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gJy4vbnVtYmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnLi9lcnJvci5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcuanMnXG5cbmNvbnN0IGVycm9yVW5leHBlY3RlZEVuZE9mQXJyYXkgPSBlcnJvci5jcmVhdGUoJ1VuZXhwZWN0ZWQgZW5kIG9mIGFycmF5JylcbmNvbnN0IGVycm9ySW50ZWdlck91dE9mUmFuZ2UgPSBlcnJvci5jcmVhdGUoJ0ludGVnZXIgb3V0IG9mIFJhbmdlJylcblxuLyoqXG4gKiBBIERlY29kZXIgaGFuZGxlcyB0aGUgZGVjb2Rpbmcgb2YgYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5IEJpbmFyeSBkYXRhIHRvIGRlY29kZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGluZyB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IHVpbnQ4QXJyYXlcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRlY29kaW5nIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDBcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtEZWNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVjb2RlciA9IHVpbnQ4QXJyYXkgPT4gbmV3IERlY29kZXIodWludDhBcnJheSlcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbnRlbnQgPSBkZWNvZGVyID0+IGRlY29kZXIucG9zICE9PSBkZWNvZGVyLmFyci5sZW5ndGhcblxuLyoqXG4gKiBDbG9uZSBhIGRlY29kZXIgaW5zdGFuY2UuXG4gKiBPcHRpb25hbGx5IHNldCBhIG5ldyBwb3NpdGlvbiBwYXJhbWV0ZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3UG9zXSBEZWZhdWx0cyB0byBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtEZWNvZGVyfSBBIGNsb25lIG9mIGBkZWNvZGVyYFxuICovXG5leHBvcnQgY29uc3QgY2xvbmUgPSAoZGVjb2RlciwgbmV3UG9zID0gZGVjb2Rlci5wb3MpID0+IHtcbiAgY29uc3QgX2RlY29kZXIgPSBjcmVhdGVEZWNvZGVyKGRlY29kZXIuYXJyKVxuICBfZGVjb2Rlci5wb3MgPSBuZXdQb3NcbiAgcmV0dXJuIF9kZWNvZGVyXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIFVpbnQ4QXJyYXkgdmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcyBhbmQgYWR2YW5jZSB0aGUgcG9zaXRpb24gYnkgYGxlbmAuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFRoZSBsZW5ndGggb2YgYnl0ZXMgdG8gcmVhZFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OEFycmF5ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiB2aWV3XG59XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBhcyBhbiBBcnJheUJ1ZmZlclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVGFpbEFzVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgZGVjb2Rlci5hcnIubGVuZ3RoIC0gZGVjb2Rlci5wb3MpXG5cbi8qKlxuICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBza2lwOCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MrK1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cblxuLyoqXG4gKiBSZWFkIDIgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQxNiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG4gIGRlY29kZXIucG9zICs9IDJcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgMTYpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMkJpZ0VuZGlhbiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zXVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MTYgPSBkZWNvZGVyID0+XG4gIGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQzMiA9IGRlY29kZXIgPT4gKFxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KVxuKSA+Pj4gMFxuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDBcbiAgbGV0IG11bHQgPSAxXG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aFxuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIGJpbmFyeS5CSVRTNykgKiBtdWx0IC8vIHNoaWZ0ICRyIDw8ICg3KiNpdGVyYXRpb25zKSBhbmQgYWRkIGl0IHRvIG51bVxuICAgIG11bHQgKj0gMTI4IC8vIG5leHQgaXRlcmF0aW9uLCBzaGlmdCA3IFwibW9yZVwiIHRvIHRoZSBsZWZ0XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gbnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgbGV0IG51bSA9IHIgJiBiaW5hcnkuQklUUzZcbiAgbGV0IG11bHQgPSA2NFxuICBjb25zdCBzaWduID0gKHIgJiBiaW5hcnkuQklUNykgPiAwID8gLTEgOiAxXG4gIGlmICgociAmIGJpbmFyeS5CSVQ4KSA9PT0gMCkge1xuICAgIC8vIGRvbid0IGNvbnRpbnVlIHJlYWRpbmdcbiAgICByZXR1cm4gc2lnbiAqIG51bVxuICB9XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aFxuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIGJpbmFyeS5CSVRTNykgKiBtdWx0XG4gICAgbXVsdCAqPSAxMjhcbiAgICBpZiAociA8IGJpbmFyeS5CSVQ4KSB7XG4gICAgICByZXR1cm4gc2lnbiAqIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gbnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFyVWludChkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFySW50KGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogV2UgZG9uJ3QgdGVzdCB0aGlzIGZ1bmN0aW9uIGFueW1vcmUgYXMgd2UgdXNlIG5hdGl2ZSBkZWNvZGluZy9lbmNvZGluZyBieSBkZWZhdWx0IG5vdy5cbiAqIEJldHRlciBub3QgbW9kaWZ5IHRoaXMgYW55bW9yZS4uXG4gKlxuICogVHJhbnNmb3JtaW5nIHV0ZjggdG8gYSBzdHJpbmcgaXMgcHJldHR5IGV4cGVuc2l2ZS4gVGhlIGNvZGUgcGVyZm9ybXMgMTB4IGJldHRlclxuICogd2hlbiBTdHJpbmcuZnJvbUNvZGVQb2ludCBpcyBmZWQgd2l0aCBhbGwgY2hhcmFjdGVycyBhcyBhcmd1bWVudHMuXG4gKiBCdXQgbW9zdCBlbnZpcm9ubWVudHMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBwZXIgZnVuY3Rpb25zLlxuICogRm9yIGVmZmllbmN5IHJlYXNvbnMgd2UgYXBwbHkgYSBtYXhpbXVtIG9mIDEwMDAwIGNoYXJhY3RlcnMgYXQgb25jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSkgLy8gcmVtZW1iZXIgdG8gZGVjcmVhc2UgcmVtYWluaW5nTGVuXG4gICAgaWYgKC0tcmVtYWluaW5nTGVuIDwgMTAwKSB7IC8vIGRvIG5vdCBjcmVhdGUgYSBVaW50OEFycmF5IGZvciBzbWFsbCBzdHJpbmdzXG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuLS0pIHtcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pXG4gICAgICAgIGRlY29kZXIucG9zICs9IG5leHRMZW5cbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW5cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBfcmVhZFZhclN0cmluZ05hdGl2ZSA9IGRlY29kZXIgPT5cbiAgLyoqIEB0eXBlIGFueSAqLyAoc3RyaW5nLnV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJTdHJpbmcgPSBzdHJpbmcudXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFRlcm1pbmF0ZWRVaW50OEFycmF5ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgbGV0IGJcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBiID0gcmVhZFVpbnQ4KGRlY29kZXIpXG4gICAgaWYgKGIgPT09IDApIHtcbiAgICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgICB9XG4gICAgaWYgKGIgPT09IDEpIHtcbiAgICAgIGIgPSByZWFkVWludDgoZGVjb2RlcilcbiAgICB9XG4gICAgZW5jb2Rpbmcud3JpdGUoZW5jb2RlciwgYilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcmVhZFRlcm1pbmF0ZWRTdHJpbmcgPSBkZWNvZGVyID0+IHN0cmluZy5kZWNvZGVVdGY4KHJlYWRUZXJtaW5hdGVkVWludDhBcnJheShkZWNvZGVyKSlcblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclN0cmluZyB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFyU3RyaW5nID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcmV0dXJuIHtEYXRhVmlld31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRGcm9tRGF0YVZpZXcgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGR2ID0gbmV3IERhdGFWaWV3KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5hcnIuYnl0ZU9mZnNldCArIGRlY29kZXIucG9zLCBsZW4pXG4gIGRlY29kZXIucG9zICs9IGxlblxuICByZXR1cm4gZHZcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRGbG9hdDMyID0gZGVjb2RlciA9PiByZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRmxvYXQ2NCA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KS5nZXRGbG9hdDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEJpZ0ludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ0ludDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEJpZ1VpbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdVaW50NjQoMCwgZmFsc2UpXG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKERlY29kZXIpOmFueT59XG4gKi9cbmNvbnN0IHJlYWRBbnlMb29rdXBUYWJsZSA9IFtcbiAgZGVjb2RlciA9PiB1bmRlZmluZWQsIC8vIENBU0UgMTI3OiB1bmRlZmluZWRcbiAgZGVjb2RlciA9PiBudWxsLCAvLyBDQVNFIDEyNjogbnVsbFxuICByZWFkVmFySW50LCAvLyBDQVNFIDEyNTogaW50ZWdlclxuICByZWFkRmxvYXQzMiwgLy8gQ0FTRSAxMjQ6IGZsb2F0MzJcbiAgcmVhZEZsb2F0NjQsIC8vIENBU0UgMTIzOiBmbG9hdDY0XG4gIHJlYWRCaWdJbnQ2NCwgLy8gQ0FTRSAxMjI6IGJpZ2ludFxuICBkZWNvZGVyID0+IGZhbHNlLCAvLyBDQVNFIDEyMTogYm9vbGVhbiAoZmFsc2UpXG4gIGRlY29kZXIgPT4gdHJ1ZSwgLy8gQ0FTRSAxMjA6IGJvb2xlYW4gKHRydWUpXG4gIHJlYWRWYXJTdHJpbmcsIC8vIENBU0UgMTE5OiBzdHJpbmdcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE4OiBvYmplY3Q8c3RyaW5nLGFueT5cbiAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICovXG4gICAgY29uc3Qgb2JqID0ge31cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICBvYmpba2V5XSA9IHJlYWRBbnkoZGVjb2RlcilcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9LFxuICBkZWNvZGVyID0+IHsgLy8gQ0FTRSAxMTc6IGFycmF5PGFueT5cbiAgICBjb25zdCBsZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyLnB1c2gocmVhZEFueShkZWNvZGVyKSlcbiAgICB9XG4gICAgcmV0dXJuIGFyclxuICB9LFxuICByZWFkVmFyVWludDhBcnJheSAvLyBDQVNFIDExNjogVWludDhBcnJheVxuXVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEFueSA9IGRlY29kZXIgPT4gcmVhZEFueUxvb2t1cFRhYmxlWzEyNyAtIHJlYWRVaW50OChkZWNvZGVyKV0oZGVjb2RlcilcblxuLyoqXG4gKiBUIG11c3Qgbm90IGJlIG51bGwuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKERlY29kZXIpOlR9IHJlYWRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXksIHJlYWRlcikge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogVGhlIHJlYWRlclxuICAgICAqL1xuICAgIHRoaXMucmVhZGVyID0gcmVhZGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gdGhpcy5yZWFkZXIodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7VH0gKi8gKHRoaXMucylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50RGlmZkRlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCBzdGFydCkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICB0aGlzLnMgKz0gcmVhZFZhckludCh0aGlzKVxuICAgIHJldHVybiB0aGlzLnNcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmxlSW50RGlmZkRlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCBzdGFydCkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgKz0gcmVhZFZhckludCh0aGlzKVxuICAgICAgaWYgKGhhc0NvbnRlbnQodGhpcykpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMSAvLyBzZWUgZW5jb2RlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBpbmNyZW1lbnRlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IC0xIC8vIHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUgZm9yZXZlclxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5jVWludE9wdFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gcmVhZFZhckludCh0aGlzKVxuICAgICAgLy8gaWYgdGhlIHNpZ24gaXMgbmVnYXRpdmUsIHdlIHJlYWQgdGhlIGNvdW50IHRvbywgb3RoZXJ3aXNlIGNvdW50IGlzIDFcbiAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBtYXRoLmlzTmVnYXRpdmVaZXJvKHRoaXMucylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICB0aGlzLnMgPSAtdGhpcy5zXG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKyspXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICAgIHRoaXMuZGlmZiA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgY29uc3QgZGlmZiA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBmaXJzdCBiaXQgaXMgc2V0LCB3ZSByZWFkIG1vcmUgZGF0YVxuICAgICAgY29uc3QgaGFzQ291bnQgPSBkaWZmICYgMVxuICAgICAgdGhpcy5kaWZmID0gbWF0aC5mbG9vcihkaWZmIC8gMikgLy8gc2hpZnQgPj4gMVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChoYXNDb3VudCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucyArPSB0aGlzLmRpZmZcbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0cmluZ0RlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2Rlcih1aW50OEFycmF5KVxuICAgIHRoaXMuc3RyID0gcmVhZFZhclN0cmluZyh0aGlzLmRlY29kZXIpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNwb3MgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5zcG9zICsgdGhpcy5kZWNvZGVyLnJlYWQoKVxuICAgIGNvbnN0IHJlcyA9IHRoaXMuc3RyLnNsaWNlKHRoaXMuc3BvcywgZW5kKVxuICAgIHRoaXMuc3BvcyA9IGVuZFxuICAgIHJldHVybiByZXNcbiAgfVxufVxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5leHBvcnQgY29uc3Qgc3VidGxlID0gY3J5cHRvLnN1YnRsZVxuZXhwb3J0IGNvbnN0IGdldFJhbmRvbVZhbHVlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pXG4iLCAiLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSBmb3IgdHJ1ZSByYW5kb20gbnVtYmVycyAvIGJ1ZmZlcnMgLyB1dWlkcy5cbiAqXG4gKiBBdHRlbnRpb246IGZhbGxzIGJhY2sgdG8gTWF0aC5yYW5kb20gaWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcnlwdG8uXG4gKlxuICogQG1vZHVsZSByYW5kb21cbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCB7IGdldFJhbmRvbVZhbHVlcyB9IGZyb20gJ2xpYjAvd2ViY3J5cHRvJ1xuXG5leHBvcnQgY29uc3QgcmFuZCA9IE1hdGgucmFuZG9tXG5cbmV4cG9ydCBjb25zdCB1aW50MzIgPSAoKSA9PiBnZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXVxuXG5leHBvcnQgY29uc3QgdWludDUzID0gKCkgPT4ge1xuICBjb25zdCBhcnIgPSBnZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDgpKVxuICByZXR1cm4gKGFyclswXSAmIGJpbmFyeS5CSVRTMjEpICogKGJpbmFyeS5CSVRTMzIgKyAxKSArIChhcnJbMV0gPj4+IDApXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFyclxuICogQHJldHVybiB7VH1cbiAqL1xuZXhwb3J0IGNvbnN0IG9uZU9mID0gYXJyID0+IGFyclttYXRoLmZsb29yKHJhbmQoKSAqIGFyci5sZW5ndGgpXVxuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB1dWlkdjRUZW1wbGF0ZSA9IFsxZTddICsgLTFlMyArIC00ZTMgKyAtOGUzICsgLTFlMTFcblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCB1dWlkdjQgPSAoKSA9PiB1dWlkdjRUZW1wbGF0ZS5yZXBsYWNlKC9bMDE4XS9nLCAvKiogQHBhcmFtIHtudW1iZXJ9IGMgKi8gYyA9PlxuICAoYyBeIHVpbnQzMigpICYgMTUgPj4gYyAvIDQpLnRvU3RyaW5nKDE2KVxuKVxuIiwgIi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIHRvIHdvcmsgd2l0aCBwcm9taXNlcy5cbiAqXG4gKiBAbW9kdWxlIHByb21pc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQGNhbGxiYWNrIFByb21pc2VSZXNvbHZlXG4gKiBAcGFyYW0ge1R8UHJvbWlzZUxpa2U8VD59IFtyZXN1bHRdXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbihQcm9taXNlUmVzb2x2ZTxUPixmdW5jdGlvbihFcnJvcik6dm9pZCk6YW55fSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gZiA9PiAvKiogQHR5cGUge1Byb21pc2U8VD59ICovIChuZXcgUHJvbWlzZShmKSlcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGZ1bmN0aW9uKCk6dm9pZCxmdW5jdGlvbihFcnJvcik6dm9pZCk6dm9pZH0gZlxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVtcHR5ID0gZiA9PiBuZXcgUHJvbWlzZShmKVxuXG4vKipcbiAqIGBQcm9taXNlLmFsbGAgd2FpdCBmb3IgYWxsIHByb21pc2VzIGluIHRoZSBhcnJheSB0byByZXNvbHZlIGFuZCByZXR1cm4gdGhlIHJlc3VsdFxuICogQHRlbXBsYXRlIHt1bmtub3duW10gfCBbXX0gUFNcbiAqXG4gKiBAcGFyYW0ge1BTfSBwc1xuICogQHJldHVybiB7UHJvbWlzZTx7IC1yZWFkb25seSBbUCBpbiBrZXlvZiBQU106IEF3YWl0ZWQ8UFNbUF0+IH0+fVxuICovXG5leHBvcnQgY29uc3QgYWxsID0gUHJvbWlzZS5hbGwuYmluZChQcm9taXNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IFtyZWFzb25dXG4gKiBAcmV0dXJuIHtQcm9taXNlPG5ldmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlamVjdCA9IHJlYXNvbiA9PiBQcm9taXNlLnJlamVjdChyZWFzb24pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VHx2b2lkfSByZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8VHx2b2lkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmUgPSByZXMgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcylcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSByZXNcbiAqIEByZXR1cm4ge1Byb21pc2U8VD59XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlV2l0aCA9IHJlcyA9PiBQcm9taXNlLnJlc29sdmUocmVzKVxuXG4vKipcbiAqIEB0b2RvIE5leHQgdmVyc2lvbiwgcmVvcmRlciBwYXJhbWV0ZXJzOiBjaGVjaywgW3RpbWVvdXQsIFtpbnRlcnZhbFJlc29sdXRpb25dXVxuICogQGRlcHJlY2F0ZWQgdXNlIHVudGlsQXN5bmMgaW5zdGVhZFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6Ym9vbGVhbn0gY2hlY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW50ZXJ2YWxSZXNvbHV0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVudGlsID0gKHRpbWVvdXQsIGNoZWNrLCBpbnRlcnZhbFJlc29sdXRpb24gPSAxMCkgPT4gY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IGhhc1RpbWVvdXQgPSB0aW1lb3V0ID4gMFxuICBjb25zdCB1bnRpbEludGVydmFsID0gKCkgPT4ge1xuICAgIGlmIChjaGVjaygpKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChoYXNUaW1lb3V0KSB7XG4gICAgICAvKiBjOCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRpbWUuZ2V0VW5peFRpbWUoKSAtIHN0YXJ0VGltZSA+IHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVGltZW91dCcpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKHVudGlsSW50ZXJ2YWwsIGludGVydmFsUmVzb2x1dGlvbilcbn0pXG5cbi8qKlxuICogQHBhcmFtIHsoKT0+UHJvbWlzZTxib29sZWFuPnxib29sZWFufSBjaGVja1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbFJlc29sdXRpb25cbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bnRpbEFzeW5jID0gYXN5bmMgKGNoZWNrLCB0aW1lb3V0ID0gMCwgaW50ZXJ2YWxSZXNvbHV0aW9uID0gMTApID0+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG4gIGNvbnN0IG5vVGltZW91dCA9IHRpbWVvdXQgPD0gMFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5tb2RpZmllZC1sb29wLWNvbmRpdGlvblxuICB3aGlsZSAobm9UaW1lb3V0IHx8IHRpbWUuZ2V0VW5peFRpbWUoKSAtIHN0YXJ0VGltZSA8PSB0aW1lb3V0KSB7XG4gICAgaWYgKGF3YWl0IGNoZWNrKCkpIHJldHVyblxuICAgIGF3YWl0IHdhaXQoaW50ZXJ2YWxSZXNvbHV0aW9uKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignVGltZW91dCcpXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHdhaXQgPSB0aW1lb3V0ID0+IGNyZWF0ZSgocmVzb2x2ZSwgX3JlamVjdCkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSlcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGEgcHJvbWlzZSB1c2luZyBkdWNrdHlwaW5nLlxuICpcbiAqIFByb21pc2VzIGFyZSBvZnRlbiBwb2x5ZmlsbGVkLCBzbyBpdCBtYWtlcyBzZW5zZSB0byBhZGQgc29tZSBhZGRpdGlvbmFsIGd1YXJhbnRlZXMgaWYgdGhlIHVzZXIgb2YgdGhpc1xuICogbGlicmFyeSBoYXMgc29tZSBpbnNhbmUgZW52aXJvbm1lbnQgd2hlcmUgZ2xvYmFsIFByb21pc2Ugb2JqZWN0cyBhcmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHthbnl9IHBcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBwID0+IHAgaW5zdGFuY2VvZiBQcm9taXNlIHx8IChwICYmIHAudGhlbiAmJiBwLmNhdGNoICYmIHAuZmluYWxseSlcbiIsICIvKipcbiAqIE9mdGVuIHVzZWQgY29uZGl0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGNvbmRpdGlvbnNcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8bnVsbHx1bmRlZmluZWR9IHZcbiAqIEByZXR1cm4ge1R8bnVsbH1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB1bmRlZmluZWRUb051bGwgPSB2ID0+IHYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSXNvbW9ycGhpYyB2YXJpYWJsZSBzdG9yYWdlLlxuICpcbiAqIFVzZXMgTG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGFuZCBmYWxscyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlLlxuICpcbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY2xhc3MgVmFyU3RvcmFnZVBvbHlmaWxsIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWVcbiAgICovXG4gIHNldEl0ZW0gKGtleSwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBnZXRJdGVtIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAdHlwZSB7YW55fVxuICovXG5sZXQgX2xvY2FsU3RvcmFnZSA9IG5ldyBWYXJTdG9yYWdlUG9seWZpbGwoKVxubGV0IHVzZVBvbHlmaWxsID0gdHJ1ZVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnRyeSB7XG4gIC8vIGlmIHRoZSBzYW1lLW9yaWdpbiBydWxlIGlzIHZpb2xhdGVkLCBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIG1pZ2h0IHRocm93biBhbiBlcnJvclxuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9jYWxTdG9yYWdlKSB7XG4gICAgX2xvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZVxuICAgIHVzZVBvbHlmaWxsID0gZmFsc2VcbiAgfVxufSBjYXRjaCAoZSkgeyB9XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGxvY2FsU3RvcmFnZSBpbiBicm93c2VyLCBvciBhIHBvbHlmaWxsIGluIG5vZGVqc1xuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgYGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBldmVudCA9PiB7Li59KWAgdGhhdCBkb2VzIG5vdGhpbmcgaWYgdGhlIHBvbHlmaWxsIGlzIGJlaW5nIHVzZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih7IGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIH0pOiB2b2lkfSBldmVudEhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9uQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpXG5cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBldmVudCA9PiB7Li59KWAgdGhhdCBkb2VzIG5vdGhpbmcgaWYgdGhlIHBvbHlmaWxsIGlzIGJlaW5nIHVzZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih7IGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIH0pOiB2b2lkfSBldmVudEhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG9mZkNoYW5nZSA9IGV2ZW50SGFuZGxlciA9PiB1c2VQb2x5ZmlsbCB8fCByZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgLyoqIEB0eXBlIHthbnl9ICovIChldmVudEhhbmRsZXIpKVxuIiwgIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFY21hU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8qKlxuICogT2JqZWN0LmFzc2lnblxuICovXG5leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGtleXMgPSBPYmplY3Qua2V5c1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge3tbazpzdHJpbmddOlZ9fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixzdHJpbmcpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgZihvYmpba2V5XSwga2V5KVxuICB9XG59XG5cbi8qKlxuICogQHRvZG8gaW1wbGVtZW50IG1hcFRvQXJyYXkgJiBtYXBcbiAqXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChvYmosIGYpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdHMucHVzaChmKG9ialtrZXldLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG9iamVjdC5zaXplIGluc3RlYWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGxlbmd0aCA9IG9iaiA9PiBrZXlzKG9iaikubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3Qgc2l6ZSA9IG9iaiA9PiBrZXlzKG9iaikubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3Qgc29tZSA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGYob2JqW2tleV0sIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBpc0VtcHR5ID0gb2JqID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIGZvciAoY29uc3QgX2sgaW4gb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBDYWxscyBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChzaXplKGEpID09PSBzaXplKGIpICYmIGV2ZXJ5KGEsICh2YWwsIGtleSkgPT4gKHZhbCAhPT0gdW5kZWZpbmVkIHx8IGhhc1Byb3BlcnR5KGIsIGtleSkpICYmIGJba2V5XSA9PT0gdmFsKSlcbiIsICIvKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsQWxsID0gKGZzLCBhcmdzLCBpID0gMCkgPT4ge1xuICB0cnkge1xuICAgIGZvciAoOyBpIDwgZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZzW2ldKC4uLmFyZ3MpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBmXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmID0+IGYoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKlxuICogQHBhcmFtIHtBfSBhXG4gKiBAcmV0dXJuIHtBfVxuICovXG5leHBvcnQgY29uc3QgaWQgPSBhID0+IGFcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGFcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3RvciAmJiAoKGFycmF5LmlzQXJyYXkoYSkgJiYgYXJyYXkuZXF1YWxGbGF0KGEsIC8qKiBAdHlwZSB7QXJyYXk8VD59ICovIChiKSkpIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSkpKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbGl0eURlZXAgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcXVhbGl0eVN0cmljdChhLCBiKVxuICB9XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN3aXRjaCAoYS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSlcbiAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGNhc2UgVWludDhBcnJheToge1xuICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgU2V0OiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBNYXA6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSB8fCAhZXF1YWxpdHlEZWVwKGEuZ2V0KGtleSksIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgT2JqZWN0OlxuICAgICAgaWYgKG9iamVjdC5sZW5ndGgoYSkgIT09IG9iamVjdC5sZW5ndGgoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgIGlmICghb2JqZWN0Lmhhc1Byb3BlcnR5KGEsIGtleSkgfHwgIWVxdWFsaXR5RGVlcChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIEFycmF5OlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdGVtcGxhdGUge1Z9IE9QVFNcbiAqXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5PE9QVFM+fSBvcHRpb25zXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc09uZU9mID0gKHZhbHVlLCBvcHRpb25zKSA9PiBvcHRpb25zLmluY2x1ZGVzKHZhbHVlKVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBhcnJheS5pc0FycmF5XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge3MgaXMgU3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSAocykgPT4gcyAmJiBzLmNvbnN0cnVjdG9yID09PSBTdHJpbmdcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gblxuICogQHJldHVybiB7biBpcyBOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBpc051bWJlciA9IG4gPT4gbiAhPSBudWxsICYmIG4uY29uc3RydWN0b3IgPT09IE51bWJlclxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7YWJzdHJhY3QgbmV3ICguLi5hcmdzOiBhbnkpID0+IGFueX0gVFlQRVxuICogQHBhcmFtIHthbnl9IG5cbiAqIEBwYXJhbSB7VFlQRX0gVFxuICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gKi9cbmV4cG9ydCBjb25zdCBpcyA9IChuLCBUKSA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcblxuLyoqXG4gKiBAdGVtcGxhdGUge2Fic3RyYWN0IG5ldyAoLi4uYXJnczogYW55KSA9PiBhbnl9IFRZUEVcbiAqIEBwYXJhbSB7VFlQRX0gVFxuICovXG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZSA9IChUKSA9PlxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG5cbiAgICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gICAqKi9cbiAgbiA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcbiIsICIvKipcbiAqIElzb21vcnBoaWMgbW9kdWxlIHRvIHdvcmsgYWNjZXNzIHRoZSBlbnZpcm9ubWVudCAocXVlcnkgcGFyYW1zLCBlbnYgdmFyaWFibGVzKS5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGNvbmRpdGlvbnMgZnJvbSAnLi9jb25kaXRpb25zLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5pbXBvcnQgKiBhcyBmIGZyb20gJy4vZnVuY3Rpb24uanMnXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlICYmIC9ub2RlfGlvXFwuanMvLnRlc3QocHJvY2Vzcy5yZWxlYXNlLm5hbWUpICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9jZXNzIDogMCkgPT09ICdbb2JqZWN0IHByb2Nlc3NdJ1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTm9kZVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xuZXhwb3J0IGNvbnN0IGlzTWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgOiBmYWxzZVxuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLHN0cmluZz59XG4gKi9cbmxldCBwYXJhbXNcbmNvbnN0IGFyZ3MgPSBbXVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVQYXJhbXMgPSAoKSA9PiB7XG4gIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFyZ3MgPSBwcm9jZXNzLmFyZ3ZcbiAgICAgIGxldCBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJnID0gcGFyZ3NbaV1cbiAgICAgICAgaWYgKHBhcmdbMF0gPT09ICctJykge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gcGFyZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsIHBhcmcpXG4gICAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gocGFyZylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpXG4gICAgICB9XG4gICAgICAvLyBpbiBSZWFjdE5hdGl2ZSBmb3IgZXhhbXBsZSB0aGlzIHdvdWxkIG5vdCBiZSB0cnVlICh1bmxlc3MgY29ubmVjdGVkIHRvIHRoZSBSZW1vdGUgRGVidWdnZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgKGxvY2F0aW9uLnNlYXJjaCB8fCAnPycpLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaCgoa3YpID0+IHtcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGt2LnNwbGl0KCc9JylcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtLSR7c3RyaW5nLmZyb21DYW1lbENhc2Uoa2V5LCAnLScpfWAsIHZhbHVlKVxuICAgICAgICAgIHBhcmFtcy5zZXQoYC0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zID0gbWFwLmNyZWF0ZSgpXG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaGFzUGFyYW0gPSAobmFtZSkgPT4gY29tcHV0ZVBhcmFtcygpLmhhcyhuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdFZhbFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgZ2V0UGFyYW0gPSAobmFtZSwgZGVmYXVsdFZhbCkgPT5cbiAgY29tcHV0ZVBhcmFtcygpLmdldChuYW1lKSB8fCBkZWZhdWx0VmFsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCA0ICovXG5leHBvcnQgY29uc3QgZ2V0VmFyaWFibGUgPSAobmFtZSkgPT5cbiAgaXNOb2RlXG4gICAgPyBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChwcm9jZXNzLmVudltuYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZUFsbCgnLScsICdfJyldKVxuICAgIDogY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwoc3RvcmFnZS52YXJTdG9yYWdlLmdldEl0ZW0obmFtZSkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgZ2V0Q29uZiA9IChuYW1lKSA9PlxuICBjb21wdXRlUGFyYW1zKCkuZ2V0KCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbmV4cG9ydCBjb25zdCBlbnN1cmVDb25mID0gKG5hbWUpID0+IHtcbiAgY29uc3QgYyA9IGdldENvbmYobmFtZSlcbiAgaWYgKGMgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBjb25maWd1cmF0aW9uIFwiJHtuYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZUFsbCgnLScsICdfJyl9XCJgKVxuICByZXR1cm4gY1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5leHBvcnQgY29uc3QgaGFzQ29uZiA9IChuYW1lKSA9PlxuICBoYXNQYXJhbSgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSkgIT09IG51bGxcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwcm9kdWN0aW9uID0gaGFzQ29uZigncHJvZHVjdGlvbicpXG5cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmNvbnN0IGZvcmNlQ29sb3IgPSBpc05vZGUgJiZcbiAgZi5pc09uZU9mKHByb2Nlc3MuZW52LkZPUkNFX0NPTE9SLCBbJ3RydWUnLCAnMScsICcyJ10pXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzQ29sb3IgPSAhaGFzUGFyYW0oJy0tbm8tY29sb3JzJykgJiZcbiAgKCFpc05vZGUgfHwgcHJvY2Vzcy5zdGRvdXQuaXNUVFkgfHwgZm9yY2VDb2xvcikgJiYgKFxuICAhaXNOb2RlIHx8IGhhc1BhcmFtKCctLWNvbG9yJykgfHwgZm9yY2VDb2xvciB8fFxuICAgIGdldFZhcmlhYmxlKCdDT0xPUlRFUk0nKSAhPT0gbnVsbCB8fFxuICAgIChnZXRWYXJpYWJsZSgnVEVSTScpIHx8ICcnKS5pbmNsdWRlcygnY29sb3InKVxuKVxuLyogYzggaWdub3JlIHN0b3AgKi9cbiIsICIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCBidWZmZXJzIChVaW50OEFycmF5KS5cbiAqXG4gKiBAbW9kdWxlIGJ1ZmZlclxuICovXG5cbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnLi9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJy4vZGVjb2RpbmcuanMnXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21MZW4gPSBsZW4gPT4gbmV3IFVpbnQ4QXJyYXkobGVuKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIgPSAoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyID0gYnVmZmVyID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9CYXNlNjRCcm93c2VyID0gYnl0ZXMgPT4ge1xuICBsZXQgcyA9ICcnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSBzdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKVxuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICByZXR1cm4gYnRvYShzKVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvQmFzZTY0Tm9kZSA9IGJ5dGVzID0+IEJ1ZmZlci5mcm9tKGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZnJvbUJhc2U2NEJyb3dzZXIgPSBzID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNvbnN0IGEgPSBhdG9iKHMpXG4gIGNvbnN0IGJ5dGVzID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4oYS5sZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYS5jaGFyQ29kZUF0KGkpXG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKi9cbmNvbnN0IGZyb21CYXNlNjROb2RlID0gcyA9PiB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHMsICdiYXNlNjQnKVxuICByZXR1cm4gY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKVxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gZW52LmlzQnJvd3NlciA/IHRvQmFzZTY0QnJvd3NlciA6IHRvQmFzZTY0Tm9kZVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGZyb21CYXNlNjQgPSBlbnYuaXNCcm93c2VyID8gZnJvbUJhc2U2NEJyb3dzZXIgOiBmcm9tQmFzZTY0Tm9kZVxuXG4vKipcbiAqIEltcGxlbWVudHMgYmFzZTY0dXJsIC0gc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKi9cbmV4cG9ydCBjb25zdCB0b0Jhc2U2NFVybEVuY29kZWQgPSBidWYgPT4gdG9CYXNlNjQoYnVmKS5yZXBsYWNlQWxsKCcrJywgJy0nKS5yZXBsYWNlQWxsKCcvJywgJ18nKS5yZXBsYWNlQWxsKCc9JywgJycpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICovXG5leHBvcnQgY29uc3QgZnJvbUJhc2U2NFVybEVuY29kZWQgPSBiYXNlNjQgPT4gZnJvbUJhc2U2NChiYXNlNjQucmVwbGFjZUFsbCgnLScsICcrJykucmVwbGFjZUFsbCgnXycsICcvJykpXG5cbi8qKlxuICogQmFzZTY0IGlzIGFsd2F5cyBhIG1vcmUgZWZmaWNpZW50IGNob2ljZS4gVGhpcyBleGlzdHMgZm9yIHV0aWxpdHkgcHVycG9zZXMgb25seS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICovXG5leHBvcnQgY29uc3QgdG9IZXhTdHJpbmcgPSBidWYgPT4gYXJyYXkubWFwKGJ1ZiwgYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKVxuXG4vKipcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gZXhwZWN0cyB0aGF0IHRoZSBoZXggZG9lc24ndCBzdGFydCB3aXRoIDB4Li5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tSGV4U3RyaW5nID0gaGV4ID0+IHtcbiAgY29uc3QgaGxlbiA9IGhleC5sZW5ndGhcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5jZWlsKGhsZW4gLyAyKSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBobGVuOyBpICs9IDIpIHtcbiAgICBidWZbYnVmLmxlbmd0aCAtIGkgLyAyIC0gMV0gPSBOdW1iZXIucGFyc2VJbnQoaGV4LnNsaWNlKGhsZW4gLSBpIC0gMiwgaGxlbiAtIGkpLCAxNilcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogQ29weSB0aGUgY29udGVudCBvZiBhbiBVaW50OEFycmF5IHZpZXcgdG8gYSBuZXcgQXJyYXlCdWZmZXIuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgY29weVVpbnQ4QXJyYXkgPSB1aW50OEFycmF5ID0+IHtcbiAgY29uc3QgbmV3QnVmID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4odWludDhBcnJheS5ieXRlTGVuZ3RoKVxuICBuZXdCdWYuc2V0KHVpbnQ4QXJyYXkpXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW55dGhpbmcgYXMgYSBVSW50OEFycmF5LiBJdCdzIGEgcHVuIG9uIHR5cGVzY3JpcHRzJ3MgYGFueWAgdHlwZS5cbiAqIFNlZSBlbmNvZGluZy53cml0ZUFueSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUFueSA9IGRhdGEgPT5cbiAgZW5jb2RpbmcuZW5jb2RlKGVuY29kZXIgPT4gZW5jb2Rpbmcud3JpdGVBbnkoZW5jb2RlciwgZGF0YSkpXG5cbi8qKlxuICogRGVjb2RlIGFuIGFueS1lbmNvZGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVBbnkgPSBidWYgPT4gZGVjb2RpbmcucmVhZEFueShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpXG5cbi8qKlxuICogU2hpZnQgQnl0ZSBBcnJheSB7Tn0gYml0cyB0byB0aGUgbGVmdC4gRG9lcyBub3QgZXhwYW5kIGJ5dGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBic1xuICogQHBhcmFtIHtudW1iZXJ9IE4gc2hvdWxkIGJlIGluIHRoZSByYW5nZSBvZiBbMC03XVxuICovXG5leHBvcnQgY29uc3Qgc2hpZnROQml0c0xlZnQgPSAoYnMsIE4pID0+IHtcbiAgaWYgKE4gPT09IDApIHJldHVybiBic1xuICBicyA9IG5ldyBVaW50OEFycmF5KGJzKVxuICBic1swXSA8PD0gTlxuICBmb3IgKGxldCBpID0gMTsgaSA8IGJzLmxlbmd0aDsgaSsrKSB7XG4gICAgYnNbaSAtIDFdIHw9IGJzW2ldID4+PiAoOCAtIE4pXG4gICAgYnNbaV0gPDw9IE5cbiAgfVxuICByZXR1cm4gYnNcbn1cbiIsICIvKipcbiAqIFdvcmtpbmcgd2l0aCB2YWx1ZSBwYWlycy5cbiAqXG4gKiBAbW9kdWxlIHBhaXJcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqL1xuZXhwb3J0IGNsYXNzIFBhaXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMfSBsZWZ0XG4gICAqIEBwYXJhbSB7Un0gcmlnaHRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHBhcmFtIHtSfSByaWdodFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcGFyYW0ge0x9IGxlZnRcbiAqIEByZXR1cm4ge1BhaXI8TCxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJldmVyc2VkID0gKHJpZ2h0LCBsZWZ0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge0FycmF5PFBhaXI8TCxSPj59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihMLCBSKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoYXJyLCBmKSA9PiBhcnIuZm9yRWFjaChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSLFhcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOlh9IGZcbiAqIEByZXR1cm4ge0FycmF5PFg+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKGFyciwgZikgPT4gYXJyLm1hcChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBAbW9kdWxlIGRvbVxuICovXG5cbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnLi9wYWlyLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHR5cGUge0RvY3VtZW50fVxuICovXG5leHBvcnQgY29uc3QgZG9jID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSBuYW1lID0+IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpXG5cbi8qKlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoKSA9PiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUZXh0Tm9kZSA9IHRleHQgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpXG5cbmV4cG9ydCBjb25zdCBkb21QYXJzZXIgPSAvKiogQHR5cGUge0RPTVBhcnNlcn0gKi8gKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IERPTVBhcnNlcigpIDogbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmV4cG9ydCBjb25zdCBlbWl0Q3VzdG9tRXZlbnQgPSAoZWwsIG5hbWUsIG9wdHMpID0+IGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmd8Ym9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyaWJ1dGVzID0gKGVsLCBhdHRycykgPT4ge1xuICBwYWlyLmZvckVhY2goYXR0cnMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSlcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCAnJylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIHN0cmluZz59IGF0dHJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlyc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXNNYXAgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIGF0dHJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHsgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIH0pXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT58SFRNTENvbGxlY3Rpb259IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSBjaGlsZHJlbiA9PiB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRDaGlsZChmcmFnbWVudCwgY2hpbGRyZW5baV0pXG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kID0gKHBhcmVudCwgbm9kZXMpID0+IHtcbiAgYXBwZW5kQ2hpbGQocGFyZW50LCBmcmFnbWVudChub2RlcykpXG4gIHJldHVybiBwYXJlbnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlID0gZWwgPT4gZWwucmVtb3ZlKClcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKGVsLCBuYW1lLCBmKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGYpXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsRXZlbnRMaXN0ZW5lcj4+fSBsaXN0ZW5lcnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsRXZlbnRMaXN0ZW5lcj4+fSBsaXN0ZW5lcnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fHBhaXIuUGFpcjxzdHJpbmcsYm9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgZWxlbWVudCA9IChuYW1lLCBhdHRycyA9IFtdLCBjaGlsZHJlbiA9IFtdKSA9PlxuICBhcHBlbmQoc2V0QXR0cmlidXRlcyhjcmVhdGVFbGVtZW50KG5hbWUpLCBhdHRycyksIGNoaWxkcmVuKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICovXG5leHBvcnQgY29uc3QgY2FudmFzID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgY29uc3QgYyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChjcmVhdGVFbGVtZW50KCdjYW52YXMnKSlcbiAgYy5oZWlnaHQgPSBoZWlnaHRcbiAgYy53aWR0aCA9IHdpZHRoXG4gIHJldHVybiBjXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbmV4cG9ydCBjb25zdCB0ZXh0ID0gY3JlYXRlVGV4dE5vZGVcblxuLyoqXG4gKiBAcGFyYW0ge3BhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPn0gcGFpclxuICovXG5leHBvcnQgY29uc3QgcGFpclRvU3R5bGVTdHJpbmcgPSBwYWlyID0+IGAke3BhaXIubGVmdH06JHtwYWlyLnJpZ2h0fTtgXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz4+fSBwYWlyc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcGFpcnNUb1N0eWxlU3RyaW5nID0gcGFpcnMgPT4gcGFpcnMubWFwKHBhaXJUb1N0eWxlU3RyaW5nKS5qb2luKCcnKVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxzdHJpbmc+fSBtXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBUb1N0eWxlU3RyaW5nID0gbSA9PiBtYXAubWFwKG0sICh2YWx1ZSwga2V5KSA9PiBgJHtrZXl9OiR7dmFsdWV9O2ApLmpvaW4oJycpXG5cbi8qKlxuICogQHRvZG8gc2hvdWxkIGFsd2F5cyBxdWVyeSBvbiBhIGRvbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvcihxdWVyeSlcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFNoYWRvd1Jvb3R9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvckFsbCA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRCeUlkID0gaWQgPT4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvYy5nZXRFbGVtZW50QnlJZChpZCkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5jb25zdCBfcGFyc2UgPSBodG1sID0+IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcoYDxodG1sPjxib2R5PiR7aHRtbH08L2JvZHk+PC9odG1sPmAsICd0ZXh0L2h0bWwnKS5ib2R5XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUZyYWdtZW50ID0gaHRtbCA9PiBmcmFnbWVudCgvKiogQHR5cGUge2FueX0gKi8gKF9wYXJzZShodG1sKS5jaGlsZE5vZGVzKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUVsZW1lbnQgPSBodG1sID0+IC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqLyAoX3BhcnNlKGh0bWwpLmZpcnN0RWxlbWVudENoaWxkKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9sZEVsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5ld0VsXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlV2l0aCA9IChvbGRFbCwgbmV3RWwpID0+IG9sZEVsLnJlcGxhY2VXaXRoKG5ld0VsKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Tm9kZXxudWxsfSByZWZcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgaW5zZXJ0QmVmb3JlID0gKHBhcmVudCwgZWwsIHJlZikgPT4gcGFyZW50Lmluc2VydEJlZm9yZShlbCwgcmVmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gZG9jLkVMRU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IGRvYy5URVhUX05PREVcbmV4cG9ydCBjb25zdCBDREFUQV9TRUNUSU9OX05PREUgPSBkb2MuQ0RBVEFfU0VDVElPTl9OT0RFXG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gZG9jLkNPTU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1RZUEVfTk9ERSA9IGRvYy5ET0NVTUVOVF9UWVBFX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTm9kZVR5cGUgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gdHlwZVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZFxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGxldCBwID0gY2hpbGQucGFyZW50Tm9kZVxuICB3aGlsZSAocCAmJiBwICE9PSBwYXJlbnQpIHtcbiAgICBwID0gcC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIHAgPT09IHBhcmVudFxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cbiIsICIvKipcbiAqIEpTT04gdXRpbGl0eSBmdW5jdGlvbnMuXG4gKlxuICogQG1vZHVsZSBqc29uXG4gKi9cblxuLyoqXG4gKiBUcmFuc2Zvcm0gSmF2YVNjcmlwdCBvYmplY3QgdG8gSlNPTi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqZWN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeVxuXG4vKipcbiAqIFBhcnNlIEpTT04gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBqc29uXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZSA9IEpTT04ucGFyc2VcbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0IFN5bWJvbHMuXG4gKlxuICogQG1vZHVsZSBzeW1ib2xcbiAqL1xuXG4vKipcbiAqIFJldHVybiBmcmVzaCBzeW1ib2wuXG4gKlxuICogQHJldHVybiB7U3ltYm9sfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gU3ltYm9sXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IHMgPT4gdHlwZW9mIHMgPT09ICdzeW1ib2wnXG4iLCAiaW1wb3J0ICogYXMgc3ltYm9sIGZyb20gJy4vc3ltYm9sLmpzJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIGZ1bmMgZnJvbSAnLi9mdW5jdGlvbi5qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnLi9qc29uLmpzJ1xuXG5leHBvcnQgY29uc3QgQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IFVOQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEJMVUUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBHUkVZID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFRU4gPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBSRUQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBQVVJQTEUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBPUkFOR0UgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkNPTE9SID0gc3ltYm9sLmNyZWF0ZSgpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHVuZGVmaW5lZHxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXJ8ZnVuY3Rpb24oKTphbnk+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBjb21wdXRlTm9Db2xvckxvZ2dpbmdBcmdzID0gYXJncyA9PiB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdPy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICBhcmdzID0gLyoqIEB0eXBlIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSAqLyAoLyoqIEB0eXBlIHtbZnVuY3Rpb25dfSAqLyAoYXJncylbMF0oKSlcbiAgfVxuICBjb25zdCBzdHJCdWlsZGVyID0gW11cbiAgY29uc3QgbG9nQXJncyA9IFtdXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaCgndW5kZWZpbmVkJylcbiAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChKU09OLnN0cmluZ2lmeShhcmcpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuY29uc3QgbG9nZ2luZ0NvbG9ycyA9IFtHUkVFTiwgUFVSUExFLCBPUkFOR0UsIEJMVUVdXG5sZXQgbmV4dENvbG9yID0gMFxubGV0IGxhc3RMb2dnaW5nVGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9IF9wcmludFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IChfcHJpbnQsIG1vZHVsZU5hbWUpID0+IHtcbiAgY29uc3QgY29sb3IgPSBsb2dnaW5nQ29sb3JzW25leHRDb2xvcl1cbiAgY29uc3QgZGVidWdSZWdleFZhciA9IGVudi5nZXRWYXJpYWJsZSgnbG9nJylcbiAgY29uc3QgZG9Mb2dnaW5nID0gZGVidWdSZWdleFZhciAhPT0gbnVsbCAmJlxuICAgIChkZWJ1Z1JlZ2V4VmFyID09PSAnKicgfHwgZGVidWdSZWdleFZhciA9PT0gJ3RydWUnIHx8XG4gICAgICBuZXcgUmVnRXhwKGRlYnVnUmVnZXhWYXIsICdnaScpLnRlc3QobW9kdWxlTmFtZSkpXG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoXG4gIG1vZHVsZU5hbWUgKz0gJzogJ1xuICByZXR1cm4gIWRvTG9nZ2luZ1xuICAgID8gZnVuYy5ub3BcbiAgICA6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdPy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgICBhcmdzID0gYXJnc1swXSgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZU5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWVOb3cgLSBsYXN0TG9nZ2luZ1RpbWVcbiAgICAgICAgbGFzdExvZ2dpbmdUaW1lID0gdGltZU5vd1xuICAgICAgICBfcHJpbnQoXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgbW9kdWxlTmFtZSxcbiAgICAgICAgICBVTkNPTE9SLFxuICAgICAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgICAgIGlmIChhcmcgIT0gbnVsbCAmJiBhcmcuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgYXJnID0gQXJyYXkuZnJvbShhcmcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ID0gdHlwZW9mIGFyZ1xuICAgICAgICAgICAgc3dpdGNoICh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1xuICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb24uc3RyaW5naWZ5KGFyZylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICcgKycgKyB0aW1lRGlmZiArICdtcydcbiAgICAgICAgKVxuICAgICAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cbiIsICIvKipcbiAqIElzb21vcnBoaWMgbG9nZ2luZyBtb2R1bGUgd2l0aCBzdXBwb3J0IGZvciBjb2xvcnMhXG4gKlxuICogQG1vZHVsZSBsb2dnaW5nXG4gKi9cblxuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJy4vcGFpci5qcydcbmltcG9ydCAqIGFzIGRvbSBmcm9tICcuL2RvbS5qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnLi9qc29uLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJy4vZXZlbnRsb29wLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9sb2dnaW5nLmNvbW1vbi5qcydcblxuZXhwb3J0IHsgQk9MRCwgVU5CT0xELCBCTFVFLCBHUkVZLCBHUkVFTiwgUkVELCBQVVJQTEUsIE9SQU5HRSwgVU5DT0xPUiB9IGZyb20gJy4vbG9nZ2luZy5jb21tb24uanMnXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxTeW1ib2wscGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn1cbiAqL1xuY29uc3QgX2Jyb3dzZXJTdHlsZU1hcCA9IHtcbiAgW2NvbW1vbi5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKSxcbiAgW2NvbW1vbi5VTkJPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnbm9ybWFsJyksXG4gIFtjb21tb24uQkxVRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibHVlJyksXG4gIFtjb21tb24uR1JFRU5dOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnZ3JlZW4nKSxcbiAgW2NvbW1vbi5HUkVZXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZXknKSxcbiAgW2NvbW1vbi5SRURdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncmVkJyksXG4gIFtjb21tb24uUFVSUExFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3B1cnBsZScpLFxuICBbY29tbW9uLk9SQU5HRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdvcmFuZ2UnKSwgLy8gbm90IHdlbGwgc3VwcG9ydGVkIGluIGNocm9tZSB3aGVuIGRlYnVnZ2luZyBub2RlIHdpdGggaW5zcGVjdG9yIC0gVE9ETzogZGVwcmVjYXRlXG4gIFtjb21tb24uVU5DT0xPUl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibGFjaycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXJ8ZnVuY3Rpb24oKTphbnk+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJncyA9IChhcmdzKSA9PiB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdPy5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICBhcmdzID0gLyoqIEB0eXBlIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSAqLyAoLyoqIEB0eXBlIHtbZnVuY3Rpb25dfSAqLyAoYXJncylbMF0oKSlcbiAgfVxuICBjb25zdCBzdHJCdWlsZGVyID0gW11cbiAgY29uc3Qgc3R5bGVzID0gW11cbiAgY29uc3QgY3VycmVudFN0eWxlID0gbWFwLmNyZWF0ZSgpXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nfE9iamVjdHxudW1iZXI+fVxuICAgKi9cbiAgbGV0IGxvZ0FyZ3MgPSBbXVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0eWxlID0gX2Jyb3dzZXJTdHlsZU1hcFthcmddXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRTdHlsZS5zZXQoc3R5bGUubGVmdCwgc3R5bGUucmlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKVxuICAgICAgICBpZiAoaSA+IDAgfHwgc3R5bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaCgnJWMnICsgYXJnKVxuICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaChhcmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIGxvZ0FyZ3MgPSBzdHlsZXNcbiAgICBsb2dBcmdzLnVuc2hpZnQoc3RyQnVpbGRlci5qb2luKCcnKSlcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVMb2dnaW5nQXJncyA9IGVudi5zdXBwb3J0c0NvbG9yXG4gID8gY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJnc1xuICA6IGNvbW1vbi5jb21wdXRlTm9Db2xvckxvZ2dpbmdBcmdzXG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgcHJpbnQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLndhcm4oLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICBhcmdzLnVuc2hpZnQoY29tbW9uLk9SQU5HRSlcbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludChhcmdzKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50RXJyb3IgPSAoZXJyKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLnByaW50RXJyb3IoZXJyKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBpbWFnZSBsb2NhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nID0gKHVybCwgaGVpZ2h0KSA9PiB7XG4gIGlmIChlbnYuaXNCcm93c2VyKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnJWMgICAgICAgICAgICAgICAgICAgICAgJyxcbiAgICAgIGBmb250LXNpemU6ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3VybH0pYFxuICAgIClcbiAgICAvLyBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9eDsgYmFja2dyb3VuZDogdXJsKCR7dXJsfSkgbm8tcmVwZWF0O2ApXG4gIH1cbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nQmFzZTY0ID0gKGJhc2U2NCwgaGVpZ2h0KSA9PlxuICBwcmludEltZyhgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YmFzZTY0fWAsIGhlaWdodClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMuZ3JvdXAoYXJncykpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBncm91cENvbGxhcHNlZCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwQ29sbGFwc2VkKGFyZ3MpKVxufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBFbmQgPSAoKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwRW5kKCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOk5vZGV9IGNyZWF0ZU5vZGVcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50RG9tID0gKGNyZWF0ZU5vZGUpID0+XG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnREb20oY3JlYXRlTm9kZSgpKSlcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50Q2FudmFzID0gKGNhbnZhcywgaGVpZ2h0KSA9PlxuICBwcmludEltZyhjYW52YXMudG9EYXRhVVJMKCksIGhlaWdodClcblxuZXhwb3J0IGNvbnN0IHZjb25zb2xlcyA9IHNldC5jcmVhdGUoKVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgX2NvbXB1dGVMaW5lU3BhbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBzcGFucyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG5ldyBNYXAoKVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50U3R5bGUuc2V0KHN0eWxlLmxlZnQsIHN0eWxlLnJpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJnID0gJ3VuZGVmaW5lZCAnXG4gICAgICB9XG4gICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBzcGFuID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXG4gICAgICAgICAgcGFpci5jcmVhdGUoJ3N0eWxlJywgZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKSlcbiAgICAgICAgXSwgW2RvbS50ZXh0KGFyZy50b1N0cmluZygpKV0pXG4gICAgICAgIGlmIChzcGFuLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICBzcGFuLmlubmVySFRNTCA9ICcmbmJzcDsnXG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaChzcGFuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjb250ZW50ID0gYXJnc1tpXVxuICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBpZiAoY29udGVudC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nICYmIGNvbnRlbnQuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xuICAgICAgICBjb250ZW50ID0gJyAnICsganNvbi5zdHJpbmdpZnkoY29udGVudCkgKyAnICdcbiAgICAgIH1cbiAgICAgIHNwYW5zLnB1c2goXG4gICAgICAgIGRvbS5lbGVtZW50KCdzcGFuJywgW10sIFtkb20udGV4dCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGNvbnRlbnQpKV0pXG4gICAgICApXG4gICAgfVxuICB9XG4gIHJldHVybiBzcGFuc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuY29uc3QgbGluZVN0eWxlID1cbiAgJ2ZvbnQtZmFtaWx5Om1vbm9zcGFjZTtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTJlMmUyO3BhZGRpbmc6MnB4OydcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5leHBvcnQgY2xhc3MgVkNvbnNvbGUge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb20pIHtcbiAgICB0aGlzLmRvbSA9IGRvbVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqL1xuICAgIHRoaXMuY2NvbnRhaW5lciA9IHRoaXMuZG9tXG4gICAgdGhpcy5kZXB0aCA9IDBcbiAgICB2Y29uc29sZXMuYWRkKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sbGFwc2VkXG4gICAqL1xuICBncm91cCAoYXJncywgY29sbGFwc2VkID0gZmFsc2UpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0cmlhbmdsZURvd24gPSBkb20uZWxlbWVudCgnc3BhbicsIFtcbiAgICAgICAgcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZCksXG4gICAgICAgIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjAlOycpXG4gICAgICBdLCBbZG9tLnRleHQoJ1x1MjVCQycpXSlcbiAgICAgIGNvbnN0IHRyaWFuZ2xlUmlnaHQgPSBkb20uZWxlbWVudCgnc3BhbicsIFtcbiAgICAgICAgcGFpci5jcmVhdGUoJ2hpZGRlbicsICFjb2xsYXBzZWQpLFxuICAgICAgICBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTI1JTsnKVxuICAgICAgXSwgW2RvbS50ZXh0KCdcdTI1QjYnKV0pXG4gICAgICBjb25zdCBjb250ZW50ID0gZG9tLmVsZW1lbnQoXG4gICAgICAgICdkaXYnLFxuICAgICAgICBbcGFpci5jcmVhdGUoXG4gICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICBgJHtsaW5lU3R5bGV9O3BhZGRpbmctbGVmdDoke3RoaXMuZGVwdGggKiAxMH1weGBcbiAgICAgICAgKV0sXG4gICAgICAgIFt0cmlhbmdsZURvd24sIHRyaWFuZ2xlUmlnaHQsIGRvbS50ZXh0KCcgJyldLmNvbmNhdChcbiAgICAgICAgICBfY29tcHV0ZUxpbmVTcGFucyhhcmdzKVxuICAgICAgICApXG4gICAgICApXG4gICAgICBjb25zdCBuZXh0Q29udGFpbmVyID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtcbiAgICAgICAgcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZClcbiAgICAgIF0pXG4gICAgICBjb25zdCBuZXh0TGluZSA9IGRvbS5lbGVtZW50KCdkaXYnLCBbXSwgW2NvbnRlbnQsIG5leHRDb250YWluZXJdKVxuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtuZXh0TGluZV0pXG4gICAgICB0aGlzLmNjb250YWluZXIgPSBuZXh0Q29udGFpbmVyXG4gICAgICB0aGlzLmRlcHRoKytcbiAgICAgIC8vIHdoZW4gaGVhZGVyIGlzIGNsaWNrZWQsIGNvbGxhcHNlL3VuY29sbGFwc2UgY29udGFpbmVyXG4gICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihjb250ZW50LCAnY2xpY2snLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIG5leHRDb250YWluZXIudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZURvd24udG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZVJpZ2h0LnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIGdyb3VwQ29sbGFwc2VkIChhcmdzKSB7XG4gICAgdGhpcy5ncm91cChhcmdzLCB0cnVlKVxuICB9XG5cbiAgZ3JvdXBFbmQgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcHRoID4gMCkge1xuICAgICAgICB0aGlzLmRlcHRoLS1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmNjb250YWluZXIucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIHByaW50IChhcmdzKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtcbiAgICAgICAgZG9tLmVsZW1lbnQoJ2RpdicsIFtcbiAgICAgICAgICBwYWlyLmNyZWF0ZShcbiAgICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgICBgJHtsaW5lU3R5bGV9O3BhZGRpbmctbGVmdDoke3RoaXMuZGVwdGggKiAxMH1weGBcbiAgICAgICAgICApXG4gICAgICAgIF0sIF9jb21wdXRlTGluZVNwYW5zKGFyZ3MpKVxuICAgICAgXSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgcHJpbnRFcnJvciAoZXJyKSB7XG4gICAgdGhpcy5wcmludChbY29tbW9uLlJFRCwgY29tbW9uLkJPTEQsIGVyci50b1N0cmluZygpXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHByaW50SW1nICh1cmwsIGhlaWdodCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbXG4gICAgICAgIGRvbS5lbGVtZW50KCdpbWcnLCBbXG4gICAgICAgICAgcGFpci5jcmVhdGUoJ3NyYycsIHVybCksXG4gICAgICAgICAgcGFpci5jcmVhdGUoJ2hlaWdodCcsIGAke21hdGgucm91bmQoaGVpZ2h0ICogMS41KX1weGApXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBwcmludERvbSAobm9kZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbbm9kZV0pXG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIHZjb25zb2xlcy5kZWxldGUodGhpcylcbiAgICB9KVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlVkNvbnNvbGUgPSAoZG9tKSA9PiBuZXcgVkNvbnNvbGUoZG9tKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2R1bGVMb2dnZXIgPSAobW9kdWxlTmFtZSkgPT4gY29tbW9uLmNyZWF0ZU1vZHVsZUxvZ2dlcihwcmludCwgbW9kdWxlTmFtZSlcbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIGNyZWF0ZSBhbmQgbWFuaXB1bGF0ZSBJdGVyYXRvcnMuXG4gKlxuICogQG1vZHVsZSBpdGVyYXRvclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFQsUlxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Un0gZlxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcEl0ZXJhdG9yID0gKGl0ZXJhdG9yLCBmKSA9PiAoe1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBuZXh0ICgpIHtcbiAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG4gICAgcmV0dXJuIHsgdmFsdWU6IHIuZG9uZSA/IHVuZGVmaW5lZCA6IGYoci52YWx1ZSksIGRvbmU6IHIuZG9uZSB9XG4gIH1cbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpJdGVyYXRvclJlc3VsdDxUPn0gbmV4dFxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUl0ZXJhdG9yID0gbmV4dCA9PiAoe1xuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHRcbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOmJvb2xlYW59IGZpbHRlclxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0b3JGaWx0ZXIgPSAoaXRlcmF0b3IsIGZpbHRlcikgPT4gY3JlYXRlSXRlcmF0b3IoKCkgPT4ge1xuICBsZXQgcmVzXG4gIGRvIHtcbiAgICByZXMgPSBpdGVyYXRvci5uZXh0KClcbiAgfSB3aGlsZSAoIXJlcy5kb25lICYmICFmaWx0ZXIocmVzLnZhbHVlKSlcbiAgcmV0dXJuIHJlc1xufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxNXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpNfSBmbWFwXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvck1hcCA9IChpdGVyYXRvciwgZm1hcCkgPT4gY3JlYXRlSXRlcmF0b3IoKCkgPT4ge1xuICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdGVyYXRvci5uZXh0KClcbiAgcmV0dXJuIHsgZG9uZSwgdmFsdWU6IGRvbmUgPyB1bmRlZmluZWQgOiBmbWFwKHZhbHVlKSB9XG59KVxuIiwgImltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcblxuaW1wb3J0IHtcbiAgRG9jIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgaW50ZXJmYWNlIHRoYXQgYWxsIENvbm5lY3RvcnMgc2hvdWxkIGltcGxlbWVudCB0byBrZWVwIHRoZW0gaW50ZXJjaGFuZ2VhYmxlLlxuICpcbiAqIEBub3RlIFRoaXMgaW50ZXJmYWNlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXQgaXMgbm90IGFkdmlzZWQgdG8gYWN0dWFsbHkgaW5oZXJpdCB0aGlzIGNsYXNzLlxuICogICAgICAgSXQganVzdCBzZXJ2ZXMgYXMgdHlwaW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlVjI8YW55Pn1cbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q29ubmVjdG9yIGV4dGVuZHMgT2JzZXJ2YWJsZVYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gICAqIEBwYXJhbSB7YW55fSBhd2FyZW5lc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5ZG9jLCBhd2FyZW5lc3MpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5kb2MgPSB5ZG9jXG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3NcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIGZpbmRJbmRleFNTLFxuICBnZXRTdGF0ZSxcbiAgc3BsaXRJdGVtLFxuICBpdGVyYXRlU3RydWN0cyxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBEU0RlY29kZXJWMSwgRFNFbmNvZGVyVjEsIERTRGVjb2RlclYyLCBEU0VuY29kZXJWMiwgSXRlbSwgR0MsIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiwgSUQgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuXG5leHBvcnQgY2xhc3MgRGVsZXRlSXRlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsb2NrLCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9ja1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW5cbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5leHBvcnQgY2xhc3MgRGVsZXRlU2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PERlbGV0ZUl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKClcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVEZWxldGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgZHMsIGYpID0+XG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlcywgY2xpZW50aWQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnRpZCkpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWwgPSBkZWxldGVzW2ldXG4gICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgZGVsLmNsb2NrLCBkZWwubGVuLCBmKVxuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PERlbGV0ZUl0ZW0+fSBkaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICogQHJldHVybiB7bnVtYmVyfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZmluZEluZGV4RFMgPSAoZGlzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gZGlzLmxlbmd0aCAtIDFcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKVxuICAgIGNvbnN0IG1pZCA9IGRpc1ttaWRpbmRleF1cbiAgICBjb25zdCBtaWRjbG9jayA9IG1pZC5jbG9ja1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNEZWxldGVkID0gKGRzLCBpZCkgPT4ge1xuICBjb25zdCBkaXMgPSBkcy5jbGllbnRzLmdldChpZC5jbGllbnQpXG4gIHJldHVybiBkaXMgIT09IHVuZGVmaW5lZCAmJiBmaW5kSW5kZXhEUyhkaXMsIGlkLmNsb2NrKSAhPT0gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNvcnRBbmRNZXJnZURlbGV0ZVNldCA9IGRzID0+IHtcbiAgZHMuY2xpZW50cy5mb3JFYWNoKGRlbHMgPT4ge1xuICAgIGRlbHMuc29ydCgoYSwgYikgPT4gYS5jbG9jayAtIGIuY2xvY2spXG4gICAgLy8gbWVyZ2UgaXRlbXMgd2l0aG91dCBmaWx0ZXJpbmcgb3Igc3BsaWNpbmcgdGhlIGFycmF5XG4gICAgLy8gaSBpcyB0aGUgY3VycmVudCBwb2ludGVyXG4gICAgLy8gaiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zZXJ0IHBvc2l0aW9uIGZvciB0aGUgcG9pbnRlZCBpdGVtXG4gICAgLy8gdHJ5IHRvIG1lcmdlIGRlbHNbaV0gaW50byBkZWxzW2otMV0gb3Igc2V0IGRlbHNbal09ZGVsc1tpXVxuICAgIGxldCBpLCBqXG4gICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gZGVsc1tqIC0gMV1cbiAgICAgIGNvbnN0IHJpZ2h0ID0gZGVsc1tpXVxuICAgICAgaWYgKGxlZnQuY2xvY2sgKyBsZWZ0LmxlbiA+PSByaWdodC5jbG9jaykge1xuICAgICAgICBsZWZ0LmxlbiA9IG1hdGgubWF4KGxlZnQubGVuLCByaWdodC5jbG9jayArIHJpZ2h0LmxlbiAtIGxlZnQuY2xvY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaiA8IGkpIHtcbiAgICAgICAgICBkZWxzW2pdID0gcmlnaHRcbiAgICAgICAgfVxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG4gICAgZGVscy5sZW5ndGggPSBqXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVTZXQ+fSBkc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gQSBmcmVzaCBEZWxldGVTZXRcbiAqL1xuZXhwb3J0IGNvbnN0IG1lcmdlRGVsZXRlU2V0cyA9IGRzcyA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBEZWxldGVTZXQoKVxuICBmb3IgKGxldCBkc3NJID0gMDsgZHNzSSA8IGRzcy5sZW5ndGg7IGRzc0krKykge1xuICAgIGRzc1tkc3NJXS5jbGllbnRzLmZvckVhY2goKGRlbHNMZWZ0LCBjbGllbnQpID0+IHtcbiAgICAgIGlmICghbWVyZ2VkLmNsaWVudHMuaGFzKGNsaWVudCkpIHtcbiAgICAgICAgLy8gV3JpdGUgYWxsIG1pc3Npbmcga2V5cyBmcm9tIGN1cnJlbnQgZHMgYW5kIGFsbCBmb2xsb3dpbmcuXG4gICAgICAgIC8vIElmIG1lcmdlZCBhbHJlYWR5IGNvbnRhaW5zIGBjbGllbnRgIGN1cnJlbnQgZHMgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlbHMgPSBkZWxzTGVmdC5zbGljZSgpXG4gICAgICAgIGZvciAobGV0IGkgPSBkc3NJICsgMTsgaSA8IGRzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFycmF5LmFwcGVuZFRvKGRlbHMsIGRzc1tpXS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdKVxuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5jbGllbnRzLnNldChjbGllbnQsIGRlbHMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQobWVyZ2VkKVxuICByZXR1cm4gbWVyZ2VkXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRUb0RlbGV0ZVNldCA9IChkcywgY2xpZW50LCBjbG9jaywgbGVuZ3RoKSA9PiB7XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbmd0aCkpXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWxldGVTZXQgPSAoKSA9PiBuZXcgRGVsZXRlU2V0KClcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzc1xuICogQHJldHVybiB7RGVsZXRlU2V0fSBNZXJnZWQgYW5kIHNvcnRlZCBEZWxldGVTZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUgPSBzcyA9PiB7XG4gIGNvbnN0IGRzID0gY3JlYXRlRGVsZXRlU2V0KClcbiAgc3MuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICovXG4gICAgY29uc3QgZHNpdGVtcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2ldXG4gICAgICBpZiAoc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBzdHJ1Y3QuaWQuY2xvY2tcbiAgICAgICAgbGV0IGxlbiA9IHN0cnVjdC5sZW5ndGhcbiAgICAgICAgaWYgKGkgKyAxIDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBuZXh0ID0gc3RydWN0c1tpICsgMV07IGkgKyAxIDwgc3RydWN0cy5sZW5ndGggJiYgbmV4dC5kZWxldGVkOyBuZXh0ID0gc3RydWN0c1srK2kgKyAxXSkge1xuICAgICAgICAgICAgbGVuICs9IG5leHQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRzaXRlbXMucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRzaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgZHMuY2xpZW50cy5zZXQoY2xpZW50LCBkc2l0ZW1zKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZURlbGV0ZVNldCA9IChlbmNvZGVyLCBkcykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgZHMuY2xpZW50cy5zaXplKVxuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBkZWxldGUgc2V0IGlzIHdyaXR0ZW4gaW4gYSBkZXRlcm1pbmlzdGljIG9yZGVyXG4gIGFycmF5LmZyb20oZHMuY2xpZW50cy5lbnRyaWVzKCkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKVxuICAgIC5mb3JFYWNoKChbY2xpZW50LCBkc2l0ZW1zXSkgPT4ge1xuICAgICAgZW5jb2Rlci5yZXNldERzQ3VyVmFsKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpXG4gICAgICBjb25zdCBsZW4gPSBkc2l0ZW1zLmxlbmd0aFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxlbilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRzaXRlbXNbaV1cbiAgICAgICAgZW5jb2Rlci53cml0ZURzQ2xvY2soaXRlbS5jbG9jaylcbiAgICAgICAgZW5jb2Rlci53cml0ZURzTGVuKGl0ZW0ubGVuKVxuICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZERlbGV0ZVNldCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBkcyA9IG5ldyBEZWxldGVTZXQoKVxuICBjb25zdCBudW1DbGllbnRzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKVxuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBpZiAobnVtYmVyT2ZEZWxldGVzID4gMCkge1xuICAgICAgY29uc3QgZHNGaWVsZCA9IG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICAgIGRzRmllbGQucHVzaChuZXcgRGVsZXRlSXRlbShkZWNvZGVyLnJlYWREc0Nsb2NrKCksIGRlY29kZXIucmVhZERzTGVuKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZHNcbn1cblxuLyoqXG4gKiBAdG9kbyBZRGVjb2RlciBhbHNvIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gU3RyaW5nIGFuZCBvdGhlciBEZWNvZGVycy4gV291bGQgbWFrZSBzZW5zZSB0byBleGNoYW5nZSBZRGVjb2Rlci50b1VpbnQ4QXJyYXkgZm9yIFlEZWNvZGVyLkRzVG9VaW50OEFycmF5KCkuLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl8bnVsbH0gUmV0dXJucyBhIHYyIHVwZGF0ZSBjb250YWluaW5nIGFsbCBkZWxldGVzIHRoYXQgY291bGRuJ3QgYmUgYXBwbGllZCB5ZXQ7IG9yIG51bGwgaWYgYWxsIGRlbGV0ZXMgd2VyZSBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQW5kQXBwbHlEZWxldGVTZXQgPSAoZGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKSA9PiB7XG4gIGNvbnN0IHVuYXBwbGllZERTID0gbmV3IERlbGV0ZVNldCgpXG4gIGNvbnN0IG51bUNsaWVudHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpXG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpXG4gICAgICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrICsgZGVjb2Rlci5yZWFkRHNMZW4oKVxuICAgICAgaWYgKGNsb2NrIDwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldCh1bmFwcGxpZWREUywgY2xpZW50LCBzdGF0ZSwgY2xvY2tFbmQgLSBzdGF0ZSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhbiBpZ25vcmUgdGhlIGNhc2Ugb2YgR0MgYW5kIERlbGV0ZSBzdHJ1Y3RzLCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBza2lwIHRoZW1cbiAgICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XVxuICAgICAgICAvLyBzcGxpdCB0aGUgZmlyc3QgaXRlbSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jaykge1xuICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSlcbiAgICAgICAgICBpbmRleCsrIC8vIGluY3JlYXNlIHdlIG5vdyB3YW50IHRvIHVzZSB0aGUgbmV4dCBzdHJ1Y3RcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdXG4gICAgICAgICAgaWYgKHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrRW5kIC0gc3RydWN0LmlkLmNsb2NrKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVG9EZWxldGVTZXQodW5hcHBsaWVkRFMsIGNsaWVudCwgY2xvY2ssIGNsb2NrRW5kIC0gY2xvY2spXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh1bmFwcGxpZWREUy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZHMgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZHMucmVzdEVuY29kZXIsIDApIC8vIGVuY29kZSAwIHN0cnVjdHNcbiAgICB3cml0ZURlbGV0ZVNldChkcywgdW5hcHBsaWVkRFMpXG4gICAgcmV0dXJuIGRzLnRvVWludDhBcnJheSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMxXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMyXG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbERlbGV0ZVNldHMgPSAoZHMxLCBkczIpID0+IHtcbiAgaWYgKGRzMS5jbGllbnRzLnNpemUgIT09IGRzMi5jbGllbnRzLnNpemUpIHJldHVybiBmYWxzZVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zMV0gb2YgZHMxLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3QgZGVsZXRlSXRlbXMyID0gLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFscy5qcycpLkRlbGV0ZUl0ZW0+fSAqLyAoZHMyLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgaWYgKGRlbGV0ZUl0ZW1zMiA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUl0ZW1zMS5sZW5ndGggIT09IGRlbGV0ZUl0ZW1zMi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlSXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaTEgPSBkZWxldGVJdGVtczFbaV1cbiAgICAgIGNvbnN0IGRpMiA9IGRlbGV0ZUl0ZW1zMltpXVxuICAgICAgaWYgKGRpMS5jbG9jayAhPT0gZGkyLmNsb2NrIHx8IGRpMS5sZW4gIT09IGRpMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlcbiAqL1xuXG5pbXBvcnQge1xuICBTdHJ1Y3RTdG9yZSxcbiAgQWJzdHJhY3RUeXBlLFxuICBZQXJyYXksXG4gIFlUZXh0LFxuICBZTWFwLFxuICBZWG1sRWxlbWVudCxcbiAgWVhtbEZyYWdtZW50LFxuICB0cmFuc2FjdCxcbiAgQ29udGVudERvYywgSXRlbSwgVHJhbnNhY3Rpb24sIFlFdmVudCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZVYyIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJ1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVOZXdDbGllbnRJZCA9IHJhbmRvbS51aW50MzJcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NPcHRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmdjPXRydWVdIERpc2FibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIChkZWZhdWx0OiBnYz10cnVlKVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbRG9jT3B0cy5nY0ZpbHRlcl0gV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIEl0ZW0gaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFJldHVybiBmYWxzZSB0byBrZWVwIHRoZSBJdGVtLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtEb2NPcHRzLmd1aWRdIERlZmluZSBhIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IFtEb2NPcHRzLmNvbGxlY3Rpb25pZF0gQXNzb2NpYXRlIHRoaXMgZG9jdW1lbnQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoaXMgb25seSBwbGF5cyBhIHJvbGUgaWYgeW91ciBwcm92aWRlciBoYXMgYSBjb25jZXB0IG9mIGNvbGxlY3Rpb24uXG4gKiBAcHJvcGVydHkge2FueX0gW0RvY09wdHMubWV0YV0gQW55IGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvbiB5b3Ugd2FudCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIHN0b3JlIHRoZSBtZXRhIGluZm9ybWF0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmF1dG9Mb2FkXSBJZiBhIHN1YmRvY3VtZW50LCBhdXRvbWF0aWNhbGx5IGxvYWQgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgbG9hZCB0aGUgZG9jdW1lbnQgYXMgd2VsbCBhdXRvbWF0aWNhbGx5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5zaG91bGRMb2FkXSBXaGV0aGVyIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgc3luY2VkIGJ5IHRoZSBwcm92aWRlciBub3cuIFRoaXMgaXMgdG9nZ2xlZCB0byB0cnVlIHdoZW4geW91IGNhbGwgeWRvYy5sb2FkKClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvY0V2ZW50c1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihEb2MpOnZvaWR9IERvY0V2ZW50cy5kZXN0cm95XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKERvYyk6dm9pZH0gRG9jRXZlbnRzLmxvYWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oYm9vbGVhbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuc3luY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihVaW50OEFycmF5LCBhbnksIERvYywgVHJhbnNhY3Rpb24pOnZvaWR9IERvY0V2ZW50cy51cGRhdGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVWludDhBcnJheSwgYW55LCBEb2MsIFRyYW5zYWN0aW9uKTp2b2lkfSBEb2NFdmVudHMudXBkYXRlVjJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oRG9jKTp2b2lkfSBEb2NFdmVudHMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFRyYW5zYWN0aW9uLCBEb2MpOnZvaWR9IERvY0V2ZW50cy5iZWZvcmVUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYmVmb3JlT2JzZXJ2ZXJDYWxsc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYWZ0ZXJUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYWZ0ZXJUcmFuc2FjdGlvbkNsZWFudXBcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oRG9jLCBBcnJheTxUcmFuc2FjdGlvbj4pOnZvaWR9IERvY0V2ZW50cy5hZnRlckFsbFRyYW5zYWN0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbih7IGxvYWRlZDogU2V0PERvYz4sIGFkZGVkOiBTZXQ8RG9jPiwgcmVtb3ZlZDogU2V0PERvYz4gfSwgRG9jLCBUcmFuc2FjdGlvbik6dm9pZH0gRG9jRXZlbnRzLnN1YmRvY3NcbiAqL1xuXG4vKipcbiAqIEEgWWpzIGluc3RhbmNlIGhhbmRsZXMgdGhlIHN0YXRlIG9mIHNoYXJlZCBkYXRhLlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZVYyPERvY0V2ZW50cz5cbiAqL1xuZXhwb3J0IGNsYXNzIERvYyBleHRlbmRzIE9ic2VydmFibGVWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY09wdHN9IG9wdHMgY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHsgZ3VpZCA9IHJhbmRvbS51dWlkdjQoKSwgY29sbGVjdGlvbmlkID0gbnVsbCwgZ2MgPSB0cnVlLCBnY0ZpbHRlciA9ICgpID0+IHRydWUsIG1ldGEgPSBudWxsLCBhdXRvTG9hZCA9IGZhbHNlLCBzaG91bGRMb2FkID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5nYyA9IGdjXG4gICAgdGhpcy5nY0ZpbHRlciA9IGdjRmlsdGVyXG4gICAgdGhpcy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKVxuICAgIHRoaXMuZ3VpZCA9IGd1aWRcbiAgICB0aGlzLmNvbGxlY3Rpb25pZCA9IGNvbGxlY3Rpb25pZFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBBYnN0cmFjdFR5cGU8WUV2ZW50PGFueT4+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXJlID0gbmV3IE1hcCgpXG4gICAgdGhpcy5zdG9yZSA9IG5ldyBTdHJ1Y3RTdG9yZSgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9uIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3MgPSBuZXcgU2V0KClcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgLSBhIGRvY3VtZW50IGludGVncmF0ZWQgaW50byBhbm90aGVyIGRvY3VtZW50IC0gdGhlbiBfaXRlbSBpcyBkZWZpbmVkLlxuICAgICAqIEB0eXBlIHtJdGVtP31cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbFxuICAgIHRoaXMuc2hvdWxkTG9hZCA9IHNob3VsZExvYWRcbiAgICB0aGlzLmF1dG9Mb2FkID0gYXV0b0xvYWRcbiAgICB0aGlzLm1ldGEgPSBtZXRhXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBwZXJzaXN0ZW5jZSBwcm92aWRlciBsb2FkZWQgdGhlIGRvY3VtZW50IGZyb20gdGhlIGRhdGFiYXNlIG9yIHdoZW4gdGhlIGBzeW5jYCBldmVudCBmaXJlcy5cbiAgICAgKiBOb3RlIHRoYXQgbm90IGFsbCBwcm92aWRlcnMgaW1wbGVtZW50IHRoaXMgZmVhdHVyZS4gUHJvdmlkZXIgYXV0aG9ycyBhcmUgZW5jb3VyYWdlZCB0byBmaXJlIHRoZSBgbG9hZGAgZXZlbnQgd2hlbiB0aGUgZG9jIGNvbnRlbnQgaXMgbG9hZGVkIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyIGhhcyBzdWNjZXNzZnVsbHkgc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHVzaW5nIHBlZXItdG8tcGVlciBwcm92aWRlcnMgdGhpcyBldmVudCBtYXkgbm90IHByb3ZpZGUgdmVyeSB1c2VmdWwuXG4gICAgICogQWxzbyBub3RlIHRoYXQgbm90IGFsbCBwcm92aWRlcnMgaW1wbGVtZW50IHRoaXMgZmVhdHVyZS4gUHJvdmlkZXIgYXV0aG9ycyBhcmUgZW5jb3VyYWdlZCB0byBmaXJlXG4gICAgICogdGhlIGBzeW5jYCBldmVudCB3aGVuIHRoZSBkb2MgaGFzIGJlZW4gc3luY2VkICh3aXRoIGB0cnVlYCBhcyBhIHBhcmFtZXRlcikgb3IgaWYgY29ubmVjdGlvbiBpc1xuICAgICAqIGxvc3QgKHdpdGggZmFsc2UgYXMgYSBwYXJhbWV0ZXIpLlxuICAgICAqL1xuICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBsb2FkZWQgZnJvbSBhIHByZXNpc3RlbmNlIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHRoaXMud2hlbkxvYWRlZCA9IHByb21pc2UuY3JlYXRlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5vbignbG9hZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWVcbiAgICAgICAgcmVzb2x2ZSh0aGlzKVxuICAgICAgfSlcbiAgICB9KVxuICAgIGNvbnN0IHByb3ZpZGVTeW5jZWRQcm9taXNlID0gKCkgPT4gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTeW5jZWRcbiAgICAgICAqL1xuICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGlzU3luY2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ3N5bmMnLCBldmVudEhhbmRsZXIpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub24oJ3N5bmMnLCBldmVudEhhbmRsZXIpXG4gICAgfSlcbiAgICB0aGlzLm9uKCdzeW5jJywgaXNTeW5jZWQgPT4ge1xuICAgICAgaWYgKGlzU3luY2VkID09PSBmYWxzZSAmJiB0aGlzLmlzU3luY2VkKSB7XG4gICAgICAgIHRoaXMud2hlblN5bmNlZCA9IHByb3ZpZGVTeW5jZWRQcm9taXNlKClcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlXG4gICAgICBpZiAodGhpcy5pc1N5bmNlZCAmJiAhdGhpcy5pc0xvYWRlZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCBbdGhpc10pXG4gICAgICB9XG4gICAgfSlcbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIFRoaXMgcHJvbWlzZSBpcyByZWNyZWF0ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgICAqIE5vdGUgdGhlIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlIGBpc1N5bmNlZGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgcGFyZW50IGRvY3VtZW50IHRoYXQgeW91IHJlcXVlc3QgdG8gbG9hZCBkYXRhIGludG8gdGhpcyBzdWJkb2N1bWVudCAoaWYgaXQgaXMgYSBzdWJkb2N1bWVudCkuXG4gICAqXG4gICAqIGBsb2FkKClgIG1pZ2h0IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZSB0byByZXF1ZXN0IGFueSBwcm92aWRlciB0byBsb2FkIHRoZSBtb3N0IGN1cnJlbnQgZGF0YS5cbiAgICpcbiAgICogSXQgaXMgc2FmZSB0byBjYWxsIGBsb2FkKClgIG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1cbiAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiAhdGhpcy5zaG91bGRMb2FkKSB7XG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0ucGFyZW50KS5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZC5hZGQodGhpcylcbiAgICAgIH0sIG51bGwsIHRydWUpXG4gICAgfVxuICAgIHRoaXMuc2hvdWxkTG9hZCA9IHRydWVcbiAgfVxuXG4gIGdldFN1YmRvY3MgKCkge1xuICAgIHJldHVybiB0aGlzLnN1YmRvY3NcbiAgfVxuXG4gIGdldFN1YmRvY0d1aWRzICgpIHtcbiAgICByZXR1cm4gbmV3IFNldChhcnJheS5mcm9tKHRoaXMuc3ViZG9jcykubWFwKGRvYyA9PiBkb2MuZ3VpZCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGF0IGhhcHBlbiBpbnNpZGUgb2YgYSB0cmFuc2FjdGlvbiBhcmUgYnVuZGxlZC4gVGhpcyBtZWFucyB0aGF0XG4gICAqIHRoZSBvYnNlcnZlciBmaXJlcyBfYWZ0ZXJfIHRoZSB0cmFuc2FjdGlvbiBpcyBmaW5pc2hlZCBhbmQgdGhhdCBhbGwgY2hhbmdlc1xuICAgKiB0aGF0IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgdHJhbnNhY3Rpb24gYXJlIHNlbnQgYXMgb25lIG1lc3NhZ2UgdG8gdGhlXG4gICAqIG90aGVyIHBlZXJzLlxuICAgKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpUfSBmIFRoZSBmdW5jdGlvbiB0aGF0IHNob3VsZCBiZSBleGVjdXRlZCBhcyBhIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7YW55fSBbb3JpZ2luXSBPcmlnaW4gb2Ygd2hvIHN0YXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLiBXaWxsIGJlIHN0b3JlZCBvbiB0cmFuc2FjdGlvbi5vcmlnaW5cbiAgICogQHJldHVybiBUXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRyYW5zYWN0IChmLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgcmV0dXJuIHRyYW5zYWN0KHRoaXMsIGYsIG9yaWdpbilcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBzaGFyZWQgZGF0YSB0eXBlLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjYWxscyBvZiBgeWRvYy5nZXQobmFtZSwgVHlwZUNvbnN0cnVjdG9yKWAgeWllbGQgdGhlIHNhbWUgcmVzdWx0XG4gICAqIGFuZCBkbyBub3Qgb3ZlcndyaXRlIGVhY2ggb3RoZXIuIEkuZS5cbiAgICogYHlkb2MuZ2V0KG5hbWUsIFkuQXJyYXkpID09PSB5ZG9jLmdldChuYW1lLCBZLkFycmF5KWBcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgdHlwZSBpcyBhbHNvIGF2YWlsYWJsZSBvbiBgeWRvYy5zaGFyZS5nZXQobmFtZSlgLlxuICAgKlxuICAgKiAqQmVzdCBQcmFjdGljZXM6KlxuICAgKiBEZWZpbmUgYWxsIHR5cGVzIHJpZ2h0IGFmdGVyIHRoZSBZLkRvYyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBzdG9yZSB0aGVtIGluIGEgc2VwYXJhdGUgb2JqZWN0LlxuICAgKiBBbHNvIHVzZSB0aGUgdHlwZWQgbWV0aG9kcyBgZ2V0VGV4dChuYW1lKWAsIGBnZXRBcnJheShuYW1lKWAsIC4uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7dHlwZW9mIEFic3RyYWN0VHlwZTxhbnk+fSBUeXBlXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29uc3QgeWRvYyA9IG5ldyBZLkRvYyguLilcbiAgICogICBjb25zdCBhcHBTdGF0ZSA9IHtcbiAgICogICAgIGRvY3VtZW50OiB5ZG9jLmdldFRleHQoJ2RvY3VtZW50JylcbiAgICogICAgIGNvbW1lbnRzOiB5ZG9jLmdldEFycmF5KCdjb21tZW50cycpXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1R5cGV9IFR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHR5cGUgZGVmaW5pdGlvbi4gRS5nLiBZLlRleHQsIFkuQXJyYXksIFkuTWFwLCAuLi5cbiAgICogQHJldHVybiB7SW5zdGFuY2VUeXBlPFR5cGU+fSBUaGUgY3JlYXRlZCB0eXBlLiBDb25zdHJ1Y3RlZCB3aXRoIFR5cGVDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgKG5hbWUsIFR5cGVDb25zdHJ1Y3RvciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoQWJzdHJhY3RUeXBlKSkge1xuICAgIGNvbnN0IHR5cGUgPSBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5zaGFyZSwgbmFtZSwgKCkgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKVxuICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpXG4gICAgICByZXR1cm4gdFxuICAgIH0pXG4gICAgY29uc3QgQ29uc3RyID0gdHlwZS5jb25zdHJ1Y3RvclxuICAgIGlmIChUeXBlQ29uc3RydWN0b3IgIT09IEFic3RyYWN0VHlwZSAmJiBDb25zdHIgIT09IFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKENvbnN0ciA9PT0gQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKVxuICAgICAgICB0Ll9tYXAgPSB0eXBlLl9tYXBcbiAgICAgICAgdHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbT99IG4gKi8gbiA9PiB7XG4gICAgICAgICAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLmxlZnQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG4ucGFyZW50ID0gdFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgdC5fc3RhcnQgPSB0eXBlLl9zdGFydFxuICAgICAgICBmb3IgKGxldCBuID0gdC5fc3RhcnQ7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgICAgICAgbi5wYXJlbnQgPSB0XG4gICAgICAgIH1cbiAgICAgICAgdC5fbGVuZ3RoID0gdHlwZS5fbGVuZ3RoXG4gICAgICAgIHRoaXMuc2hhcmUuc2V0KG5hbWUsIHQpXG4gICAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKVxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtJbnN0YW5jZVR5cGU8VHlwZT59ICovICh0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIHdpdGggdGhlIG5hbWUgJHtuYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcmApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge0luc3RhbmNlVHlwZTxUeXBlPn0gKi8gKHR5cGUpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEFycmF5IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtZQXJyYXk8VD59ICovICh0aGlzLmdldChuYW1lLCBZQXJyYXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFRleHQgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZVGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lNYXA8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldE1hcCAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7WU1hcDxUPn0gKi8gKHRoaXMuZ2V0KG5hbWUsIFlNYXApKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEVsZW1lbnQgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiAvKiogQHR5cGUge1lYbWxFbGVtZW50PHtba2V5OnN0cmluZ106c3RyaW5nfT59ICovICh0aGlzLmdldChuYW1lLCBZWG1sRWxlbWVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEZyYWdtZW50IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVhtbEZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBlbnRpcmUgZG9jdW1lbnQgaW50byBhIGpzIG9iamVjdCwgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyBlYWNoIHlqcyB0eXBlXG4gICAqIERvZXNuJ3QgbG9nIHR5cGVzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkICh1c2luZyB5ZG9jLmdldFR5cGUoLi4pKS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBhbmQgcmF0aGVyIGNhbGwgdG9KU09OIGRpcmVjdGx5IG9uIHRoZSBzaGFyZWQgdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IGRvYyA9IHt9XG5cbiAgICB0aGlzLnNoYXJlLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGRvY1trZXldID0gdmFsdWUudG9KU09OKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYGRlc3Ryb3lgIGV2ZW50IGFuZCB1bnJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtXG4gICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBudWxsXG4gICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoaXRlbS5jb250ZW50KVxuICAgICAgY29udGVudC5kb2MgPSBuZXcgRG9jKHsgZ3VpZDogdGhpcy5ndWlkLCAuLi5jb250ZW50Lm9wdHMsIHNob3VsZExvYWQ6IGZhbHNlIH0pXG4gICAgICBjb250ZW50LmRvYy5faXRlbSA9IGl0ZW1cbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbSkucGFyZW50LmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBjb250ZW50LmRvY1xuICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQoZG9jKVxuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzKVxuICAgICAgfSwgbnVsbCwgdHJ1ZSlcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZW1pdCgnZGVzdHJveWVkJywgW3RydWVdKSAvLyBERVBSRUNBVEVEIVxuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSlcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICdsaWIwL2J1ZmZlcidcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQge1xuICBJRCwgY3JlYXRlSURcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5jb3B5VWludDhBcnJheShkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWdhY3kgaW1wbGVtZW50YXRpb24gdXNlcyBKU09OIHBhcnNlLiBXZSB1c2UgYW55LWRlY29kaW5nIGluIHYyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRzQ3VyclZhbCA9IDBcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlclxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gICAgcmV0dXJuIHRoaXMuZHNDdXJyVmFsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxXG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGlmZlxuICAgIHJldHVybiBkaWZmXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVwZGF0ZURlY29kZXJWMiBleHRlbmRzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICBzdXBlcihkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY2FjaGVkIGtleXMuIElmIHRoZSBrZXlzW2lkXSBkb2VzIG5vdCBleGlzdCwgd2UgcmVhZCBhIG5ldyBrZXlcbiAgICAgKiBmcm9tIHN0cmluZ0VuY29kZXIgYW5kIHB1c2ggaXQgdG8ga2V5cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdXG4gICAgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gcmVhZCBmZWF0dXJlIGZsYWcgLSBjdXJyZW50bHkgdW51c2VkXG4gICAgdGhpcy5rZXlDbG9ja0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuSW50RGlmZk9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG4gICAgdGhpcy5jbGllbnREZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMubGVmdENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgICB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMuaW5mb0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuUmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFVpbnQ4KVxuICAgIHRoaXMuc3RyaW5nRGVjb2RlciA9IG5ldyBkZWNvZGluZy5TdHJpbmdEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMucGFyZW50SW5mb0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuUmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFVpbnQ4KVxuICAgIHRoaXMudHlwZVJlZkRlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG4gICAgdGhpcy5sZW5EZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZExlZnRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLmxlZnRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5yaWdodENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkSW5mbyAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5pbmZvRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgcmVhZFBhcmVudEluZm8gKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEluZm9EZWNvZGVyLnJlYWQoKSA9PT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZFR5cGVSZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVSZWZEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWRMZW4gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICBjb25zdCBrZXlDbG9jayA9IHRoaXMua2V5Q2xvY2tEZWNvZGVyLnJlYWQoKVxuICAgIGlmIChrZXlDbG9jayA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXNba2V5Q2xvY2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKClcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSlcbiAgICAgIHJldHVybiBrZXlcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcblxuaW1wb3J0IHtcbiAgSUQgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmV4cG9ydCBjbGFzcyBEU0VuY29kZXJWMSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIC8vIG5vcFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbG9jaylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZURzTGVuIChsZW4pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVFbmNvZGVyVjEgZXh0ZW5kcyBEU0VuY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jaylcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2Ugd3JpdGVDbGllbnQgYW5kIHdyaXRlQ2xvY2sgaW5zdGVhZCBvZiB3cml0ZUlEIGlmIHBvc3NpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqL1xuICB3cml0ZUNsaWVudCAoY2xpZW50KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsaWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KHRoaXMucmVzdEVuY29kZXIsIGluZm8pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2RlciwgcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaXNZS2V5ID8gMSA6IDApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGluZm8pXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGFueVxuICAgKi9cbiAgd3JpdGVBbnkgKGFueSkge1xuICAgIGVuY29kaW5nLndyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGFueSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoZW1iZWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBrZXkpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERTRW5jb2RlclYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCkgLy8gZW5jb2RlcyBhbGwgdGhlIHJlc3QgLyBub24tb3B0aW1pemVkXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwXG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGNvbnN0IGRpZmYgPSBjbG9jayAtIHRoaXMuZHNDdXJyVmFsXG4gICAgdGhpcy5kc0N1cnJWYWwgPSBjbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBkaWZmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbiAtIDEpXG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gbGVuXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVwZGF0ZUVuY29kZXJWMiBleHRlbmRzIERTRW5jb2RlclYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogUmVmZXJzIHRvIHRoZSBuZXh0IHVuaXFlIGtleS1pZGVudGlmaWVyIHRvIG1lIHVzZWQuXG4gICAgICogU2VlIHdyaXRlS2V5IG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5rZXlDbG9jayA9IDBcbiAgICB0aGlzLmtleUNsb2NrRW5jb2RlciA9IG5ldyBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcigpXG4gICAgdGhpcy5jbGllbnRFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKClcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKVxuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKVxuICAgIHRoaXMuaW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KVxuICAgIHRoaXMuc3RyaW5nRW5jb2RlciA9IG5ldyBlbmNvZGluZy5TdHJpbmdFbmNvZGVyKClcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyID0gbmV3IGVuY29kaW5nLlJsZUVuY29kZXIoZW5jb2Rpbmcud3JpdGVVaW50OClcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKClcbiAgICB0aGlzLmxlbkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDApIC8vIHRoaXMgaXMgYSBmZWF0dXJlIGZsYWcgdGhhdCB3ZSBtaWdodCB1c2UgaW4gdGhlIGZ1dHVyZVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmtleUNsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5jbGllbnRFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlZnRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMucmlnaHRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLmluZm9FbmNvZGVyKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5zdHJpbmdFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5wYXJlbnRJbmZvRW5jb2RlcikpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMudHlwZVJlZkVuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICAvLyBAbm90ZSBUaGUgcmVzdCBlbmNvZGVyIGlzIGFwcGVuZGVkISAobm90ZSB0aGUgbWlzc2luZyB2YXIpXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KGVuY29kZXIsIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKSlcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpXG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudClcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoY2xpZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIHRoaXMuaW5mb0VuY29kZXIud3JpdGUoaW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgKi9cbiAgd3JpdGVTdHJpbmcgKHMpIHtcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIud3JpdGUocylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyLndyaXRlKGlzWUtleSA/IDEgOiAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIud3JpdGUoaW5mbylcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZUxlbiAobGVuKSB7XG4gICAgdGhpcy5sZW5FbmNvZGVyLndyaXRlKGxlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciBsZWdhY3kgcHVycG9zZXMuXG4gICAqXG4gICAqIEluaXRpYWwgd2UgaW5jb2RlZCBvYmplY3RzIHVzaW5nIEpTT04uIE5vdyB3ZSB1c2UgdGhlIG11Y2ggZmFzdGVyIGxpYjAvYW55LWVuY29kZXIuIFRoaXMgbWV0aG9kIG1haW5seSBleGlzdHMgZm9yIGxlZ2FjeSBwdXJwb3NlcyBmb3IgdGhlIHYxIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIGVuY29kaW5nLndyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGtleXMgYXJlIG9mdGVuIHJldXNlZC4gRm9yIGV4YW1wbGUsIGluIHktcHJvc2VtaXJyb3IgdGhlIGtleSBgYm9sZGAgbWlnaHRcbiAgICogb2NjdXIgdmVyeSBvZnRlbi4gRm9yIGEgM2QgYXBwbGljYXRpb24sIHRoZSBrZXkgYHBvc2l0aW9uYCBtaWdodCBvY2N1ciB2ZXJ5IG9mdGVuLlxuICAgKlxuICAgKiBXZSBjYWNoZSB0aGVzZSBrZXlzIGluIGEgTWFwIGFuZCByZWZlciB0byB0aGVtIHZpYSBhIHVuaXF1ZSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRoaXMua2V5TWFwLmdldChrZXkpXG4gICAgaWYgKGNsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHRvZG8gdW5jb21tZW50IHRvIGludHJvZHVjZSB0aGlzIGZlYXR1cmUgZmluYWxseVxuICAgICAgICpcbiAgICAgICAqIEJhY2tncm91bmQuIFRoZSBDb250ZW50Rm9ybWF0IG9iamVjdCB3YXMgYWx3YXlzIGVuY29kZWQgdXNpbmcgd3JpdGVLZXksIGJ1dCB0aGUgZGVjb2RlciB1c2VkIHRvIHVzZSByZWFkU3RyaW5nLlxuICAgICAgICogRnVydGhlcm1vcmUsIEkgZm9yZ290IHRvIHNldCB0aGUga2V5Y2xvY2suIFNvIGV2ZXJ5dGhpbmcgd2FzIHdvcmtpbmcgZmluZS5cbiAgICAgICAqXG4gICAgICAgKiBIb3dldmVyLCB0aGlzIGZlYXR1cmUgaGVyZSBpcyBiYXNpY2FsbHkgdXNlbGVzcyBhcyBpdCBpcyBub3QgYmVpbmcgdXNlZCAoaXQgYWN0dWFsbHkgb25seSBjb25zdW1lcyBleHRyYSBtZW1vcnkpLlxuICAgICAgICpcbiAgICAgICAqIEkgZG9uJ3Qga25vdyB5ZXQgaG93IHRvIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4uXG4gICAgICAgKlxuICAgICAgICogT2xkZXIgY2xpZW50cyB3b24ndCBiZSBhYmxlIHRvIHJlYWQgdXBkYXRlcyB3aGVuIHdlIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4gU28gdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSB1c2luZyBhIGZsYWcuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICAvLyB0aGlzLmtleU1hcC5zZXQoa2V5LCB0aGlzLmtleUNsb2NrKVxuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUodGhpcy5rZXlDbG9jaysrKVxuICAgICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKGtleSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUoY2xvY2spXG4gICAgfVxuICB9XG59XG4iLCAiLyoqXG4gKiBAbW9kdWxlIGVuY29kaW5nXG4gKi9cbi8qXG4gKiBXZSB1c2UgdGhlIGZpcnN0IGZpdmUgYml0cyBpbiB0aGUgaW5mbyBmbGFnIGZvciBkZXRlcm1pbmluZyB0aGUgdHlwZSBvZiB0aGUgc3RydWN0LlxuICpcbiAqIDA6IEdDXG4gKiAxOiBJdGVtIHdpdGggRGVsZXRlZCBjb250ZW50XG4gKiAyOiBJdGVtIHdpdGggSlNPTiBjb250ZW50XG4gKiAzOiBJdGVtIHdpdGggQmluYXJ5IGNvbnRlbnRcbiAqIDQ6IEl0ZW0gd2l0aCBTdHJpbmcgY29udGVudFxuICogNTogSXRlbSB3aXRoIEVtYmVkIGNvbnRlbnQgKGZvciByaWNodGV4dCBjb250ZW50KVxuICogNjogSXRlbSB3aXRoIEZvcm1hdCBjb250ZW50IChhIGZvcm1hdHRpbmcgbWFya2VyIGZvciByaWNodGV4dCBjb250ZW50KVxuICogNzogSXRlbSB3aXRoIFR5cGVcbiAqL1xuXG5pbXBvcnQge1xuICBmaW5kSW5kZXhTUyxcbiAgZ2V0U3RhdGUsXG4gIGNyZWF0ZUlELFxuICBnZXRTdGF0ZVZlY3RvcixcbiAgcmVhZEFuZEFwcGx5RGVsZXRlU2V0LFxuICB3cml0ZURlbGV0ZVNldCxcbiAgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLFxuICB0cmFuc2FjdCxcbiAgcmVhZEl0ZW1Db250ZW50LFxuICBVcGRhdGVEZWNvZGVyVjEsXG4gIFVwZGF0ZURlY29kZXJWMixcbiAgVXBkYXRlRW5jb2RlclYxLFxuICBVcGRhdGVFbmNvZGVyVjIsXG4gIERTRW5jb2RlclYyLFxuICBEU0RlY29kZXJWMSxcbiAgRFNFbmNvZGVyVjEsXG4gIG1lcmdlVXBkYXRlcyxcbiAgbWVyZ2VVcGRhdGVzVjIsXG4gIFNraXAsXG4gIGRpZmZVcGRhdGVWMixcbiAgY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSxcbiAgRFNEZWNvZGVyVjIsIERvYywgVHJhbnNhY3Rpb24sIEdDLCBJdGVtLCBTdHJ1Y3RTdG9yZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnbGliMC9iaW5hcnknXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7QXJyYXk8R0N8SXRlbT59IHN0cnVjdHMgQWxsIHN0cnVjdHMgYnkgYGNsaWVudGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB3cml0ZSBzdHJ1Y3RzIHN0YXJ0aW5nIHdpdGggYElEKGNsaWVudCxjbG9jaylgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0cyA9IChlbmNvZGVyLCBzdHJ1Y3RzLCBjbGllbnQsIGNsb2NrKSA9PiB7XG4gIC8vIHdyaXRlIGZpcnN0IGlkXG4gIGNsb2NrID0gbWF0aC5tYXgoY2xvY2ssIHN0cnVjdHNbMF0uaWQuY2xvY2spIC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgaWQgZXhpc3RzXG4gIGNvbnN0IHN0YXJ0TmV3U3RydWN0cyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKVxuICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0cy5sZW5ndGggLSBzdGFydE5ld1N0cnVjdHMpXG4gIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spXG4gIGNvbnN0IGZpcnN0U3RydWN0ID0gc3RydWN0c1tzdGFydE5ld1N0cnVjdHNdXG4gIC8vIHdyaXRlIGZpcnN0IHN0cnVjdCB3aXRoIGFuIG9mZnNldFxuICBmaXJzdFN0cnVjdC53cml0ZShlbmNvZGVyLCBjbG9jayAtIGZpcnN0U3RydWN0LmlkLmNsb2NrKVxuICBmb3IgKGxldCBpID0gc3RhcnROZXdTdHJ1Y3RzICsgMTsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJ1Y3RzW2ldLndyaXRlKGVuY29kZXIsIDApXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBfc21cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUNsaWVudHNTdHJ1Y3RzID0gKGVuY29kZXIsIHN0b3JlLCBfc20pID0+IHtcbiAgLy8gd2UgZmlsdGVyIGFsbCB2YWxpZCBfc20gZW50cmllcyBpbnRvIHNtXG4gIGNvbnN0IHNtID0gbmV3IE1hcCgpXG4gIF9zbS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgLy8gb25seSB3cml0ZSBpZiBuZXcgc3RydWN0cyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCBjbGllbnQpID4gY2xvY2spIHtcbiAgICAgIHNtLnNldChjbGllbnQsIGNsb2NrKVxuICAgIH1cbiAgfSlcbiAgZ2V0U3RhdGVWZWN0b3Ioc3RvcmUpLmZvckVhY2goKF9jbG9jaywgY2xpZW50KSA9PiB7XG4gICAgaWYgKCFfc20uaGFzKGNsaWVudCkpIHtcbiAgICAgIHNtLnNldChjbGllbnQsIDApXG4gICAgfVxuICB9KVxuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZFxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc20uc2l6ZSlcbiAgLy8gV3JpdGUgaXRlbXMgd2l0aCBoaWdoZXIgY2xpZW50IGlkcyBmaXJzdFxuICAvLyBUaGlzIGhlYXZpbHkgaW1wcm92ZXMgdGhlIGNvbmZsaWN0IGFsZ29yaXRobS5cbiAgYXJyYXkuZnJvbShzbS5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICB3cml0ZVN0cnVjdHMoZW5jb2RlciwgLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbGllbnQsIGNsb2NrKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDbGllbnRzU3RydWN0UmVmcyA9IChkZWNvZGVyLCBkb2MpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAgICovXG4gIGNvbnN0IGNsaWVudFJlZnMgPSBtYXAuY3JlYXRlKClcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn1cbiAgICAgKi9cbiAgICBjb25zdCByZWZzID0gbmV3IEFycmF5KG51bWJlck9mU3RydWN0cylcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgLy8gY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNsaWVudFJlZnMuc2V0KGNsaWVudCwgeyBpOiAwLCByZWZzIH0pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKVxuICAgICAgc3dpdGNoIChiaW5hcnkuQklUUzUgJiBpbmZvKSB7XG4gICAgICAgIGNhc2UgMDogeyAvLyBHQ1xuICAgICAgICAgIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpXG4gICAgICAgICAgcmVmc1tpXSA9IG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKVxuICAgICAgICAgIGNsb2NrICs9IGxlblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDogeyAvLyBTa2lwIFN0cnVjdCAobm90aGluZyB0byBhcHBseSlcbiAgICAgICAgICAvLyBAdG9kbyB3ZSBjb3VsZCByZWR1Y2UgdGhlIGFtb3VudCBvZiBjaGVja3MgYnkgYWRkaW5nIFNraXAgc3RydWN0IHRvIGNsaWVudFJlZnMgc28gd2Uga25vdyB0aGF0IHNvbWV0aGluZyBpcyBtaXNzaW5nLlxuICAgICAgICAgIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgICAgICAgcmVmc1tpXSA9IG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pXG4gICAgICAgICAgY2xvY2sgKz0gbGVuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7IC8vIEl0ZW0gd2l0aCBjb250ZW50XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBhbnkgdmFyaWFibGVzIGJlY2F1c2UgaW5saW5pbmcgdmFyaWFibGVzIGlzIGZhc3Rlci5cbiAgICAgICAgICAgKiBCZWxvdyBhIG5vbi1vcHRpbWl6ZWQgdmVyc2lvbiBpcyBzaG93biB0aGF0IGltcGxlbWVudHMgdGhlIGJhc2ljIGFsZ29yaXRobSB3aXRoXG4gICAgICAgICAgICogYSBmZXcgY29tbWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgICAgbnVsbCwgLy8gbGVmdFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKVxuICAgICAgICAgIC8qIEEgbm9uLW9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWJvdmUgYWxnb3JpdGhtOlxuXG4gICAgICAgICAgLy8gVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICAgICAgY29uc3Qgb3JpZ2luID0gKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsXG4gICAgICAgICAgLy8gVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IHJpZ2h0T3JpZ2luID0gKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbFxuICAgICAgICAgIGNvbnN0IGNhbnRDb3B5UGFyZW50SW5mbyA9IChpbmZvICYgKGJpbmFyeS5CSVQ3IHwgYmluYXJ5LkJJVDgpKSA9PT0gMFxuICAgICAgICAgIGNvbnN0IGhhc1BhcmVudFlLZXkgPSBjYW50Q29weVBhcmVudEluZm8gPyBkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgOiBmYWxzZVxuICAgICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICAgIGNvbnN0IHBhcmVudFlLZXkgPSBjYW50Q29weVBhcmVudEluZm8gJiYgaGFzUGFyZW50WUtleSA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbFxuXG4gICAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAgIG9yaWdpbiwgLy8gb3JpZ2luXG4gICAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgICAgcmlnaHRPcmlnaW4sIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmICFoYXNQYXJlbnRZS2V5ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiAocGFyZW50WUtleSAhPT0gbnVsbCA/IGRvYy5nZXQocGFyZW50WUtleSkgOiBudWxsKSwgLy8gcGFyZW50XG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBiaW5hcnkuQklUNikgPT09IGJpbmFyeS5CSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgICApXG4gICAgICAgICAgKi9cbiAgICAgICAgICByZWZzW2ldID0gc3RydWN0XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQ6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICB9XG4gIHJldHVybiBjbGllbnRSZWZzXG59XG5cbi8qKlxuICogUmVzdW1lIGNvbXB1dGluZyBzdHJ1Y3RzIGdlbmVyYXRlZCBieSBzdHJ1Y3QgcmVhZGVycy5cbiAqXG4gKiBXaGlsZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8sIHdlIGludGVncmF0ZSBzdHJ1Y3RzIGluIHRoaXMgb3JkZXJcbiAqIDEuIHRvcCBlbGVtZW50IG9uIHN0YWNrLCBpZiBzdGFjayBpcyBub3QgZW1wdHlcbiAqIDIuIG5leHQgZWxlbWVudCBmcm9tIGN1cnJlbnQgc3RydWN0IHJlYWRlciAoaWYgZW1wdHksIHVzZSBuZXh0IHN0cnVjdCByZWFkZXIpXG4gKlxuICogSWYgc3RydWN0IGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciBzdHJ1Y3QgKHJlZi5taXNzaW5nKSwgd2UgcHV0IG5leHQgcmVhZGVyIG9mXG4gKiBgcmVmLmlkLmNsaWVudGAgb24gdG9wIG9mIHN0YWNrLlxuICpcbiAqIEF0IHNvbWUgcG9pbnQgd2UgZmluZCBhIHN0cnVjdCB0aGF0IGhhcyBubyBjYXVzYWwgZGVwZW5kZW5jaWVzLFxuICogdGhlbiB3ZSBzdGFydCBlbXB0eWluZyB0aGUgc3RhY2suXG4gKlxuICogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgY2lyY2xlczogaS5lLiBzdHJ1Y3QxIChmcm9tIGNsaWVudDEpIGRlcGVuZHMgb24gc3RydWN0MiAoZnJvbSBjbGllbnQyKVxuICogZGVwZW5kcyBvbiBzdHJ1Y3QzIChmcm9tIGNsaWVudDEpLiBUaGVyZWZvcmUgdGhlIG1heCBzdGFjayBzaXplIGlzIGVxYXVsIHRvIGBzdHJ1Y3RSZWFkZXJzLmxlbmd0aGAuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgaW1wbGVtZW50ZWQgaW4gYSB3YXkgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIGNvbXB1dGF0aW9uIGlmIHRoaXMgdXBkYXRlXG4gKiBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogKEdDIHwgSXRlbSlbXSB9Pn0gY2xpZW50c1N0cnVjdFJlZnNcbiAqIEByZXR1cm4geyBudWxsIHwgeyB1cGRhdGU6IFVpbnQ4QXJyYXksIG1pc3Npbmc6IE1hcDxudW1iZXIsbnVtYmVyPiB9IH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGludGVncmF0ZVN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBjbGllbnRzU3RydWN0UmVmcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0gfCBHQz59XG4gICAqL1xuICBjb25zdCBzdGFjayA9IFtdXG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBhcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IGdldE5leHRTdHJ1Y3RUYXJnZXQgPSAoKSA9PiB7XG4gICAgaWYgKGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgbGV0IG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKVxuICAgIHdoaWxlIChuZXh0U3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCA9PT0gbmV4dFN0cnVjdHNUYXJnZXQuaSkge1xuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMucG9wKClcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdHJ1Y3RzVGFyZ2V0XG4gIH1cbiAgbGV0IGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KClcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJ1Y3RTdG9yZX1cbiAgICovXG4gIGNvbnN0IHJlc3RTdHJ1Y3RzID0gbmV3IFN0cnVjdFN0b3JlKClcbiAgY29uc3QgbWlzc2luZ1NWID0gbmV3IE1hcCgpXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgY29uc3QgdXBkYXRlTWlzc2luZ1N2ID0gKGNsaWVudCwgY2xvY2spID0+IHtcbiAgICBjb25zdCBtY2xvY2sgPSBtaXNzaW5nU1YuZ2V0KGNsaWVudClcbiAgICBpZiAobWNsb2NrID09IG51bGwgfHwgbWNsb2NrID4gY2xvY2spIHtcbiAgICAgIG1pc3NpbmdTVi5zZXQoY2xpZW50LCBjbG9jaylcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtHQ3xJdGVtfVxuICAgKi9cbiAgbGV0IHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoY3VyU3RydWN0c1RhcmdldCkucmVmc1svKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLmkrK11cbiAgLy8gY2FjaGluZyB0aGUgc3RhdGUgYmVjYXVzZSBpdCBpcyB1c2VkIHZlcnkgb2Z0ZW5cbiAgY29uc3Qgc3RhdGUgPSBuZXcgTWFwKClcblxuICBjb25zdCBhZGRTdGFja1RvUmVzdFNTID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBzdGFjaykge1xuICAgICAgY29uc3QgY2xpZW50ID0gaXRlbS5pZC5jbGllbnRcbiAgICAgIGNvbnN0IHVuYXBwbGljYWJsZUl0ZW1zID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudClcbiAgICAgIGlmICh1bmFwcGxpY2FibGVJdGVtcykge1xuICAgICAgICAvLyBkZWNyZW1lbnQgYmVjYXVzZSB3ZSB3ZXJlbid0IGFibGUgdG8gYXBwbHkgcHJldmlvdXMgb3BlcmF0aW9uXG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLmktLVxuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIHVuYXBwbGljYWJsZUl0ZW1zLnJlZnMuc2xpY2UodW5hcHBsaWNhYmxlSXRlbXMuaSkpXG4gICAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzLmRlbGV0ZShjbGllbnQpXG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLmkgPSAwXG4gICAgICAgIHVuYXBwbGljYWJsZUl0ZW1zLnJlZnMgPSBbXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXRlbSB3YXMgdGhlIGxhc3QgaXRlbSBvbiBjbGllbnRzU3RydWN0UmVmcyBhbmQgdGhlIGZpZWxkIHdhcyBhbHJlYWR5IGNsZWFyZWQuIEFkZCBpdGVtIHRvIHJlc3RTdHJ1Y3RzIGFuZCBjb250aW51ZVxuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIFtpdGVtXSlcbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBjbGllbnQgZnJvbSBjbGllbnRzU3RydWN0UmVmc0lkcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gYXBwbHlpbmcgdGhlIHNhbWUgdXBkYXRlIGFnYWluXG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcyA9IGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmZpbHRlcihjID0+IGMgIT09IGNsaWVudClcbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gMFxuICB9XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBzdHJ1Y3QgcmVhZGVycyB1bnRpbCB3ZSBhcmUgZG9uZVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChzdGFja0hlYWQuY29uc3RydWN0b3IgIT09IFNraXApIHtcbiAgICAgIGNvbnN0IGxvY2FsQ2xvY2sgPSBtYXAuc2V0SWZVbmRlZmluZWQoc3RhdGUsIHN0YWNrSGVhZC5pZC5jbGllbnQsICgpID0+IGdldFN0YXRlKHN0b3JlLCBzdGFja0hlYWQuaWQuY2xpZW50KSlcbiAgICAgIGNvbnN0IG9mZnNldCA9IGxvY2FsQ2xvY2sgLSBzdGFja0hlYWQuaWQuY2xvY2tcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIHRoZSBzYW1lIGNsaWVudCBpcyBtaXNzaW5nXG4gICAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKVxuICAgICAgICB1cGRhdGVNaXNzaW5nU3Yoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrIC0gMSlcbiAgICAgICAgLy8gaGlkIGEgZGVhZCB3YWxsLCBhZGQgYWxsIGl0ZW1zIGZyb20gc3RhY2sgdG8gcmVzdFNTXG4gICAgICAgIGFkZFN0YWNrVG9SZXN0U1MoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHN0YWNrSGVhZC5nZXRNaXNzaW5nKHRyYW5zYWN0aW9uLCBzdG9yZSlcbiAgICAgICAgaWYgKG1pc3NpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZClcbiAgICAgICAgICAvLyBnZXQgdGhlIHN0cnVjdCByZWFkZXIgdGhhdCBoYXMgdGhlIG1pc3Npbmcgc3RydWN0XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge3sgcmVmczogQXJyYXk8R0N8SXRlbT4sIGk6IG51bWJlciB9fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IHN0cnVjdFJlZnMgPSBjbGllbnRzU3RydWN0UmVmcy5nZXQoLyoqIEB0eXBlIHtudW1iZXJ9ICovIChtaXNzaW5nKSkgfHwgeyByZWZzOiBbXSwgaTogMCB9XG4gICAgICAgICAgaWYgKHN0cnVjdFJlZnMucmVmcy5sZW5ndGggPT09IHN0cnVjdFJlZnMuaSkge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgbWVzc2FnZSBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlIG1lc3NhZ2UgdGhhdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICAgICAgdXBkYXRlTWlzc2luZ1N2KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZyksIGdldFN0YXRlKHN0b3JlLCBtaXNzaW5nKSlcbiAgICAgICAgICAgIGFkZFN0YWNrVG9SZXN0U1MoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFja0hlYWQgPSBzdHJ1Y3RSZWZzLnJlZnNbc3RydWN0UmVmcy5pKytdXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDAgfHwgb2Zmc2V0IDwgc3RhY2tIZWFkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFsbCBmaW5lLCBhcHBseSB0aGUgc3RhY2toZWFkXG4gICAgICAgICAgc3RhY2tIZWFkLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgb2Zmc2V0KVxuICAgICAgICAgIHN0YXRlLnNldChzdGFja0hlYWQuaWQuY2xpZW50LCBzdGFja0hlYWQuaWQuY2xvY2sgKyBzdGFja0hlYWQubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGl0ZXJhdGUgdG8gbmV4dCBzdGFja0hlYWRcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoc3RhY2sucG9wKCkpXG4gICAgfSBlbHNlIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ICE9PSBudWxsICYmIGN1clN0cnVjdHNUYXJnZXQuaSA8IGN1clN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pXG4gICAgfSBlbHNlIHtcbiAgICAgIGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KClcbiAgICAgIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIHdlIGFyZSBkb25lIVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpXG4gICAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCByZXN0U3RydWN0cywgbmV3IE1hcCgpKVxuICAgIC8vIHdyaXRlIGVtcHR5IGRlbGV0ZXNldFxuICAgIC8vIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIG5ldyBEZWxldGVTZXQoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMCkgLy8gPT4gbm8gbmVlZCBmb3IgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbCwganVzdCB3cml0ZSAwIGRlbGV0ZXNcbiAgICByZXR1cm4geyBtaXNzaW5nOiBtaXNzaW5nU1YsIHVwZGF0ZTogZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZSlcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gW3N0cnVjdERlY29kZXJdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVXBkYXRlVjIgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIHN0cnVjdERlY29kZXIgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGRlY29kZXIpKSA9PlxuICB0cmFuc2FjdCh5ZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgLy8gZm9yY2UgdGhhdCB0cmFuc2FjdGlvbi5sb2NhbCBpcyBzZXQgdG8gbm9uLWxvY2FsXG4gICAgdHJhbnNhY3Rpb24ubG9jYWwgPSBmYWxzZVxuICAgIGxldCByZXRyeSA9IGZhbHNlXG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgICAvLyBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHNzID0gcmVhZENsaWVudHNTdHJ1Y3RSZWZzKHN0cnVjdERlY29kZXIsIGRvYylcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkIHN0cnVjdHM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBtZXJnZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHJlc3RTdHJ1Y3RzID0gaW50ZWdyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RvcmUsIHNzKVxuICAgIGNvbnN0IHBlbmRpbmcgPSBzdG9yZS5wZW5kaW5nU3RydWN0c1xuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gYXBwbHkgc29tZXRoaW5nXG4gICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiBwZW5kaW5nLm1pc3NpbmcpIHtcbiAgICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgICByZXRyeSA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdFN0cnVjdHMpIHtcbiAgICAgICAgLy8gbWVyZ2UgcmVzdFN0cnVjdHMgaW50byBzdG9yZS5wZW5kaW5nXG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHJlc3RTdHJ1Y3RzLm1pc3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBtY2xvY2sgPSBwZW5kaW5nLm1pc3NpbmcuZ2V0KGNsaWVudClcbiAgICAgICAgICBpZiAobWNsb2NrID09IG51bGwgfHwgbWNsb2NrID4gY2xvY2spIHtcbiAgICAgICAgICAgIHBlbmRpbmcubWlzc2luZy5zZXQoY2xpZW50LCBjbG9jaylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZy51cGRhdGUgPSBtZXJnZVVwZGF0ZXNWMihbcGVuZGluZy51cGRhdGUsIHJlc3RTdHJ1Y3RzLnVwZGF0ZV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gcmVzdFN0cnVjdHNcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gaW50ZWdyYXRlOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3QgZHNSZXN0ID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHN0cnVjdERlY29kZXIsIHRyYW5zYWN0aW9uLCBzdG9yZSlcbiAgICBpZiAoc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgICAvLyBAdG9kbyB3ZSBjb3VsZCBtYWtlIGEgbG93ZXItYm91bmQgc3RhdGUtdmVjdG9yIGNoZWNrIGFzIHdlIGRvIGFib3ZlXG4gICAgICBjb25zdCBwZW5kaW5nRFNVcGRhdGUgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoc3RvcmUucGVuZGluZ0RzKSlcbiAgICAgIGRlY29kaW5nLnJlYWRWYXJVaW50KHBlbmRpbmdEU1VwZGF0ZS5yZXN0RGVjb2RlcikgLy8gcmVhZCAwIHN0cnVjdHMsIGJlY2F1c2Ugd2Ugb25seSBlbmNvZGUgZGVsZXRlcyBpbiBwZW5kaW5nZHN1cGRhdGVcbiAgICAgIGNvbnN0IGRzUmVzdDIgPSByZWFkQW5kQXBwbHlEZWxldGVTZXQocGVuZGluZ0RTVXBkYXRlLCB0cmFuc2FjdGlvbiwgc3RvcmUpXG4gICAgICBpZiAoZHNSZXN0ICYmIGRzUmVzdDIpIHtcbiAgICAgICAgLy8gY2FzZSAxOiBkczEgIT0gbnVsbCAmJiBkczIgIT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBtZXJnZVVwZGF0ZXNWMihbZHNSZXN0LCBkc1Jlc3QyXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgMjogZHMxICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSAzOiBkczIgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDQ6IGRzMSA9PSBudWxsICYmIGRzMiA9PSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdCB8fCBkc1Jlc3QyXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVpdGhlciBkc1Jlc3QgPT0gbnVsbCAmJiBwZW5kaW5nRHMgPT0gbnVsbCBPUiBkc1Jlc3QgIT0gbnVsbFxuICAgICAgc3RvcmUucGVuZGluZ0RzID0gZHNSZXN0XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGNsZWFudXA6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlc3VtZSBkZWxldGUgcmVhZGVyczogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGlmIChyZXRyeSkge1xuICAgICAgY29uc3QgdXBkYXRlID0gLyoqIEB0eXBlIHt7dXBkYXRlOiBVaW50OEFycmF5fX0gKi8gKHN0b3JlLnBlbmRpbmdTdHJ1Y3RzKS51cGRhdGVcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbFxuICAgICAgYXBwbHlVcGRhdGVWMih0cmFuc2FjdGlvbi5kb2MsIHVwZGF0ZSlcbiAgICB9XG4gIH0sIHRyYW5zYWN0aW9uT3JpZ2luLCBmYWxzZSlcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVXBkYXRlID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBVcGRhdGVEZWNvZGVyVjEoZGVjb2RlcikpXG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5VXBkYXRlVjIgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBZRGVjb2RlcihkZWNvZGVyKSlcbn1cblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYXBwbHlVcGRhdGUgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gYXBwbHlVcGRhdGVWMih5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBVcGRhdGVEZWNvZGVyVjEpXG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZS4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVWZWN0b3JgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBbdGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3RhdGVBc1VwZGF0ZSA9IChlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yID0gbmV3IE1hcCgpKSA9PiB7XG4gIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgZG9jLnN0b3JlLCB0YXJnZXRTdGF0ZVZlY3RvcilcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSkpXG59XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGVWMiA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBVaW50OEFycmF5KFswXSksIGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCkpID0+IHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVWZWN0b3IgPSBkZWNvZGVTdGF0ZVZlY3RvcihlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpXG4gIHdyaXRlU3RhdGVBc1VwZGF0ZShlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yKVxuICBjb25zdCB1cGRhdGVzID0gW2VuY29kZXIudG9VaW50OEFycmF5KCldXG4gIC8vIGFsc28gYWRkIHRoZSBwZW5kaW5nIHVwZGF0ZXMgKGlmIHRoZXJlIGFyZSBhbnkpXG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgdXBkYXRlcy5wdXNoKGRvYy5zdG9yZS5wZW5kaW5nRHMpXG4gIH1cbiAgaWYgKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cykge1xuICAgIHVwZGF0ZXMucHVzaChkaWZmVXBkYXRlVjIoZG9jLnN0b3JlLnBlbmRpbmdTdHJ1Y3RzLnVwZGF0ZSwgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSlcbiAgfVxuICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMSkge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlcyh1cGRhdGVzLm1hcCgodXBkYXRlLCBpKSA9PiBpID09PSAwID8gdXBkYXRlIDogY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSh1cGRhdGUpKSlcbiAgICB9IGVsc2UgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMikge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cGRhdGVzWzBdXG59XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGUgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpID0+IGVuY29kZVN0YXRlQXNVcGRhdGVWMihkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciwgbmV3IFVwZGF0ZUVuY29kZXJWMSgpKVxuXG4vKipcbiAqIFJlYWQgc3RhdGUgdmVjdG9yIGZyb20gRGVjb2RlciBhbmQgcmV0dXJuIGFzIE1hcFxuICpcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3RhdGVWZWN0b3IgPSBkZWNvZGVyID0+IHtcbiAgY29uc3Qgc3MgPSBuZXcgTWFwKClcbiAgY29uc3Qgc3NMZW5ndGggPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBzcy5zZXQoY2xpZW50LCBjbG9jaylcbiAgfVxuICByZXR1cm4gc3Ncbn1cblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvclYyID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSlcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvciA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpXG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc3ZcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBzdikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3Yuc2l6ZSlcbiAgYXJyYXkuZnJvbShzdi5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KSAvLyBAdG9kbyB1c2UgYSBzcGVjaWFsIGNsaWVudCBkZWNvZGVyIHRoYXQgaXMgYmFzZWQgb24gbWFwcGluZ1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jaylcbiAgfSlcbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRG9jdW1lbnRTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBkb2MpID0+IHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSlcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvclYyID0gKGRvYywgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYylcbiAgfSBlbHNlIHtcbiAgICB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKVxuICB9XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvciA9IGRvYyA9PiBlbmNvZGVTdGF0ZVZlY3RvclYyKGRvYywgbmV3IERTRW5jb2RlclYxKCkpXG4iLCAiaW1wb3J0ICogYXMgZiBmcm9tICdsaWIwL2Z1bmN0aW9uJ1xuXG4vKipcbiAqIEdlbmVyYWwgZXZlbnQgaGFuZGxlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCwgQVJHMVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcmV0dXJucyB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpXG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGlzIGNhbGxlZCB3aGVuXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2NhbGxFdmVudExpc3RlbmVyc30gaXMgY2FsbGVkLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtmdW5jdGlvbihBUkcwLEFSRzEpOnZvaWR9IGYgVGhlIGV2ZW50IGhhbmRsZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpXG5cbi8qKlxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyIHRoYXQgd2FzIGFkZGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAge0BsaW5rIEV2ZW50SGFuZGxlciNhZGRFdmVudExpc3RlbmVyfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmxcbiAgY29uc3QgbGVuID0gbC5sZW5ndGhcbiAgZXZlbnRIYW5kbGVyLmwgPSBsLmZpbHRlcihnID0+IGYgIT09IGcpXG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpXG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSBldmVudEhhbmRsZXIgPT4ge1xuICBldmVudEhhbmRsZXIubC5sZW5ndGggPSAwXG59XG5cbi8qKlxuICogQ2FsbCBhbGwgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZCB2aWFcbiAqIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn0uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge0FSRzB9IGFyZzBcbiAqIEBwYXJhbSB7QVJHMX0gYXJnMVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBmLmNhbGxBbGwoZXZlbnRIYW5kbGVyLmwsIFthcmcwLCBhcmcxXSlcbiIsICJpbXBvcnQgeyBBYnN0cmFjdFR5cGUgfSBmcm9tICcuLi9pbnRlcm5hbHMuanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5leHBvcnQgY2xhc3MgSUQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudCBjbGllbnQgaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrIHVuaXF1ZSBwZXIgY2xpZW50IGlkLCBjb250aW51b3VzIG51bWJlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsaWVudCwgY2xvY2spIHtcbiAgICAvKipcbiAgICAgKiBDbGllbnQgaWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgLyoqXG4gICAgICogdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2tcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SUQgfCBudWxsfSBhXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBhcmVJRHMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuY2xpZW50ID09PSBiLmNsaWVudCAmJiBhLmNsb2NrID09PSBiLmNsb2NrKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlEID0gKGNsaWVudCwgY2xvY2spID0+IG5ldyBJRChjbGllbnQsIGNsb2NrKVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtJRH0gaWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUlEID0gKGVuY29kZXIsIGlkKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbGllbnQpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbG9jaylcbn1cblxuLyoqXG4gKiBSZWFkIElELlxuICogKiBJZiBmaXJzdCB2YXJVaW50IHJlYWQgaXMgMHhGRkZGRkYgYSBSb290SUQgaXMgcmV0dXJuZWQuXG4gKiAqIE90aGVyd2lzZSBhbiBJRCBpcyByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7SUR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZElEID0gZGVjb2RlciA9PlxuICBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpXG5cbi8qKlxuICogVGhlIHRvcCB0eXBlcyBhcmUgbWFwcGVkIGZyb20geS5zaGFyZS5nZXQoa2V5bmFtZSkgPT4gdHlwZS5cbiAqIGB0eXBlYCBkb2VzIG5vdCBzdG9yZSBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGBrZXluYW1lYC5cbiAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGNvcnJlY3QgYGtleW5hbWVgIGZvciBgdHlwZWAgYW5kIHRocm93cyBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRSb290VHlwZUtleSA9IHR5cGUgPT4ge1xuICAvLyBAdHMtaWdub3JlIF95IG11c3QgYmUgZGVmaW5lZCwgb3RoZXJ3aXNlIHVuZXhwZWN0ZWQgY2FzZVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0eXBlLmRvYy5zaGFyZS5lbnRyaWVzKCkpIHtcbiAgICBpZiAodmFsdWUgPT09IHR5cGUpIHtcbiAgICAgIHJldHVybiBrZXlcbiAgICB9XG4gIH1cbiAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxufVxuIiwgImltcG9ydCB7IEFic3RyYWN0VHlwZSwgSXRlbSB9IGZyb20gJy4uL2ludGVybmFscy5qcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIENoZWNrIGlmIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY2hpbGRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc1BhcmVudE9mID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5wYXJlbnQpLl9pdGVtXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG4iLCAiaW1wb3J0IHtcbiAgQWJzdHJhY3RUeXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIENvbnZlbmllbnQgaGVscGVyIHRvIGxvZyB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIERvIG5vdCB1c2UgaW4gcHJvZHVjdGl2ZSBzeXN0ZW1zIGFzIHRoZSBvdXRwdXQgY2FuIGJlIGltbWVuc2UhXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICovXG5leHBvcnQgY29uc3QgbG9nVHlwZSA9IHR5cGUgPT4ge1xuICBjb25zdCByZXMgPSBbXVxuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIHdoaWxlIChuKSB7XG4gICAgcmVzLnB1c2gobilcbiAgICBuID0gbi5yaWdodFxuICB9XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbjogJywgcmVzKVxuICBjb25zb2xlLmxvZygnQ2hpbGRyZW4gY29udGVudDogJywgcmVzLmZpbHRlcihtID0+ICFtLmRlbGV0ZWQpLm1hcChtID0+IG0uY29udGVudCkpXG59XG4iLCAiaW1wb3J0IHtcbiAgWUFycmF5LFxuICBZTWFwLFxuICByZWFkRGVsZXRlU2V0LFxuICB3cml0ZURlbGV0ZVNldCxcbiAgY3JlYXRlRGVsZXRlU2V0LFxuICBEU0VuY29kZXJWMSwgRFNEZWNvZGVyVjEsIElELCBEZWxldGVTZXQsIFlBcnJheUV2ZW50LCBUcmFuc2FjdGlvbiwgRG9jIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuXG5pbXBvcnQgeyBtZXJnZURlbGV0ZVNldHMsIGlzRGVsZXRlZCB9IGZyb20gJy4vRGVsZXRlU2V0LmpzJ1xuXG5leHBvcnQgY2xhc3MgUGVybWFuZW50VXNlckRhdGEge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gW3N0b3JlVHlwZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIHN0b3JlVHlwZSA9IGRvYy5nZXRNYXAoJ3VzZXJzJykpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxEZWxldGVTZXQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMueXVzZXJzID0gc3RvcmVUeXBlXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50aWQgdG8gdXNlckRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuZHNzID0gZHNzXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZTWFwPGFueT59IHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgY29uc3QgaW5pdFVzZXIgPSAodXNlciwgdXNlckRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtZQXJyYXk8VWludDhBcnJheT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRzID0gdXNlci5nZXQoJ2RzJylcbiAgICAgIGNvbnN0IGlkcyA9IHVzZXIuZ2V0KCdpZHMnKVxuICAgICAgY29uc3QgYWRkQ2xpZW50SWQgPSAvKiogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkICovIGNsaWVudGlkID0+IHRoaXMuY2xpZW50cy5zZXQoY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbilcbiAgICAgIGRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGVuY29kZWREcyA9PiB7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZERzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoW3RoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pIHx8IGNyZWF0ZURlbGV0ZVNldCgpLCByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKV0pKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKGRzLm1hcChlbmNvZGVkRHMgPT4gcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSkpKSlcbiAgICAgIGlkcy5vYnNlcnZlKC8qKiBAcGFyYW0ge1lBcnJheUV2ZW50PGFueT59IGV2ZW50ICovIGV2ZW50ID0+XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkuZm9yRWFjaChhZGRDbGllbnRJZCkpXG4gICAgICApXG4gICAgICBpZHMuZm9yRWFjaChhZGRDbGllbnRJZClcbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSB1c2Vyc1xuICAgIHN0b3JlVHlwZS5vYnNlcnZlKGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LmtleXNDaGFuZ2VkLmZvckVhY2godXNlckRlc2NyaXB0aW9uID0+XG4gICAgICAgIGluaXRVc2VyKHN0b3JlVHlwZS5nZXQodXNlckRlc2NyaXB0aW9uKSwgdXNlckRlc2NyaXB0aW9uKVxuICAgICAgKVxuICAgIH0pXG4gICAgLy8gYWRkIGludGlhbCBkYXRhXG4gICAgc3RvcmVUeXBlLmZvckVhY2goaW5pdFVzZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJEZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uLCBEZWxldGVTZXQpOmJvb2xlYW59IFtjb25mLmZpbHRlcl1cbiAgICovXG4gIHNldFVzZXJNYXBwaW5nIChkb2MsIGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24sIHsgZmlsdGVyID0gKCkgPT4gdHJ1ZSB9ID0ge30pIHtcbiAgICBjb25zdCB1c2VycyA9IHRoaXMueXVzZXJzXG4gICAgbGV0IHVzZXIgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKVxuICAgIGlmICghdXNlcikge1xuICAgICAgdXNlciA9IG5ldyBZTWFwKClcbiAgICAgIHVzZXIuc2V0KCdpZHMnLCBuZXcgWUFycmF5KCkpXG4gICAgICB1c2VyLnNldCgnZHMnLCBuZXcgWUFycmF5KCkpXG4gICAgICB1c2Vycy5zZXQodXNlckRlc2NyaXB0aW9uLCB1c2VyKVxuICAgIH1cbiAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKVxuICAgIHVzZXJzLm9ic2VydmUoX2V2ZW50ID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyT3ZlcndyaXRlID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbilcbiAgICAgICAgaWYgKHVzZXJPdmVyd3JpdGUgIT09IHVzZXIpIHtcbiAgICAgICAgICAvLyB1c2VyIHdhcyBvdmVyd3JpdHRlbiwgcG9ydCBhbGwgZGF0YSBvdmVyIHRvIHRoZSBuZXh0IHVzZXIgb2JqZWN0XG4gICAgICAgICAgLy8gQHRvZG8gRXhwZXJpbWVudCB3aXRoIFkuU2V0cyBoZXJlXG4gICAgICAgICAgdXNlciA9IHVzZXJPdmVyd3JpdGVcbiAgICAgICAgICAvLyBAdG9kbyBpdGVyYXRlIG92ZXIgb2xkIHR5cGVcbiAgICAgICAgICB0aGlzLmNsaWVudHMuZm9yRWFjaCgoX3VzZXJEZXNjcmlwdGlvbiwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VyRGVzY3JpcHRpb24gPT09IF91c2VyRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKVxuICAgICAgICAgIGNvbnN0IGRzID0gdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbilcbiAgICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKVxuICAgICAgICAgICAgdXNlci5nZXQoJ2RzJykucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKVxuICAgIH0pXG4gICAgZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgLyoqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uICovIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB5ZHMgPSB1c2VyLmdldCgnZHMnKVxuICAgICAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldFxuICAgICAgICBpZiAodHJhbnNhY3Rpb24ubG9jYWwgJiYgZHMuY2xpZW50cy5zaXplID4gMCAmJiBmaWx0ZXIodHJhbnNhY3Rpb24sIGRzKSkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKVxuICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKVxuICAgICAgICAgIHlkcy5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBnZXRVc2VyQnlDbGllbnRJZCAoY2xpZW50aWQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRzLmdldChjbGllbnRpZCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXRVc2VyQnlEZWxldGVkSWQgKGlkKSB7XG4gICAgZm9yIChjb25zdCBbdXNlckRlc2NyaXB0aW9uLCBkc10gb2YgdGhpcy5kc3MuZW50cmllcygpKSB7XG4gICAgICBpZiAoaXNEZWxldGVkKGRzLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJEZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgd3JpdGVJRCxcbiAgcmVhZElELFxuICBjb21wYXJlSURzLFxuICBnZXRTdGF0ZSxcbiAgZmluZFJvb3RUeXBlS2V5LFxuICBJdGVtLFxuICBjcmVhdGVJRCxcbiAgQ29udGVudFR5cGUsXG4gIGZvbGxvd1JlZG9uZSxcbiAgZ2V0SXRlbSxcbiAgSUQsIERvYywgQWJzdHJhY3RUeXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBiYXNlZCBvbiB0aGUgWWpzIG1vZGVsIGFuZCBpcyBub3QgYWZmZWN0ZWQgYnkgZG9jdW1lbnQgY2hhbmdlcy5cbiAqIEUuZy4gSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIGEgY2VydGFpbiBjaGFyYWN0ZXIsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoaXMgY2hhcmFjdGVyLlxuICogSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiBhIHR5cGUsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoZSBlbmQgb2YgdGhlIHR5cGUuXG4gKlxuICogQSBudW1lcmljIHBvc2l0aW9uIGlzIG9mdGVuIHVuc3VpdGVkIGZvciB1c2VyIHNlbGVjdGlvbnMsIGJlY2F1c2UgaXQgZG9lcyBub3QgY2hhbmdlIHdoZW4gY29udGVudCBpcyBpbnNlcnRlZFxuICogYmVmb3JlIG9yIGFmdGVyLlxuICpcbiAqIGBgYEluc2VydCgwLCAneCcpKCdhfGJjJykgPSAneGF8YmMnYGBgIFdoZXJlIHwgaXMgdGhlIHJlbGF0aXZlIHBvc2l0aW9uLlxuICpcbiAqIE9uZSBvZiB0aGUgcHJvcGVydGllcyBtdXN0IGJlIGRlZmluZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gaXMgYXQgcG9zaXRpb24gMTBcbiAqICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSW5kZXgoeVRleHQsIDEwKVxuICogICAvLyBtb2RpZnkgeVRleHRcbiAqICAgeVRleHQuaW5zZXJ0KDAsICdhYmMnKVxuICogICB5VGV4dC5kZWxldGUoMywgMTApXG4gKiAgIC8vIENvbXB1dGUgdGhlIGN1cnNvciBwb3NpdGlvblxuICogICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHksIHJlbGF0aXZlUG9zaXRpb24pXG4gKiAgIGFic29sdXRlUG9zaXRpb24udHlwZSA9PT0geVRleHQgLy8gPT4gdHJ1ZVxuICogICBjb25zb2xlLmxvZygnY3Vyc29yIGxvY2F0aW9uIGlzICcgKyBhYnNvbHV0ZVBvc2l0aW9uLmluZGV4KSAvLyA9PiBjdXJzb3IgbG9jYXRpb24gaXMgM1xuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFJlbGF0aXZlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJRHxudWxsfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHRuYW1lXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICAgKiBAcGFyYW0ge251bWJlcn0gYXNzb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCB0bmFtZSwgaXRlbSwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRuYW1lID0gdG5hbWVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaXRlbSA9IGl0ZW1cbiAgICAvKipcbiAgICAgKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gYSBzcGVjaWZpYyBjaGFyYWN0ZXIuIEJ5IGRlZmF1bHRcbiAgICAgKiBhc3NvYyA+PSAwLCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2hhcmFjdGVyXG4gICAgICogYWZ0ZXIgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqIEkuZS4gcG9zaXRpb24gMSBpbiAnYWInIGlzIGFzc29jaWF0ZWQgdG8gY2hhcmFjdGVyICdiJy5cbiAgICAgKlxuICAgICAqIElmIGFzc29jIDwgMCwgdGhlbiB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byB0aGUgY2FoYXJhY3RlclxuICAgICAqIGJlZm9yZSB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvY1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9KU09OID0gcnBvcyA9PiB7XG4gIGNvbnN0IGpzb24gPSB7fVxuICBpZiAocnBvcy50eXBlKSB7XG4gICAganNvbi50eXBlID0gcnBvcy50eXBlXG4gIH1cbiAgaWYgKHJwb3MudG5hbWUpIHtcbiAgICBqc29uLnRuYW1lID0gcnBvcy50bmFtZVxuICB9XG4gIGlmIChycG9zLml0ZW0pIHtcbiAgICBqc29uLml0ZW0gPSBycG9zLml0ZW1cbiAgfVxuICBpZiAocnBvcy5hc3NvYyAhPSBudWxsKSB7XG4gICAganNvbi5hc3NvYyA9IHJwb3MuYXNzb2NcbiAgfVxuICByZXR1cm4ganNvblxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OID0ganNvbiA9PiBuZXcgUmVsYXRpdmVQb3NpdGlvbihqc29uLnR5cGUgPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLnR5cGUuY2xpZW50LCBqc29uLnR5cGUuY2xvY2spLCBqc29uLnRuYW1lID8/IG51bGwsIGpzb24uaXRlbSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24uaXRlbS5jbGllbnQsIGpzb24uaXRlbS5jbG9jayksIGpzb24uYXNzb2MgPT0gbnVsbCA/IDAgOiBqc29uLmFzc29jKVxuXG5leHBvcnQgY2xhc3MgQWJzb2x1dGVQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4XG4gICAgdGhpcy5hc3NvYyA9IGFzc29jXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IG5ldyBBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBhc3NvYylcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uID0gKHR5cGUsIGl0ZW0sIGFzc29jKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsXG4gIGxldCB0bmFtZSA9IG51bGxcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IGZpbmRSb290VHlwZUtleSh0eXBlKVxuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IGNyZWF0ZUlEKHR5cGUuX2l0ZW0uaWQuY2xpZW50LCB0eXBlLl9pdGVtLmlkLmNsb2NrKVxuICB9XG4gIHJldHVybiBuZXcgUmVsYXRpdmVQb3NpdGlvbih0eXBlaWQsIHRuYW1lLCBpdGVtLCBhc3NvYylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiB7XG4gIGxldCB0ID0gdHlwZS5fc3RhcnRcbiAgaWYgKGFzc29jIDwgMCkge1xuICAgIC8vIGFzc29jaWF0ZWQgdG8gdGhlIGxlZnQgY2hhcmFjdGVyIG9yIHRoZSBiZWdpbm5pbmcgb2YgYSB0eXBlLCBpbmNyZW1lbnQgaW5kZXggaWYgcG9zc2libGUuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbiAgICB9XG4gICAgaW5kZXgtLVxuICB9XG4gIHdoaWxlICh0ICE9PSBudWxsKSB7XG4gICAgaWYgKCF0LmRlbGV0ZWQgJiYgdC5jb3VudGFibGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgIC8vIGNhc2UgMTogZm91bmQgcG9zaXRpb24gc29tZXdoZXJlIGluIHRoZSBsaW5rZWQgbGlzdFxuICAgICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBjcmVhdGVJRCh0LmlkLmNsaWVudCwgdC5pZC5jbG9jayArIGluZGV4KSwgYXNzb2MpXG4gICAgICB9XG4gICAgICBpbmRleCAtPSB0Lmxlbmd0aFxuICAgIH1cbiAgICBpZiAodC5yaWdodCA9PT0gbnVsbCAmJiBhc3NvYyA8IDApIHtcbiAgICAgIC8vIGxlZnQtYXNzb2NpYXRlZCBwb3NpdGlvbiwgcmV0dXJuIGxhc3QgYXZhaWxhYmxlIGlkXG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCB0Lmxhc3RJZCwgYXNzb2MpXG4gICAgfVxuICAgIHQgPSB0LnJpZ2h0XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlUmVsYXRpdmVQb3NpdGlvbiA9IChlbmNvZGVyLCBycG9zKSA9PiB7XG4gIGNvbnN0IHsgdHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jIH0gPSBycG9zXG4gIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDApXG4gICAgd3JpdGVJRChlbmNvZGVyLCBpdGVtKVxuICB9IGVsc2UgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyLCAxKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRuYW1lKVxuICB9IGVsc2UgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAvLyBjYXNlIDM6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgYXR0YWNoZWQgdG8gYW4gaXRlbVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlciwgMilcbiAgICB3cml0ZUlEKGVuY29kZXIsIHR5cGUpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICB9XG4gIGVuY29kaW5nLndyaXRlVmFySW50KGVuY29kZXIsIGFzc29jKVxuICByZXR1cm4gZW5jb2RlclxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVJlbGF0aXZlUG9zaXRpb24gPSBycG9zID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICB3cml0ZVJlbGF0aXZlUG9zaXRpb24oZW5jb2RlciwgcnBvcylcbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRSZWxhdGl2ZVBvc2l0aW9uID0gZGVjb2RlciA9PiB7XG4gIGxldCB0eXBlID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGxldCBpdGVtSUQgPSBudWxsXG4gIHN3aXRjaCAoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgIGl0ZW1JRCA9IHJlYWRJRChkZWNvZGVyKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDE6XG4gICAgICAvLyBjYXNlIDI6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgc3RvcmVkIGluIHkuc2hhcmVcbiAgICAgIHRuYW1lID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6IHtcbiAgICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgICB0eXBlID0gcmVhZElEKGRlY29kZXIpXG4gICAgfVxuICB9XG4gIGNvbnN0IGFzc29jID0gZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSA/IGRlY29kaW5nLnJlYWRWYXJJbnQoZGVjb2RlcikgOiAwXG4gIHJldHVybiBuZXcgUmVsYXRpdmVQb3NpdGlvbih0eXBlLCB0bmFtZSwgaXRlbUlELCBhc3NvYylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gdWludDhBcnJheSA9PiByZWFkUmVsYXRpdmVQb3NpdGlvbihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVpbnQ4QXJyYXkpKVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHJlbGF0aXZlIHBvc2l0aW9uIHRvIGFuIGFic29sdXRlIHBvc2l0aW9uLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHNoYXJlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB3aXRoIG90aGVyIHVzZXJzLCB5b3Ugc2hvdWxkIHNldFxuICogYGZvbGxvd1VuZG9uZURlbGV0aW9uc2AgdG8gZmFsc2UgdG8gZ2V0IGNvbnNpc3RlbnQgcmVzdWx0cyBhY3Jvc3MgYWxsIGNsaWVudHMuXG4gKlxuICogV2hlbiBjYWxjdWxhdGluZyB0aGUgYWJzb2x1dGUgcG9zaXRpb24sIHdlIHRyeSB0byBmb2xsb3cgdGhlIFwidW5kb25lIGRlbGV0aW9uc1wiLiBUaGlzIHlpZWxkc1xuICogYmV0dGVyIHJlc3VsdHMgZm9yIHRoZSB1c2VyIHdobyBwZXJmb3JtZWQgdW5kby4gSG93ZXZlciwgb25seSB0aGUgdXNlciB3aG8gcGVyZm9ybWVkIHRoZSB1bmRvXG4gKiB3aWxsIGdldCB0aGUgYmV0dGVyIHJlc3VsdHMsIHRoZSBvdGhlciB1c2VycyBkb24ndCBrbm93IHdoaWNoIG9wZXJhdGlvbnMgcmVjcmVhdGVkIGEgZGVsZXRlZFxuICogcmFuZ2Ugb2YgY29udGVudC4gVGhlcmUgaXMgbW9yZSBpbmZvcm1hdGlvbiBpbiB0aGlzIHRpY2tldDogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzYzOFxuICpcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtib29sZWFufSBmb2xsb3dVbmRvbmVEZWxldGlvbnMgLSB3aGV0aGVyIHRvIGZvbGxvdyB1bmRvbmUgZGVsZXRpb25zIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy82MzhcbiAqIEByZXR1cm4ge0Fic29sdXRlUG9zaXRpb258bnVsbH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbiA9IChycG9zLCBkb2MsIGZvbGxvd1VuZG9uZURlbGV0aW9ucyA9IHRydWUpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgY29uc3QgcmlnaHRJRCA9IHJwb3MuaXRlbVxuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGVcbiAgY29uc3QgdG5hbWUgPSBycG9zLnRuYW1lXG4gIGNvbnN0IGFzc29jID0gcnBvcy5hc3NvY1xuICBsZXQgdHlwZSA9IG51bGxcbiAgbGV0IGluZGV4ID0gMFxuICBpZiAocmlnaHRJRCAhPT0gbnVsbCkge1xuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgcmlnaHRJRC5jbGllbnQpIDw9IHJpZ2h0SUQuY2xvY2spIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGZvbGxvd1VuZG9uZURlbGV0aW9ucyA/IGZvbGxvd1JlZG9uZShzdG9yZSwgcmlnaHRJRCkgOiB7IGl0ZW06IGdldEl0ZW0oc3RvcmUsIHJpZ2h0SUQpLCBkaWZmOiAwIH1cbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtXG4gICAgaWYgKCEocmlnaHQgaW5zdGFuY2VvZiBJdGVtKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpXG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgaW5kZXggPSAocmlnaHQuZGVsZXRlZCB8fCAhcmlnaHQuY291bnRhYmxlKSA/IDAgOiAocmVzLmRpZmYgKyAoYXNzb2MgPj0gMCA/IDAgOiAxKSkgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnRcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICAgICAgaW5kZXggKz0gbi5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5sZWZ0XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpXG4gICAgfSBlbHNlIGlmICh0eXBlSUQgIT09IG51bGwpIHtcbiAgICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgdHlwZUlELmNsaWVudCkgPD0gdHlwZUlELmNsb2NrKSB7XG4gICAgICAgIC8vIHR5cGUgZG9lcyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBjb25zdCB7IGl0ZW0gfSA9IGZvbGxvd1VuZG9uZURlbGV0aW9ucyA/IGZvbGxvd1JlZG9uZShzdG9yZSwgdHlwZUlEKSA6IHsgaXRlbTogZ2V0SXRlbShzdG9yZSwgdHlwZUlEKSB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgaXRlbS5jb250ZW50IGluc3RhbmNlb2YgQ29udGVudFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IGl0ZW0uY29udGVudC50eXBlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJ1Y3QgaXMgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAoYXNzb2MgPj0gMCkge1xuICAgICAgaW5kZXggPSB0eXBlLl9sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBycG9zLmFzc29jKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbnxudWxsfSBhXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChcbiAgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEudG5hbWUgPT09IGIudG5hbWUgJiYgY29tcGFyZUlEcyhhLml0ZW0sIGIuaXRlbSkgJiYgY29tcGFyZUlEcyhhLnR5cGUsIGIudHlwZSkgJiYgYS5hc3NvYyA9PT0gYi5hc3NvY1xuKVxuIiwgImltcG9ydCB7XG4gIGlzRGVsZXRlZCxcbiAgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLFxuICBnZXRTdGF0ZVZlY3RvcixcbiAgZ2V0SXRlbUNsZWFuU3RhcnQsXG4gIGl0ZXJhdGVEZWxldGVkU3RydWN0cyxcbiAgd3JpdGVEZWxldGVTZXQsXG4gIHdyaXRlU3RhdGVWZWN0b3IsXG4gIHJlYWREZWxldGVTZXQsXG4gIHJlYWRTdGF0ZVZlY3RvcixcbiAgY3JlYXRlRGVsZXRlU2V0LFxuICBjcmVhdGVJRCxcbiAgZ2V0U3RhdGUsXG4gIGZpbmRJbmRleFNTLFxuICBVcGRhdGVFbmNvZGVyVjIsXG4gIGFwcGx5VXBkYXRlVjIsXG4gIExhenlTdHJ1Y3RSZWFkZXIsXG4gIGVxdWFsRGVsZXRlU2V0cyxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIERTRW5jb2RlclYxLCBEU0VuY29kZXJWMiwgRFNEZWNvZGVyVjEsIERTRGVjb2RlclYyLCBUcmFuc2FjdGlvbiwgRG9jLCBEZWxldGVTZXQsIEl0ZW0sIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgbWVyZ2VEZWxldGVTZXRzXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5cbmV4cG9ydCBjbGFzcyBTbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAgICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2IHN0YXRlIG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBzdikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kcyA9IGRzXG4gICAgLyoqXG4gICAgICogU3RhdGUgTWFwXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnN2ID0gc3ZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAxXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsU25hcHNob3RzID0gKHNuYXAxLCBzbmFwMikgPT4ge1xuICBjb25zdCBkczEgPSBzbmFwMS5kcy5jbGllbnRzXG4gIGNvbnN0IGRzMiA9IHNuYXAyLmRzLmNsaWVudHNcbiAgY29uc3Qgc3YxID0gc25hcDEuc3ZcbiAgY29uc3Qgc3YyID0gc25hcDIuc3ZcbiAgaWYgKHN2MS5zaXplICE9PSBzdjIuc2l6ZSB8fCBkczEuc2l6ZSAhPT0gZHMyLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdjEuZW50cmllcygpKSB7XG4gICAgaWYgKHN2Mi5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRzaXRlbXMxXSBvZiBkczEuZW50cmllcygpKSB7XG4gICAgY29uc3QgZHNpdGVtczIgPSBkczIuZ2V0KGNsaWVudCkgfHwgW11cbiAgICBpZiAoZHNpdGVtczEubGVuZ3RoICE9PSBkc2l0ZW1zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzaXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkc2l0ZW0xID0gZHNpdGVtczFbaV1cbiAgICAgIGNvbnN0IGRzaXRlbTIgPSBkc2l0ZW1zMltpXVxuICAgICAgaWYgKGRzaXRlbTEuY2xvY2sgIT09IGRzaXRlbTIuY2xvY2sgfHwgZHNpdGVtMS5sZW4gIT09IGRzaXRlbTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVNuYXBzaG90VjIgPSAoc25hcHNob3QsIGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjIoKSkgPT4ge1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBzbmFwc2hvdC5kcylcbiAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBzbmFwc2hvdC5zdilcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVNuYXBzaG90ID0gc25hcHNob3QgPT4gZW5jb2RlU25hcHNob3RWMihzbmFwc2hvdCwgbmV3IERTRW5jb2RlclYxKCkpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gW2RlY29kZXJdXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVNuYXBzaG90VjIgPSAoYnVmLCBkZWNvZGVyID0gbmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSkpID0+IHtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChyZWFkRGVsZXRlU2V0KGRlY29kZXIpLCByZWFkU3RhdGVWZWN0b3IoZGVjb2RlcikpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlU25hcHNob3QgPSBidWYgPT4gZGVjb2RlU25hcHNob3RWMihidWYsIG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHNtXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNuYXBzaG90ID0gKGRzLCBzbSkgPT4gbmV3IFNuYXBzaG90KGRzLCBzbSlcblxuZXhwb3J0IGNvbnN0IGVtcHR5U25hcHNob3QgPSBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXQoKSwgbmV3IE1hcCgpKVxuXG4vKipcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5leHBvcnQgY29uc3Qgc25hcHNob3QgPSBkb2MgPT4gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSksIGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NuYXBzaG90fHVuZGVmaW5lZH0gc25hcHNob3RcbiAqXG4gKiBAcHJvdGVjdGVkXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT4gc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICA/ICFpdGVtLmRlbGV0ZWRcbiAgOiBzbmFwc2hvdC5zdi5oYXMoaXRlbS5pZC5jbGllbnQpICYmIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApID4gaXRlbS5pZC5jbG9jayAmJiAhaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICovXG5leHBvcnQgY29uc3Qgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgbWV0YSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5tZXRhLCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLCBzZXQuY3JlYXRlKVxuICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLmRvYy5zdG9yZVxuICAvLyBjaGVjayBpZiB3ZSBhbHJlYWR5IHNwbGl0IGZvciB0aGlzIHNuYXBzaG90XG4gIGlmICghbWV0YS5oYXMoc25hcHNob3QpKSB7XG4gICAgc25hcHNob3Quc3YuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKVxuICAgICAgfVxuICAgIH0pXG4gICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdC5kcywgX2l0ZW0gPT4ge30pXG4gICAgbWV0YS5hZGQoc25hcHNob3QpXG4gIH1cbn1cblxuLyoqXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoeyBnYzogZmFsc2UgfSlcbiAqICB5ZG9jLmdldFRleHQoKS5pbnNlcnQoMCwgJ3dvcmxkIScpXG4gKiAgY29uc3Qgc25hcHNob3QgPSBZLnNuYXBzaG90KHlkb2MpXG4gKiAgeWRvYy5nZXRUZXh0KCkuaW5zZXJ0KDAsICdoZWxsbyAnKVxuICogIGNvbnN0IHJlc3RvcmVkID0gWS5jcmVhdGVEb2NGcm9tU25hcHNob3QoeWRvYywgc25hcHNob3QpXG4gKiAgYXNzZXJ0KHJlc3RvcmVkLmdldFRleHQoKS50b1N0cmluZygpID09PSAnd29ybGQhJylcbiAqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRG9jRnJvbVNuYXBzaG90ID0gKG9yaWdpbkRvYywgc25hcHNob3QsIG5ld0RvYyA9IG5ldyBEb2MoKSkgPT4ge1xuICBpZiAob3JpZ2luRG9jLmdjKSB7XG4gICAgLy8gd2Ugc2hvdWxkIG5vdCB0cnkgdG8gcmVzdG9yZSBhIEdDLWVkIGRvY3VtZW50LCBiZWNhdXNlIHNvbWUgb2YgdGhlIHJlc3RvcmVkIGl0ZW1zIG1pZ2h0IGhhdmUgdGhlaXIgY29udGVudCBkZWxldGVkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXJiYWdlLWNvbGxlY3Rpb24gbXVzdCBiZSBkaXNhYmxlZCBpbiBgb3JpZ2luRG9jYCEnKVxuICB9XG4gIGNvbnN0IHsgc3YsIGRzIH0gPSBzbmFwc2hvdFxuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgb3JpZ2luRG9jLnRyYW5zYWN0KHRyYW5zYWN0aW9uID0+IHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBzdi5mb3JFYWNoKGNsb2NrID0+IHtcbiAgICAgIGlmIChjbG9jayA+IDApIHtcbiAgICAgICAgc2l6ZSsrXG4gICAgICB9XG4gICAgfSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc2l6ZSlcbiAgICAvLyBzcGxpdHRpbmcgdGhlIHN0cnVjdHMgYmVmb3JlIHdyaXRpbmcgdGhlbSB0byB0aGUgZW5jb2RlclxuICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHN2KSB7XG4gICAgICBpZiAoY2xvY2sgPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKG9yaWdpbkRvYy5zdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpXG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW11cbiAgICAgIGNvbnN0IGxhc3RTdHJ1Y3RJbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrIC0gMSlcbiAgICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgbGFzdFN0cnVjdEluZGV4ICsgMSlcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KVxuICAgICAgLy8gZmlyc3QgY2xvY2sgd3JpdHRlbiBpcyAwXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxhc3RTdHJ1Y3RJbmRleDsgaSsrKSB7XG4gICAgICAgIHN0cnVjdHNbaV0ud3JpdGUoZW5jb2RlciwgMClcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpXG4gIH0pXG5cbiAgYXBwbHlVcGRhdGVWMihuZXdEb2MsIGVuY29kZXIudG9VaW50OEFycmF5KCksICdzbmFwc2hvdCcpXG4gIHJldHVybiBuZXdEb2Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHNuYXBzaG90Q29udGFpbnNVcGRhdGVWMiA9IChzbmFwc2hvdCwgdXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW11cbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpXG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpXG4gICAgaWYgKChzbmFwc2hvdC5zdi5nZXQoY3Vyci5pZC5jbGllbnQpIHx8IDApIDwgY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgY29uc3QgbWVyZ2VkRFMgPSBtZXJnZURlbGV0ZVNldHMoW3NuYXBzaG90LmRzLCByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXSlcbiAgcmV0dXJuIGVxdWFsRGVsZXRlU2V0cyhzbmFwc2hvdC5kcywgbWVyZ2VkRFMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzbmFwc2hvdENvbnRhaW5zVXBkYXRlID0gKHNuYXBzaG90LCB1cGRhdGUpID0+IHNuYXBzaG90Q29udGFpbnNVcGRhdGVWMihzbmFwc2hvdCwgdXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpXG4iLCAiaW1wb3J0IHtcbiAgR0MsXG4gIHNwbGl0SXRlbSxcbiAgVHJhbnNhY3Rpb24sIElELCBJdGVtLCBEU0RlY29kZXJWMiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5leHBvcnQgY2xhc3MgU3RydWN0U3RvcmUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8R0N8SXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgeyBtaXNzaW5nOiBNYXA8bnVtYmVyLCBudW1iZXI+LCB1cGRhdGU6IFVpbnQ4QXJyYXkgfX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgVWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdEcyA9IG51bGxcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhdGVzIGFzIGEgTWFwPGNsaWVudCxjbG9jaz4uXG4gKiBOb3RlIHRoYXQgY2xvY2sgcmVmZXJzIHRvIHRoZSBuZXh0IGV4cGVjdGVkIGNsb2NrIGlkLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTdGF0ZVZlY3RvciA9IHN0b3JlID0+IHtcbiAgY29uc3Qgc20gPSBuZXcgTWFwKClcbiAgc3RvcmUuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV1cbiAgICBzbS5zZXQoY2xpZW50LCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKVxuICB9KVxuICByZXR1cm4gc21cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHJldHVybiB7bnVtYmVyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RhdGUgPSAoc3RvcmUsIGNsaWVudCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KVxuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBjb25zdCBsYXN0U3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdXG4gIHJldHVybiBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGhcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGludGVncmV0eUNoZWNrID0gc3RvcmUgPT4ge1xuICBzdG9yZS5jbGllbnRzLmZvckVhY2goc3RydWN0cyA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsID0gc3RydWN0c1tpIC0gMV1cbiAgICAgIGNvbnN0IHIgPSBzdHJ1Y3RzW2ldXG4gICAgICBpZiAobC5pZC5jbG9jayArIGwubGVuZ3RoICE9PSByLmlkLmNsb2NrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RydWN0U3RvcmUgZmFpbGVkIGludGVncmV0eSBjaGVjaycpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0dDfEl0ZW19IHN0cnVjdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZFN0cnVjdCA9IChzdG9yZSwgc3RydWN0KSA9PiB7XG4gIGxldCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudClcbiAgaWYgKHN0cnVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0cnVjdHMgPSBbXVxuICAgIHN0b3JlLmNsaWVudHMuc2V0KHN0cnVjdC5pZC5jbGllbnQsIHN0cnVjdHMpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXVxuICAgIGlmIChsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGggIT09IHN0cnVjdC5pZC5jbG9jaykge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgfVxuICBzdHJ1Y3RzLnB1c2goc3RydWN0KVxufVxuXG4vKipcbiAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhTUyA9IChzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gc3RydWN0cy5sZW5ndGggLSAxXG4gIGxldCBtaWQgPSBzdHJ1Y3RzW3JpZ2h0XVxuICBsZXQgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2tcbiAgaWYgKG1pZGNsb2NrID09PSBjbG9jaykge1xuICAgIHJldHVybiByaWdodFxuICB9XG4gIC8vIEB0b2RvIGRvZXMgaXQgZXZlbiBtYWtlIHNlbnNlIHRvIHBpdm90IHRoZSBzZWFyY2g/XG4gIC8vIElmIGEgZ29vZCBzcGxpdCBtaXNzZXMsIGl0IG1pZ2h0IGFjdHVhbGx5IGluY3JlYXNlIHRoZSB0aW1lIHRvIGZpbmQgdGhlIGNvcnJlY3QgaXRlbS5cbiAgLy8gQ3VycmVudGx5LCB0aGUgb25seSBhZHZhbnRhZ2UgaXMgdGhhdCBzZWFyY2ggd2l0aCBwaXZvdGluZyBtaWdodCBmaW5kIHRoZSBpdGVtIG9uIHRoZSBmaXJzdCB0cnkuXG4gIGxldCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGNsb2NrIC8gKG1pZGNsb2NrICsgbWlkLmxlbmd0aCAtIDEpKSAqIHJpZ2h0KSAvLyBwaXZvdGluZyB0aGUgc2VhcmNoXG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgbWlkID0gc3RydWN0c1ttaWRpbmRleF1cbiAgICBtaWRjbG9jayA9IG1pZC5pZC5jbG9ja1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMVxuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMVxuICAgIH1cbiAgICBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKVxuICB9XG4gIC8vIEFsd2F5cyBjaGVjayBzdGF0ZSBiZWZvcmUgbG9va2luZyBmb3IgYSBzdHJ1Y3QgaW4gU3RydWN0U3RvcmVcbiAgLy8gVGhlcmVmb3JlIHRoZSBjYXNlIG9mIG5vdCBmaW5kaW5nIGEgc3RydWN0IGlzIHVuZXhwZWN0ZWRcbiAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxufVxuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtHQ3xJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmQgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpXG4gIHJldHVybiBzdHJ1Y3RzW2ZpbmRJbmRleFNTKHN0cnVjdHMsIGlkLmNsb2NrKV1cbn1cblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0SXRlbSA9IC8qKiBAdHlwZSB7ZnVuY3Rpb24oU3RydWN0U3RvcmUsSUQpOkl0ZW19ICovIChmaW5kKVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRJbmRleENsZWFuU3RhcnQgPSAodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spXG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdXG4gIGlmIChzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jayAmJiBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKVxuICAgIHJldHVybiBpbmRleCArIDFcbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJdGVtQ2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgaWQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8SXRlbT59ICovICh0cmFuc2FjdGlvbi5kb2Muc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KSlcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgaWQuY2xvY2spXVxufVxuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRJdGVtQ2xlYW5FbmQgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KVxuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGlkLmNsb2NrKVxuICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XVxuICBpZiAoaWQuY2xvY2sgIT09IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGggLSAxICYmIHN0cnVjdC5jb25zdHJ1Y3RvciAhPT0gR0MpIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpZC5jbG9jayAtIHN0cnVjdC5pZC5jbG9jayArIDEpKVxuICB9XG4gIHJldHVybiBzdHJ1Y3Rcbn1cblxuLyoqXG4gKiBSZXBsYWNlIGBpdGVtYCB3aXRoIGBuZXdpdGVtYCBpbiBzdG9yZVxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKiBAcGFyYW0ge0dDfEl0ZW19IG5ld1N0cnVjdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGxhY2VTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCwgbmV3U3RydWN0KSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudCkpXG4gIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgc3RydWN0LmlkLmNsb2NrKV0gPSBuZXdTdHJ1Y3Rcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiBzdHJ1Y3RzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1N0YXJ0IEluY2x1c2l2ZSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHBhcmFtIHtmdW5jdGlvbihHQ3xJdGVtKTp2b2lkfSBmXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCwgbGVuLCBmKSA9PiB7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrU3RhcnQgKyBsZW5cbiAgbGV0IGluZGV4ID0gZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydClcbiAgbGV0IHN0cnVjdFxuICBkbyB7XG4gICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXVxuICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgIGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrRW5kKVxuICAgIH1cbiAgICBmKHN0cnVjdClcbiAgfSB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3RzW2luZGV4XS5pZC5jbG9jayA8IGNsb2NrRW5kKVxufVxuIiwgImltcG9ydCB7XG4gIGdldFN0YXRlLFxuICB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24sXG4gIHdyaXRlRGVsZXRlU2V0LFxuICBEZWxldGVTZXQsXG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldCxcbiAgZ2V0U3RhdGVWZWN0b3IsXG4gIGZpbmRJbmRleFNTLFxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzLFxuICBJdGVtLFxuICBnZW5lcmF0ZU5ld0NsaWVudElkLFxuICBjcmVhdGVJRCxcbiAgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbixcbiAgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIEdDLCBTdHJ1Y3RTdG9yZSwgQWJzdHJhY3RUeXBlLCBBYnN0cmFjdFN0cnVjdCwgWUV2ZW50LCBEb2MgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICdsaWIwL2xvZ2dpbmcnXG5pbXBvcnQgeyBjYWxsQWxsIH0gZnJvbSAnbGliMC9mdW5jdGlvbidcblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICogdG8gYnVuZGxlIGNoYW5nZXMgb24gdGhlIFlqcyBtb2RlbCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0b1xuICogbWluaW1pemUgdGhlIG51bWJlciBvbiBtZXNzYWdlcyBzZW50IGFuZCB0aGUgbnVtYmVyIG9mIG9ic2VydmVyIGNhbGxzLlxuICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gKiBwb3NzaWJsZS4gSGVyZSBpcyBhbiBleGFtcGxlIHRvIGlsbHVzdHJhdGUgdGhlIGFkdmFudGFnZXMgb2YgYnVuZGxpbmc6XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoKVxuICogY29uc3QgbWFwID0geWRvYy5nZXRNYXAoJ21hcCcpXG4gKiAvLyBMb2cgY29udGVudCB3aGVuIGNoYW5nZSBpcyB0cmlnZ2VyZWRcbiAqIG1hcC5vYnNlcnZlKCgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ2NoYW5nZSB0cmlnZ2VyZWQnKVxuICogfSlcbiAqIC8vIEVhY2ggY2hhbmdlIG9uIHRoZSBtYXAgdHlwZSB0cmlnZ2VycyBhIGxvZyBtZXNzYWdlOlxuICogbWFwLnNldCgnYScsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiBtYXAuc2V0KCdiJywgMCkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqIC8vIFdoZW4gcHV0IGluIGEgdHJhbnNhY3Rpb24sIGl0IHdpbGwgdHJpZ2dlciB0aGUgbG9nIGFmdGVyIHRoZSB0cmFuc2FjdGlvbjpcbiAqIHlkb2MudHJhbnNhY3QoKCkgPT4ge1xuICogICBtYXAuc2V0KCdhJywgMSlcbiAqICAgbWFwLnNldCgnYicsIDEpXG4gKiB9KSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBvcmlnaW4sIGxvY2FsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFlqcyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHRoZSBzZXQgb2YgZGVsZXRlZCBpdGVtcyBieSBpZHNcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlU2V0ID0gbmV3IERlbGV0ZVNldCgpXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gc3RhcnRlZC5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYmVmb3JlU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJTdGF0ZSA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEFsbCB0eXBlcyB0aGF0IHdlcmUgZGlyZWN0bHkgbW9kaWZpZWQgKHByb3BlcnR5IGFkZGVkIG9yIGNoaWxkXG4gICAgICogaW5zZXJ0ZWQvZGVsZXRlZCkuIE5ldyB0eXBlcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgU2V0LlxuICAgICAqIE1hcHMgZnJvbSB0eXBlIHRvIHBhcmVudFN1YnMgKGBpdGVtLnBhcmVudFN1YiA9IG51bGxgIGZvciBZQXJyYXkpXG4gICAgICogQHR5cGUge01hcDxBYnN0cmFjdFR5cGU8WUV2ZW50PGFueT4+LFNldDxTdHJpbmd8bnVsbD4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgZXZlbnRzIGZvciB0aGUgdHlwZXMgdGhhdCBvYnNlcnZlIGFsc28gY2hpbGQgZWxlbWVudHMuXG4gICAgICogSXQgaXMgbWFpbmx5IHVzZWQgYnkgYG9ic2VydmVEZWVwYC5cbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4sQXJyYXk8WUV2ZW50PGFueT4+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWRQYXJlbnRUeXBlcyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59XG4gICAgICovXG4gICAgdGhpcy5fbWVyZ2VTdHJ1Y3RzID0gW11cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG4gICAgLyoqXG4gICAgICogU3RvcmVzIG1ldGEgaW5mb3JtYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHR5cGUge01hcDxhbnksYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIG9yaWdpbmF0ZXMgZnJvbSB0aGlzIGRvYy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsID0gbG9jYWxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzQWRkZWQgPSBuZXcgU2V0KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzUmVtb3ZlZCA9IG5ldyBTZXQoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NMb2FkZWQgPSBuZXcgU2V0KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9uZWVkRm9ybWF0dGluZ0NsZWFudXAgPSBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGRhdGEgd2FzIHdyaXR0ZW4uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHtcbiAgaWYgKHRyYW5zYWN0aW9uLmRlbGV0ZVNldC5jbGllbnRzLnNpemUgPT09IDAgJiYgIW1hcC5hbnkodHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZSwgKGNsb2NrLCBjbGllbnQpID0+IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpICE9PSBjbG9jaykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0KVxuICB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pXG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldClcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IG5leHRJRCA9IHRyYW5zYWN0aW9uID0+IHtcbiAgY29uc3QgeSA9IHRyYW5zYWN0aW9uLmRvY1xuICByZXR1cm4gY3JlYXRlSUQoeS5jbGllbnRJRCwgZ2V0U3RhdGUoeS5zdG9yZSwgeS5jbGllbnRJRCkpXG59XG5cbi8qKlxuICogSWYgYHR5cGUucGFyZW50YCB3YXMgYWRkZWQgaW4gY3VycmVudCB0cmFuc2FjdGlvbiwgYHR5cGVgIHRlY2huaWNhbGx5XG4gKiBkaWQgbm90IGNoYW5nZSwgaXQgd2FzIGp1c3QgYWRkZWQgYW5kIHdlIHNob3VsZCBub3QgZmlyZSBldmVudHMgZm9yIGB0eXBlYC5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8WUV2ZW50PGFueT4+fSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBwYXJlbnRTdWJcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbiwgdHlwZSwgcGFyZW50U3ViKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSB0eXBlLl9pdGVtXG4gIGlmIChpdGVtID09PSBudWxsIHx8IChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkgJiYgIWl0ZW0uZGVsZXRlZCkpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodHJhbnNhY3Rpb24uY2hhbmdlZCwgdHlwZSwgc2V0LmNyZWF0ZSkuYWRkKHBhcmVudFN1YilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICMgb2YgbWVyZ2VkIHN0cnVjdHNcbiAqL1xuY29uc3QgdHJ5VG9NZXJnZVdpdGhMZWZ0cyA9IChzdHJ1Y3RzLCBwb3MpID0+IHtcbiAgbGV0IHJpZ2h0ID0gc3RydWN0c1twb3NdXG4gIGxldCBsZWZ0ID0gc3RydWN0c1twb3MgLSAxXVxuICBsZXQgaSA9IHBvc1xuICBmb3IgKDsgaSA+IDA7IHJpZ2h0ID0gbGVmdCwgbGVmdCA9IHN0cnVjdHNbLS1pIC0gMV0pIHtcbiAgICBpZiAobGVmdC5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmIGxlZnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAobGVmdC5tZXJnZVdpdGgocmlnaHQpKSB7XG4gICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEl0ZW0gJiYgcmlnaHQucGFyZW50U3ViICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuZ2V0KHJpZ2h0LnBhcmVudFN1YikgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5zZXQocmlnaHQucGFyZW50U3ViLCAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KSlcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cbiAgICBicmVha1xuICB9XG4gIGNvbnN0IG1lcmdlZCA9IHBvcyAtIGlcbiAgaWYgKG1lcmdlZCkge1xuICAgIC8vIHJlbW92ZSBhbGwgbWVyZ2VkIHN0cnVjdHMgZnJvbSB0aGUgYXJyYXlcbiAgICBzdHJ1Y3RzLnNwbGljZShwb3MgKyAxIC0gbWVyZ2VkLCBtZXJnZWQpXG4gIH1cbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gZ2NGaWx0ZXJcbiAqL1xuY29uc3QgdHJ5R2NEZWxldGVTZXQgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zXSBvZiBkcy5jbGllbnRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSlcbiAgICBmb3IgKGxldCBkaSA9IGRlbGV0ZUl0ZW1zLmxlbmd0aCAtIDE7IGRpID49IDA7IGRpLS0pIHtcbiAgICAgIGNvbnN0IGRlbGV0ZUl0ZW0gPSBkZWxldGVJdGVtc1tkaV1cbiAgICAgIGNvbnN0IGVuZERlbGV0ZUl0ZW1DbG9jayA9IGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlblxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayksIHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBzaSA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdC5pZC5jbG9jayA8IGVuZERlbGV0ZUl0ZW1DbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1srK3NpXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbc2ldXG4gICAgICAgIGlmIChkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gPD0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJiBzdHJ1Y3QuZGVsZXRlZCAmJiAhc3RydWN0LmtlZXAgJiYgZ2NGaWx0ZXIoc3RydWN0KSkge1xuICAgICAgICAgIHN0cnVjdC5nYyhzdG9yZSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKi9cbmNvbnN0IHRyeU1lcmdlRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSkgPT4ge1xuICAvLyB0cnkgdG8gbWVyZ2UgZGVsZXRlZCAvIGdjJ2QgaXRlbXNcbiAgLy8gbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0IGZvciBiZXR0ZXIgZWZmaWNpZW5jeSBhbmQgc28gd2UgZG9uJ3QgbWlzcyBhbnkgbWVyZ2UgdGFyZ2V0c1xuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZUl0ZW1zLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldXG4gICAgICAvLyBzdGFydCB3aXRoIG1lcmdpbmcgdGhlIGl0ZW0gbmV4dCB0byB0aGUgbGFzdCBkZWxldGVkIGl0ZW1cbiAgICAgIGNvbnN0IG1vc3RSaWdodEluZGV4VG9DaGVjayA9IG1hdGgubWluKHN0cnVjdHMubGVuZ3RoIC0gMSwgMSArIGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiAtIDEpKVxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gbW9zdFJpZ2h0SW5kZXhUb0NoZWNrLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPiAwICYmIHN0cnVjdC5pZC5jbG9jayA+PSBkZWxldGVJdGVtLmNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXVxuICAgICAgKSB7XG4gICAgICAgIHNpIC09IDEgKyB0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIHNpKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmV4cG9ydCBjb25zdCB0cnlHYyA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIHRyeUdjRGVsZXRlU2V0KGRzLCBzdG9yZSwgZ2NGaWx0ZXIpXG4gIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uPn0gdHJhbnNhY3Rpb25DbGVhbnVwc1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuY29uc3QgY2xlYW51cFRyYW5zYWN0aW9ucyA9ICh0cmFuc2FjdGlvbkNsZWFudXBzLCBpKSA9PiB7XG4gIGlmIChpIDwgdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGgpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uQ2xlYW51cHNbaV1cbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZVxuICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0XG4gICAgY29uc3QgbWVyZ2VTdHJ1Y3RzID0gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0c1xuICAgIHRyeSB7XG4gICAgICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQoZHMpXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlID0gZ2V0U3RhdGVWZWN0b3IodHJhbnNhY3Rpb24uZG9jLnN0b3JlKVxuICAgICAgZG9jLmVtaXQoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBbdHJhbnNhY3Rpb24sIGRvY10pXG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAqXG4gICAgICAgKiBFYWNoIGNhbGxiYWNrIGlzIGNhbGxlZCBldmVuIGlmIHRoZSBvdGhlciBvbmVzIHRocm93IGVycm9ycy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZnMgPSBbXVxuICAgICAgLy8gb2JzZXJ2ZSBldmVudHMgb24gY2hhbmdlZCB0eXBlc1xuICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKChzdWJzLCBpdGVtdHlwZSkgPT5cbiAgICAgICAgZnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW10eXBlLl9pdGVtID09PSBudWxsIHx8ICFpdGVtdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICBpdGVtdHlwZS5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBzdWJzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyBkZWVwIG9ic2VydmUgZXZlbnRzXG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKChldmVudHMsIHR5cGUpID0+IHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRoaW5rIGFib3V0IHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSB1c2VyIHRyYW5zZm9ybXMgdGhlXG4gICAgICAgICAgLy8gWS5Eb2MgaW4gdGhlIGV2ZW50LlxuICAgICAgICAgIGlmICh0eXBlLl9kRUgubC5sZW5ndGggPiAwICYmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHNcbiAgICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5faXRlbSA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0Ll9pdGVtLmRlbGV0ZWRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgIC5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdHlwZVxuICAgICAgICAgICAgICAgIC8vIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgZXZlbnQuX3BhdGggPSBudWxsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAvLyBzb3J0IGV2ZW50cyBieSBwYXRoIGxlbmd0aCBzbyB0aGF0IHRvcC1sZXZlbCBldmVudHMgYXJlIGZpcmVkIGZpcnN0LlxuICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgIC5zb3J0KChldmVudDEsIGV2ZW50MikgPT4gZXZlbnQxLnBhdGgubGVuZ3RoIC0gZXZlbnQyLnBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZXZlbnRzLmxlbmd0aFxuICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBrbm93IGl0IGhhcyBhdCBsZWFzdCBvbmUgZWxlbWVudFxuICAgICAgICAgICAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyh0eXBlLl9kRUgsIGV2ZW50cywgdHJhbnNhY3Rpb24pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGZzLnB1c2goKCkgPT4gZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb24nLCBbdHJhbnNhY3Rpb24sIGRvY10pKVxuICAgICAgY2FsbEFsbChmcywgW10pXG4gICAgICBpZiAodHJhbnNhY3Rpb24uX25lZWRGb3JtYXR0aW5nQ2xlYW51cCkge1xuICAgICAgICBjbGVhbnVwWVRleHRBZnRlclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXBsYWNlIGRlbGV0ZWQgaXRlbXMgd2l0aCBJdGVtRGVsZXRlZCAvIEdDLlxuICAgICAgLy8gVGhpcyBpcyB3aGVyZSBjb250ZW50IGlzIGFjdHVhbGx5IHJlbW92ZSBmcm9tIHRoZSBZanMgRG9jLlxuICAgICAgaWYgKGRvYy5nYykge1xuICAgICAgICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGRvYy5nY0ZpbHRlcilcbiAgICAgIH1cbiAgICAgIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSlcblxuICAgICAgLy8gb24gYWxsIGFmZmVjdGVkIHN0b3JlLmNsaWVudHMgcHJvcHMsIHRyeSB0byBtZXJnZVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGJlZm9yZUNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMFxuICAgICAgICBpZiAoYmVmb3JlQ2xvY2sgIT09IGNsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKVxuICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgZnJvbSByaWdodCB0byBsZWZ0IHNvIHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGVudHJpZXNcbiAgICAgICAgICBjb25zdCBmaXJzdENoYW5nZVBvcyA9IG1hdGgubWF4KGZpbmRJbmRleFNTKHN0cnVjdHMsIGJlZm9yZUNsb2NrKSwgMSlcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RydWN0cy5sZW5ndGggLSAxOyBpID49IGZpcnN0Q2hhbmdlUG9zOykge1xuICAgICAgICAgICAgaSAtPSAxICsgdHJ5VG9NZXJnZVdpdGhMZWZ0cyhzdHJ1Y3RzLCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC8vIHRyeSB0byBtZXJnZSBtZXJnZVN0cnVjdHNcbiAgICAgIC8vIEB0b2RvOiBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHRyYW5zZm9ybSBtZXJnZVN0cnVjdHMgdG8gYSBEUywgc29ydCBpdCwgYW5kIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgLy8gICAgICAgIGJ1dCBhdCB0aGUgbW9tZW50IERTIGRvZXMgbm90IGhhbmRsZSBkdXBsaWNhdGVzXG4gICAgICBmb3IgKGxldCBpID0gbWVyZ2VTdHJ1Y3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbWVyZ2VTdHJ1Y3RzW2ldLmlkXG4gICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSlcbiAgICAgICAgY29uc3QgcmVwbGFjZWRTdHJ1Y3RQb3MgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MgKyAxKSA+IDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlIC8vIG5vIG5lZWQgdG8gcGVyZm9ybSBuZXh0IGNoZWNrLCBib3RoIGFyZSBhbHJlYWR5IG1lcmdlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwbGFjZWRTdHJ1Y3RQb3MgPiAwKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0cyhzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCAmJiB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmdldChkb2MuY2xpZW50SUQpICE9PSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSkge1xuICAgICAgICBsb2dnaW5nLnByaW50KGxvZ2dpbmcuT1JBTkdFLCBsb2dnaW5nLkJPTEQsICdbeWpzXSAnLCBsb2dnaW5nLlVOQk9MRCwgbG9nZ2luZy5SRUQsICdDaGFuZ2VkIHRoZSBjbGllbnQtaWQgYmVjYXVzZSBhbm90aGVyIGNsaWVudCBzZWVtcyB0byBiZSB1c2luZyBpdC4nKVxuICAgICAgICBkb2MuY2xpZW50SUQgPSBnZW5lcmF0ZU5ld0NsaWVudElkKClcbiAgICAgIH1cbiAgICAgIC8vIEB0b2RvIE1lcmdlIGFsbCB0aGUgdHJhbnNhY3Rpb25zIGludG8gb25lIGFuZCBwcm92aWRlIHNlbmQgdGhlIGRhdGEgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2VcbiAgICAgIGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uQ2xlYW51cCcsIFt0cmFuc2FjdGlvbiwgZG9jXSlcbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZScpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYxKClcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbilcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZVYyJykpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKVxuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKVxuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGVWMicsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB7IHN1YmRvY3NBZGRlZCwgc3ViZG9jc0xvYWRlZCwgc3ViZG9jc1JlbW92ZWQgfSA9IHRyYW5zYWN0aW9uXG4gICAgICBpZiAoc3ViZG9jc0FkZGVkLnNpemUgPiAwIHx8IHN1YmRvY3NSZW1vdmVkLnNpemUgPiAwIHx8IHN1YmRvY3NMb2FkZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgc3ViZG9jc0FkZGVkLmZvckVhY2goc3ViZG9jID0+IHtcbiAgICAgICAgICBzdWJkb2MuY2xpZW50SUQgPSBkb2MuY2xpZW50SURcbiAgICAgICAgICBpZiAoc3ViZG9jLmNvbGxlY3Rpb25pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJkb2MuY29sbGVjdGlvbmlkID0gZG9jLmNvbGxlY3Rpb25pZFxuICAgICAgICAgIH1cbiAgICAgICAgICBkb2Muc3ViZG9jcy5hZGQoc3ViZG9jKVxuICAgICAgICB9KVxuICAgICAgICBzdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBkb2Muc3ViZG9jcy5kZWxldGUoc3ViZG9jKSlcbiAgICAgICAgZG9jLmVtaXQoJ3N1YmRvY3MnLCBbeyBsb2FkZWQ6IHN1YmRvY3NMb2FkZWQsIGFkZGVkOiBzdWJkb2NzQWRkZWQsIHJlbW92ZWQ6IHN1YmRvY3NSZW1vdmVkIH0sIGRvYywgdHJhbnNhY3Rpb25dKVxuICAgICAgICBzdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKVxuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPD0gaSArIDEpIHtcbiAgICAgICAgZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW11cbiAgICAgICAgZG9jLmVtaXQoJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgW2RvYywgdHJhbnNhY3Rpb25DbGVhbnVwc10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkgKyAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYHkudHJhbnNhY3QoKCk9PnsuLn0pYFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpUfSBmXG4gKiBAcGFyYW0ge2FueX0gW29yaWdpbj10cnVlXVxuICogQHJldHVybiB7VH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zYWN0ID0gKGRvYywgZiwgb3JpZ2luID0gbnVsbCwgbG9jYWwgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uQ2xlYW51cHMgPSBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHNcbiAgbGV0IGluaXRpYWxDYWxsID0gZmFsc2VcbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgcmVzdWx0ID0gbnVsbFxuICBpZiAoZG9jLl90cmFuc2FjdGlvbiA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxDYWxsID0gdHJ1ZVxuICAgIGRvYy5fdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oZG9jLCBvcmlnaW4sIGxvY2FsKVxuICAgIHRyYW5zYWN0aW9uQ2xlYW51cHMucHVzaChkb2MuX3RyYW5zYWN0aW9uKVxuICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIFtkb2NdKVxuICAgIH1cbiAgICBkb2MuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCBbZG9jLl90cmFuc2FjdGlvbiwgZG9jXSlcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IGYoZG9jLl90cmFuc2FjdGlvbilcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgIGNvbnN0IGZpbmlzaENsZWFudXAgPSBkb2MuX3RyYW5zYWN0aW9uID09PSB0cmFuc2FjdGlvbkNsZWFudXBzWzBdXG4gICAgICBkb2MuX3RyYW5zYWN0aW9uID0gbnVsbFxuICAgICAgaWYgKGZpbmlzaENsZWFudXApIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRyYW5zYWN0aW9uIGVuZGVkLCBub3cgcHJvY2VzcyBvYnNlcnZlciBjYWxscy5cbiAgICAgICAgLy8gT2JzZXJ2ZXIgY2FsbCBtYXkgY3JlYXRlIG5ldyB0cmFuc2FjdGlvbnMgZm9yIHdoaWNoIHdlIG5lZWQgdG8gY2FsbCB0aGUgb2JzZXJ2ZXJzIGFuZCBkbyBjbGVhbnVwLlxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIG5lc3QgdGhlc2UgY2FsbHMsIHNvIHdlIGV4ZWN1dGUgdGhlc2UgY2FsbHMgb25lIGFmdGVyXG4gICAgICAgIC8vIGFub3RoZXIuXG4gICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgY2xlYW51cHMgYXJlIGNhbGxlZCwgZXZlbiBpZiB0aGVcbiAgICAgICAgLy8gb2JzZXJ2ZXMgdGhyb3cgZXJyb3JzLlxuICAgICAgICAvLyBUaGlzIGZpbGUgaXMgZnVsbCBvZiBoYWNreSB0cnkge30gZmluYWxseSB7fSBibG9ja3MgdG8gZW5zdXJlIHRoYXQgYW5cbiAgICAgICAgLy8gZXZlbnQgY2FuIHRocm93IGVycm9ycyBhbmQgYWxzbyB0aGF0IHRoZSBjbGVhbnVwIGlzIGNhbGxlZC5cbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCAiaW1wb3J0IHtcbiAgbWVyZ2VEZWxldGVTZXRzLFxuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHMsXG4gIGtlZXBJdGVtLFxuICB0cmFuc2FjdCxcbiAgY3JlYXRlSUQsXG4gIHJlZG9JdGVtLFxuICBpc1BhcmVudE9mLFxuICBmb2xsb3dSZWRvbmUsXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICBpc0RlbGV0ZWQsXG4gIGFkZFRvRGVsZXRlU2V0LFxuICBZRXZlbnQsIFRyYW5zYWN0aW9uLCBEb2MsIEl0ZW0sIEdDLCBEZWxldGVTZXQsIEFic3RyYWN0VHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tICdsaWIwL2xvZ2dpbmcnXG5pbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbmV4cG9ydCBjbGFzcyBTdGFja0l0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRlbGV0aW9uc1xuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gaW5zZXJ0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlbGV0aW9ucywgaW5zZXJ0aW9ucykge1xuICAgIHRoaXMuaW5zZXJ0aW9ucyA9IGluc2VydGlvbnNcbiAgICB0aGlzLmRlbGV0aW9ucyA9IGRlbGV0aW9uc1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIHNhdmUgYW5kIHJlc3RvcmUgbWV0YWRhdGEgbGlrZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW1cbiAqIEBwYXJhbSB7U3RhY2tJdGVtfSBzdGFja0l0ZW1cbiAqL1xuY29uc3QgY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSA9ICh0ciwgdW0sIHN0YWNrSXRlbSkgPT4ge1xuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHIsIHN0YWNrSXRlbS5kZWxldGlvbnMsIGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB1bS5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHsndW5kbyd8J3JlZG8nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge1N0YWNrSXRlbT99XG4gKi9cbmNvbnN0IHBvcFN0YWNrSXRlbSA9ICh1bmRvTWFuYWdlciwgc3RhY2ssIGV2ZW50VHlwZSkgPT4ge1xuICAvKipcbiAgICogS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdHJhbnNhY3Rpb24gc28gd2UgY2FuIGZpcmUgdGhlIGV2ZW50IHdpdGggdGhlIGNoYW5nZWRQYXJlbnRUeXBlc1xuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IF90ciA9IG51bGxcbiAgY29uc3QgZG9jID0gdW5kb01hbmFnZXIuZG9jXG4gIGNvbnN0IHNjb3BlID0gdW5kb01hbmFnZXIuc2NvcGVcbiAgdHJhbnNhY3QoZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgdW5kb01hbmFnZXIuY3VyclN0YWNrSXRlbSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgICAgIGNvbnN0IHN0YWNrSXRlbSA9IC8qKiBAdHlwZSB7U3RhY2tJdGVtfSAqLyAoc3RhY2sucG9wKCkpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9SZWRvID0gbmV3IFNldCgpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb0RlbGV0ZSA9IFtdXG4gICAgICBsZXQgcGVyZm9ybWVkQ2hhbmdlID0gZmFsc2VcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB7IGl0ZW0sIGRpZmYgfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgc3RydWN0LmlkKVxuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2sgKyBkaWZmKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cnVjdCA9IGl0ZW1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCAvKiogQHR5cGUge0l0ZW19ICovIChzdHJ1Y3QpKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJlxuICAgICAgICAgIHNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIHN0cnVjdCkpICYmXG4gICAgICAgICAgLy8gTmV2ZXIgcmVkbyBzdHJ1Y3RzIGluIHN0YWNrSXRlbS5pbnNlcnRpb25zIGJlY2F1c2UgdGhleSB3ZXJlIGNyZWF0ZWQgYW5kIGRlbGV0ZWQgaW4gdGhlIHNhbWUgY2FwdHVyZSBpbnRlcnZhbC5cbiAgICAgICAgICAhaXNEZWxldGVkKHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QuaWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGl0ZW1zVG9SZWRvLmFkZChzdHJ1Y3QpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpdGVtc1RvUmVkby5mb3JFYWNoKHN0cnVjdCA9PiB7XG4gICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGl0ZW1zVG9SZWRvLCBzdGFja0l0ZW0uaW5zZXJ0aW9ucywgdW5kb01hbmFnZXIuaWdub3JlUmVtb3RlTWFwQ2hhbmdlcywgdW5kb01hbmFnZXIpICE9PSBudWxsIHx8IHBlcmZvcm1lZENoYW5nZVxuICAgICAgfSlcbiAgICAgIC8vIFdlIHdhbnQgdG8gZGVsZXRlIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBjaGlsZHJlbiBhcmUgZGVsZXRlZCBiZWZvcmVcbiAgICAgIC8vIHBhcmVudHMsIHNvIHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiBhdmFpbGFibGUgd2hlbiBpdGVtcyBhcmUgZmlsdGVyZWQuXG4gICAgICBmb3IgKGxldCBpID0gaXRlbXNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNUb0RlbGV0ZVtpXVxuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGVsZXRlRmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1bmRvTWFuYWdlci5jdXJyU3RhY2tJdGVtID0gcGVyZm9ybWVkQ2hhbmdlID8gc3RhY2tJdGVtIDogbnVsbFxuICAgIH1cbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YlByb3BzLCB0eXBlKSA9PiB7XG4gICAgICAvLyBkZXN0cm95IHNlYXJjaCBtYXJrZXIgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3ViUHJvcHMuaGFzKG51bGwpICYmIHR5cGUuX3NlYXJjaE1hcmtlcikge1xuICAgICAgICB0eXBlLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMFxuICAgICAgfVxuICAgIH0pXG4gICAgX3RyID0gdHJhbnNhY3Rpb25cbiAgfSwgdW5kb01hbmFnZXIpXG4gIGNvbnN0IHJlcyA9IHVuZG9NYW5hZ2VyLmN1cnJTdGFja0l0ZW1cbiAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gX3RyLmNoYW5nZWRQYXJlbnRUeXBlc1xuICAgIHVuZG9NYW5hZ2VyLmVtaXQoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgW3sgc3RhY2tJdGVtOiByZXMsIHR5cGU6IGV2ZW50VHlwZSwgY2hhbmdlZFBhcmVudFR5cGVzLCBvcmlnaW46IHVuZG9NYW5hZ2VyIH0sIHVuZG9NYW5hZ2VyXSlcbiAgICB1bmRvTWFuYWdlci5jdXJyU3RhY2tJdGVtID0gbnVsbFxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmRvTWFuYWdlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUaW1lb3V0PTUwMF1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOmJvb2xlYW59IFtVbmRvTWFuYWdlck9wdGlvbnMuY2FwdHVyZVRyYW5zYWN0aW9uXSBEbyBub3QgY2FwdHVyZSBjaGFuZ2VzIG9mIGEgVHJhbnNhY3Rpb24gaWYgcmVzdWx0IGZhbHNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmRlbGV0ZUZpbHRlcj0oKT0+dHJ1ZV0gU29tZXRpbWVzXG4gKiBpdCBpcyBuZWNlc3NhcnkgdG8gZmlsdGVyIHdoYXQgYW4gVW5kby9SZWRvIG9wZXJhdGlvbiBjYW4gZGVsZXRlLiBJZiB0aGlzXG4gKiBmaWx0ZXIgcmV0dXJucyBmYWxzZSwgdGhlIHR5cGUvaXRlbSB3b24ndCBiZSBkZWxldGVkIGV2ZW4gaXQgaXMgaW4gdGhlXG4gKiB1bmRvL3JlZG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge1NldDxhbnk+fSBbVW5kb01hbmFnZXJPcHRpb25zLnRyYWNrZWRPcmlnaW5zPW5ldyBTZXQoW251bGxdKV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZVJlbW90ZU1hcENoYW5nZXNdIEV4cGVyaW1lbnRhbC4gQnkgZGVmYXVsdCwgdGhlIFVuZG9NYW5hZ2VyIHdpbGwgbmV2ZXIgb3ZlcndyaXRlIHJlbW90ZSBjaGFuZ2VzLiBFbmFibGUgdGhpcyBwcm9wZXJ0eSB0byBlbmFibGUgb3ZlcndyaXRpbmcgcmVtb3RlIGNoYW5nZXMgb24ga2V5LXZhbHVlIGNoYW5nZXMgKFkuTWFwLCBwcm9wZXJ0aWVzIG9uIFkuWG1sLCBldGMuLikuXG4gKiBAcHJvcGVydHkge0RvY30gW2RvY10gVGhlIGRvY3VtZW50IHRoYXQgdGhpcyBVbmRvTWFuYWdlciBvcGVyYXRlcyBvbi4gT25seSBuZWVkZWQgaWYgdHlwZVNjb3BlIGlzIGVtcHR5LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhY2tJdGVtRXZlbnRcbiAqIEBwcm9wZXJ0eSB7U3RhY2tJdGVtfSBTdGFja0l0ZW1FdmVudC5zdGFja0l0ZW1cbiAqIEBwcm9wZXJ0eSB7YW55fSBTdGFja0l0ZW1FdmVudC5vcmlnaW5cbiAqIEBwcm9wZXJ0eSB7J3VuZG8nfCdyZWRvJ30gU3RhY2tJdGVtRXZlbnQudHlwZVxuICogQHByb3BlcnR5IHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixBcnJheTxZRXZlbnQ8YW55Pj4+fSBTdGFja0l0ZW1FdmVudC5jaGFuZ2VkUGFyZW50VHlwZXNcbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlVjI8eydzdGFjay1pdGVtLWFkZGVkJzpmdW5jdGlvbihTdGFja0l0ZW1FdmVudCwgVW5kb01hbmFnZXIpOnZvaWQsICdzdGFjay1pdGVtLXBvcHBlZCc6IGZ1bmN0aW9uKFN0YWNrSXRlbUV2ZW50LCBVbmRvTWFuYWdlcik6dm9pZCwgJ3N0YWNrLWNsZWFyZWQnOiBmdW5jdGlvbih7IHVuZG9TdGFja0NsZWFyZWQ6IGJvb2xlYW4sIHJlZG9TdGFja0NsZWFyZWQ6IGJvb2xlYW4gfSk6dm9pZCwgJ3N0YWNrLWl0ZW0tdXBkYXRlZCc6IGZ1bmN0aW9uKFN0YWNrSXRlbUV2ZW50LCBVbmRvTWFuYWdlcik6dm9pZCB9Pn1cbiAqL1xuZXhwb3J0IGNsYXNzIFVuZG9NYW5hZ2VyIGV4dGVuZHMgT2JzZXJ2YWJsZVYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fSB0eXBlU2NvcGUgQWNjZXB0cyBlaXRoZXIgYSBzaW5nbGUgdHlwZSwgb3IgYW4gYXJyYXkgb2YgdHlwZXNcbiAgICogQHBhcmFtIHtVbmRvTWFuYWdlck9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlU2NvcGUsIHtcbiAgICBjYXB0dXJlVGltZW91dCA9IDUwMCxcbiAgICBjYXB0dXJlVHJhbnNhY3Rpb24gPSBfdHIgPT4gdHJ1ZSxcbiAgICBkZWxldGVGaWx0ZXIgPSAoKSA9PiB0cnVlLFxuICAgIHRyYWNrZWRPcmlnaW5zID0gbmV3IFNldChbbnVsbF0pLFxuICAgIGlnbm9yZVJlbW90ZU1hcENoYW5nZXMgPSBmYWxzZSxcbiAgICBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKGFycmF5LmlzQXJyYXkodHlwZVNjb3BlKSA/IHR5cGVTY29wZVswXS5kb2MgOiB0eXBlU2NvcGUuZG9jKVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFic3RyYWN0VHlwZTxhbnk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNjb3BlID0gW11cbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMuYWRkVG9TY29wZSh0eXBlU2NvcGUpXG4gICAgdGhpcy5kZWxldGVGaWx0ZXIgPSBkZWxldGVGaWx0ZXJcbiAgICB0cmFja2VkT3JpZ2lucy5hZGQodGhpcylcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zID0gdHJhY2tlZE9yaWdpbnNcbiAgICB0aGlzLmNhcHR1cmVUcmFuc2FjdGlvbiA9IGNhcHR1cmVUcmFuc2FjdGlvblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMudW5kb1N0YWNrID0gW11cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSB1bmRvaW5nIChjYWxsaW5nIFVuZG9NYW5hZ2VyLnVuZG8pXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZVxuICAgIHRoaXMucmVkb2luZyA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnRseSBwb3BwZWQgc3RhY2sgaXRlbSBpZiBVbmRvTWFuYWdlci51bmRvaW5nIG9yIFVuZG9NYW5hZ2VyLnJlZG9pbmdcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTdGFja0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJTdGFja0l0ZW0gPSBudWxsXG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMFxuICAgIHRoaXMuaWdub3JlUmVtb3RlTWFwQ2hhbmdlcyA9IGlnbm9yZVJlbW90ZU1hcENoYW5nZXNcbiAgICB0aGlzLmNhcHR1cmVUaW1lb3V0ID0gY2FwdHVyZVRpbWVvdXRcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIgPSB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvLyBPbmx5IHRyYWNrIGNlcnRhaW4gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmNhcHR1cmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikgfHxcbiAgICAgICAgIXRoaXMuc2NvcGUuc29tZSh0eXBlID0+IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5oYXModHlwZSkpIHx8XG4gICAgICAgICghdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luKSAmJiAoIXRyYW5zYWN0aW9uLm9yaWdpbiB8fCAhdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luLmNvbnN0cnVjdG9yKSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCB1bmRvaW5nID0gdGhpcy51bmRvaW5nXG4gICAgICBjb25zdCByZWRvaW5nID0gdGhpcy5yZWRvaW5nXG4gICAgICBjb25zdCBzdGFjayA9IHVuZG9pbmcgPyB0aGlzLnJlZG9TdGFjayA6IHRoaXMudW5kb1N0YWNrXG4gICAgICBpZiAodW5kb2luZykge1xuICAgICAgICB0aGlzLnN0b3BDYXB0dXJpbmcoKSAvLyBuZXh0IHVuZG8gc2hvdWxkIG5vdCBiZSBhcHBlbmRlZCB0byBsYXN0IHN0YWNrIGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gbmVpdGhlciB1bmRvaW5nIG5vciByZWRvaW5nOiBkZWxldGUgcmVkb1N0YWNrXG4gICAgICAgIHRoaXMuY2xlYXIoZmFsc2UsIHRydWUpXG4gICAgICB9XG4gICAgICBjb25zdCBpbnNlcnRpb25zID0gbmV3IERlbGV0ZVNldCgpXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGVuZENsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDBcbiAgICAgICAgY29uc3QgbGVuID0gZW5kQ2xvY2sgLSBzdGFydENsb2NrXG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgYWRkVG9EZWxldGVTZXQoaW5zZXJ0aW9ucywgY2xpZW50LCBzdGFydENsb2NrLCBsZW4pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGxldCBkaWRBZGQgPSBmYWxzZVxuICAgICAgaWYgKHRoaXMubGFzdENoYW5nZSA+IDAgJiYgbm93IC0gdGhpcy5sYXN0Q2hhbmdlIDwgdGhpcy5jYXB0dXJlVGltZW91dCAmJiBzdGFjay5sZW5ndGggPiAwICYmICF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIC8vIGFwcGVuZCBjaGFuZ2UgdG8gbGFzdCBzdGFjayBvcFxuICAgICAgICBjb25zdCBsYXN0T3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXVxuICAgICAgICBsYXN0T3AuZGVsZXRpb25zID0gbWVyZ2VEZWxldGVTZXRzKFtsYXN0T3AuZGVsZXRpb25zLCB0cmFuc2FjdGlvbi5kZWxldGVTZXRdKVxuICAgICAgICBsYXN0T3AuaW5zZXJ0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmluc2VydGlvbnMsIGluc2VydGlvbnNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0YWNrIG9wXG4gICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrSXRlbSh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGluc2VydGlvbnMpKVxuICAgICAgICBkaWRBZGQgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gbm93XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBkZWxldGVkIHN0cnVjdHMgYXJlIG5vdCBnYydkXG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgLyoqIEBwYXJhbSB7SXRlbXxHQ30gaXRlbSAqLyBpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIHRoaXMuc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICAgICAga2VlcEl0ZW0oaXRlbSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1tTdGFja0l0ZW1FdmVudCwgVW5kb01hbmFnZXJdfVxuICAgICAgICovXG4gICAgICBjb25zdCBjaGFuZ2VFdmVudCA9IFt7IHN0YWNrSXRlbTogc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIG9yaWdpbjogdHJhbnNhY3Rpb24ub3JpZ2luLCB0eXBlOiB1bmRvaW5nID8gJ3JlZG8nIDogJ3VuZG8nLCBjaGFuZ2VkUGFyZW50VHlwZXM6IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcyB9LCB0aGlzXVxuICAgICAgaWYgKGRpZEFkZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tYWRkZWQnLCBjaGFuZ2VFdmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS11cGRhdGVkJywgY2hhbmdlRXZlbnQpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcy5hZnRlclRyYW5zYWN0aW9uSGFuZGxlcilcbiAgICB0aGlzLmRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PEFic3RyYWN0VHlwZTxhbnk+PiB8IEFic3RyYWN0VHlwZTxhbnk+fSB5dHlwZXNcbiAgICovXG4gIGFkZFRvU2NvcGUgKHl0eXBlcykge1xuICAgIHl0eXBlcyA9IGFycmF5LmlzQXJyYXkoeXR5cGVzKSA/IHl0eXBlcyA6IFt5dHlwZXNdXG4gICAgeXR5cGVzLmZvckVhY2goeXR5cGUgPT4ge1xuICAgICAgaWYgKHRoaXMuc2NvcGUuZXZlcnkoeXQgPT4geXQgIT09IHl0eXBlKSkge1xuICAgICAgICBpZiAoeXR5cGUuZG9jICE9PSB0aGlzLmRvYykgbG9nZ2luZy53YXJuKCdbeWpzIzUwOV0gTm90IHNhbWUgWS5Eb2MnKSAvLyB1c2UgTXVsdGlEb2NVbmRvTWFuYWdlciBpbnN0ZWFkLiBhbHNvIHNlZSBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNTA5XG4gICAgICAgIHRoaXMuc2NvcGUucHVzaCh5dHlwZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICovXG4gIGFkZFRyYWNrZWRPcmlnaW4gKG9yaWdpbikge1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMuYWRkKG9yaWdpbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICByZW1vdmVUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmRlbGV0ZShvcmlnaW4pXG4gIH1cblxuICBjbGVhciAoY2xlYXJVbmRvU3RhY2sgPSB0cnVlLCBjbGVhclJlZG9TdGFjayA9IHRydWUpIHtcbiAgICBpZiAoKGNsZWFyVW5kb1N0YWNrICYmIHRoaXMuY2FuVW5kbygpKSB8fCAoY2xlYXJSZWRvU3RhY2sgJiYgdGhpcy5jYW5SZWRvKCkpKSB7XG4gICAgICB0aGlzLmRvYy50cmFuc2FjdCh0ciA9PiB7XG4gICAgICAgIGlmIChjbGVhclVuZG9TdGFjaykge1xuICAgICAgICAgIHRoaXMudW5kb1N0YWNrLmZvckVhY2goaXRlbSA9PiBjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtKHRyLCB0aGlzLCBpdGVtKSlcbiAgICAgICAgICB0aGlzLnVuZG9TdGFjayA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFyUmVkb1N0YWNrKSB7XG4gICAgICAgICAgdGhpcy5yZWRvU3RhY2suZm9yRWFjaChpdGVtID0+IGNsZWFyVW5kb01hbmFnZXJTdGFja0l0ZW0odHIsIHRoaXMsIGl0ZW0pKVxuICAgICAgICAgIHRoaXMucmVkb1N0YWNrID0gW11cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWNsZWFyZWQnLCBbeyB1bmRvU3RhY2tDbGVhcmVkOiBjbGVhclVuZG9TdGFjaywgcmVkb1N0YWNrQ2xlYXJlZDogY2xlYXJSZWRvU3RhY2sgfV0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvTWFuYWdlciBtZXJnZXMgVW5kby1TdGFja0l0ZW0gaWYgdGhleSBhcmUgY3JlYXRlZCB3aXRoaW4gdGltZS1nYXBcbiAgICogc21hbGxlciB0aGFuIGBvcHRpb25zLmNhcHR1cmVUaW1lb3V0YC4gQ2FsbCBgdW0uc3RvcENhcHR1cmluZygpYCBzbyB0aGF0IHRoZSBuZXh0XG4gICAqIFN0YWNrSXRlbSB3b24ndCBiZSBtZXJnZWQuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgICAvLyB3aXRob3V0IHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMSwgJ2InKVxuICAgKiAgICAgdW0udW5kbygpXG4gICAqICAgICB5dGV4dC50b1N0cmluZygpIC8vID0+ICcnIChub3RlIHRoYXQgJ2FiJyB3YXMgcmVtb3ZlZClcbiAgICogICAgIC8vIHdpdGggc3RvcENhcHR1cmluZ1xuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdhJylcbiAgICogICAgIHVtLnN0b3BDYXB0dXJpbmcoKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnYScgKG5vdGUgdGhhdCBvbmx5ICdiJyB3YXMgcmVtb3ZlZClcbiAgICpcbiAgICovXG4gIHN0b3BDYXB0dXJpbmcgKCkge1xuICAgIHRoaXMubGFzdENoYW5nZSA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvIGxhc3QgY2hhbmdlcyBvbiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgdGhpcy51bmRvaW5nID0gdHJ1ZVxuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgcmVzID0gcG9wU3RhY2tJdGVtKHRoaXMsIHRoaXMudW5kb1N0YWNrLCAndW5kbycpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5kb2luZyA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRvIGxhc3QgdW5kbyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICByZWRvICgpIHtcbiAgICB0aGlzLnJlZG9pbmcgPSB0cnVlXG4gICAgbGV0IHJlc1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy5yZWRvU3RhY2ssICdyZWRvJylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWRvaW5nID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyoqXG4gICAqIEFyZSB1bmRvIHN0ZXBzIGF2YWlsYWJsZT9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHVuZG8gaXMgcG9zc2libGVcbiAgICovXG4gIGNhblVuZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnVuZG9TdGFjay5sZW5ndGggPiAwXG4gIH1cblxuICAvKipcbiAgICogQXJlIHJlZG8gc3RlcHMgYXZhaWxhYmxlP1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVkbyBpcyBwb3NzaWJsZVxuICAgKi9cbiAgY2FuUmVkbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkb1N0YWNrLmxlbmd0aCA+IDBcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMuZGVsZXRlKHRoaXMpXG4gICAgdGhpcy5kb2Mub2ZmKCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcy5hZnRlclRyYW5zYWN0aW9uSGFuZGxlcilcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICdsaWIwL2JpbmFyeSdcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnbGliMC9zdHJpbmcnXG5cbmltcG9ydCB7XG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRCaW5hcnksXG4gIENvbnRlbnREZWxldGVkLFxuICBDb250ZW50RG9jLFxuICBDb250ZW50RW1iZWQsXG4gIENvbnRlbnRGb3JtYXQsXG4gIENvbnRlbnRKU09OLFxuICBDb250ZW50U3RyaW5nLFxuICBDb250ZW50VHlwZSxcbiAgY3JlYXRlSUQsXG4gIGRlY29kZVN0YXRlVmVjdG9yLFxuICBEU0VuY29kZXJWMSxcbiAgRFNFbmNvZGVyVjIsXG4gIEdDLFxuICBJdGVtLFxuICBtZXJnZURlbGV0ZVNldHMsXG4gIHJlYWREZWxldGVTZXQsXG4gIHJlYWRJdGVtQ29udGVudCxcbiAgU2tpcCxcbiAgVXBkYXRlRGVjb2RlclYxLFxuICBVcGRhdGVEZWNvZGVyVjIsXG4gIFVwZGF0ZUVuY29kZXJWMSxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICB3cml0ZURlbGV0ZVNldCxcbiAgWVhtbEVsZW1lbnQsXG4gIFlYbWxIb29rXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICovXG5mdW5jdGlvbiAqIGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IgKGRlY29kZXIpIHtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kZXIucmVhZENsaWVudCgpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3RydWN0czsgaSsrKSB7XG4gICAgICBjb25zdCBpbmZvID0gZGVjb2Rlci5yZWFkSW5mbygpXG4gICAgICAvLyBAdG9kbyB1c2Ugc3dpdGNoIGluc3RlYWQgb2YgaWZzXG4gICAgICBpZiAoaW5mbyA9PT0gMTApIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICAgICAgeWllbGQgbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgY2xvY2sgKz0gbGVuXG4gICAgICB9IGVsc2UgaWYgKChiaW5hcnkuQklUUzUgJiBpbmZvKSAhPT0gMCkge1xuICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbCwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBGb3JjZSB3cml0aW5nIGEgc3RyaW5nIGhlcmUuXG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRlY29kZXIucmVhZFN0cmluZygpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICApXG4gICAgICAgIHlpZWxkIHN0cnVjdFxuICAgICAgICBjbG9jayArPSBzdHJ1Y3QubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKVxuICAgICAgICB5aWVsZCBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgY2xvY2sgKz0gbGVuXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMYXp5U3RydWN0UmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyU2tpcHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyLCBmaWx0ZXJTa2lwcykge1xuICAgIHRoaXMuZ2VuID0gbGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvcihkZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgSXRlbSB8IFNraXAgfCBHQ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnIgPSBudWxsXG4gICAgdGhpcy5kb25lID0gZmFsc2VcbiAgICB0aGlzLmZpbHRlclNraXBzID0gZmlsdGVyU2tpcHNcbiAgICB0aGlzLm5leHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZW0gfCBHQyB8IFNraXAgfG51bGx9XG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvLyBpZ25vcmUgXCJTa2lwXCIgc3RydWN0c1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY3VyciA9IHRoaXMuZ2VuLm5leHQoKS52YWx1ZSB8fCBudWxsXG4gICAgfSB3aGlsZSAodGhpcy5maWx0ZXJTa2lwcyAmJiB0aGlzLmN1cnIgIT09IG51bGwgJiYgdGhpcy5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKVxuICAgIHJldHVybiB0aGlzLmN1cnJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9nVXBkYXRlID0gdXBkYXRlID0+IGxvZ1VwZGF0ZVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKlxuICovXG5leHBvcnQgY29uc3QgbG9nVXBkYXRlVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW11cbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpXG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpXG4gIH1cbiAgbG9nZ2luZy5wcmludCgnU3RydWN0czogJywgc3RydWN0cylcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXG4gIGxvZ2dpbmcucHJpbnQoJ0RlbGV0ZVNldDogJywgZHMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVVcGRhdGUgPSAodXBkYXRlKSA9PiBkZWNvZGVVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVVwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdXG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKVxuICB9XG4gIHJldHVybiB7XG4gICAgc3RydWN0cyxcbiAgICBkczogcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMYXp5U3RydWN0V3JpdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW5jb2Rlcikge1xuICAgIHRoaXMuY3VyckNsaWVudCA9IDBcbiAgICB0aGlzLnN0YXJ0Q2xvY2sgPSAwXG4gICAgdGhpcy53cml0dGVuID0gMFxuICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXJcbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIHdyaXRlIG9wZXJhdGlvbnMgbGF6aWx5LCBidXQgYWxzbyB3ZSBuZWVkIHRvIGtub3cgYmVmb3JlaGFuZCBob3cgbWFueSBvcGVyYXRpb25zIHdlIHdhbnQgdG8gd3JpdGUgZm9yIGVhY2ggY2xpZW50LlxuICAgICAqXG4gICAgICogVGhpcyBraW5kIG9mIG1ldGEtaW5mb3JtYXRpb24gKCNjbGllbnRzLCAjc3RydWN0cy1wZXItY2xpZW50LXdyaXR0ZW4pIGlzIHdyaXR0ZW4gdG8gdGhlIHJlc3RFbmNvZGVyLlxuICAgICAqXG4gICAgICogV2UgZnJhZ21lbnQgdGhlIHJlc3RFbmNvZGVyIGFuZCBzdG9yZSBhIHNsaWNlIG9mIGl0IHBlci1jbGllbnQgdW50aWwgd2Uga25vdyBob3cgbWFueSBjbGllbnRzIHRoZXJlIGFyZS5cbiAgICAgKiBXaGVuIHdlIGZsdXNoICh0b1VpbnQ4QXJyYXkpIHdlIHdyaXRlIHRoZSByZXN0RW5jb2RlciB1c2luZyB0aGUgZnJhZ21lbnRzIGFuZCB0aGUgbWV0YS1pbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTx7IHdyaXR0ZW46IG51bWJlciwgcmVzdEVuY29kZXI6IFVpbnQ4QXJyYXkgfT59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRTdHJ1Y3RzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZVVwZGF0ZXMgPSB1cGRhdGVzID0+IG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBEU0VuY29kZXJWMSB8IHR5cGVvZiBEU0VuY29kZXJWMn0gWUVuY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIgPSAodXBkYXRlLCBZRW5jb2RlciA9IERTRW5jb2RlclYyLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKClcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSlcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnJcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgc2l6ZSA9IDBcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgbGV0IHN0b3BDb3VudGluZyA9IGN1cnIuaWQuY2xvY2sgIT09IDAgLy8gbXVzdCBzdGFydCBhdCAwXG4gICAgbGV0IGN1cnJDbG9jayA9IHN0b3BDb3VudGluZyA/IDAgOiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGhcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgICAgIHNpemUrK1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZSB0byB0aGUgZW5jb2RlclxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KVxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spXG4gICAgICAgIH1cbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgICAgIGN1cnJDbG9jayA9IDBcbiAgICAgICAgc3RvcENvdW50aW5nID0gY3Vyci5pZC5jbG9jayAhPT0gMFxuICAgICAgfVxuICAgICAgLy8gd2UgaWdub3JlIHNraXBzXG4gICAgICBpZiAoY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICBzdG9wQ291bnRpbmcgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIXN0b3BDb3VudGluZykge1xuICAgICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlXG4gICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgc2l6ZSsrXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spXG4gICAgfVxuICAgIC8vIHByZXBlbmQgdGhlIHNpemUgb2YgdGhlIHN0YXRlIHZlY3RvclxuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmMsIHNpemUpXG4gICAgZW5jb2Rpbmcud3JpdGVCaW5hcnlFbmNvZGVyKGVuYywgZW5jb2Rlci5yZXN0RW5jb2RlcilcbiAgICBlbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jXG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMClcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUgPSB1cGRhdGUgPT4gZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIodXBkYXRlLCBEU0VuY29kZXJWMSwgVXBkYXRlRGVjb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVXBkYXRlTWV0YVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgZnJvbSA9IG5ldyBNYXAoKVxuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCB0byA9IG5ldyBNYXAoKVxuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSksIGZhbHNlKVxuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VyclxuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnRcbiAgICBsZXQgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9ja1xuICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgZnJvbS5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKVxuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spXG4gICAgICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgICAgIGZyb20uc2V0KGN1cnIuaWQuY2xpZW50LCBjdXJyLmlkLmNsb2NrKVxuICAgICAgICAvLyB1cGRhdGUgY3VyckNsaWVudFxuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnRcbiAgICAgIH1cbiAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aFxuICAgIH1cbiAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKVxuICB9XG4gIHJldHVybiB7IGZyb20sIHRvIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlVXBkYXRlTWV0YSA9IHVwZGF0ZSA9PiBwYXJzZVVwZGF0ZU1ldGFWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBzbGljZSBhbnkga2luZCBvZiBzdHJ1Y3QgYW5kIHJldHJpZXZlIHRoZSByaWdodCBwYXJ0LlxuICogSXQgZG9lcyBub3QgaGFuZGxlIHNpZGUtZWZmZWN0cywgc28gaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSB0aGUgbGF6eS1lbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7SXRlbSB8IEdDIHwgU2tpcH0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW0gfCBHQ31cbiAqL1xuY29uc3Qgc2xpY2VTdHJ1Y3QgPSAobGVmdCwgZGlmZikgPT4ge1xuICBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWRcbiAgICByZXR1cm4gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2UgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWRcbiAgICByZXR1cm4gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdEl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KVxuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWRcbiAgICByZXR1cm4gbmV3IEl0ZW0oXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgICBudWxsLFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICAgIG51bGwsXG4gICAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3Mgc2ltaWxhcmx5IHRvIGByZWFkVXBkYXRlVjJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZVVwZGF0ZXNWMiA9ICh1cGRhdGVzLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgaWYgKHVwZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHVwZGF0ZXNbMF1cbiAgfVxuICBjb25zdCB1cGRhdGVEZWNvZGVycyA9IHVwZGF0ZXMubWFwKHVwZGF0ZSA9PiBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSlcbiAgbGV0IGxhenlTdHJ1Y3REZWNvZGVycyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIHRydWUpKVxuXG4gIC8qKlxuICAgKiBAdG9kbyB3ZSBkb24ndCBuZWVkIG9mZnNldCBiZWNhdXNlIHdlIGFsd2F5cyBzbGljZSBiZWZvcmVcbiAgICogQHR5cGUge251bGwgfCB7IHN0cnVjdDogSXRlbSB8IEdDIHwgU2tpcCwgb2Zmc2V0OiBudW1iZXIgfX1cbiAgICovXG4gIGxldCBjdXJyV3JpdGUgPSBudWxsXG5cbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIC8vIHdyaXRlIHN0cnVjdHMgbGF6aWx5XG4gIGNvbnN0IGxhenlTdHJ1Y3RFbmNvZGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIodXBkYXRlRW5jb2RlcilcblxuICAvLyBOb3RlOiBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBsYXp5U3RydWN0RGVjb2RlcnMgYXJlIGZ1bGx5IGNvbnN1bWVkXG4gIC8vIE5vdGU6IFNob3VsZCBtZXJnZSBkb2N1bWVudCB1cGRhdGVzIHdoZW5ldmVyIHBvc3NpYmxlIC0gZXZlbiBmcm9tIGRpZmZlcmVudCB1cGRhdGVzXG4gIC8vIE5vdGU6IFNob3VsZCBoYW5kbGUgdGhhdCBzb21lIG9wZXJhdGlvbnMgY2Fubm90IGJlIGFwcGxpZWQgeWV0ICgpXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBXcml0ZSBoaWdoZXIgY2xpZW50cyBmaXJzdCDih5Igc29ydCBieSBjbGllbnRJRCAmIGNsb2NrIGFuZCByZW1vdmUgZGVjb2RlcnMgd2l0aG91dCBjb250ZW50XG4gICAgbGF6eVN0cnVjdERlY29kZXJzID0gbGF6eVN0cnVjdERlY29kZXJzLmZpbHRlcihkZWMgPT4gZGVjLmN1cnIgIT09IG51bGwpXG4gICAgbGF6eVN0cnVjdERlY29kZXJzLnNvcnQoXG4gICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGFueSxhbnkpOm51bWJlcn0gKi8gKGRlYzEsIGRlYzIpID0+IHtcbiAgICAgICAgaWYgKGRlYzEuY3Vyci5pZC5jbGllbnQgPT09IGRlYzIuY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgICBjb25zdCBjbG9ja0RpZmYgPSBkZWMxLmN1cnIuaWQuY2xvY2sgLSBkZWMyLmN1cnIuaWQuY2xvY2tcbiAgICAgICAgICBpZiAoY2xvY2tEaWZmID09PSAwKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZW1vdmUgcmVmZXJlbmNlcyB0byBza2lwIHNpbmNlIHRoZSBzdHJ1Y3REZWNvZGVycyBtdXN0IGZpbHRlciBTa2lwcy5cbiAgICAgICAgICAgIHJldHVybiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IGRlYzIuY3Vyci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgOiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXAgPyAxIDogLTEgLy8gd2UgYXJlIGZpbHRlcmluZyBza2lwcyBhbnl3YXkuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9ja0RpZmZcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlYzIuY3Vyci5pZC5jbGllbnQgLSBkZWMxLmN1cnIuaWQuY2xpZW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICAgaWYgKGxhenlTdHJ1Y3REZWNvZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IGN1cnJEZWNvZGVyID0gbGF6eVN0cnVjdERlY29kZXJzWzBdXG4gICAgLy8gd3JpdGUgZnJvbSBjdXJyRGVjb2RlciB1bnRpbCB0aGUgbmV4dCBvcGVyYXRpb24gaXMgZnJvbSBhbm90aGVyIGNsaWVudCBvciBpZiBmaWxsZXItc3RydWN0XG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlb3JkZXIgdGhlIGRlY29kZXJzIGFuZCBmaW5kIHRoZSBuZXh0IG9wZXJhdGlvbiB0byB3cml0ZVxuICAgIGNvbnN0IGZpcnN0Q2xpZW50ID0gLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKS5pZC5jbGllbnRcblxuICAgIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBjdXJyID0gLyoqIEB0eXBlIHtJdGVtIHwgR0MgfCBudWxsfSAqLyAoY3VyckRlY29kZXIuY3VycilcbiAgICAgIGxldCBpdGVyYXRlZCA9IGZhbHNlXG5cbiAgICAgIC8vIGl0ZXJhdGUgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdGhhdCB3ZSBoYXZlbid0IHdyaXR0ZW4gYWxyZWFkeVxuICAgICAgLy8gcmVtZW1iZXI6IGZpcnN0IHRoZSBoaWdoIGNsaWVudC1pZHMgYXJlIHdyaXR0ZW5cbiAgICAgIHdoaWxlIChjdXJyICE9PSBudWxsICYmIGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA8PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgY3Vyci5pZC5jbGllbnQgPj0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgY3VyciA9IGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICAgICBpdGVyYXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgY3VyciA9PT0gbnVsbCB8fCAvLyBjdXJyZW50IGRlY29kZXIgaXMgZW1wdHlcbiAgICAgICAgY3Vyci5pZC5jbGllbnQgIT09IGZpcnN0Q2xpZW50IHx8IC8vIGNoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW5vdGhlciBkZWNvZGVyIHRoYXQgaGFzIGhhcyB1cGRhdGVzIGZyb20gYGZpcnN0Q2xpZW50YFxuICAgICAgICAoaXRlcmF0ZWQgJiYgY3Vyci5pZC5jbG9jayA+IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCkgLy8gdGhlIGFib3ZlIHdoaWxlIGxvb3Agd2FzIHVzZWQgYW5kIHdlIGFyZSBwb3RlbnRpYWxseSBtaXNzaW5nIHVwZGF0ZXNcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDbGllbnQgIT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH1cbiAgICAgICAgY3VyckRlY29kZXIubmV4dCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIDwgY3Vyci5pZC5jbG9jaykge1xuICAgICAgICAgIC8vIEB0b2RvIHdyaXRlIGN1cnJTdHJ1Y3QgJiBzZXQgY3VyclN0cnVjdCA9IFNraXAoY2xvY2sgPSBjdXJyU3RydWN0LmlkLmNsb2NrICsgY3VyclN0cnVjdC5sZW5ndGgsIGxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgLSBzZWxmLmNsb2NrKVxuICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAvLyBleHRlbmQgZXhpc3Rpbmcgc2tpcFxuICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnIuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5sZW5ndGhcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge1NraXB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBTa2lwKGNyZWF0ZUlEKGZpcnN0Q2xpZW50LCBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpLCBkaWZmKVxuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3QsIG9mZnNldDogMCB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID49IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC0gY3Vyci5pZC5jbG9ja1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgICAgLy8gcHJlZmVyIHRvIHNsaWNlIFNraXAgYmVjYXVzZSB0aGUgb3RoZXIgc3RydWN0IG1pZ2h0IGNvbnRhaW4gbW9yZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtPSBkaWZmXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gc2xpY2VTdHJ1Y3QoY3VyciwgZGlmZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjdXJyV3JpdGUuc3RydWN0Lm1lcmdlV2l0aCgvKiogQHR5cGUge2FueX0gKi8gKGN1cnIpKSkge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpXG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH1cbiAgICAgICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKSwgb2Zmc2V0OiAwIH1cbiAgICAgIGN1cnJEZWNvZGVyLm5leHQoKVxuICAgIH1cbiAgICBmb3IgKFxuICAgICAgbGV0IG5leHQgPSBjdXJyRGVjb2Rlci5jdXJyO1xuICAgICAgbmV4dCAhPT0gbnVsbCAmJiBuZXh0LmlkLmNsaWVudCA9PT0gZmlyc3RDbGllbnQgJiYgbmV4dC5pZC5jbG9jayA9PT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIG5leHQuY29uc3RydWN0b3IgIT09IFNraXA7XG4gICAgICBuZXh0ID0gY3VyckRlY29kZXIubmV4dCgpXG4gICAgKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldClcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBuZXh0LCBvZmZzZXQ6IDAgfVxuICAgIH1cbiAgfVxuICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpXG4gICAgY3VycldyaXRlID0gbnVsbFxuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RFbmNvZGVyKVxuXG4gIGNvbnN0IGRzcyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IHJlYWREZWxldGVTZXQoZGVjb2RlcikpXG4gIGNvbnN0IGRzID0gbWVyZ2VEZWxldGVTZXRzKGRzcylcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpXG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc3ZcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqL1xuZXhwb3J0IGNvbnN0IGRpZmZVcGRhdGVWMiA9ICh1cGRhdGUsIHN2LCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RhdGUgPSBkZWNvZGVTdGF0ZVZlY3RvcihzdilcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIGNvbnN0IGxhenlTdHJ1Y3RXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcihlbmNvZGVyKVxuICBjb25zdCBkZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSlcbiAgY29uc3QgcmVhZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgZmFsc2UpXG4gIHdoaWxlIChyZWFkZXIuY3Vycikge1xuICAgIGNvbnN0IGN1cnIgPSByZWFkZXIuY3VyclxuICAgIGNvbnN0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudFxuICAgIGNvbnN0IHN2Q2xvY2sgPSBzdGF0ZS5nZXQoY3VyckNsaWVudCkgfHwgMFxuICAgIGlmIChyZWFkZXIuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgLy8gdGhlIGZpcnN0IHdyaXR0ZW4gc3RydWN0IHNob3VsZG4ndCBiZSBhIHNraXBcbiAgICAgIHJlYWRlci5uZXh0KClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPiBzdkNsb2NrKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCBjdXJyLCBtYXRoLm1heChzdkNsb2NrIC0gY3Vyci5pZC5jbG9jaywgMCkpXG4gICAgICByZWFkZXIubmV4dCgpXG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIHJlYWRlci5jdXJyLCAwKVxuICAgICAgICByZWFkZXIubmV4dCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWQgdW50aWwgc29tZXRoaW5nIG5ldyBjb21lcyB1cFxuICAgICAgd2hpbGUgKHJlYWRlci5jdXJyICYmIHJlYWRlci5jdXJyLmlkLmNsaWVudCA9PT0gY3VyckNsaWVudCAmJiByZWFkZXIuY3Vyci5pZC5jbG9jayArIHJlYWRlci5jdXJyLmxlbmd0aCA8PSBzdkNsb2NrKSB7XG4gICAgICAgIHJlYWRlci5uZXh0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdFdyaXRlcilcbiAgLy8gd3JpdGUgZHNcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KGRlY29kZXIpXG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKi9cbmV4cG9ydCBjb25zdCBkaWZmVXBkYXRlID0gKHVwZGF0ZSwgc3YpID0+IGRpZmZVcGRhdGVWMih1cGRhdGUsIHN2LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmx1c2hMYXp5U3RydWN0V3JpdGVyID0gbGF6eVdyaXRlciA9PiB7XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwKSB7XG4gICAgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLnB1c2goeyB3cml0dGVuOiBsYXp5V3JpdGVyLndyaXR0ZW4sIHJlc3RFbmNvZGVyOiBlbmNvZGluZy50b1VpbnQ4QXJyYXkobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyKSB9KVxuICAgIGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGxhenlXcml0ZXIud3JpdHRlbiA9IDBcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICogQHBhcmFtIHtJdGVtIHwgR0N9IHN0cnVjdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5jb25zdCB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlciA9IChsYXp5V3JpdGVyLCBzdHJ1Y3QsIG9mZnNldCkgPT4ge1xuICAvLyBmbHVzaCBjdXJyIGlmIHdlIHN0YXJ0IGFub3RoZXIgY2xpZW50XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwICYmIGxhenlXcml0ZXIuY3VyckNsaWVudCAhPT0gc3RydWN0LmlkLmNsaWVudCkge1xuICAgIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKVxuICB9XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPT09IDApIHtcbiAgICBsYXp5V3JpdGVyLmN1cnJDbGllbnQgPSBzdHJ1Y3QuaWQuY2xpZW50XG4gICAgLy8gd3JpdGUgbmV4dCBjbGllbnRcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIud3JpdGVDbGllbnQoc3RydWN0LmlkLmNsaWVudClcbiAgICAvLyB3cml0ZSBzdGFydENsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0LmlkLmNsb2NrICsgb2Zmc2V0KVxuICB9XG4gIHN0cnVjdC53cml0ZShsYXp5V3JpdGVyLmVuY29kZXIsIG9mZnNldClcbiAgbGF6eVdyaXRlci53cml0dGVuKytcbn1cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgY29sbGVjdGVkIGFsbCBwYXJ0cyBhbmQgd2FudCB0b1xuICogcHV0IGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gKiB5b3UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBVcGRhdGVFbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyA9IChsYXp5V3JpdGVyKSA9PiB7XG4gIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKVxuXG4gIC8vIHRoaXMgaXMgYSBmcmVzaCBlbmNvZGVyIGJlY2F1c2Ugd2UgY2FsbGVkIGZsdXNoQ3VyclxuICBjb25zdCByZXN0RW5jb2RlciA9IGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlclxuXG4gIC8qKlxuICAgKiBOb3cgd2UgcHV0IGFsbCB0aGUgZnJhZ21lbnRzIHRvZ2V0aGVyLlxuICAgKiBUaGlzIHdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVDbGllbnRzU3RydWN0c2BcbiAgICovXG5cbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgLSBpLmUuIHRoZSBjbGllbnRzXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChyZXN0RW5jb2RlciwgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLmxlbmd0aClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnRTdHJ1Y3RzID0gbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzW2ldXG4gICAgLyoqXG4gICAgICogV29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZVN0cnVjdHNgXG4gICAgICovXG4gICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLndyaXR0ZW4pXG4gICAgLy8gd3JpdGUgdGhlIHJlc3Qgb2YgdGhlIGZyYWdtZW50XG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy5yZXN0RW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW18R0N8U2tpcCk6SXRlbXxHQ3xTa2lwfSBibG9ja1RyYW5zZm9ybWVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBZRGVjb2RlclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYyIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB9IFlFbmNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0ID0gKHVwZGF0ZSwgYmxvY2tUcmFuc2Zvcm1lciwgWURlY29kZXIsIFlFbmNvZGVyKSA9PiB7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBjb25zdCB1cGRhdGVFbmNvZGVyID0gbmV3IFlFbmNvZGVyKClcbiAgY29uc3QgbGF6eVdyaXRlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpXG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlciwgYmxvY2tUcmFuc2Zvcm1lcihjdXJyKSwgMClcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5V3JpdGVyKVxuICBjb25zdCBkcyA9IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2RlcilcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpXG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT2JmdXNjYXRvck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLmZvcm1hdHRpbmc9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnN1YmRvY3M9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnl4bWw9dHJ1ZV0gV2hldGhlciB0byBvYmZ1c2NhdGUgbm9kZU5hbWUgLyBob29rTmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gb2JmdXNjYXRvclxuICovXG5jb25zdCBjcmVhdGVPYmZ1c2NhdG9yID0gKHsgZm9ybWF0dGluZyA9IHRydWUsIHN1YmRvY3MgPSB0cnVlLCB5eG1sID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgbGV0IGkgPSAwXG4gIGNvbnN0IG1hcEtleUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IG5vZGVOYW1lQ2FjaGUgPSBtYXAuY3JlYXRlKClcbiAgY29uc3QgZm9ybWF0dGluZ0tleUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IGZvcm1hdHRpbmdWYWx1ZUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGZvcm1hdHRpbmdWYWx1ZUNhY2hlLnNldChudWxsLCBudWxsKSAvLyBlbmQgb2YgYSBmb3JtYXR0aW5nIHJhbmdlIHNob3VsZCBhbHdheXMgYmUgdGhlIGVuZCBvZiBhIGZvcm1hdHRpbmcgcmFuZ2VcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxHQ3xTa2lwfSBibG9ja1xuICAgKiBAcmV0dXJuIHtJdGVtfEdDfFNraXB9XG4gICAqL1xuICByZXR1cm4gYmxvY2sgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2suY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgR0M6XG4gICAgICBjYXNlIFNraXA6XG4gICAgICAgIHJldHVybiBibG9ja1xuICAgICAgY2FzZSBJdGVtOiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChibG9jaylcbiAgICAgICAgY29uc3QgY29udGVudCA9IGl0ZW0uY29udGVudFxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnREZWxldGVkOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOiB7XG4gICAgICAgICAgICBpZiAoeXhtbCkge1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKGNvbnRlbnQpLnR5cGVcbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHR5cGUubm9kZU5hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ub2RlTmFtZSwgKCkgPT4gJ25vZGUtJyArIGkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sSG9vaykge1xuICAgICAgICAgICAgICAgIHR5cGUuaG9va05hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ob29rTmFtZSwgKCkgPT4gJ2hvb2stJyArIGkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEFueToge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEFueX0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBjLmFyciA9IGMuYXJyLm1hcCgoKSA9PiBpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50QmluYXJ5OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50QmluYXJ5fSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuY29udGVudCA9IG5ldyBVaW50OEFycmF5KFtpXSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudERvYzoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBpZiAoc3ViZG9jcykge1xuICAgICAgICAgICAgICBjLm9wdHMgPSB7fVxuICAgICAgICAgICAgICBjLmRvYy5ndWlkID0gaSArICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuZW1iZWQgPSB7fVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGlmIChmb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgIGMua2V5ID0gbWFwLnNldElmVW5kZWZpbmVkKGZvcm1hdHRpbmdLZXlDYWNoZSwgYy5rZXksICgpID0+IGkgKyAnJylcbiAgICAgICAgICAgICAgYy52YWx1ZSA9IG1hcC5zZXRJZlVuZGVmaW5lZChmb3JtYXR0aW5nVmFsdWVDYWNoZSwgYy52YWx1ZSwgKCkgPT4gKHsgaSB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEpTT046IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRKU09OfSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuYXJyID0gYy5hcnIubWFwKCgpID0+IGkpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChjb250ZW50KVxuICAgICAgICAgICAgYy5zdHIgPSBzdHJpbmcucmVwZWF0KChpICUgMTApICsgJycsIGMuc3RyLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB1bmtub3duIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtLnBhcmVudFN1Yikge1xuICAgICAgICAgIGl0ZW0ucGFyZW50U3ViID0gbWFwLnNldElmVW5kZWZpbmVkKG1hcEtleUNhY2hlLCBpdGVtLnBhcmVudFN1YiwgKCkgPT4gaSArICcnKVxuICAgICAgICB9XG4gICAgICAgIGkrK1xuICAgICAgICByZXR1cm4gYmxvY2tcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHVua25vd24gYmxvY2stdHlwZVxuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBvYmZ1c2NhdGVzIHRoZSBjb250ZW50IG9mIGEgWWpzIHVwZGF0ZS4gVGhpcyBpcyB1c2VmdWwgdG8gc2hhcmVcbiAqIGJ1Z2d5IFlqcyBkb2N1bWVudHMgd2hpbGUgc2lnbmlmaWNhbnRseSBsaW1pdGluZyB0aGUgcG9zc2liaWxpdHkgdGhhdCBhXG4gKiBkZXZlbG9wZXIgY2FuIG9uIHRoZSB1c2VyLiBOb3RlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgcG9zc2libGUgdG8gZGVkdWNlXG4gKiBzb21lIGluZm9ybWF0aW9uIGJ5IGFuYWx5emluZyB0aGUgXCJzdHJ1Y3R1cmVcIiBvZiB0aGUgZG9jdW1lbnQgb3IgYnkgYW5hbHl6aW5nXG4gKiB0aGUgdHlwaW5nIGJlaGF2aW9yIHVzaW5nIHRoZSBDUkRULXJlbGF0ZWQgbWV0YWRhdGEgdGhhdCBpcyBzdGlsbCBrZXB0IGZ1bGx5XG4gKiBpbnRhY3QuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IFtvcHRzXVxuICovXG5leHBvcnQgY29uc3Qgb2JmdXNjYXRlVXBkYXRlID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBbb3B0c11cbiAqL1xuZXhwb3J0IGNvbnN0IG9iZnVzY2F0ZVVwZGF0ZVYyID0gKHVwZGF0ZSwgb3B0cykgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGNyZWF0ZU9iZnVzY2F0b3Iob3B0cyksIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYyKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyID0gdXBkYXRlID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBmLmlkLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSA9IHVwZGF0ZSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgZi5pZCwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEpXG4iLCAiaW1wb3J0IHtcbiAgaXNEZWxldGVkLFxuICBJdGVtLCBBYnN0cmFjdFR5cGUsIFRyYW5zYWN0aW9uLCBBYnN0cmFjdFN0cnVjdCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbmNvbnN0IGVycm9yQ29tcHV0ZUNoYW5nZXMgPSAnWW91IG11c3Qgbm90IGNvbXB1dGUgY2hhbmdlcyBhZnRlciB0aGUgZXZlbnQtaGFuZGxlciBmaXJlZC4nXG5cbi8qKlxuICogQHRlbXBsYXRlIHtBYnN0cmFjdFR5cGU8YW55Pn0gVFxuICogWUV2ZW50IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlUeXBlLlxuICovXG5leHBvcnQgY2xhc3MgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdGFyZ2V0IFRoZSBjaGFuZ2VkIHR5cGUuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFyZ2V0LCB0cmFuc2FjdGlvbikge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9uIHdoaWNoIHRoaXMgZXZlbnQgd2FzIGNyZWF0ZWQgb24uXG4gICAgICogQHR5cGUge1R9XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXRcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0YXJnZXQgb24gd2hpY2ggdGhlIG9ic2VydmUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXRcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC5cbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2NoYW5nZXMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2tleXMgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBBcnJheTx7IGluc2VydD86IHN0cmluZyB8IEFycmF5PGFueT4gfCBvYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2RlbHRhID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8bnVtYmVyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3BhdGggPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHBhdGggZnJvbSBgeWAgdG8gdGhlIGNoYW5nZWQgdHlwZS5cbiAgICpcbiAgICogQHRvZG8gdjE0IHNob3VsZCBzdGFuZGFyZGl6ZSBvbiBwYXRoOiBBcnJheTx7cGFyZW50LCBpbmRleH0+IGJlY2F1c2UgdGhhdCBpcyBlYXNpZXIgdG8gd29yayB3aXRoLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnR5IGhvbGRzOlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGxldCB0eXBlID0geVxuICAgKiAgIGV2ZW50LnBhdGguZm9yRWFjaChkaXIgPT4ge1xuICAgKiAgICAgdHlwZSA9IHR5cGUuZ2V0KGRpcilcbiAgICogICB9KVxuICAgKiAgIHR5cGUgPT09IGV2ZW50LnRhcmdldCAvLyA9PiB0cnVlXG4gICAqL1xuICBnZXQgcGF0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGggfHwgKHRoaXMuX3BhdGggPSBnZXRQYXRoVG8odGhpcy5jdXJyZW50VGFyZ2V0LCB0aGlzLnRhcmdldCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgZGVsZXRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZWxldGVzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gaXNEZWxldGVkKHRoaXMudHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBzdHJ1Y3QuaWQpXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIHsgYWN0aW9uOiAnYWRkJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkgfT59XG4gICAqL1xuICBnZXQga2V5cyAoKSB7XG4gICAgaWYgKHRoaXMuX2tleXMgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKGVycm9yQ29tcHV0ZUNoYW5nZXMpXG4gICAgICB9XG4gICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpXG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldFxuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpXG4gICAgICBjaGFuZ2VkLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovICh0YXJnZXQuX21hcC5nZXQoa2V5KSlcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7J2RlbGV0ZScgfCAnYWRkJyB8ICd1cGRhdGUnfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCBhY3Rpb25cbiAgICAgICAgICBsZXQgb2xkVmFsdWVcbiAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGl0ZW0ubGVmdFxuICAgICAgICAgICAgd2hpbGUgKHByZXYgIT09IG51bGwgJiYgdGhpcy5hZGRzKHByZXYpKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwcmV2LmxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ3VwZGF0ZSdcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnYWRkJ1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJ1xuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QoLyoqIEB0eXBlIHtJdGVtfSAqLyBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8vIG5vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzLnNldChrZXksIHsgYWN0aW9uLCBvbGRWYWx1ZSB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5fa2V5cyA9IGtleXNcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29tcHV0ZWQgcHJvcGVydHkuIE5vdGUgdGhhdCB0aGlzIGNhbiBvbmx5IGJlIHNhZmVseSBjb21wdXRlZCBkdXJpbmcgdGhlXG4gICAqIGV2ZW50IGNhbGwuIENvbXB1dGluZyB0aGlzIHByb3BlcnR5IGFmdGVyIG90aGVyIGNoYW5nZXMgaGFwcGVuZWQgbWlnaHQgcmVzdWx0IGluXG4gICAqIHVuZXhwZWN0ZWQgYmVoYXZpb3IgKGluY29ycmVjdCBjb21wdXRhdGlvbiBvZiBkZWx0YXMpLiBBIHNhZmUgd2F5IHRvIGNvbGxlY3QgY2hhbmdlc1xuICAgKiBpcyB0byBzdG9yZSB0aGUgYGNoYW5nZXNgIG9yIHRoZSBgZGVsdGFgIG9iamVjdC4gQXZvaWQgc3RvcmluZyB0aGUgYHRyYW5zYWN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiB8IG9iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT59Pn1cbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5kZWx0YVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGFkZGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFkZHMgKHN0cnVjdCkge1xuICAgIHJldHVybiBzdHJ1Y3QuaWQuY2xvY2sgPj0gKHRoaXMudHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KHN0cnVjdC5pZC5jbGllbnQpIHx8IDApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZSBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZVxuICAgKiBldmVudCBjYWxsLiBDb21wdXRpbmcgdGhpcyBwcm9wZXJ0eSBhZnRlciBvdGhlciBjaGFuZ2VzIGhhcHBlbmVkIG1pZ2h0IHJlc3VsdCBpblxuICAgKiB1bmV4cGVjdGVkIGJlaGF2aW9yIChpbmNvcnJlY3QgY29tcHV0YXRpb24gb2YgZGVsdGFzKS4gQSBzYWZlIHdheSB0byBjb2xsZWN0IGNoYW5nZXNcbiAgICogaXMgdG8gc3RvcmUgdGhlIGBjaGFuZ2VzYCBvciB0aGUgYGRlbHRhYCBvYmplY3QuIEF2b2lkIHN0b3JpbmcgdGhlIGB0cmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGxldCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlc1xuICAgIGlmIChjaGFuZ2VzID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5kb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGVycm9yLmNyZWF0ZShlcnJvckNvbXB1dGVDaGFuZ2VzKVxuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRcbiAgICAgIGNvbnN0IGFkZGVkID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb25zdCBkZWxldGVkID0gc2V0LmNyZWF0ZSgpXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0OkFycmF5PGFueT59fHtkZWxldGU6bnVtYmVyfXx7cmV0YWluOm51bWJlcn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdXG4gICAgICBjaGFuZ2VzID0ge1xuICAgICAgICBhZGRlZCxcbiAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGtleXM6IHRoaXMua2V5c1xuICAgICAgfVxuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpXG4gICAgICBpZiAoY2hhbmdlZC5oYXMobnVsbCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGFzdE9wID0gbnVsbFxuICAgICAgICBjb25zdCBwYWNrT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGxhc3RPcCkge1xuICAgICAgICAgICAgZGVsdGEucHVzaChsYXN0T3ApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGl0ZW0gPSB0YXJnZXQuX3N0YXJ0OyBpdGVtICE9PSBudWxsOyBpdGVtID0gaXRlbS5yaWdodCkge1xuICAgICAgICAgIGlmIChpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkgJiYgIXRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5kZWxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpXG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBkZWxldGU6IDAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5kZWxldGUgKz0gaXRlbS5sZW5ndGhcbiAgICAgICAgICAgICAgZGVsZXRlZC5hZGQoaXRlbSlcbiAgICAgICAgICAgIH0gLy8gZWxzZSBub3BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5pbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpXG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBpbnNlcnQ6IFtdIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuaW5zZXJ0ID0gbGFzdE9wLmluc2VydC5jb25jYXQoaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSlcbiAgICAgICAgICAgICAgYWRkZWQuYWRkKGl0ZW0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpXG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyByZXRhaW46IDAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5yZXRhaW4gKz0gaXRlbS5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPcCAhPT0gbnVsbCAmJiBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYWNrT3AoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlc1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjaGFuZ2VzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBgY2hpbGRgIHNob3VsZCBiZSBhY2Nlc3NpYmxlIHZpYSBgdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pLi5gXG4gKiAgIGNvbnN0IHBhdGggPSB0eXBlLmdldFBhdGhUbyhjaGlsZClcbiAqICAgLy8gYXNzdW1pbmcgYHR5cGUgaW5zdGFuY2VvZiBZQXJyYXlgXG4gKiAgIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICogICBjaGlsZCA9PT0gdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBjaGlsZCB0YXJnZXRcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFBhdGhUbyA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbXVxuICB3aGlsZSAoY2hpbGQuX2l0ZW0gIT09IG51bGwgJiYgY2hpbGQgIT09IHBhcmVudCkge1xuICAgIGlmIChjaGlsZC5faXRlbS5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgIC8vIHBhcmVudCBpcyBtYXAtaXNoXG4gICAgICBwYXRoLnVuc2hpZnQoY2hpbGQuX2l0ZW0ucGFyZW50U3ViKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgYXJyYXktaXNoXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGxldCBjID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCkuX3N0YXJ0XG4gICAgICB3aGlsZSAoYyAhPT0gY2hpbGQuX2l0ZW0gJiYgYyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWMuZGVsZXRlZCAmJiBjLmNvdW50YWJsZSkge1xuICAgICAgICAgIGkgKz0gYy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBjID0gYy5yaWdodFxuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpXG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudClcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuIiwgImltcG9ydCB7XG4gIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyLFxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzLFxuICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcixcbiAgY3JlYXRlRXZlbnRIYW5kbGVyLFxuICBnZXRTdGF0ZSxcbiAgaXNWaXNpYmxlLFxuICBDb250ZW50VHlwZSxcbiAgY3JlYXRlSUQsXG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRCaW5hcnksXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICBDb250ZW50RG9jLCBZVGV4dCwgWUFycmF5LCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBTbmFwc2hvdCwgVHJhbnNhY3Rpb24sIEV2ZW50SGFuZGxlciwgWUV2ZW50LCBJdGVtLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgaXRlcmF0b3IgZnJvbSAnbGliMC9pdGVyYXRvcidcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcblxuY29uc3QgbWF4U2VhcmNoTWFya2VyID0gODBcblxuLyoqXG4gKiBBIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpZGVudGlmaWVzIGVhY2ggbWFya2VyLlxuICpcbiAqIFRpbWUgaXMgcmVsYXRpdmUsLi4gdGhpcyBpcyBtb3JlIGxpa2UgYW4gZXZlci1pbmNyZWFzaW5nIGNsb2NrLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXAgPSAwXG5cbmV4cG9ydCBjbGFzcyBBcnJheVNlYXJjaE1hcmtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW19IHBcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAocCwgaW5kZXgpIHtcbiAgICBwLm1hcmtlciA9IHRydWVcbiAgICB0aGlzLnAgPSBwXG4gICAgdGhpcy5pbmRleCA9IGluZGV4XG4gICAgdGhpcy50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArK1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKi9cbmNvbnN0IHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAgPSBtYXJrZXIgPT4geyBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKysgfVxuXG4vKipcbiAqIFRoaXMgaXMgcmF0aGVyIGNvbXBsZXggc28gdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25seSB0aGluZyB0aGF0IHNob3VsZCBvdmVyd3JpdGUgYSBtYXJrZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG92ZXJ3cml0ZU1hcmtlciA9IChtYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIG1hcmtlci5wLm1hcmtlciA9IGZhbHNlXG4gIG1hcmtlci5wID0gcFxuICBwLm1hcmtlciA9IHRydWVcbiAgbWFya2VyLmluZGV4ID0gaW5kZXhcbiAgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgbWFya1Bvc2l0aW9uID0gKHNlYXJjaE1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgaWYgKHNlYXJjaE1hcmtlci5sZW5ndGggPj0gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gb3ZlcnJpZGUgb2xkZXN0IG1hcmtlciAod2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgbW9yZSBvYmplY3RzKVxuICAgIGNvbnN0IG1hcmtlciA9IHNlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IGEudGltZXN0YW1wIDwgYi50aW1lc3RhbXAgPyBhIDogYilcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBpbmRleClcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICBjb25zdCBwbSA9IG5ldyBBcnJheVNlYXJjaE1hcmtlcihwLCBpbmRleClcbiAgICBzZWFyY2hNYXJrZXIucHVzaChwbSlcbiAgICByZXR1cm4gcG1cbiAgfVxufVxuXG4vKipcbiAqIFNlYXJjaCBtYXJrZXIgaGVscCB1cyB0byBmaW5kIHBvc2l0aW9ucyBpbiB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgZmFzdGVyLlxuICpcbiAqIFRoZXkgc3BlZWQgdXAgdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHBvc2l0aW9uIHdpdGhvdXQgbXVjaCBib29ra2VlcGluZy5cbiAqXG4gKiBBIG1heGltdW0gb2YgYG1heFNlYXJjaE1hcmtlcmAgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcmVmcmVzaGVkIG1hcmtlciAodXBkYXRlZCB0aW1lc3RhbXApXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0geWFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRNYXJrZXIgPSAoeWFycmF5LCBpbmRleCkgPT4ge1xuICBpZiAoeWFycmF5Ll9zdGFydCA9PT0gbnVsbCB8fCBpbmRleCA9PT0gMCB8fCB5YXJyYXkuX3NlYXJjaE1hcmtlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgbWFya2VyID0geWFycmF5Ll9zZWFyY2hNYXJrZXIubGVuZ3RoID09PSAwID8gbnVsbCA6IHlhcnJheS5fc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gbWF0aC5hYnMoaW5kZXggLSBhLmluZGV4KSA8IG1hdGguYWJzKGluZGV4IC0gYi5pbmRleCkgPyBhIDogYilcbiAgbGV0IHAgPSB5YXJyYXkuX3N0YXJ0XG4gIGxldCBwaW5kZXggPSAwXG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBwID0gbWFya2VyLnBcbiAgICBwaW5kZXggPSBtYXJrZXIuaW5kZXhcbiAgICByZWZyZXNoTWFya2VyVGltZXN0YW1wKG1hcmtlcikgLy8gd2UgdXNlZCBpdCwgd2UgbWlnaHQgbmVlZCB0byB1c2UgaXQgYWdhaW5cbiAgfVxuICAvLyBpdGVyYXRlIHRvIHJpZ2h0IGlmIHBvc3NpYmxlXG4gIHdoaWxlIChwLnJpZ2h0ICE9PSBudWxsICYmIHBpbmRleCA8IGluZGV4KSB7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IHBpbmRleCArIHAubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwaW5kZXggKz0gcC5sZW5ndGhcbiAgICB9XG4gICAgcCA9IHAucmlnaHRcbiAgfVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgaWYgbmVjZXNzYXJ5IChtaWdodCBiZSB0aGF0IHBpbmRleCA+IGluZGV4KVxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHBpbmRleCA+IGluZGV4KSB7XG4gICAgcCA9IHAubGVmdFxuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGhcbiAgICB9XG4gIH1cbiAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnQsIGJlY2F1c2UgdGhhdCB3b3VsZCBzY3JldyB1cCBldmVyeXRoaW5nXG4gIC8vIGluIHRoYXQgY2FzIGp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZSAoaXQgaXMgbW9zdCBsaWtlbHkgdGhlIGJlc3QgbWFya2VyIGFueXdheSlcbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IHVudGlsIHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdFxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHAubGVmdC5pZC5jbGllbnQgPT09IHAuaWQuY2xpZW50ICYmIHAubGVmdC5pZC5jbG9jayArIHAubGVmdC5sZW5ndGggPT09IHAuaWQuY2xvY2spIHtcbiAgICBwID0gcC5sZWZ0XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIC8vIEB0b2RvIHJlbW92ZSFcbiAgLy8gYXNzdXJlIHBvc2l0aW9uXG4gIC8vIHtcbiAgLy8gICBsZXQgc3RhcnQgPSB5YXJyYXkuX3N0YXJ0XG4gIC8vICAgbGV0IHBvcyA9IDBcbiAgLy8gICB3aGlsZSAoc3RhcnQgIT09IHApIHtcbiAgLy8gICAgIGlmICghc3RhcnQuZGVsZXRlZCAmJiBzdGFydC5jb3VudGFibGUpIHtcbiAgLy8gICAgICAgcG9zICs9IHN0YXJ0Lmxlbmd0aFxuICAvLyAgICAgfVxuICAvLyAgICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodClcbiAgLy8gICB9XG4gIC8vICAgaWYgKHBvcyAhPT0gcGluZGV4KSB7XG4gIC8vICAgICBkZWJ1Z2dlclxuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdHb3RjaGEgcG9zaXRpb24gZmFpbCEnKVxuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBpZiAobWFya2VyKSB7XG4gIC8vICAgaWYgKHdpbmRvdy5sZW5ndGhlcyA9PSBudWxsKSB7XG4gIC8vICAgICB3aW5kb3cubGVuZ3RoZXMgPSBbXVxuICAvLyAgICAgd2luZG93LmdldExlbmd0aGVzID0gKCkgPT4gd2luZG93Lmxlbmd0aGVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAvLyAgIH1cbiAgLy8gICB3aW5kb3cubGVuZ3RoZXMucHVzaChtYXJrZXIuaW5kZXggLSBwaW5kZXgpXG4gIC8vICAgY29uc29sZS5sb2coJ2Rpc3RhbmNlJywgbWFya2VyLmluZGV4IC0gcGluZGV4LCAnbGVuJywgcCAmJiBwLnBhcmVudC5sZW5ndGgpXG4gIC8vIH1cbiAgaWYgKG1hcmtlciAhPT0gbnVsbCAmJiBtYXRoLmFicyhtYXJrZXIuaW5kZXggLSBwaW5kZXgpIDwgLyoqIEB0eXBlIHtZVGV4dHxZQXJyYXk8YW55Pn0gKi8gKHAucGFyZW50KS5sZW5ndGggLyBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBhZGp1c3QgZXhpc3RpbmcgbWFya2VyXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgcGluZGV4KVxuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIHJldHVybiBtYXJrUG9zaXRpb24oeWFycmF5Ll9zZWFyY2hNYXJrZXIsIHAsIHBpbmRleClcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBtYXJrZXJzIHdoZW4gYSBjaGFuZ2UgaGFwcGVuZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBkb2luZyBhIGRlbGV0aW9uIVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBJZiBpbnNlcnRpb24sIGxlbiBpcyBwb3NpdGl2ZS4gSWYgZGVsZXRpb24sIGxlbiBpcyBuZWdhdGl2ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZU1hcmtlckNoYW5nZXMgPSAoc2VhcmNoTWFya2VyLCBpbmRleCwgbGVuKSA9PiB7XG4gIGZvciAobGV0IGkgPSBzZWFyY2hNYXJrZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBtID0gc2VhcmNoTWFya2VyW2ldXG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHAgPSBtLnBcbiAgICAgIHAubWFya2VyID0gZmFsc2VcbiAgICAgIC8vIElkZWFsbHkgd2UganVzdCB3YW50IHRvIGRvIGEgc2ltcGxlIHBvc2l0aW9uIGNvbXBhcmlzb24sIGJ1dCB0aGlzIHdpbGwgb25seSB3b3JrIGlmXG4gICAgICAvLyBzZWFyY2ggbWFya2VycyBkb24ndCBwb2ludCB0byBkZWxldGVkIGl0ZW1zIGZvciBmb3JtYXRzLlxuICAgICAgLy8gSXRlcmF0ZSBtYXJrZXIgdG8gcHJldiB1bmRlbGV0ZWQgY291bnRhYmxlIHBvc2l0aW9uIHNvIHdlIGtub3cgd2hhdCB0byBkbyB3aGVuIHVwZGF0aW5nIGEgcG9zaXRpb25cbiAgICAgIHdoaWxlIChwICYmIChwLmRlbGV0ZWQgfHwgIXAuY291bnRhYmxlKSkge1xuICAgICAgICBwID0gcC5sZWZ0XG4gICAgICAgIGlmIChwICYmICFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgICAgICAvLyBhZGp1c3QgcG9zaXRpb24uIHRoZSBsb29wIHNob3VsZCBicmVhayBub3dcbiAgICAgICAgICBtLmluZGV4IC09IHAubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBudWxsIHx8IHAubWFya2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBzZWFyY2ggbWFya2VyIGlmIHVwZGF0ZWQgcG9zaXRpb24gaXMgbnVsbCBvciBpZiBwb3NpdGlvbiBpcyBhbHJlYWR5IG1hcmtlZFxuICAgICAgICBzZWFyY2hNYXJrZXIuc3BsaWNlKGksIDEpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBtLnAgPSBwXG4gICAgICBwLm1hcmtlciA9IHRydWVcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgbS5pbmRleCB8fCAobGVuID4gMCAmJiBpbmRleCA9PT0gbS5pbmRleCkpIHsgLy8gYSBzaW1wbGUgaW5kZXggPD0gbS5pbmRleCBjaGVjayB3b3VsZCBhY3R1YWxseSBzdWZmaWNlXG4gICAgICBtLmluZGV4ID0gbWF0aC5tYXgoaW5kZXgsIG0uaW5kZXggKyBsZW4pXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZSBhbGwgKGxpc3QpIGNoaWxkcmVuIG9mIGEgdHlwZSBhbmQgcmV0dXJuIHRoZW0gYXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdFxuICogQHJldHVybiB7QXJyYXk8SXRlbT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRUeXBlQ2hpbGRyZW4gPSB0ID0+IHtcbiAgbGV0IHMgPSB0Ll9zdGFydFxuICBjb25zdCBhcnIgPSBbXVxuICB3aGlsZSAocykge1xuICAgIGFyci5wdXNoKHMpXG4gICAgcyA9IHMucmlnaHRcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbi8qKlxuICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fSB0eXBlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtFdmVudFR5cGV9IGV2ZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsVHlwZU9ic2VydmVycyA9ICh0eXBlLCB0cmFuc2FjdGlvbiwgZXZlbnQpID0+IHtcbiAgY29uc3QgY2hhbmdlZFR5cGUgPSB0eXBlXG4gIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlc1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbmdlZFBhcmVudFR5cGVzLCB0eXBlLCAoKSA9PiBbXSkucHVzaChldmVudClcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0eXBlLl9pdGVtLnBhcmVudClcbiAgfVxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzKGNoYW5nZWRUeXBlLl9lSCwgZXZlbnQsIHRyYW5zYWN0aW9uKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEFic3RyYWN0IFlqcyBUeXBlIGNsYXNzXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gbnVsbFxuICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8RXZlbnRUeXBlLFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpXG4gICAgLyoqXG4gICAgICogRGVlcCBldmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8QXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9kRUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8YW55PnxudWxsfVxuICAgKi9cbiAgZ2V0IHBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW0gPyAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5faXRlbS5wYXJlbnQpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgdGhpcy5kb2MgPSB5XG4gICAgdGhpcy5faXRlbSA9IGl0ZW1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gX2VuY29kZXJcbiAgICovXG4gIF93cml0ZSAoX2VuY29kZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3Qgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IF9maXJzdCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydFxuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBfcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgX3BhcmVudFN1YnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdGhpcy5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDBcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgb24gdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSwgVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmUgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGlzIHR5cGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmVEZWVwIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZEVILCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmUgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlRGVlcCAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgdG9KU09OICgpIHt9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0U2xpY2UgPSAodHlwZSwgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0eXBlLl9sZW5ndGggKyBzdGFydFxuICB9XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gdHlwZS5fbGVuZ3RoICsgZW5kXG4gIH1cbiAgbGV0IGxlbiA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGNzID0gW11cbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCAmJiBsZW4gPiAwKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpXG4gICAgICBpZiAoYy5sZW5ndGggPD0gc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgLT0gYy5sZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGMubGVuZ3RoICYmIGxlbiA+IDA7IGkrKykge1xuICAgICAgICAgIGNzLnB1c2goY1tpXSlcbiAgICAgICAgICBsZW4tLVxuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMFxuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodFxuICB9XG4gIHJldHVybiBjc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RUb0FycmF5ID0gdHlwZSA9PiB7XG4gIGNvbnN0IGNzID0gW11cbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4gY3Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCA9ICh0eXBlLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBjcyA9IFtdXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIGNzXG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksbnVtYmVyLGFueSk6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEZvckVhY2ggPSAodHlwZSwgZikgPT4ge1xuICBsZXQgaW5kZXggPSAwXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGNbaV0sIGluZGV4KyssIHR5cGUpXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQyxSXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEMsbnVtYmVyLEFic3RyYWN0VHlwZTxhbnk+KTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIHR5cGVMaXN0Rm9yRWFjaCh0eXBlLCAoYywgaSkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKGYoYywgaSwgdHlwZSkpXG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgKi9cbiAgbGV0IGN1cnJlbnRDb250ZW50ID0gbnVsbFxuICBsZXQgY3VycmVudENvbnRlbnRJbmRleCA9IDBcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCwgbm8gbmVlZCB0byBjaGVjayBjdXJyZW50Q29udGVudCwgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBmb3VuZCBuLCBzbyB3ZSBjYW4gc2V0IGN1cnJlbnRDb250ZW50XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgICBjdXJyZW50Q29udGVudEluZGV4ID0gMFxuICAgICAgICBuID0gbi5yaWdodCAvLyB3ZSB1c2VkIHRoZSBjb250ZW50IG9mIG4sIG5vdyBpdGVyYXRlIHRvIG5leHRcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudENvbnRlbnRbY3VycmVudENvbnRlbnRJbmRleCsrXVxuICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBlbXB0eSBjdXJyZW50Q29udGVudFxuICAgICAgaWYgKGN1cnJlbnRDb250ZW50Lmxlbmd0aCA8PSBjdXJyZW50Q29udGVudEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbnVsbFxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKiBPcGVyYXRlcyBvbiBhIHNuYXBzaG90dGVkIHN0YXRlIG9mIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxudW1iZXIsQWJzdHJhY3RUeXBlPGFueT4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0Rm9yRWFjaFNuYXBzaG90ID0gKHR5cGUsIGYsIHNuYXBzaG90KSA9PiB7XG4gIGxldCBpbmRleCA9IDBcbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiBpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYoY1tpXSwgaW5kZXgrKywgdHlwZSlcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0R2V0ID0gKHR5cGUsIGluZGV4KSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIodHlwZSwgaW5kZXgpXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucFxuICAgIGluZGV4IC09IG1hcmtlci5pbmRleFxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbi5jb250ZW50LmdldENvbnRlbnQoKVtpbmRleF1cbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtP30gcmVmZXJlbmNlSXRlbVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55Pnxib29sZWFufG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCByZWZlcmVuY2VJdGVtLCBjb250ZW50KSA9PiB7XG4gIGxldCBsZWZ0ID0gcmVmZXJlbmNlSXRlbVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgY29uc3QgcmlnaHQgPSByZWZlcmVuY2VJdGVtID09PSBudWxsID8gcGFyZW50Ll9zdGFydCA6IHJlZmVyZW5jZUl0ZW0ucmlnaHRcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxPYmplY3R8QXJyYXk8YW55PnxudW1iZXJ8bnVsbD59XG4gICAqL1xuICBsZXQganNvbkNvbnRlbnQgPSBbXVxuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpXG4gICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgIGpzb25Db250ZW50ID0gW11cbiAgICB9XG4gIH1cbiAgY29udGVudC5mb3JFYWNoKGMgPT4ge1xuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICBqc29uQ29udGVudC5wdXNoKGMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgICAganNvbkNvbnRlbnQucHVzaChjKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFja0pzb25Db250ZW50KClcbiAgICAgICAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEJpbmFyeShuZXcgVWludDhBcnJheSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovIChjKSkpKVxuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovIChjKSkpXG4gICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRUeXBlKGMpKVxuICAgICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUgaW4gaW5zZXJ0IG9wZXJhdGlvbicpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBwYWNrSnNvbkNvbnRlbnQoKVxufVxuXG5jb25zdCBsZW5ndGhFeGNlZWRlZCA9ICgpID0+IGVycm9yLmNyZWF0ZSgnTGVuZ3RoIGV4Y2VlZGVkIScpXG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGNvbnRlbnQpID0+IHtcbiAgaWYgKGluZGV4ID4gcGFyZW50Ll9sZW5ndGgpIHtcbiAgICB0aHJvdyBsZW5ndGhFeGNlZWRlZCgpXG4gIH1cbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBpbmRleCwgY29udGVudC5sZW5ndGgpXG4gICAgfVxuICAgIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbnVsbCwgY29udGVudClcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXhcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KVxuICBsZXQgbiA9IHBhcmVudC5fc3RhcnRcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucFxuICAgIGluZGV4IC09IG1hcmtlci5pbmRleFxuICAgIC8vIHdlIG5lZWQgdG8gaXRlcmF0ZSBvbmUgdG8gdGhlIGxlZnQgc28gdGhhdCB0aGUgYWxnb3JpdGhtIHdvcmtzXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAvLyBAdG9kbyByZWZhY3RvciB0aGlzIGFzIGl0IGFjdHVhbGx5IGRvZXNuJ3QgY29uc2lkZXIgZm9ybWF0c1xuICAgICAgbiA9IG4ucHJldiAvLyBpbXBvcnRhbnQhIGdldCB0aGUgbGVmdCB1bmRlbGV0ZWQgaXRlbSBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBkZWNyZWFzZSBpbmRleFxuICAgICAgaW5kZXggKz0gKG4gJiYgbi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkgPyBuLmxlbmd0aCA6IDBcbiAgICB9XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8PSBuLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGluc2VydCBpbi1iZXR3ZWVuXG4gICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCBjb250ZW50Lmxlbmd0aClcbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59XG5cbi8qKlxuICogUHVzaGluZyBjb250ZW50IGlzIHNwZWNpYWwgYXMgd2UgZ2VuZXJhbGx5IHdhbnQgdG8gcHVzaCBhZnRlciB0aGUgbGFzdCBpdGVtLiBTbyB3ZSBkb24ndCBoYXZlIHRvIHVwZGF0ZVxuICogdGhlIHNlcmFjaCBtYXJrZXIuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdFB1c2hHZW5lcmljcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjb250ZW50KSA9PiB7XG4gIC8vIFVzZSB0aGUgbWFya2VyIHdpdGggdGhlIGhpZ2hlc3QgaW5kZXggYW5kIGl0ZXJhdGUgdG8gdGhlIHJpZ2h0LlxuICBjb25zdCBtYXJrZXIgPSAocGFyZW50Ll9zZWFyY2hNYXJrZXIgfHwgW10pLnJlZHVjZSgobWF4TWFya2VyLCBjdXJyTWFya2VyKSA9PiBjdXJyTWFya2VyLmluZGV4ID4gbWF4TWFya2VyLmluZGV4ID8gY3Vyck1hcmtlciA6IG1heE1hcmtlciwgeyBpbmRleDogMCwgcDogcGFyZW50Ll9zdGFydCB9KVxuICBsZXQgbiA9IG1hcmtlci5wXG4gIGlmIChuKSB7XG4gICAgd2hpbGUgKG4ucmlnaHQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICB9XG4gIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbiwgY29udGVudClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gIGlmIChsZW5ndGggPT09IDApIHsgcmV0dXJuIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gbGVuZ3RoXG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleClcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnBcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXhcbiAgfVxuICAvLyBjb21wdXRlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIGRlbGV0ZWRcbiAgZm9yICg7IG4gIT09IG51bGwgJiYgaW5kZXggPiAwOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBpbmRleCkpXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSlcbiAgICAgIH1cbiAgICAgIG4uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgbGVuZ3RoIC09IG4ubGVuZ3RoXG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBsZW5ndGhFeGNlZWRlZCgpXG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoIC8qIGluIGNhc2Ugd2UgcmVtb3ZlIHRoZSBhYm92ZSBleGNlcHRpb24gKi8pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgYyA9IHBhcmVudC5fbWFwLmdldChrZXkpXG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBjLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IHZhbHVlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcFNldCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXksIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsXG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRFxuICBsZXQgY29udGVudFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKVxuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodmFsdWUuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRCaW5hcnkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAodmFsdWUpKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBEb2M6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKHZhbHVlKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudFR5cGUodmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgbnVsbCwgbnVsbCwgcGFyZW50LCBrZXksIGNvbnRlbnQpLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwR2V0ID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpXG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWQgPyB2YWwuY29udGVudC5nZXRDb250ZW50KClbdmFsLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZD59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fVxuICBwYXJlbnQuX21hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCF2YWx1ZS5kZWxldGVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbHVlLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbHVlLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVNYXBIYXMgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSlcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwR2V0U25hcHNob3QgPSAocGFyZW50LCBrZXksIHNuYXBzaG90KSA9PiB7XG4gIGxldCB2ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbFxuICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICB2ID0gdi5sZWZ0XG4gIH1cbiAgcmV0dXJuIHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSA/IHYuY29udGVudC5nZXRDb250ZW50KClbdi5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsT2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwR2V0QWxsU25hcHNob3QgPSAocGFyZW50LCBzbmFwc2hvdCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIGNvbnN0IHJlcyA9IHt9XG4gIHBhcmVudC5fbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCB2ID0gdmFsdWVcbiAgICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICAgIHYgPSB2LmxlZnRcbiAgICB9XG4gICAgaWYgKHYgIT09IG51bGwgJiYgaXNWaXNpYmxlKHYsIHNuYXBzaG90KSkge1xuICAgICAgcmVzW2tleV0gPSB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsSXRlbT59IG1hcFxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxBcnJheTxhbnk+Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXBJdGVyYXRvciA9IG1hcCA9PiBpdGVyYXRvci5pdGVyYXRvckZpbHRlcihtYXAuZW50cmllcygpLCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIGVudHJ5ID0+ICFlbnRyeVsxXS5kZWxldGVkKVxuIiwgIi8qKlxuICogQG1vZHVsZSBZQXJyYXlcbiAqL1xuXG5pbXBvcnQge1xuICBZRXZlbnQsXG4gIEFic3RyYWN0VHlwZSxcbiAgdHlwZUxpc3RHZXQsXG4gIHR5cGVMaXN0VG9BcnJheSxcbiAgdHlwZUxpc3RGb3JFYWNoLFxuICB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yLFxuICB0eXBlTGlzdEluc2VydEdlbmVyaWNzLFxuICB0eXBlTGlzdFB1c2hHZW5lcmljcyxcbiAgdHlwZUxpc3REZWxldGUsXG4gIHR5cGVMaXN0TWFwLFxuICBZQXJyYXlSZWZJRCxcbiAgY2FsbFR5cGVPYnNlcnZlcnMsXG4gIHRyYW5zYWN0LFxuICBBcnJheVNlYXJjaE1hcmtlciwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBEb2MsIFRyYW5zYWN0aW9uLCBJdGVtIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuaW1wb3J0IHsgdHlwZUxpc3RTbGljZSB9IGZyb20gJy4vQWJzdHJhY3RUeXBlLmpzJ1xuXG4vKipcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWUFycmF5XG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgWUV2ZW50PFlBcnJheTxUPj5cbiAqL1xuZXhwb3J0IGNsYXNzIFlBcnJheUV2ZW50IGV4dGVuZHMgWUV2ZW50IHt9XG5cbi8qKlxuICogQSBzaGFyZWQgQXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlBcnJheUV2ZW50PFQ+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFQ+fVxuICovXG5leHBvcnQgY2xhc3MgWUFycmF5IGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW11cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdXG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IFlBcnJheSBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgaXRlbXMuXG4gICAqIEB0ZW1wbGF0ZSB7T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXl9IFRcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gaXRlbXNcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgc3RhdGljIGZyb20gKGl0ZW1zKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lBcnJheTxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBhID0gbmV3IFlBcnJheSgpXG4gICAgYS5wdXNoKGl0ZW1zKVxuICAgIHJldHVybiBhXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKVxuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWUFycmF5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lBcnJheTxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBhcnIgPSBuZXcgWUFycmF5KClcbiAgICBhcnIuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChlbCA9PlxuICAgICAgZWwgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyAvKiogQHR5cGUge3R5cGVvZiBlbH0gKi8gKGVsLmNsb25lKCkpIDogZWxcbiAgICApKVxuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVsaW1Db250ZW50ID09PSBudWxsID8gdGhpcy5fbGVuZ3RoIDogdGhpcy5fcHJlbGltQ29udGVudC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlBcnJheUV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpXG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZQXJyYXlFdmVudCh0aGlzLCB0cmFuc2FjdGlvbikpXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICogaXMgdmVyeSBlZmZpY2llbnQgd2hlbiBpdCBpcyBkb25lIGFzIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICogIHlhcnJheS5pbnNlcnQoMSwgWzEsIDJdKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0LlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAdG9kbyBVc2UgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbiBhbGwgdHlwZXMuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdFB1c2hHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnB1c2goLi4uY29udGVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoID0gMSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3REZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBsZW5ndGgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIGxlbmd0aClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtUfVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBvcnRpb24gb2YgdGhpcyBZQXJyYXkgaW50byBhIEphdmFTY3JpcHQgQXJyYXkgc2VsZWN0ZWRcbiAgICogZnJvbSBzdGFydCB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8VD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChjID0+IGMgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBjLnRvSlNPTigpIDogYylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEFycmF5IHdpdGggdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gZXZlcnlcbiAgICogZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHRlbXBsYXRlIE1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOk19IGYgRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgQXJyYXlcbiAgICogQHJldHVybiB7QXJyYXk8TT59IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgbWFwIChmKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIC8qKiBAdHlwZSB7YW55fSAqLyAoZikpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWUFycmF5UmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWUFycmF5ID0gX2RlY29kZXIgPT4gbmV3IFlBcnJheSgpXG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlNYXBcbiAqL1xuXG5pbXBvcnQge1xuICBZRXZlbnQsXG4gIEFic3RyYWN0VHlwZSxcbiAgdHlwZU1hcERlbGV0ZSxcbiAgdHlwZU1hcFNldCxcbiAgdHlwZU1hcEdldCxcbiAgdHlwZU1hcEhhcyxcbiAgY3JlYXRlTWFwSXRlcmF0b3IsXG4gIFlNYXBSZWZJRCxcbiAgY2FsbFR5cGVPYnNlcnZlcnMsXG4gIHRyYW5zYWN0LFxuICBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIERvYywgVHJhbnNhY3Rpb24sIEl0ZW0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGl0ZXJhdG9yIGZyb20gJ2xpYjAvaXRlcmF0b3InXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIFlFdmVudDxZTWFwPFQ+PlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZTWFwLlxuICovXG5leHBvcnQgY2xhc3MgWU1hcEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WU1hcDxUPn0geW1hcCBUaGUgWUFycmF5IHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeW1hcCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5bWFwLCB0cmFuc2FjdGlvbilcbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gc3Vic1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIE1hcFR5cGVcbiAqIEEgc2hhcmVkIE1hcCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WU1hcEV2ZW50PE1hcFR5cGU+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFtzdHJpbmcsIE1hcFR5cGVdPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFlNYXAgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtJdGVyYWJsZTxyZWFkb25seSBbc3RyaW5nLCBhbnldPj19IGVudHJpZXMgLSBhbiBvcHRpb25hbCBpdGVyYWJsZSB0byBpbml0aWFsaXplIHRoZSBZTWFwXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW50cmllcykge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsXG5cbiAgICBpZiAoZW50cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBuZXcgTWFwKGVudHJpZXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WU1hcDxNYXBUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lNYXA8TWFwVHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lNYXA8TWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0gbmV3IFlNYXAoKVxuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gLyoqIEB0eXBlIHt0eXBlb2YgdmFsdWV9ICovICh2YWx1ZS5jbG9uZSgpKSA6IHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWU1hcEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWU1hcEV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxNYXBUeXBlPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fVxuICAgIHRoaXMuX21hcC5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IHYgPSBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpW2l0ZW0ubGVuZ3RoIC0gMV1cbiAgICAgICAgbWFwW2tleV0gPSB2IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdi50b0pTT04oKSA6IHZcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBZTWFwIChjb3VudCBvZiBrZXkvdmFsdWUgcGFpcnMpXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplICgpIHtcbiAgICByZXR1cm4gWy4uLmNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCldLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz59XG4gICAqL1xuICBrZXlzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlswXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPE1hcFR5cGU+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSXRlcmF0b3Igb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8W3N0cmluZywgTWFwVHlwZV0+fVxuICAgKi9cbiAgZW50cmllcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IC8qKiBAdHlwZSB7YW55fSAqLyAoW3ZbMF0sIHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXV0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBrZXktdmFsdWUgcGFpci5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihNYXBUeXBlLHN0cmluZyxZTWFwPE1hcFR5cGU+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHRoaXMuX21hcC5mb3JFYWNoKChpdGVtLCBrZXkpID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGYoaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdLCBrZXksIHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEl0ZXJhdG9yIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIE1hcFR5cGVdPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBrZXkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5kZWxldGUoa2V5KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSB7TWFwVHlwZX0gVkFMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhpcyBZTWFwXG4gICAqIEBwYXJhbSB7VkFMfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqIEByZXR1cm4ge1ZBTH1cbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywga2V5LCAvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLnNldChrZXksIHZhbHVlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7TWFwVHlwZXx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgKGtleSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywga2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXMgKGtleSkge1xuICAgIHJldHVybiB0eXBlTWFwSGFzKHRoaXMsIGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoaXMgWU1hcC5cbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBrZXksIG1hcCkge1xuICAgICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIG1hcCwga2V5KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuY2xlYXIoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWU1hcFJlZklEKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFlNYXAgPSBfZGVjb2RlciA9PiBuZXcgWU1hcCgpXG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlUZXh0XG4gKi9cblxuaW1wb3J0IHtcbiAgWUV2ZW50LFxuICBBYnN0cmFjdFR5cGUsXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICBnZXRTdGF0ZSxcbiAgaXNWaXNpYmxlLFxuICBjcmVhdGVJRCxcbiAgWVRleHRSZWZJRCxcbiAgY2FsbFR5cGVPYnNlcnZlcnMsXG4gIHRyYW5zYWN0LFxuICBDb250ZW50RW1iZWQsXG4gIEdDLFxuICBDb250ZW50Rm9ybWF0LFxuICBDb250ZW50U3RyaW5nLFxuICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLFxuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHMsXG4gIGl0ZXJhdGVTdHJ1Y3RzLFxuICBmaW5kTWFya2VyLFxuICB0eXBlTWFwRGVsZXRlLFxuICB0eXBlTWFwU2V0LFxuICB0eXBlTWFwR2V0LFxuICB0eXBlTWFwR2V0QWxsLFxuICB1cGRhdGVNYXJrZXJDaGFuZ2VzLFxuICBDb250ZW50VHlwZSxcbiAgQXJyYXlTZWFyY2hNYXJrZXIsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgSUQsIERvYywgSXRlbSwgU25hcHNob3QsIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChhLCBiKSA9PiBhID09PSBiIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYiAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKVxuXG5leHBvcnQgY2xhc3MgSXRlbVRleHRMaXN0UG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCwgaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdFxuICAgIHRoaXMucmlnaHQgPSByaWdodFxuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZXMgPSBjdXJyZW50QXR0cmlidXRlc1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgY2FsbCB0aGlzIGlmIHlvdSBrbm93IHRoYXQgdGhpcy5yaWdodCBpcyBkZWZpbmVkXG4gICAqL1xuICBmb3J3YXJkICgpIHtcbiAgICBpZiAodGhpcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHRoaXMuY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKHRoaXMucmlnaHQuY29udGVudCkpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCArPSB0aGlzLnJpZ2h0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRoaXMubGVmdCA9IHRoaXMucmlnaHRcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5yaWdodFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IHBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IHN0ZXBzIHRvIG1vdmUgZm9yd2FyZFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kTmV4dFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwb3MsIGNvdW50KSA9PiB7XG4gIHdoaWxlIChwb3MucmlnaHQgIT09IG51bGwgJiYgY291bnQgPiAwKSB7XG4gICAgc3dpdGNoIChwb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMocG9zLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChwb3MucmlnaHQuY29udGVudCkpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghcG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICBpZiAoY291bnQgPCBwb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByaWdodFxuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKHBvcy5yaWdodC5pZC5jbGllbnQsIHBvcy5yaWdodC5pZC5jbG9jayArIGNvdW50KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zLmluZGV4ICs9IHBvcy5yaWdodC5sZW5ndGhcbiAgICAgICAgICBjb3VudCAtPSBwb3MucmlnaHQubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcG9zLmxlZnQgPSBwb3MucmlnaHRcbiAgICBwb3MucmlnaHQgPSBwb3MucmlnaHQucmlnaHRcbiAgICAvLyBwb3MuZm9yd2FyZCgpIC0gd2UgZG9uJ3QgZm9yd2FyZCBiZWNhdXNlIHRoYXQgd291bGQgaGFsdmUgdGhlIHBlcmZvcm1hbmNlIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgY2hlY2tzIGFib3ZlXG4gIH1cbiAgcmV0dXJuIHBvc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSB1c2VTZWFyY2hNYXJrZXJcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCB1c2VTZWFyY2hNYXJrZXIpID0+IHtcbiAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgY29uc3QgbWFya2VyID0gdXNlU2VhcmNoTWFya2VyID8gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KSA6IG51bGxcbiAgaWYgKG1hcmtlcikge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihtYXJrZXIucC5sZWZ0LCBtYXJrZXIucCwgbWFya2VyLmluZGV4LCBjdXJyZW50QXR0cmlidXRlcylcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleCAtIG1hcmtlci5pbmRleClcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgcGFyZW50Ll9zdGFydCwgMCwgY3VycmVudEF0dHJpYnV0ZXMpXG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXgpXG4gIH1cbn1cblxuLyoqXG4gKiBOZWdhdGUgYXBwbGllZCBmb3JtYXRzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcykgPT4ge1xuICAvLyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCB0byByZW1vdmUgYXR0cmlidXRlc1xuICB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJiAoXG4gICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IHRydWUgfHwgKFxuICAgICAgICBjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiZcbiAgICAgICAgZXF1YWxBdHRycyhuZWdhdGVkQXR0cmlidXRlcy5nZXQoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZSgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSlcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgbmVnYXRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gY3VyclBvcy5sZWZ0XG4gICAgY29uc3QgcmlnaHQgPSBjdXJyUG9zLnJpZ2h0XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpXG4gICAgbmV4dEZvcm1hdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgY3VyclBvcy5yaWdodCA9IG5leHRGb3JtYXRcbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBmb3JtYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzID0gKGN1cnJlbnRBdHRyaWJ1dGVzLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBmb3JtYXRcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKGtleSlcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMgPSAoY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICAvLyBnbyByaWdodCB3aGlsZSBhdHRyaWJ1dGVzW3JpZ2h0LmtleV0gPT09IHJpZ2h0LnZhbHVlIChvciByaWdodCBpcyBkZWxldGVkKVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjdXJyUG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoY3VyclBvcy5yaWdodC5kZWxldGVkIHx8IChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiYgZXF1YWxBdHRycyhhdHRyaWJ1dGVzWygvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpKS5rZXldID8/IG51bGwsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkudmFsdWUpKSkge1xuICAgICAgLy9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtNYXA8c3RyaW5nLGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0QXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRFxuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKVxuICAvLyBpbnNlcnQgZm9ybWF0LXN0YXJ0IGl0ZW1zXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB2YWwgPSBhdHRyaWJ1dGVzW2tleV1cbiAgICBjb25zdCBjdXJyZW50VmFsID0gY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSA/PyBudWxsXG4gICAgaWYgKCFlcXVhbEF0dHJzKGN1cnJlbnRWYWwsIHZhbCkpIHtcbiAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbClcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGN1cnJQb3NcbiAgICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKVxuICAgICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgICBjdXJyUG9zLmZvcndhcmQoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVnYXRlZEF0dHJpYnV0ZXNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT59IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgoX3ZhbCwga2V5KSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBudWxsXG4gICAgfVxuICB9KVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpXG4gIGNvbnN0IG5lZ2F0ZWRBdHRyaWJ1dGVzID0gaW5zZXJ0QXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKVxuICAvLyBpbnNlcnQgY29udGVudFxuICBjb25zdCBjb250ZW50ID0gdGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbmV3IENvbnRlbnRTdHJpbmcoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0KSkgOiAodGV4dCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IG5ldyBDb250ZW50VHlwZSh0ZXh0KSA6IG5ldyBDb250ZW50RW1iZWQodGV4dCkpXG4gIGxldCB7IGxlZnQsIHJpZ2h0LCBpbmRleCB9ID0gY3VyclBvc1xuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBjdXJyUG9zLmluZGV4LCBjb250ZW50LmdldExlbmd0aCgpKVxuICB9XG4gIHJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpXG4gIHJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgY3VyclBvcy5yaWdodCA9IHJpZ2h0XG4gIGN1cnJQb3MuaW5kZXggPSBpbmRleFxuICBjdXJyUG9zLmZvcndhcmQoKVxuICBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZm9ybWF0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEXG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKVxuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcylcbiAgLy8gaXRlcmF0ZSB1bnRpbCBmaXJzdCBub24tZm9ybWF0IG9yIG51bGwgaXMgZm91bmRcbiAgLy8gZGVsZXRlIGFsbCBmb3JtYXRzIHdpdGggYXR0cmlidXRlc1tmb3JtYXQua2V5XSAhPSBudWxsXG4gIC8vIGFsc28gY2hlY2sgdGhlIGF0dHJpYnV0ZXMgYWZ0ZXIgdGhlIGZpcnN0IG5vbi1mb3JtYXQgYXMgd2UgZG8gbm90IHdhbnQgdG8gaW5zZXJ0IHJlZHVuZGFudCBuZWdhdGVkIGF0dHJpYnV0ZXMgdGhlcmVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICBpdGVyYXRpb25Mb29wOiB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJlxuICAgIChsZW5ndGggPiAwIHx8XG4gICAgICAoXG4gICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNpemUgPiAwICYmXG4gICAgICAgIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KVxuICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBuZWVkIHRvIGZ1cnRoZXIgZXh0ZW5kIG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgICAgIGJyZWFrIGl0ZXJhdGlvbkxvb3BcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGhcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9XG4gIC8vIFF1aWxsIGp1c3QgYXNzdW1lcyB0aGF0IHRoZSBlZGl0b3Igc3RhcnRzIHdpdGggYSBuZXdsaW5lIGFuZCB0aGF0IGl0IGFsd2F5c1xuICAvLyBlbmRzIHdpdGggYSBuZXdsaW5lLiBXZSBvbmx5IGluc2VydCB0aGF0IG5ld2xpbmUgd2hlbiBhIG5ldyBuZXdsaW5lIGlzXG4gIC8vIGluc2VydGVkIC0gaS5lIHdoZW4gbGVuZ3RoIGlzIGJpZ2dlciB0aGFuIHR5cGUubGVuZ3RoXG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgbGV0IG5ld2xpbmVzID0gJydcbiAgICBmb3IgKDsgbGVuZ3RoID4gMDsgbGVuZ3RoLS0pIHtcbiAgICAgIG5ld2xpbmVzICs9ICdcXG4nXG4gICAgfVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBjdXJyUG9zLmxlZnQsIGN1cnJQb3MubGVmdCAmJiBjdXJyUG9zLmxlZnQubGFzdElkLCBjdXJyUG9zLnJpZ2h0LCBjdXJyUG9zLnJpZ2h0ICYmIGN1cnJQb3MucmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRTdHJpbmcobmV3bGluZXMpKVxuICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpXG4gIH1cbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpXG59XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHN0cmluZyBjb250ZW50IGhhcyBiZWVuIGRlbGV0ZWQgaW4gb3JkZXIgdG9cbiAqIGNsZWFuIHVwIGZvcm1hdHRpbmcgSXRlbXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gc3RhcnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjdXJyIGV4Y2x1c2l2ZSBlbmQsIGF1dG9tYXRpY2FsbHkgaXRlcmF0ZXMgdG8gdGhlIG5leHQgQ29udGVudCBJdGVtXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gc3RhcnRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VyckF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBvZiBmb3JtYXR0aW5nIEl0ZW1zIGRlbGV0ZWQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNsZWFudXBGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBzdGFydCwgY3Vyciwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyQXR0cmlidXRlcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBlbmQgPSBzdGFydFxuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsQ29udGVudEZvcm1hdD59XG4gICAqL1xuICBjb25zdCBlbmRGb3JtYXRzID0gbWFwLmNyZWF0ZSgpXG4gIHdoaWxlIChlbmQgJiYgKCFlbmQuY291bnRhYmxlIHx8IGVuZC5kZWxldGVkKSkge1xuICAgIGlmICghZW5kLmRlbGV0ZWQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGNmID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpXG4gICAgICBlbmRGb3JtYXRzLnNldChjZi5rZXksIGNmKVxuICAgIH1cbiAgICBlbmQgPSBlbmQucmlnaHRcbiAgfVxuICBsZXQgY2xlYW51cHMgPSAwXG4gIGxldCByZWFjaGVkQ3VyciA9IGZhbHNlXG4gIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKGN1cnIgPT09IHN0YXJ0KSB7XG4gICAgICByZWFjaGVkQ3VyciA9IHRydWVcbiAgICB9XG4gICAgaWYgKCFzdGFydC5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gc3RhcnQuY29udGVudFxuICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudClcbiAgICAgICAgICBjb25zdCBzdGFydEF0dHJWYWx1ZSA9IHN0YXJ0QXR0cmlidXRlcy5nZXQoa2V5KSA/PyBudWxsXG4gICAgICAgICAgaWYgKGVuZEZvcm1hdHMuZ2V0KGtleSkgIT09IGNvbnRlbnQgfHwgc3RhcnRBdHRyVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgdGhpcyBmb3JtYXQgaXMgb3ZlcndyaXR0ZW4gb3IgaXQgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdGVkLlxuICAgICAgICAgICAgc3RhcnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgY2xlYW51cHMrK1xuICAgICAgICAgICAgaWYgKCFyZWFjaGVkQ3VyciAmJiAoY3VyckF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbCkgPT09IHZhbHVlICYmIHN0YXJ0QXR0clZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnRBdHRyVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyQXR0cmlidXRlcy5kZWxldGUoa2V5KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJBdHRyaWJ1dGVzLnNldChrZXksIHN0YXJ0QXR0clZhbHVlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVhY2hlZEN1cnIgJiYgIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KVxuICB9XG4gIHJldHVybiBjbGVhbnVwc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbmNvbnN0IGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIGl0ZW0pID0+IHtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBpdGVtLnJpZ2h0IGlzIG51bGwgb3IgY29udGVudFxuICB3aGlsZSAoaXRlbSAmJiBpdGVtLnJpZ2h0ICYmIChpdGVtLnJpZ2h0LmRlbGV0ZWQgfHwgIWl0ZW0ucmlnaHQuY291bnRhYmxlKSkge1xuICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBuZXcgU2V0KClcbiAgLy8gaXRlcmF0ZSBiYWNrIHVudGlsIGEgY29udGVudCBpdGVtIGlzIGZvdW5kXG4gIHdoaWxlIChpdGVtICYmIChpdGVtLmRlbGV0ZWQgfHwgIWl0ZW0uY291bnRhYmxlKSkge1xuICAgIGlmICghaXRlbS5kZWxldGVkICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KS5rZXlcbiAgICAgIGlmIChhdHRycy5oYXMoa2V5KSkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLmFkZChrZXkpXG4gICAgICB9XG4gICAgfVxuICAgIGl0ZW0gPSBpdGVtLmxlZnRcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSAvIGJlIHJlbW92ZWQuXG4gKlxuICogSWRlYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGF0IGFsbC4gRm9ybWF0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBjbGVhbmVkIHVwXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGVhY2ggY2hhbmdlLiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHR3aWNlIG92ZXIgdGhlIGNvbXBsZXRlIFlUZXh0IHR5cGVcbiAqIGFuZCByZW1vdmVzIHVubmVjZXNzYXJ5IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4gVGhpcyBpcyBhbHNvIGhlbHBmdWwgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBleHBvcnRlZCBhbnltb3JlIGFzIHNvb24gYXMgdGhlcmUgaXMgY29uZmlkZW5jZSB0aGF0IHRoZSBZVGV4dCB0eXBlIHdvcmtzIGFzIGludGVuZGVkLlxuICpcbiAqIEBwYXJhbSB7WVRleHR9IHR5cGVcbiAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjbGVhbmVkIHVwLlxuICovXG5leHBvcnQgY29uc3QgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyA9IHR5cGUgPT4ge1xuICBsZXQgcmVzID0gMFxuICB0cmFuc2FjdCgvKiogQHR5cGUge0RvY30gKi8gKHR5cGUuZG9jKSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHR5cGUuX3N0YXJ0KVxuICAgIGxldCBlbmQgPSB0eXBlLl9zdGFydFxuICAgIGxldCBzdGFydEF0dHJpYnV0ZXMgPSBtYXAuY3JlYXRlKClcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG1hcC5jb3B5KHN0YXJ0QXR0cmlidXRlcylcbiAgICB3aGlsZSAoZW5kKSB7XG4gICAgICBpZiAoZW5kLmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHN3aXRjaCAoZW5kLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoZW5kLmNvbnRlbnQpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzICs9IGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgZW5kLCBzdGFydEF0dHJpYnV0ZXMsIGN1cnJlbnRBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgc3RhcnRBdHRyaWJ1dGVzID0gbWFwLmNvcHkoY3VycmVudEF0dHJpYnV0ZXMpXG4gICAgICAgICAgICBzdGFydCA9IGVuZFxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gZW5kLnJpZ2h0XG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogVGhpcyB3aWxsIGJlIGNhbGxlZCBieSB0aGUgdHJhbnNjdGlvbiBvbmNlIHRoZSBldmVudCBoYW5kbGVycyBhcmUgY2FsbGVkIHRvIHBvdGVudGlhbGx5IGNsZWFudXBcbiAqIGZvcm1hdHRpbmcgYXR0cmlidXRlcy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICovXG5leHBvcnQgY29uc3QgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTZXQ8WVRleHQ+fVxuICAgKi9cbiAgY29uc3QgbmVlZEZ1bGxDbGVhbnVwID0gbmV3IFNldCgpXG4gIC8vIGNoZWNrIGlmIGFub3RoZXIgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZFxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgZm9yIChjb25zdCBbY2xpZW50LCBhZnRlckNsb2NrXSBvZiB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMFxuICAgIGlmIChhZnRlckNsb2NrID09PSBjbG9jaykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QXJyYXk8SXRlbXxHQz59ICovIChkb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSksIGNsb2NrLCBhZnRlckNsb2NrLCBpdGVtID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWl0ZW0uZGVsZXRlZCAmJiAvKiogQHR5cGUge0l0ZW19ICovIChpdGVtKS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGl0ZW0uY29uc3RydWN0b3IgIT09IEdDXG4gICAgICApIHtcbiAgICAgICAgbmVlZEZ1bGxDbGVhbnVwLmFkZCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudClcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIC8vIGNsZWFudXAgaW4gYSBuZXcgdHJhbnNhY3Rpb25cbiAgdHJhbnNhY3QoZG9jLCAodCkgPT4ge1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MgfHwgISgvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpLl9oYXNGb3JtYXR0aW5nKSB8fCBuZWVkRnVsbENsZWFudXAuaGFzKC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudCkpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtZVGV4dH0gKi8gKGl0ZW0ucGFyZW50KVxuICAgICAgaWYgKGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuZWVkRnVsbENsZWFudXAuYWRkKHBhcmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIGZvcm1hdHRpbmcgYXR0cmlidXRlIHdhcyBpbnNlcnRlZCBvciBkZWxldGVkLCB3ZSBjYW4gbWFrZSBkdWUgd2l0aCBjb250ZXh0bGVzc1xuICAgICAgICAvLyBmb3JtYXR0aW5nIGNsZWFudXBzLlxuICAgICAgICAvLyBDb250ZXh0bGVzczogaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgYWZmZWN0ZWQgcG9zaXRpb24uXG4gICAgICAgIGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAodCwgaXRlbSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIElmIGEgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZCwgd2Ugc2ltcGx5IGNsZWFuIHRoZSB3aG9sZSB0eXBlLlxuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW55d2F5LlxuICAgIGZvciAoY29uc3QgeVRleHQgb2YgbmVlZEZ1bGxDbGVhbnVwKSB7XG4gICAgICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nKHlUZXh0KVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGhcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG1hcC5jb3B5KGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpXG4gIGNvbnN0IHN0YXJ0ID0gY3VyclBvcy5yaWdodFxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGhcbiAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9XG4gIGlmIChzdGFydCkge1xuICAgIGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgY3VyclBvcy5yaWdodCwgc3RhcnRBdHRycywgY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcylcbiAgfVxuICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoLyoqIEB0eXBlIHtJdGVtfSAqLyAoY3VyclBvcy5sZWZ0IHx8IGN1cnJQb3MucmlnaHQpLnBhcmVudClcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKVxuICB9XG4gIHJldHVybiBjdXJyUG9zXG59XG5cbi8qKlxuICogVGhlIFF1aWxsIERlbHRhIGZvcm1hdCByZXByZXNlbnRzIGNoYW5nZXMgb24gYSB0ZXh0IGRvY3VtZW50IHdpdGhcbiAqIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uIEZvciBtb3IgaW5mb3JtYXRpb24gdmlzaXQge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9XG4gKlxuICogQGV4YW1wbGVcbiAqICAge1xuICogICAgIG9wczogW1xuICogICAgICAgeyBpbnNlcnQ6ICdHYW5kYWxmJywgYXR0cmlidXRlczogeyBib2xkOiB0cnVlIH0gfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnIHRoZSAnIH0sXG4gKiAgICAgICB7IGluc2VydDogJ0dyZXknLCBhdHRyaWJ1dGVzOiB7IGNvbG9yOiAnI2NjY2NjYycgfSB9XG4gKiAgICAgXVxuICogICB9XG4gKlxuICovXG5cbi8qKlxuICAqIEF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYSBzZWxlY3Rpb24gb2YgdGV4dC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogICB7XG4gICogICAgIGJvbGQ6IHRydWUsXG4gICogICAgIGZvbnQtc2l6ZTogJzQwcHgnXG4gICogICB9XG4gICpcbiAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0QXR0cmlidXRlc1xuICAqL1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZVGV4dD5cbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVRleHQgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFlUZXh0RXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZVGV4dH0geXRleHRcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5dGV4dCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5dGV4dCwgdHJhbnNhY3Rpb24pXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KClcbiAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgaWYgKHN1YiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoaWxkTGlzdENoYW5nZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmtleXNDaGFuZ2VkLmFkZChzdWIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGlmICh0aGlzLl9jaGFuZ2VzID09PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nfEFic3RyYWN0VHlwZTxhbnk+fG9iamVjdCwgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgICAgICovXG4gICAgICBjb25zdCBjaGFuZ2VzID0ge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICBhZGRlZDogbmV3IFNldCgpLFxuICAgICAgICBkZWxldGVkOiBuZXcgU2V0KClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzXG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2NoYW5nZXMpXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIGlmICh0aGlzLl9kZWx0YSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgeSA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy50YXJnZXQuZG9jKVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86c3RyaW5nfG9iamVjdHxBYnN0cmFjdFR5cGU8YW55PiwgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZyxhbnk+fT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbHRhID0gW11cbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCkgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnRhcmdldC5fc3RhcnRcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmc/fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGFjdGlvbiA9IG51bGxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge30gLy8gY291bnRzIGFkZGVkIG9yIHJlbW92ZWQgbmV3IGF0dHJpYnV0ZXMgZm9yIHJldGFpblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaW5zZXJ0ID0gJydcbiAgICAgICAgbGV0IHJldGFpbiA9IDBcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDBcbiAgICAgICAgY29uc3QgYWRkT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgb3AgPSBudWxsXG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0JzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluc2VydCA9PT0gJ29iamVjdCcgfHwgaW5zZXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wID0geyBpbnNlcnQgfVxuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0gJydcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdyZXRhaW4nOlxuICAgICAgICAgICAgICAgIGlmIChyZXRhaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgcmV0YWluIH1cbiAgICAgICAgICAgICAgICAgIGlmICghb2JqZWN0LmlzRW1wdHkoYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IG9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiA9IDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wKSBkZWx0YS5wdXNoKG9wKVxuICAgICAgICAgICAgYWN0aW9uID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCdcbiAgICAgICAgICAgICAgICAgIGluc2VydCA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbMF1cbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0J1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5zZXJ0ICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGl0ZW0uY29udGVudCkuc3RyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gaXRlbS5sZW5ndGhcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLmxlbmd0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpXG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbFxuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKHZhbHVlLCAob2xkQXR0cmlidXRlcy5nZXQoa2V5KSA/PyBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSA/PyBudWxsXG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBjdXJWYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXR0ciAhPT0gbnVsbCkgeyAvLyB0aGlzIHdpbGwgYmUgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBjb250ZXh0bGVzcyBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3AoKVxuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdXG4gICAgICAgICAgaWYgKGxhc3RPcC5yZXRhaW4gIT09IHVuZGVmaW5lZCAmJiBsYXN0T3AuYXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXRhaW4gZGVsdGEncyBpZiB0aGV5IGRvbid0IGFzc2lnbiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBkZWx0YS5wb3AoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGFcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodGhpcy5fZGVsdGEpXG4gIH1cbn1cblxuLyoqXG4gKiBUeXBlIHRoYXQgcmVwcmVzZW50cyB0ZXh0IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUaGlzIHR5cGUgcmVwbGFjZXMgeS1yaWNodGV4dCBhcyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGFibGUgdG8gaGFuZGxlXG4gKiBibG9jayBmb3JtYXRzIChmb3JtYXQgaW5mb3JtYXRpb24gb24gYSBwYXJhZ3JhcGgpLCBlbWJlZHMgKGNvbXBsZXggZWxlbWVudHNcbiAqIGxpa2UgcGljdHVyZXMgYW5kIHZpZGVvcyksIGFuZCB0ZXh0IGZvcm1hdHMgKCoqYm9sZCoqLCAqaXRhbGljKikuXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlUZXh0RXZlbnQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBwZW5kaW5nIG9wZXJhdGlvbnMgb24gdGhpcyB0eXBlXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD4/fVxuICAgICAqL1xuICAgIHRoaXMuX3BlbmRpbmcgPSBzdHJpbmcgIT09IHVuZGVmaW5lZCA/IFsoKSA9PiB0aGlzLmluc2VydCgwLCBzdHJpbmcpXSA6IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIFlUZXh0IGNvbnRhaW5zIGZvcm1hdHRpbmcgYXR0cmlidXRlcy5cbiAgICAgKiBUaGlzIGZsYWcgaXMgdXBkYXRlZCB3aGVuIGEgZm9ybWF0dGluZyBpdGVtIGlzIGludGVncmF0ZWQgKHNlZSBDb250ZW50Rm9ybWF0LmludGVncmF0ZSlcbiAgICAgKi9cbiAgICB0aGlzLl9oYXNGb3JtYXR0aW5nID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY2hhcmFjdGVycyBvZiB0aGlzIHRleHQgdHlwZS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykuZm9yRWFjaChmID0+IGYoKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmcgPSBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZVGV4dCgpXG4gICAgdGV4dC5hcHBseURlbHRhKHRoaXMudG9EZWx0YSgpKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZVGV4dEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpXG4gICAgY29uc3QgZXZlbnQgPSBuZXcgWVRleHRFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicylcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgZXZlbnQpXG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdGhpcy5faGFzRm9ybWF0dGluZykge1xuICAgICAgdHJhbnNhY3Rpb24uX25lZWRGb3JtYXR0aW5nQ2xlYW51cCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGxldCBzdHIgPSAnJ1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydFxuICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyXG4gICAgICB9XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGRlbHRhIFRoZSBjaGFuZ2VzIHRvIGFwcGx5IG9uIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIHtvYmplY3R9ICBvcHRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2FuaXRpemVdIFNhbml0aXplIGlucHV0IGRlbHRhLiBSZW1vdmVzIGVuZGluZyBuZXdsaW5lcyBpZiBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYXBwbHlEZWx0YSAoZGVsdGEsIHsgc2FuaXRpemUgPSB0cnVlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VyclBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCB0aGlzLl9zdGFydCwgMCwgbmV3IE1hcCgpKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSBkZWx0YVtpXVxuICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUXVpbGwgYXNzdW1lcyB0aGF0IHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIGFuIGVtcHR5IHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFlqcy9ZLlRleHQgYXNzdW1lcyB0aGF0IGl0IHN0YXJ0cyBlbXB0eS4gV2UgYWx3YXlzIGhpZGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBJZiB3ZSBvbWl0IHRoaXMgc3RlcCwgY2xpZW50cyB3aWxsIHNlZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaHMsIGJ1dCBub3RoaW5nIGJhZCB3aWxsIGhhcHBlbi5cbiAgICAgICAgICAgIGNvbnN0IGlucyA9ICghc2FuaXRpemUgJiYgdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgaSA9PT0gZGVsdGEubGVuZ3RoIC0gMSAmJiBjdXJyUG9zLnJpZ2h0ID09PSBudWxsICYmIG9wLmluc2VydC5zbGljZSgtMSkgPT09ICdcXG4nKSA/IG9wLmluc2VydC5zbGljZSgwLCAtMSkgOiBvcC5pbnNlcnRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zICE9PSAnc3RyaW5nJyB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBpbnMsIG9wLmF0dHJpYnV0ZXMgfHwge30pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yZXRhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgb3AucmV0YWluLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgICAgIH0gZWxzZSBpZiAob3AuZGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGN1cnJQb3MsIG9wLmRlbGV0ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBJRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9EZWx0YSAoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZXtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9wcyA9IFtdXG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKVxuICAgIGxldCBzdHIgPSAnJ1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnRcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9XG4gICAgICAgIGxldCBhZGRBdHRyaWJ1dGVzID0gZmFsc2VcbiAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgIGFkZEF0dHJpYnV0ZXMgPSB0cnVlXG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBvcCA9IHsgaW5zZXJ0OiBzdHIgfVxuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzXG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2gob3ApXG4gICAgICAgIHN0ciA9ICcnXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVEZWx0YSA9ICgpID0+IHtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpXG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1ciA9PT0gdW5kZWZpbmVkIHx8IGN1ci51c2VyICE9PSBuLmlkLmNsaWVudCB8fCBjdXIudHlwZSAhPT0gJ3JlbW92ZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKClcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCBuLmlkKSA6IHsgdHlwZTogJ3JlbW92ZWQnIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgnYWRkZWQnLCBuLmlkKSA6IHsgdHlwZTogJ2FkZGVkJyB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgICAgcGFja1N0cigpXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cnMgPSAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn0gKi8gKHt9KVxuICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyc1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3BzLnB1c2gob3ApXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpXG4gICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKG4uY29udGVudCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ucmlnaHRcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKVxuICAgIH1cbiAgICBpZiAoc25hcHNob3QgfHwgcHJldlNuYXBzaG90KSB7XG4gICAgICAvLyBzbmFwc2hvdHMgYXJlIG1lcmdlZCBhZ2FpbiBhZnRlciB0aGUgdHJhbnNhY3Rpb24sIHNvIHdlIG5lZWQgdG8ga2VlcCB0aGVcbiAgICAgIC8vIHRyYW5zYWN0aW9uIGFsaXZlIHVudGlsIHdlIGFyZSBkb25lXG4gICAgICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTbmFwc2hvdCkge1xuICAgICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdClcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlRGVsdGEoKVxuICAgICAgfSwgJ2NsZWFudXAnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlRGVsdGEoKVxuICAgIH1cbiAgICByZXR1cm4gb3BzXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGluc2VydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gT3B0aW9uYWxseSBkZWZpbmUgc29tZSBmb3JtYXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlIGluc2VydGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jXG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgIWF0dHJpYnV0ZXMpXG4gICAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMgPSB7fVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBwb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodiwgaykgPT4geyBhdHRyaWJ1dGVzW2tdID0gdiB9KVxuICAgICAgICB9XG4gICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgdGV4dCwgYXR0cmlidXRlcylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gZW1iZWQgYXQgYSBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgdGhlIGVtYmVkIGF0LlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+fSBlbWJlZCBUaGUgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZW1iZWQuXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHkgPSB0aGlzLmRvY1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsICFhdHRyaWJ1dGVzKVxuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGVtYmVkLCBhdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuaW5zZXJ0RW1iZWQoaW5kZXgsIGVtYmVkLCBhdHRyaWJ1dGVzIHx8IHt9KSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jXG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgZGVsZXRlVGV4dCh0cmFuc2FjdGlvbiwgZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgdHJ1ZSksIGxlbmd0aClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmRlbGV0ZShpbmRleCwgbGVuZ3RoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBwcm9wZXJ0aWVzIHRvIGEgcmFuZ2Ugb2YgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBmb3JtYXR0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBhc3NpZ24gcHJvcGVydGllcyB0by5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9ybWF0IChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvY1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGZhbHNlKVxuICAgICAgICBpZiAocG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5mb3JtYXQoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge2FueX0gYXR0cmlidXRlVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7YW55fSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlUZXh0UmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZVGV4dCA9IF9kZWNvZGVyID0+IG5ldyBZVGV4dCgpXG4iLCAiLyoqXG4gKiBAbW9kdWxlIFlYbWxcbiAqL1xuXG5pbXBvcnQge1xuICBZWG1sRXZlbnQsXG4gIFlYbWxFbGVtZW50LFxuICBBYnN0cmFjdFR5cGUsXG4gIHR5cGVMaXN0TWFwLFxuICB0eXBlTGlzdEZvckVhY2gsXG4gIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3MsXG4gIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcixcbiAgdHlwZUxpc3REZWxldGUsXG4gIHR5cGVMaXN0VG9BcnJheSxcbiAgWVhtbEZyYWdtZW50UmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgdHlwZUxpc3RHZXQsXG4gIHR5cGVMaXN0U2xpY2UsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBDb250ZW50VHlwZSwgVHJhbnNhY3Rpb24sIEl0ZW0sIFlYbWxUZXh0LCBZWG1sSG9vayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5cbi8qKlxuICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1NlbGVjdG9yc3xDU1NfU2VsZWN0b3JzfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHF1ZXJ5ID0gJy5jbGFzc1NlbGVjdG9yJ1xuICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICovXG5cbi8qKlxuICogRG9tIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAY2FsbGJhY2sgZG9tRmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge01hcH0gYXR0cmlidXRlcyBUaGUgbWFwIG9mIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIERvbSBub2RlIGluIHRoZSBZWG1sRWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIGEgWVhtbEVsZW1lbnQgLyBZWG1sRnJhZ21lbnQgYW5kIGFcbiAqIHBvc2l0aW9uIHdpdGhpbiB0aGVtLlxuICpcbiAqIENhbiBiZSBjcmVhdGVkIHdpdGgge0BsaW5rIFlYbWxGcmFnbWVudCNjcmVhdGVUcmVlV2Fsa2VyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRWxlbWVudHxZWG1sSG9vaz59XG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sVHJlZVdhbGtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxGcmFnbWVudCB8IFlYbWxFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IFtmXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3QsIGYgPSAoKSA9PiB0cnVlKSB7XG4gICAgdGhpcy5fZmlsdGVyID0gZlxuICAgIHRoaXMuX3Jvb3QgPSByb290XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW19XG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSAvKiogQHR5cGUge0l0ZW19ICovIChyb290Ll9zdGFydClcbiAgICB0aGlzLl9maXJzdENhbGwgPSB0cnVlXG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3JSZXN1bHQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fSBUaGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCBuID0gdGhpcy5fY3VycmVudE5vZGVcbiAgICBsZXQgdHlwZSA9IG4gJiYgbi5jb250ZW50ICYmIC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlXG4gICAgaWYgKG4gIT09IG51bGwgJiYgKCF0aGlzLl9maXJzdENhbGwgfHwgbi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIodHlwZSkpKSB7IC8vIGlmIGZpcnN0IGNhbGwsIHdlIGNoZWNrIGlmIHdlIGNhbiB1c2UgdGhlIGZpcnN0IGl0ZW1cbiAgICAgIGRvIHtcbiAgICAgICAgdHlwZSA9IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlXG4gICAgICAgIGlmICghbi5kZWxldGVkICYmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRWxlbWVudCB8fCB0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQpICYmIHR5cGUuX3N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2FsayBkb3duIGluIHRoZSB0cmVlXG4gICAgICAgICAgbiA9IHR5cGUuX3N0YXJ0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2FsayByaWdodCBvciB1cCBpbiB0aGUgdHJlZVxuICAgICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobi5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuID0gbi5yaWdodFxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudCA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBuID0gbnVsbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChuLnBhcmVudCkuX2l0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgKG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpKSlcbiAgICB9XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gZmFsc2VcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gblxuICAgIHJldHVybiB7IHZhbHVlOiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZSwgZG9uZTogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGxpc3Qgb2Yge0BsaW5rIFlYbWxFbGVtZW50fS5hbmQge0BsaW5rIFlYbWxUZXh0fSB0eXBlcy5cbiAqIEEgWXhtbEZyYWdtZW50IGlzIHNpbWlsYXIgdG8gYSB7QGxpbmsgWVhtbEVsZW1lbnR9LCBidXQgaXQgZG9lcyBub3QgaGF2ZSBhXG4gKiBub2RlTmFtZSBhbmQgaXQgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLiBUaG91Z2ggaXQgY2FuIGJlIGJvdW5kIHRvIGEgRE9NXG4gKiBlbGVtZW50IC0gaW4gdGhpcyBjYXNlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbm9kZU5hbWUgYXJlIG5vdCBzaGFyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlYbWxFdmVudD5cbiAqL1xuZXhwb3J0IGNsYXNzIFlYbWxGcmFnbWVudCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBmaXJzdENoaWxkICgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuX2ZpcnN0XG4gICAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuY29udGVudC5nZXRDb250ZW50KClbMF0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKVxuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRnJhZ21lbnQoKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGl0ZW0uY2xvbmUoKSA6IGl0ZW0pKVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHF1ZXJ5KVxuICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KClcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBhcnJheS5mcm9tKG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSkpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZWG1sRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZWG1sRXZlbnQodGhpcywgcGFyZW50U3VicywgdHJhbnNhY3Rpb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBZWG1sRnJhZ21lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgY2hpbGRyZW4uXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIHhtbCA9PiB4bWwudG9TdHJpbmcoKSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW2hvb2tzPXt9XSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcylcbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHhtbFR5cGUgPT4ge1xuICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHhtbFR5cGUudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZyksIG51bGwpXG4gICAgfSlcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZlxuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHRoaXMsIHJlZkl0ZW0sIGNvbnRlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpXG4gICAgICBjb25zdCBpbmRleCA9IHJlZiA9PT0gbnVsbCA/IDAgOiBwYy5maW5kSW5kZXgoZWwgPT4gZWwgPT09IHJlZikgKyAxXG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgcmVmICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IGVycm9yLmNyZWF0ZSgnUmVmZXJlbmNlIGl0ZW0gbm90IGZvdW5kJylcbiAgICAgIH1cbiAgICAgIHBjLnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgbGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogUHJlcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBwcmVwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBvcnRpb24gb2YgdGhpcyBZWG1sRnJhZ21lbnQgaW50byBhIEphdmFTY3JpcHQgQXJyYXkgc2VsZWN0ZWRcbiAgICogZnJvbSBzdGFydCB0byBlbmQgKGVuZCBub3QgaW5jbHVkZWQpLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBjaGlsZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFlYbWxFbGVtZW50fFlYbWxUZXh0LG51bWJlciwgdHlwZW9mIHNlbGYpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIGYpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxGcmFnbWVudFJlZklEKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFlYbWxGcmFnbWVudCA9IF9kZWNvZGVyID0+IG5ldyBZWG1sRnJhZ21lbnQoKVxuIiwgImltcG9ydCAqIGFzIG9iamVjdCBmcm9tICdsaWIwL29iamVjdCdcblxuaW1wb3J0IHtcbiAgWVhtbEZyYWdtZW50LFxuICB0cmFuc2FjdCxcbiAgdHlwZU1hcERlbGV0ZSxcbiAgdHlwZU1hcEhhcyxcbiAgdHlwZU1hcFNldCxcbiAgdHlwZU1hcEdldCxcbiAgdHlwZU1hcEdldEFsbCxcbiAgdHlwZU1hcEdldEFsbFNuYXBzaG90LFxuICB0eXBlTGlzdEZvckVhY2gsXG4gIFlYbWxFbGVtZW50UmVmSUQsXG4gIFNuYXBzaG90LCBZWG1sVGV4dCwgQ29udGVudFR5cGUsIEFic3RyYWN0VHlwZSwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBEb2MsIEl0ZW0gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdHxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSBWYWx1ZVR5cGVzXG4gKi9cblxuLyoqXG4gKiBBbiBZWG1sRWxlbWVudCBpbWl0YXRlcyB0aGUgYmVoYXZpb3Igb2YgYVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnRcbiAqXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBhdHRyaWJ1dGVzIChrZXkgdmFsdWUgcGFpcnMpXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBjaGlsZEVsZW1lbnRzIHRoYXQgbXVzdCBpbmhlcml0IGZyb20gWVhtbEVsZW1lbnRcbiAqXG4gKiBAdGVtcGxhdGUge3sgW2tleTogc3RyaW5nXTogVmFsdWVUeXBlcyB9fSBbS1Y9eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfV1cbiAqL1xuZXhwb3J0IGNsYXNzIFlYbWxFbGVtZW50IGV4dGVuZHMgWVhtbEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKG5vZGVOYW1lID0gJ1VOREVGSU5FRCcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1BdHRycyA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGxcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIDsoLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJdGVtIHdpdGggdGhlIHNhbWUgZWZmZWN0IGFzIHRoaXMgSXRlbSAod2l0aG91dCBwb3NpdGlvbiBlZmZlY3QpXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudDxLVj59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lYbWxFbGVtZW50PEtWPn1cbiAgICAgKi9cbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRWxlbWVudCh0aGlzLm5vZGVOYW1lKVxuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKClcbiAgICBvYmplY3QuZm9yRWFjaChhdHRycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsLmluc2VydCgwLCB0aGlzLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgWE1MIHNlcmlhbGl6YXRpb24gb2YgdGhpcyBZWG1sRWxlbWVudC5cbiAgICogVGhlIGF0dHJpYnV0ZXMgYXJlIG9yZGVyZWQgYnkgYXR0cmlidXRlLW5hbWUsIHNvIHlvdSBjYW4gZWFzaWx5IHVzZSB0aGlzXG4gICAqIG1ldGhvZCB0byBjb21wYXJlIFlYbWxFbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKVxuICAgIGNvbnN0IHN0cmluZ0J1aWxkZXIgPSBbXVxuICAgIGNvbnN0IGtleXMgPSBbXVxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KVxuICAgIH1cbiAgICBrZXlzLnNvcnQoKVxuICAgIGNvbnN0IGtleXNMZW4gPSBrZXlzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICBzdHJpbmdCdWlsZGVyLnB1c2goa2V5ICsgJz1cIicgKyBhdHRyc1trZXldICsgJ1wiJylcbiAgICB9XG4gICAgY29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICBjb25zdCBhdHRyc1N0cmluZyA9IHN0cmluZ0J1aWxkZXIubGVuZ3RoID4gMCA/ICcgJyArIHN0cmluZ0J1aWxkZXIuam9pbignICcpIDogJydcbiAgICByZXR1cm4gYDwke25vZGVOYW1lfSR7YXR0cnNTdHJpbmd9PiR7c3VwZXIudG9TdHJpbmcoKX08LyR7bm9kZU5hbWV9PmBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIEtWICYgc3RyaW5nfSBLRVlcbiAgICpcbiAgICogQHBhcmFtIHtLRVl9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge0tWW0tFWV19IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLnNldChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAqIEByZXR1cm4ge0tWW0tFWV18dW5kZWZpbmVkfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGFuIGF0dHJpYnV0ZSBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIGNoZWNrIGZvciBleGlzdGVuY2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhc0F0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBIYXModGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHt7IFtLZXkgaW4gRXh0cmFjdDxrZXlvZiBLVixzdHJpbmc+XT86IEtWW0tleV19fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHNuYXBzaG90ID8gdHlwZU1hcEdldEFsbFNuYXBzaG90KHRoaXMsIHNuYXBzaG90KSA6IHR5cGVNYXBHZXRBbGwodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXR0cnNba2V5XVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgeXhtbCA9PiB7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RPTShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSlcbiAgICB9KVxuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRWxlbWVudFJlZklEKVxuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5ub2RlTmFtZSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sRWxlbWVudCA9IGRlY29kZXIgPT4gbmV3IFlYbWxFbGVtZW50KGRlY29kZXIucmVhZEtleSgpKVxuIiwgImltcG9ydCB7XG4gIFlFdmVudCxcbiAgWVhtbFRleHQsIFlYbWxFbGVtZW50LCBZWG1sRnJhZ21lbnQsIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRnJhZ21lbnQ+XG4gKiBBbiBFdmVudCB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIG9uIGEgWVhtbCBFbGVtZW50IG9yIFl4bWwgRnJhZ21lbnRcbiAqL1xuZXhwb3J0IGNsYXNzIFlYbWxFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZ3xudWxsPn0gc3VicyBUaGUgc2V0IG9mIGNoYW5nZWQgYXR0cmlidXRlcy4gYG51bGxgIGlzIGluY2x1ZGVkIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbilcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBTZXQgb2YgYWxsIGNoYW5nZWQgYXR0cmlidXRlcy5cbiAgICAgKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5hdHRyaWJ1dGVzQ2hhbmdlZCA9IG5ldyBTZXQoKVxuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQuYWRkKHN1YilcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgWU1hcCxcbiAgWVhtbEhvb2tSZWZJRCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIFlvdSBjYW4gbWFuYWdlIGJpbmRpbmcgdG8gYSBjdXN0b20gdHlwZSB3aXRoIFlYbWxIb29rLlxuICpcbiAqIEBleHRlbmRzIHtZTWFwPGFueT59XG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sSG9vayBleHRlbmRzIFlNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvb2tOYW1lIG5vZGVOYW1lIG9mIHRoZSBEb20gTm9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChob29rTmFtZSkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuaG9va05hbWUgPSBob29rTmFtZVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKVxuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZWwuc2V0KGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV1cbiAgICBsZXQgZG9tXG4gICAgaWYgKGhvb2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZG9tID0gaG9vay5jcmVhdGVEb20odGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKVxuICAgIH1cbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJywgdGhpcy5ob29rTmFtZSlcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihkb20sIHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRClcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMuaG9va05hbWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbEhvb2t9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFlYbWxIb29rID0gZGVjb2RlciA9PlxuICBuZXcgWVhtbEhvb2soZGVjb2Rlci5yZWFkS2V5KCkpXG4iLCAiaW1wb3J0IHtcbiAgWVRleHQsXG4gIFlYbWxUZXh0UmVmSUQsXG4gIENvbnRlbnRUeXBlLCBZWG1sRWxlbWVudCwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sVGV4dCBleHRlbmRzIFlUZXh0IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGxcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WVhtbFRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZWG1sVGV4dCgpXG4gICAgdGV4dC5hcHBseURlbHRhKHRoaXMudG9EZWx0YSgpKVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpXG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICB0b1N0cmluZyAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLnRvRGVsdGEoKS5tYXAoZGVsdGEgPT4ge1xuICAgICAgY29uc3QgbmVzdGVkTm9kZXMgPSBbXVxuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW11cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV0pIHtcbiAgICAgICAgICBhdHRycy5wdXNoKHsga2V5LCB2YWx1ZTogZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV1ba2V5XSB9KVxuICAgICAgICB9XG4gICAgICAgIC8vIHNvcnQgYXR0cmlidXRlcyB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgICAgYXR0cnMuc29ydCgoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogMSlcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KVxuICAgICAgfVxuICAgICAgLy8gc29ydCBub2RlIG9yZGVyIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgbmVzdGVkTm9kZXMuc29ydCgoYSwgYikgPT4gYS5ub2RlTmFtZSA8IGIubm9kZU5hbWUgPyAtMSA6IDEpXG4gICAgICAvLyBub3cgY29udmVydCB0byBkb20gc3RyaW5nXG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldXG4gICAgICAgIHN0ciArPSBgPCR7bm9kZS5ub2RlTmFtZX1gXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGF0dHIgPSBub2RlLmF0dHJzW2pdXG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgXG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICc+J1xuICAgICAgfVxuICAgICAgc3RyICs9IGRlbHRhLmluc2VydFxuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbFRleHRSZWZJRClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sVGV4dH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWVhtbFRleHQgPSBkZWNvZGVyID0+IG5ldyBZWG1sVGV4dCgpXG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIElELCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuZXhwb3J0IGNsYXNzIEFic3RyYWN0U3RydWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChpZCwgbGVuZ3RoKSB7XG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGlzIHN0cnVjdCB3aXRoIHRoZSBpdGVtIHRvIHRoZSByaWdodC5cbiAgICogVGhpcyBtZXRob2QgaXMgYWxyZWFkeSBhc3N1bWluZyB0aGF0IGB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHRoaXMuaWQuY2xvY2tgLlxuICAgKiBBbHNvIHRoaXMgbWV0aG9kIGRvZXMgKm5vdCogcmVtb3ZlIHJpZ2h0IGZyb20gU3RydWN0U3RvcmUhXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciB0aGlzIG1lcmdlZCB3aXRoIHJpZ2h0XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5jb2RpbmdSZWZcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQsIGVuY29kaW5nUmVmKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBBYnN0cmFjdFN0cnVjdCxcbiAgYWRkU3RydWN0LFxuICBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiwgSUQgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmV4cG9ydCBjb25zdCBzdHJ1Y3RHQ1JlZk51bWJlciA9IDBcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgR0MgZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVsZXRlICgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R0N9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXRcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldFxuICAgIH1cbiAgICBhZGRTdHJ1Y3QodHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RHQ1JlZk51bWJlcilcbiAgICBlbmNvZGVyLndyaXRlTGVuKHRoaXMubGVuZ3RoIC0gb2Zmc2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgSXRlbSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbmV4cG9ydCBjbGFzcyBDb250ZW50QmluYXJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuY29udGVudF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEJpbmFyeSh0aGlzLmNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRCaW5hcnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVCdWYodGhpcy5jb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50QmluYXJ5ID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEJpbmFyeShkZWNvZGVyLnJlYWRCdWYoKSlcbiIsICJpbXBvcnQge1xuICBhZGRUb0RlbGV0ZVNldCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgSXRlbSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb250ZW50RGVsZXRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVuKSB7XG4gICAgdGhpcy5sZW4gPSBsZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmxlblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbiAtIG9mZnNldClcbiAgICB0aGlzLmxlbiA9IG9mZnNldFxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERlbGV0ZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5sZW4gKz0gcmlnaHQubGVuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICBhZGRUb0RlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrLCB0aGlzLmxlbilcbiAgICBpdGVtLm1hcmtEZWxldGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbiAtIG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAxXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudERlbGV0ZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RGVsZXRlZChkZWNvZGVyLnJlYWRMZW4oKSlcbiIsICJpbXBvcnQge1xuICBEb2MsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIFRyYW5zYWN0aW9uLCBJdGVtIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBndWlkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdHNcbiAqL1xuY29uc3QgY3JlYXRlRG9jRnJvbU9wdHMgPSAoZ3VpZCwgb3B0cykgPT4gbmV3IERvYyh7IGd1aWQsIC4uLm9wdHMsIHNob3VsZExvYWQ6IG9wdHMuc2hvdWxkTG9hZCB8fCBvcHRzLmF1dG9Mb2FkIHx8IGZhbHNlIH0pXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnREb2Mge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIGlmIChkb2MuX2l0ZW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgZG9jdW1lbnQgd2FzIGFscmVhZHkgaW50ZWdyYXRlZCBhcyBhIHN1Yi1kb2N1bWVudC4gWW91IHNob3VsZCBjcmVhdGUgYSBzZWNvbmQgaW5zdGFuY2UgaW5zdGVhZCB3aXRoIHRoZSBzYW1lIGd1aWQuJylcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgY29uc3Qgb3B0cyA9IHt9XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIGlmICghZG9jLmdjKSB7XG4gICAgICBvcHRzLmdjID0gZmFsc2VcbiAgICB9XG4gICAgaWYgKGRvYy5hdXRvTG9hZCkge1xuICAgICAgb3B0cy5hdXRvTG9hZCA9IHRydWVcbiAgICB9XG4gICAgaWYgKGRvYy5tZXRhICE9PSBudWxsKSB7XG4gICAgICBvcHRzLm1ldGEgPSBkb2MubWV0YVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5kb2NdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREb2MoY3JlYXRlRG9jRnJvbU9wdHModGhpcy5kb2MuZ3VpZCwgdGhpcy5vcHRzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERvY30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIHJlZmxlY3RlZCBpbiBkb2MuZGVzdHJveSBhcyB3ZWxsXG4gICAgdGhpcy5kb2MuX2l0ZW0gPSBpdGVtXG4gICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZCh0aGlzLmRvYylcbiAgICBpZiAodGhpcy5kb2Muc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZC5hZGQodGhpcy5kb2MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5oYXModGhpcy5kb2MpKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuZGVsZXRlKHRoaXMuZG9jKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcy5kb2MpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHsgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyh0aGlzLmRvYy5ndWlkKVxuICAgIGVuY29kZXIud3JpdGVBbnkodGhpcy5vcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDlcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudERvYyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnREb2MoY3JlYXRlRG9jRnJvbU9wdHMoZGVjb2Rlci5yZWFkU3RyaW5nKCksIGRlY29kZXIucmVhZEFueSgpKSlcbiIsICJpbXBvcnQge1xuICBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFN0cnVjdFN0b3JlLCBJdGVtLCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudEVtYmVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVtYmVkKSB7XG4gICAgdGhpcy5lbWJlZCA9IGVtYmVkXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZW1iZWRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEVtYmVkKHRoaXMuZW1iZWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEVtYmVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLmVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDVcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50RW1iZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RW1iZWQoZGVjb2Rlci5yZWFkSlNPTigpKVxuIiwgImltcG9ydCB7XG4gIFlUZXh0LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIEl0ZW0sIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudEZvcm1hdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50Rm9ybWF0KHRoaXMua2V5LCB0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBzcGxpY2UgKF9vZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IF9yaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChfcmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKF90cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIEB0b2RvIHNlYXJjaG1hcmtlciBhcmUgY3VycmVudGx5IHVuc3VwcG9ydGVkIGZvciByaWNoIHRleHQgZG9jdW1lbnRzXG4gICAgY29uc3QgcCA9IC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudClcbiAgICBwLl9zZWFyY2hNYXJrZXIgPSBudWxsXG4gICAgcC5faGFzRm9ybWF0dGluZyA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmtleSlcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRGb3JtYXQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50Rm9ybWF0KGRlY29kZXIucmVhZEtleSgpLCBkZWNvZGVyLnJlYWRKU09OKCkpXG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBUcmFuc2FjdGlvbiwgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRKU09OIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50SlNPTih0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50SlNPTih0aGlzLmFyci5zbGljZShvZmZzZXQpKVxuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KVxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEpTT059IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aFxuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KVxuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldXG4gICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGMgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkoYykpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRKU09OID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpXG4gIGNvbnN0IGNzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGMgPSBkZWNvZGVyLnJlYWRTdHJpbmcoKVxuICAgIGlmIChjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY3MucHVzaCh1bmRlZmluZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNzLnB1c2goSlNPTi5wYXJzZShjKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50SlNPTihjcylcbn1cbiIsICJpbXBvcnQge1xuICBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFRyYW5zYWN0aW9uLCBJdGVtLCBTdHJ1Y3RTdG9yZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuZXhwb3J0IGNsYXNzIENvbnRlbnRBbnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEFueSh0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSlcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldClcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRBbnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aFxuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KVxuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldXG4gICAgICBlbmNvZGVyLndyaXRlQW55KGMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnRBbnkgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKClcbiAgY29uc3QgY3MgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY3MucHVzaChkZWNvZGVyLnJlYWRBbnkoKSlcbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRBbnkoY3MpXG59XG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBUcmFuc2FjdGlvbiwgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRTdHJpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHIgPSBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLnNwbGl0KCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0ci5zbGljZShvZmZzZXQpKVxuICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0KVxuXG4gICAgLy8gUHJldmVudCBlbmNvZGluZyBpbnZhbGlkIGRvY3VtZW50cyBiZWNhdXNlIG9mIHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy8yNDhcbiAgICBjb25zdCBmaXJzdENoYXJDb2RlID0gdGhpcy5zdHIuY2hhckNvZGVBdChvZmZzZXQgLSAxKVxuICAgIGlmIChmaXJzdENoYXJDb2RlID49IDB4RDgwMCAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxlZnQgc3BsaXQgaXMgdGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHV0ZjE2L3VjczIgcGFpci5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlycyBiZWNhdXNlIHRoaXMgbWF5IGxlYWQgdG8gaW52YWxpZCBkb2N1bWVudHMuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBpbnZhbGlkIGNoYXJhY3RlciB3aXRoIGEgdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKO+/vSAvIFUrRkZGRClcbiAgICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0IC0gMSkgKyAn77+9J1xuICAgICAgLy8gcmVwbGFjZSByaWdodCBhcyB3ZWxsXG4gICAgICByaWdodC5zdHIgPSAn77+9JyArIHJpZ2h0LnN0ci5zbGljZSgxKVxuICAgIH1cbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRTdHJpbmd9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5zdHIgKz0gcmlnaHQuc3RyXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyhvZmZzZXQgPT09IDAgPyB0aGlzLnN0ciA6IHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50U3RyaW5nID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFN0cmluZyhkZWNvZGVyLnJlYWRTdHJpbmcoKSlcbiIsICJpbXBvcnQge1xuICByZWFkWUFycmF5LFxuICByZWFkWU1hcCxcbiAgcmVhZFlUZXh0LFxuICByZWFkWVhtbEVsZW1lbnQsXG4gIHJlYWRZWG1sRnJhZ21lbnQsXG4gIHJlYWRZWG1sSG9vayxcbiAgcmVhZFlYbWxUZXh0LFxuICBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiwgSXRlbSwgWUV2ZW50LCBBYnN0cmFjdFR5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RUeXBlPGFueT4+fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVSZWZzID0gW1xuICByZWFkWUFycmF5LFxuICByZWFkWU1hcCxcbiAgcmVhZFlUZXh0LFxuICByZWFkWVhtbEVsZW1lbnQsXG4gIHJlYWRZWG1sRnJhZ21lbnQsXG4gIHJlYWRZWG1sSG9vayxcbiAgcmVhZFlYbWxUZXh0XG5dXG5cbmV4cG9ydCBjb25zdCBZQXJyYXlSZWZJRCA9IDBcbmV4cG9ydCBjb25zdCBZTWFwUmVmSUQgPSAxXG5leHBvcnQgY29uc3QgWVRleHRSZWZJRCA9IDJcbmV4cG9ydCBjb25zdCBZWG1sRWxlbWVudFJlZklEID0gM1xuZXhwb3J0IGNvbnN0IFlYbWxGcmFnbWVudFJlZklEID0gNFxuZXhwb3J0IGNvbnN0IFlYbWxIb29rUmVmSUQgPSA1XG5leHBvcnQgY29uc3QgWVhtbFRleHRSZWZJRCA9IDZcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnR5cGVdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50VHlwZSh0aGlzLnR5cGUuX2NvcHkoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRUeXBlfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIHRoaXMudHlwZS5faW50ZWdyYXRlKHRyYW5zYWN0aW9uLmRvYywgaXRlbSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydFxuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBnYydkIGxhdGVyIGFuZCB3ZSB3YW50IHRvIG1lcmdlIGl0IGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIFdlIHRyeSB0byBtZXJnZSBhbGwgZGVsZXRlZCBpdGVtcyBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLFxuICAgICAgICAvLyBidXQgd2UgaGF2ZSBubyBrbm93bGVkZ2UgYWJvdXQgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIG1lcmdlZFxuICAgICAgICAvLyBzaW5jZSBpdCBpcyBub3QgaW4gdHJhbnNhY3Rpb24uZHMuIEhlbmNlIHdlIGFkZCBpdCB0byB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKVxuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHRcbiAgICB9XG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgfSBlbHNlIGlmIChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkpIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZGVsZXRlKHRoaXMudHlwZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpXG4gICAgICBpdGVtID0gaXRlbS5yaWdodFxuICAgIH1cbiAgICB0aGlzLnR5cGUuX3N0YXJ0ID0gbnVsbFxuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGl0ZW0gKi8gKGl0ZW0pID0+IHtcbiAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpXG4gICAgICAgIGl0ZW0gPSBpdGVtLmxlZnRcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMudHlwZS5fbWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIHRoaXMudHlwZS5fd3JpdGUoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA3XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50VHlwZSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRUeXBlKHR5cGVSZWZzW2RlY29kZXIucmVhZFR5cGVSZWYoKV0oZGVjb2RlcikpXG4iLCAiaW1wb3J0IHtcbiAgR0MsXG4gIGdldFN0YXRlLFxuICBBYnN0cmFjdFN0cnVjdCxcbiAgcmVwbGFjZVN0cnVjdCxcbiAgYWRkU3RydWN0LFxuICBhZGRUb0RlbGV0ZVNldCxcbiAgZmluZFJvb3RUeXBlS2V5LFxuICBjb21wYXJlSURzLFxuICBnZXRJdGVtLFxuICBnZXRJdGVtQ2xlYW5FbmQsXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICByZWFkQ29udGVudERlbGV0ZWQsXG4gIHJlYWRDb250ZW50QmluYXJ5LFxuICByZWFkQ29udGVudEpTT04sXG4gIHJlYWRDb250ZW50QW55LFxuICByZWFkQ29udGVudFN0cmluZyxcbiAgcmVhZENvbnRlbnRFbWJlZCxcbiAgcmVhZENvbnRlbnREb2MsXG4gIGNyZWF0ZUlELFxuICByZWFkQ29udGVudEZvcm1hdCxcbiAgcmVhZENvbnRlbnRUeXBlLFxuICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24sXG4gIGlzRGVsZXRlZCxcbiAgU3RhY2tJdGVtLCBEZWxldGVTZXQsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgQ29udGVudFR5cGUsIENvbnRlbnREZWxldGVkLCBTdHJ1Y3RTdG9yZSwgSUQsIEFic3RyYWN0VHlwZSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnbGliMC9iaW5hcnknXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuXG4vKipcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHJldHVybiBzZXZlcmFsIGl0ZW1zXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHt7aXRlbTpJdGVtLCBkaWZmOm51bWJlcn19XG4gKi9cbmV4cG9ydCBjb25zdCBmb2xsb3dSZWRvbmUgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SUR8bnVsbH1cbiAgICovXG4gIGxldCBuZXh0SUQgPSBpZFxuICBsZXQgZGlmZiA9IDBcbiAgbGV0IGl0ZW1cbiAgZG8ge1xuICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgbmV4dElEID0gY3JlYXRlSUQobmV4dElELmNsaWVudCwgbmV4dElELmNsb2NrICsgZGlmZilcbiAgICB9XG4gICAgaXRlbSA9IGdldEl0ZW0oc3RvcmUsIG5leHRJRClcbiAgICBkaWZmID0gbmV4dElELmNsb2NrIC0gaXRlbS5pZC5jbG9ja1xuICAgIG5leHRJRCA9IGl0ZW0ucmVkb25lXG4gIH0gd2hpbGUgKG5leHRJRCAhPT0gbnVsbCAmJiBpdGVtIGluc3RhbmNlb2YgSXRlbSlcbiAgcmV0dXJuIHtcbiAgICBpdGVtLCBkaWZmXG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCBuZWl0aGVyIGl0ZW0gbm9yIGFueSBvZiBpdHMgcGFyZW50cyBpcyBldmVyIGRlbGV0ZWQuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCBwZXJzaXN0IHdoZW4gc3RvcmluZyBpdCBpbnRvIGEgZGF0YWJhc2Ugb3Igd2hlblxuICogc2VuZGluZyBpdCB0byBvdGhlciBwZWVyc1xuICpcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBcbiAqL1xuZXhwb3J0IGNvbnN0IGtlZXBJdGVtID0gKGl0ZW0sIGtlZXApID0+IHtcbiAgd2hpbGUgKGl0ZW0gIT09IG51bGwgJiYgaXRlbS5rZWVwICE9PSBrZWVwKSB7XG4gICAgaXRlbS5rZWVwID0ga2VlcFxuICAgIGl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtXG4gIH1cbn1cblxuLyoqXG4gKiBTcGxpdCBsZWZ0SXRlbSBpbnRvIHR3byBpdGVtc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gbGVmdEl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGl0SXRlbSA9ICh0cmFuc2FjdGlvbiwgbGVmdEl0ZW0sIGRpZmYpID0+IHtcbiAgLy8gY3JlYXRlIHJpZ2h0SXRlbVxuICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkXG4gIGNvbnN0IHJpZ2h0SXRlbSA9IG5ldyBJdGVtKFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSxcbiAgICBsZWZ0SXRlbSxcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiAtIDEpLFxuICAgIGxlZnRJdGVtLnJpZ2h0LFxuICAgIGxlZnRJdGVtLnJpZ2h0T3JpZ2luLFxuICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgbGVmdEl0ZW0uY29udGVudC5zcGxpY2UoZGlmZilcbiAgKVxuICBpZiAobGVmdEl0ZW0uZGVsZXRlZCkge1xuICAgIHJpZ2h0SXRlbS5tYXJrRGVsZXRlZCgpXG4gIH1cbiAgaWYgKGxlZnRJdGVtLmtlZXApIHtcbiAgICByaWdodEl0ZW0ua2VlcCA9IHRydWVcbiAgfVxuICBpZiAobGVmdEl0ZW0ucmVkb25lICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJlZG9uZSA9IGNyZWF0ZUlEKGxlZnRJdGVtLnJlZG9uZS5jbGllbnQsIGxlZnRJdGVtLnJlZG9uZS5jbG9jayArIGRpZmYpXG4gIH1cbiAgLy8gdXBkYXRlIGxlZnQgKGRvIG5vdCBzZXQgbGVmdEl0ZW0ucmlnaHRPcmlnaW4gYXMgaXQgd2lsbCBsZWFkIHRvIHByb2JsZW1zIHdoZW4gc3luY2luZylcbiAgbGVmdEl0ZW0ucmlnaHQgPSByaWdodEl0ZW1cbiAgLy8gdXBkYXRlIHJpZ2h0XG4gIGlmIChyaWdodEl0ZW0ucmlnaHQgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmlnaHQubGVmdCA9IHJpZ2h0SXRlbVxuICB9XG4gIC8vIHJpZ2h0IGlzIG1vcmUgc3BlY2lmaWMuXG4gIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChyaWdodEl0ZW0pXG4gIC8vIHVwZGF0ZSBwYXJlbnQuX21hcFxuICBpZiAocmlnaHRJdGVtLnBhcmVudFN1YiAhPT0gbnVsbCAmJiByaWdodEl0ZW0ucmlnaHQgPT09IG51bGwpIHtcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRJdGVtLnBhcmVudCkuX21hcC5zZXQocmlnaHRJdGVtLnBhcmVudFN1YiwgcmlnaHRJdGVtKVxuICB9XG4gIGxlZnRJdGVtLmxlbmd0aCA9IGRpZmZcbiAgcmV0dXJuIHJpZ2h0SXRlbVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKi9cbmNvbnN0IGlzRGVsZXRlZEJ5VW5kb1N0YWNrID0gKHN0YWNrLCBpZCkgPT4gYXJyYXkuc29tZShzdGFjaywgLyoqIEBwYXJhbSB7U3RhY2tJdGVtfSBzICovIHMgPT4gaXNEZWxldGVkKHMuZGVsZXRpb25zLCBpZCkpXG5cbi8qKlxuICogUmVkb2VzIHRoZSBlZmZlY3Qgb2YgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIFlqcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTZXQ8SXRlbT59IHJlZG9pdGVtc1xuICogQHBhcmFtIHtEZWxldGVTZXR9IGl0ZW1zVG9EZWxldGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlUmVtb3RlTWFwQ2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL3V0aWxzL1VuZG9NYW5hZ2VyLmpzJykuVW5kb01hbmFnZXJ9IHVtXG4gKlxuICogQHJldHVybiB7SXRlbXxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCByZWRvSXRlbSA9ICh0cmFuc2FjdGlvbiwgaXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgY29uc3Qgb3duQ2xpZW50SUQgPSBkb2MuY2xpZW50SURcbiAgY29uc3QgcmVkb25lID0gaXRlbS5yZWRvbmVcbiAgaWYgKHJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmVkb25lKVxuICB9XG4gIGxldCBwYXJlbnRJdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbVxuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBsZWZ0ID0gbnVsbFxuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCByaWdodFxuICAvLyBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgaXMgcmVkb25lXG4gIGlmIChwYXJlbnRJdGVtICE9PSBudWxsICYmIHBhcmVudEl0ZW0uZGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgIC8vIHRyeSB0byB1bmRvIHBhcmVudCBpZiBpdCB3aWxsIGJlIHVuZG9uZSBhbnl3YXlcbiAgICBpZiAocGFyZW50SXRlbS5yZWRvbmUgPT09IG51bGwgJiYgKCFyZWRvaXRlbXMuaGFzKHBhcmVudEl0ZW0pIHx8IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLCByZWRvaXRlbXMsIGl0ZW1zVG9EZWxldGUsIGlnbm9yZVJlbW90ZU1hcENoYW5nZXMsIHVtKSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHdoaWxlIChwYXJlbnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50SXRlbSA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLnJlZG9uZSlcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudEl0ZW0gPT09IG51bGwgPyAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpIDogLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKHBhcmVudEl0ZW0uY29udGVudCkudHlwZVxuXG4gIGlmIChpdGVtLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgIC8vIElzIGFuIGFycmF5IGl0ZW0uIEluc2VydCBhdCB0aGUgb2xkIHBvc2l0aW9uXG4gICAgbGVmdCA9IGl0ZW0ubGVmdFxuICAgIHJpZ2h0ID0gaXRlbVxuICAgIC8vIGZpbmQgbmV4dCBjbG9uZWRfcmVkbyBpdGVtc1xuICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCBsZWZ0VHJhY2UgPSBsZWZ0XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChsZWZ0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGxlZnRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIGxlZnRUcmFjZSA9IGxlZnRUcmFjZS5yZWRvbmUgPT09IG51bGwgPyBudWxsIDogZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnRUcmFjZS5yZWRvbmUpXG4gICAgICB9XG4gICAgICBpZiAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0ID0gbGVmdFRyYWNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBsZWZ0ID0gbGVmdC5sZWZ0XG4gICAgfVxuICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcmlnaHRUcmFjZSA9IHJpZ2h0XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHRUcmFjZSA9IHJpZ2h0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByaWdodFRyYWNlLnJlZG9uZSlcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHQgPSByaWdodFRyYWNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICByaWdodCA9IHJpZ2h0LnJpZ2h0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJpZ2h0ID0gbnVsbFxuICAgIGlmIChpdGVtLnJpZ2h0ICYmICFpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzKSB7XG4gICAgICBsZWZ0ID0gaXRlbVxuICAgICAgLy8gSXRlcmF0ZSByaWdodCB3aGlsZSByaWdodCBpcyBpbiBpdGVtc1RvRGVsZXRlXG4gICAgICAvLyBJZiBpdCBpcyBpbnRlbmRlZCB0byBkZWxldGUgcmlnaHQgd2hpbGUgaXRlbSBpcyByZWRvbmUsIHdlIGNhbiBleHBlY3QgdGhhdCBpdGVtIHNob3VsZCByZXBsYWNlIHJpZ2h0LlxuICAgICAgd2hpbGUgKGxlZnQgIT09IG51bGwgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCAmJiAobGVmdC5yaWdodC5yZWRvbmUgfHwgaXNEZWxldGVkKGl0ZW1zVG9EZWxldGUsIGxlZnQucmlnaHQuaWQpIHx8IGlzRGVsZXRlZEJ5VW5kb1N0YWNrKHVtLnVuZG9TdGFjaywgbGVmdC5yaWdodC5pZCkgfHwgaXNEZWxldGVkQnlVbmRvU3RhY2sodW0ucmVkb1N0YWNrLCBsZWZ0LnJpZ2h0LmlkKSkpIHtcbiAgICAgICAgbGVmdCA9IGxlZnQucmlnaHRcbiAgICAgICAgLy8gZm9sbG93IHJlZG9uZVxuICAgICAgICB3aGlsZSAobGVmdC5yZWRvbmUpIGxlZnQgPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgbGVmdC5yZWRvbmUpXG4gICAgICB9XG4gICAgICBpZiAobGVmdCAmJiBsZWZ0LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZWRvIHRoaXMgaXRlbSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIGFcbiAgICAgICAgLy8gY2hhbmdlIGZyb20gYW5vdGhlciBjbGllbnRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHBhcmVudFR5cGUuX21hcC5nZXQoaXRlbS5wYXJlbnRTdWIpIHx8IG51bGxcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV4dENsb2NrID0gZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElEKVxuICBjb25zdCBuZXh0SWQgPSBjcmVhdGVJRChvd25DbGllbnRJRCwgbmV4dENsb2NrKVxuICBjb25zdCByZWRvbmVJdGVtID0gbmV3IEl0ZW0oXG4gICAgbmV4dElkLFxuICAgIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsXG4gICAgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLFxuICAgIHBhcmVudFR5cGUsXG4gICAgaXRlbS5wYXJlbnRTdWIsXG4gICAgaXRlbS5jb250ZW50LmNvcHkoKVxuICApXG4gIGl0ZW0ucmVkb25lID0gbmV4dElkXG4gIGtlZXBJdGVtKHJlZG9uZUl0ZW0sIHRydWUpXG4gIHJlZG9uZUl0ZW0uaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICByZXR1cm4gcmVkb25lSXRlbVxufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhbnkgY29udGVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIEl0ZW0gZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSBvcmlnaW5cbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gcmlnaHRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IHJpZ2h0T3JpZ2luXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH0gcGFyZW50IElzIGEgdHlwZSBpZiBpbnRlZ3JhdGVkLCBpcyBudWxsIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvcHkgcGFyZW50IGZyb20gbGVmdCBvciByaWdodCwgaXMgSUQgYmVmb3JlIGludGVncmF0aW9uIHRvIHNlYXJjaCBmb3IgaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGFyZW50U3ViXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250ZW50fSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlZnQsIG9yaWdpbiwgcmlnaHQsIHJpZ2h0T3JpZ2luLCBwYXJlbnQsIHBhcmVudFN1YiwgY29udGVudCkge1xuICAgIHN1cGVyKGlkLCBjb250ZW50LmdldExlbmd0aCgpKVxuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0l0ZW0gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0T3JpZ2luID0gcmlnaHRPcmlnaW5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwYXJlbnQgcmVmZXJzIHRvIHRoaXMgaXRlbSB3aXRoIHNvbWUga2luZCBvZiBrZXkgKGUuZy4gWU1hcCwgdGhlXG4gICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAqIHRvIGluc2VydCB0aGlzIGl0ZW0uIElmIGBwYXJlbnRTdWIgPSBudWxsYCB0eXBlLl9zdGFydCBpcyB0aGUgbGlzdCBpblxuICAgICAqIHdoaWNoIHRvIGluc2VydCB0by4gT3RoZXJ3aXNlIGl0IGlzIGBwYXJlbnQuX21hcGAuXG4gICAgICogQHR5cGUge1N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWJcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIHR5cGUncyBlZmZlY3QgaXMgcmVkb25lIHRoaXMgdHlwZSByZWZlcnMgdG8gdGhlIHR5cGUgdGhhdCB1bmRpZFxuICAgICAqIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZWRvbmUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0Q29udGVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50XG4gICAgLyoqXG4gICAgICogYml0MToga2VlcFxuICAgICAqIGJpdDI6IGNvdW50YWJsZVxuICAgICAqIGJpdDM6IGRlbGV0ZWRcbiAgICAgKiBiaXQ0OiBtYXJrIC0gbWFyayBub2RlIGFzIGZhc3Qtc2VhcmNoLW1hcmtlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGJ5dGVcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB0aGlzLmNvbnRlbnQuaXNDb3VudGFibGUoKSA/IGJpbmFyeS5CSVQyIDogMFxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBtYXJrIHRoZSBpdGVtIGFzIGFuIGluZGV4ZWQgZmFzdC1zZWFyY2ggbWFya2VyXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IG1hcmtlciAoaXNNYXJrZWQpIHtcbiAgICBpZiAoKCh0aGlzLmluZm8gJiBiaW5hcnkuQklUNCkgPiAwKSAhPT0gaXNNYXJrZWQpIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUNFxuICAgIH1cbiAgfVxuXG4gIGdldCBtYXJrZXIgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGRvIG5vdCBnYXJiYWdlIGNvbGxlY3QgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGtlZXAgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgYmluYXJ5LkJJVDEpID4gMFxuICB9XG5cbiAgc2V0IGtlZXAgKGRvS2VlcCkge1xuICAgIGlmICh0aGlzLmtlZXAgIT09IGRvS2VlcCkge1xuICAgICAgdGhpcy5pbmZvIF49IGJpbmFyeS5CSVQxXG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMikgPiAwXG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGl0ZW0gd2FzIGRlbGV0ZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQzKSA+IDBcbiAgfVxuXG4gIHNldCBkZWxldGVkIChkb0RlbGV0ZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQgIT09IGRvRGVsZXRlKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDNcbiAgICB9XG4gIH1cblxuICBtYXJrRGVsZXRlZCAoKSB7XG4gICAgdGhpcy5pbmZvIHw9IGJpbmFyeS5CSVQzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjcmVhdG9yIGNsaWVudElEIG9mIHRoZSBtaXNzaW5nIG9wIG9yIGRlZmluZSBtaXNzaW5nIGl0ZW1zIGFuZCByZXR1cm4gbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiAmJiB0aGlzLm9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMub3JpZ2luLmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLm9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0T3JpZ2luICYmIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY29uc3RydWN0b3IgPT09IElEICYmIHRoaXMuaWQuY2xpZW50ICE9PSB0aGlzLnBhcmVudC5jbGllbnQgJiYgdGhpcy5wYXJlbnQuY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucGFyZW50LmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jbGllbnRcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGFsbCBtaXNzaW5nIGlkcywgbm93IGZpbmQgdGhlIGl0ZW1zXG5cbiAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgc3RvcmUsIHRoaXMub3JpZ2luKVxuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkXG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0T3JpZ2luKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHRoaXMucmlnaHRPcmlnaW4pXG4gICAgICB0aGlzLnJpZ2h0T3JpZ2luID0gdGhpcy5yaWdodC5pZFxuICAgIH1cbiAgICBpZiAoKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB8fCAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBHQykpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAvLyBvbmx5IHNldCBwYXJlbnQgaWYgdGhpcyBzaG91bGRuJ3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgIGlmICh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5sZWZ0LnBhcmVudFxuICAgICAgICB0aGlzLnBhcmVudFN1YiA9IHRoaXMubGVmdC5wYXJlbnRTdWJcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnJpZ2h0LnBhcmVudFxuICAgICAgICB0aGlzLnBhcmVudFN1YiA9IHRoaXMucmlnaHQucGFyZW50U3ViXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBnZXRJdGVtKHN0b3JlLCB0aGlzLnBhcmVudClcbiAgICAgIGlmIChwYXJlbnRJdGVtLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKHBhcmVudEl0ZW0uY29udGVudCkudHlwZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldFxuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrIC0gMSkpXG4gICAgICB0aGlzLm9yaWdpbiA9IHRoaXMubGVmdC5sYXN0SWRcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5zcGxpY2Uob2Zmc2V0KVxuICAgICAgdGhpcy5sZW5ndGggLT0gb2Zmc2V0XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBpZiAoKCF0aGlzLmxlZnQgJiYgKCF0aGlzLnJpZ2h0IHx8IHRoaXMucmlnaHQubGVmdCAhPT0gbnVsbCkpIHx8ICh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LnJpZ2h0ICE9PSB0aGlzLnJpZ2h0KSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgb1xuICAgICAgICAvLyBzZXQgbyB0byB0aGUgZmlyc3QgY29uZmxpY3RpbmcgaXRlbVxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSBsZWZ0LnJpZ2h0XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbFxuICAgICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnRcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1c2Ugc29tZXRoaW5nIGxpa2UgRGVsZXRlU2V0IGhlcmUgKGEgdHJlZSBpbXBsZW1lbnRhdGlvbiB3b3VsZCBiZSBiZXN0KVxuICAgICAgICAvLyBAdG9kbyB1c2UgZ2xvYmFsIHNldCBkZWZpbml0aW9uc1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0aW5nSXRlbXMgPSBuZXcgU2V0KClcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpdGVtc0JlZm9yZU9yaWdpbiA9IG5ldyBTZXQoKVxuICAgICAgICAvLyBMZXQgYyBpbiBjb25mbGljdGluZ0l0ZW1zLCBiIGluIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIC8vICoqKntvcmlnaW59YmJiYnt0aGlzfXtjLGJ9e2MsYn17b30qKipcbiAgICAgICAgLy8gTm90ZSB0aGF0IGNvbmZsaWN0aW5nSXRlbXMgaXMgYSBzdWJzZXQgb2YgaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgbyAhPT0gdGhpcy5yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKVxuICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuYWRkKG8pXG4gICAgICAgICAgaWYgKGNvbXBhcmVJRHModGhpcy5vcmlnaW4sIG8ub3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICBpZiAoby5pZC5jbGllbnQgPCB0aGlzLmlkLmNsaWVudCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gb1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCBvLnJpZ2h0T3JpZ2luKSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGFuZCBvIGFyZSBjb25mbGljdGluZyBhbmQgcG9pbnQgdG8gdGhlIHNhbWUgaW50ZWdyYXRpb24gcG9pbnRzLiBUaGUgaWQgZGVjaWRlcyB3aGljaCBpdGVtIGNvbWVzIGZpcnN0LlxuICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRvIHRoZSBsZWZ0IG9mIG8sIHdlIGNhbiBicmVhayBoZXJlXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IC8vIGVsc2UsIG8gbWlnaHQgYmUgaW50ZWdyYXRlZCBiZWZvcmUgYW4gaXRlbSB0aGF0IHRoaXMgY29uZmxpY3RzIHdpdGguIElmIHNvLCB3ZSB3aWxsIGZpbmQgaXQgaW4gdGhlIG5leHQgaXRlcmF0aW9uc1xuICAgICAgICAgIH0gZWxzZSBpZiAoby5vcmlnaW4gIT09IG51bGwgJiYgaXRlbXNCZWZvcmVPcmlnaW4uaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7IC8vIHVzZSBnZXRJdGVtIGluc3RlYWQgb2YgZ2V0SXRlbUNsZWFuRW5kIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCAvIG5lZWQgdG8gc3BsaXQgaXRlbXMuXG4gICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgIGlmICghY29uZmxpY3RpbmdJdGVtcy5oYXMoZ2V0SXRlbSh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIG8ub3JpZ2luKSkpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG9cbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSBvLnJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdFxuICAgICAgfVxuICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmxlZnQucmlnaHRcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gICAgICAgIHRoaXMubGVmdC5yaWdodCA9IHRoaXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByXG4gICAgICAgIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsXG4gICAgICAgICAgd2hpbGUgKHIgIT09IG51bGwgJiYgci5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByID0gci5sZWZ0XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydFxuICAgICAgICAgIDsvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydCA9IHRoaXNcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpZ2h0ID0gclxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpc1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBzZXQgYXMgY3VycmVudCBwYXJlbnQgdmFsdWUgaWYgcmlnaHQgPT09IG51bGwgYW5kIHRoaXMgaXMgcGFyZW50U3ViXG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5zZXQodGhpcy5wYXJlbnRTdWIsIHRoaXMpXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnQuIGRlbGV0ZSByaWdodFxuICAgICAgICAgIHRoaXMubGVmdC5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFkanVzdCBsZW5ndGggb2YgcGFyZW50XG4gICAgICBpZiAodGhpcy5wYXJlbnRTdWIgPT09IG51bGwgJiYgdGhpcy5jb3VudGFibGUgJiYgIXRoaXMuZGVsZXRlZCkge1xuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9sZW5ndGggKz0gdGhpcy5sZW5ndGhcbiAgICAgIH1cbiAgICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpXG4gICAgICB0aGlzLmNvbnRlbnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCB0aGlzKVxuICAgICAgLy8gYWRkIHBhcmVudCB0byB0cmFuc2FjdGlvbi5jaGFuZ2VkXG4gICAgICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCksIHRoaXMucGFyZW50U3ViKVxuICAgICAgaWYgKCgvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0uZGVsZXRlZCkgfHwgKHRoaXMucGFyZW50U3ViICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBpZiBwYXJlbnQgaXMgZGVsZXRlZCBvciBpZiB0aGlzIGlzIG5vdCB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50XG4gICAgICAgIHRoaXMuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGRlZmluZWQuIEludGVncmF0ZSBHQyBzdHJ1Y3QgaW5zdGVhZFxuICAgICAgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IG5leHQgKCkge1xuICAgIGxldCBuID0gdGhpcy5yaWdodFxuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgcHJldiAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxlZnRcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLmxlZnRcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbGFzdCBjb250ZW50IGFkZHJlc3Mgb2YgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGxhc3RJZCAoKSB7XG4gICAgLy8gYWxsb2NhdGluZyBpZHMgaXMgcHJldHR5IGNvc3RseSBiZWNhdXNlIG9mIHRoZSBhbW91bnQgb2YgaWRzIGNyZWF0ZWQsIHNvIHdlIHRyeSB0byByZXVzZSB3aGVuZXZlciBwb3NzaWJsZVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSA/IHRoaXMuaWQgOiBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gbWVyZ2UgdHdvIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3RvciAmJlxuICAgICAgY29tcGFyZUlEcyhyaWdodC5vcmlnaW4sIHRoaXMubGFzdElkKSAmJlxuICAgICAgdGhpcy5yaWdodCA9PT0gcmlnaHQgJiZcbiAgICAgIGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgcmlnaHQucmlnaHRPcmlnaW4pICYmXG4gICAgICB0aGlzLmlkLmNsaWVudCA9PT0gcmlnaHQuaWQuY2xpZW50ICYmXG4gICAgICB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHJpZ2h0LmlkLmNsb2NrICYmXG4gICAgICB0aGlzLmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiZcbiAgICAgIHRoaXMucmVkb25lID09PSBudWxsICYmXG4gICAgICByaWdodC5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHRoaXMuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciAmJlxuICAgICAgdGhpcy5jb250ZW50Lm1lcmdlV2l0aChyaWdodC5jb250ZW50KVxuICAgICkge1xuICAgICAgY29uc3Qgc2VhcmNoTWFya2VyID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc2VhcmNoTWFya2VyXG4gICAgICBpZiAoc2VhcmNoTWFya2VyKSB7XG4gICAgICAgIHNlYXJjaE1hcmtlci5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICAgICAgaWYgKG1hcmtlci5wID09PSByaWdodCkge1xuICAgICAgICAgICAgLy8gcmlnaHQgaXMgZ29pbmcgdG8gYmUgXCJmb3Jnb3R0ZW5cIiBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFya2VyXG4gICAgICAgICAgICBtYXJrZXIucCA9IHRoaXNcbiAgICAgICAgICAgIC8vIGFkanVzdCBtYXJrZXIgaW5kZXhcbiAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVkICYmIHRoaXMuY291bnRhYmxlKSB7XG4gICAgICAgICAgICAgIG1hcmtlci5pbmRleCAtPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodC5rZWVwKSB7XG4gICAgICAgIHRoaXMua2VlcCA9IHRydWVcbiAgICAgIH1cbiAgICAgIHRoaXMucmlnaHQgPSByaWdodC5yaWdodFxuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpc1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoaXMgSXRlbSBhcyBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGlmICghdGhpcy5kZWxldGVkKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpXG4gICAgICAvLyBhZGp1c3QgdGhlIGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLmNvdW50YWJsZSAmJiB0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuX2xlbmd0aCAtPSB0aGlzLmxlbmd0aFxuICAgICAgfVxuICAgICAgdGhpcy5tYXJrRGVsZXRlZCgpXG4gICAgICBhZGRUb0RlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrLCB0aGlzLmxlbmd0aClcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcGFyZW50LCB0aGlzLnBhcmVudFN1YilcbiAgICAgIHRoaXMuY29udGVudC5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyZW50R0NkXG4gICAqL1xuICBnYyAoc3RvcmUsIHBhcmVudEdDZCkge1xuICAgIGlmICghdGhpcy5kZWxldGVkKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICAgIHRoaXMuY29udGVudC5nYyhzdG9yZSlcbiAgICBpZiAocGFyZW50R0NkKSB7XG4gICAgICByZXBsYWNlU3RydWN0KHN0b3JlLCB0aGlzLCBuZXcgR0ModGhpcy5pZCwgdGhpcy5sZW5ndGgpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBvZmZzZXQgPiAwID8gY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgKyBvZmZzZXQgLSAxKSA6IHRoaXMub3JpZ2luXG4gICAgY29uc3QgcmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0T3JpZ2luXG4gICAgY29uc3QgcGFyZW50U3ViID0gdGhpcy5wYXJlbnRTdWJcbiAgICBjb25zdCBpbmZvID0gKHRoaXMuY29udGVudC5nZXRSZWYoKSAmIGJpbmFyeS5CSVRTNSkgfFxuICAgICAgKG9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUOCkgfCAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHJpZ2h0T3JpZ2luID09PSBudWxsID8gMCA6IGJpbmFyeS5CSVQ3KSB8IC8vIHJpZ2h0IG9yaWdpbiBpcyBkZWZpbmVkXG4gICAgICAocGFyZW50U3ViID09PSBudWxsID8gMCA6IGJpbmFyeS5CSVQ2KSAvLyBwYXJlbnRTdWIgaXMgbm9uLW51bGxcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhpbmZvKVxuICAgIGlmIChvcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQob3JpZ2luKVxuICAgIH1cbiAgICBpZiAocmlnaHRPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVSaWdodElEKHJpZ2h0T3JpZ2luKVxuICAgIH1cbiAgICBpZiAob3JpZ2luID09PSBudWxsICYmIHJpZ2h0T3JpZ2luID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpXG4gICAgICBpZiAocGFyZW50Ll9pdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHBhcmVudC5faXRlbVxuICAgICAgICBpZiAocGFyZW50SXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHBhcmVudCB0eXBlIG9uIHkuX21hcFxuICAgICAgICAgIC8vIGZpbmQgdGhlIGNvcnJlY3Qga2V5XG4gICAgICAgICAgY29uc3QgeWtleSA9IGZpbmRSb290VHlwZUtleShwYXJlbnQpXG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSkgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoeWtleSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSkgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnRJdGVtLmlkKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7IC8vIHRoaXMgZWRnZSBjYXNlIHdhcyBhZGRlZCBieSBkaWZmZXJlbnRpYWwgdXBkYXRlc1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKSAvLyB3cml0ZSBwYXJlbnRZS2V5XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50KVxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKGZhbHNlKSAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50U3ViKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQud3JpdGUoZW5jb2Rlciwgb2Zmc2V0KVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkSXRlbUNvbnRlbnQgPSAoZGVjb2RlciwgaW5mbykgPT4gY29udGVudFJlZnNbaW5mbyAmIGJpbmFyeS5CSVRTNV0oZGVjb2RlcilcblxuLyoqXG4gKiBBIGxvb2t1cCBtYXAgZm9yIHJlYWRpbmcgSXRlbSBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0Q29udGVudD59XG4gKi9cbmV4cG9ydCBjb25zdCBjb250ZW50UmVmcyA9IFtcbiAgKCkgPT4geyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpIH0sIC8vIEdDIGlzIG5vdCBJdGVtQ29udGVudFxuICByZWFkQ29udGVudERlbGV0ZWQsIC8vIDFcbiAgcmVhZENvbnRlbnRKU09OLCAvLyAyXG4gIHJlYWRDb250ZW50QmluYXJ5LCAvLyAzXG4gIHJlYWRDb250ZW50U3RyaW5nLCAvLyA0XG4gIHJlYWRDb250ZW50RW1iZWQsIC8vIDVcbiAgcmVhZENvbnRlbnRGb3JtYXQsIC8vIDZcbiAgcmVhZENvbnRlbnRUeXBlLCAvLyA3XG4gIHJlYWRDb250ZW50QW55LCAvLyA4XG4gIHJlYWRDb250ZW50RG9jLCAvLyA5XG4gICgpID0+IHsgZXJyb3IudW5leHBlY3RlZENhc2UoKSB9IC8vIDEwIC0gU2tpcCBpcyBub3QgSXRlbUNvbnRlbnRcbl1cblxuLyoqXG4gKiBEbyBub3QgaW1wbGVtZW50IHRoaXMgY2xhc3MhXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENvbnRlbnQge1xuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIHJldHVybiBmYWxzZSBpZiB0aGlzIEl0ZW0gaXMgc29tZSBraW5kIG9mIG1ldGEgaW5mb3JtYXRpb25cbiAgICogKGUuZy4gZm9ybWF0IGluZm9ybWF0aW9uKS5cbiAgICpcbiAgICogKiBXaGV0aGVyIHRoaXMgSXRlbSBzaG91bGQgYmUgYWRkcmVzc2FibGUgdmlhIGB5YXJyYXkuZ2V0KGkpYFxuICAgKiAqIFdoZXRoZXIgdGhpcyBJdGVtIHNob3VsZCBiZSBjb3VudGVkIHdoZW4gY29tcHV0aW5nIHlhcnJheS5sZW5ndGhcbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdENvbnRlbnR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gX29mZnNldFxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdENvbnRlbnR9XG4gICAqL1xuICBzcGxpY2UgKF9vZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udGVudH0gX3JpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKF9yaWdodCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IF90cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IF9pdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKF90cmFuc2FjdGlvbiwgX2l0ZW0pIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAoX3RyYW5zYWN0aW9uKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gX3N0b3JlXG4gICAqL1xuICBnYyAoX3N0b3JlKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IF9lbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBfb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoX2VuY29kZXIsIF9vZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5cbmV4cG9ydCBjb25zdCBzdHJ1Y3RTa2lwUmVmTnVtYmVyID0gMTBcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgU2tpcCBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtTa2lwfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCBzdHJ1Y3RzIGNhbm5vdCBiZSBpbnRlZ3JhdGVkXG4gICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RTa2lwUmVmTnVtYmVyKVxuICAgIC8vIHdyaXRlIGFzIFZhclVpbnQgYmVjYXVzZSBTa2lwcyBjYW4ndCBtYWtlIHVzZSBvZiBwcmVkaWN0YWJsZSBsZW5ndGgtZW5jb2RpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgdGhpcy5sZW5ndGggLSBvZmZzZXQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cbiIsICIvKiogZXNsaW50LWVudiBicm93c2VyICovXG5cbmV4cG9ydCB7XG4gIERvYyxcbiAgVHJhbnNhY3Rpb24sXG4gIFlBcnJheSBhcyBBcnJheSxcbiAgWU1hcCBhcyBNYXAsXG4gIFlUZXh0IGFzIFRleHQsXG4gIFlYbWxUZXh0IGFzIFhtbFRleHQsXG4gIFlYbWxIb29rIGFzIFhtbEhvb2ssXG4gIFlYbWxFbGVtZW50IGFzIFhtbEVsZW1lbnQsXG4gIFlYbWxGcmFnbWVudCBhcyBYbWxGcmFnbWVudCxcbiAgWVhtbEV2ZW50LFxuICBZTWFwRXZlbnQsXG4gIFlBcnJheUV2ZW50LFxuICBZVGV4dEV2ZW50LFxuICBZRXZlbnQsXG4gIEl0ZW0sXG4gIEFic3RyYWN0U3RydWN0LFxuICBHQyxcbiAgU2tpcCxcbiAgQ29udGVudEJpbmFyeSxcbiAgQ29udGVudERlbGV0ZWQsXG4gIENvbnRlbnREb2MsXG4gIENvbnRlbnRFbWJlZCxcbiAgQ29udGVudEZvcm1hdCxcbiAgQ29udGVudEpTT04sXG4gIENvbnRlbnRBbnksXG4gIENvbnRlbnRTdHJpbmcsXG4gIENvbnRlbnRUeXBlLFxuICBBYnN0cmFjdFR5cGUsXG4gIGdldFR5cGVDaGlsZHJlbixcbiAgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgsXG4gIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTixcbiAgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uLFxuICBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMsXG4gIEFic29sdXRlUG9zaXRpb24sXG4gIFJlbGF0aXZlUG9zaXRpb24sXG4gIElELFxuICBjcmVhdGVJRCxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0U3RhdGUsXG4gIFNuYXBzaG90LFxuICBjcmVhdGVTbmFwc2hvdCxcbiAgY3JlYXRlRGVsZXRlU2V0LFxuICBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUsXG4gIGNsZWFudXBZVGV4dEZvcm1hdHRpbmcsXG4gIHNuYXBzaG90LFxuICBlbXB0eVNuYXBzaG90LFxuICBmaW5kUm9vdFR5cGVLZXksXG4gIGZpbmRJbmRleFNTLFxuICBnZXRJdGVtLFxuICB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCxcbiAgdHlwZU1hcEdldFNuYXBzaG90LFxuICB0eXBlTWFwR2V0QWxsU25hcHNob3QsXG4gIGNyZWF0ZURvY0Zyb21TbmFwc2hvdCxcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLFxuICBhcHBseVVwZGF0ZSxcbiAgYXBwbHlVcGRhdGVWMixcbiAgcmVhZFVwZGF0ZSxcbiAgcmVhZFVwZGF0ZVYyLFxuICBlbmNvZGVTdGF0ZUFzVXBkYXRlLFxuICBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIsXG4gIGVuY29kZVN0YXRlVmVjdG9yLFxuICBVbmRvTWFuYWdlcixcbiAgZGVjb2RlU25hcHNob3QsXG4gIGVuY29kZVNuYXBzaG90LFxuICBkZWNvZGVTbmFwc2hvdFYyLFxuICBlbmNvZGVTbmFwc2hvdFYyLFxuICBkZWNvZGVTdGF0ZVZlY3RvcixcbiAgbG9nVXBkYXRlLFxuICBsb2dVcGRhdGVWMixcbiAgZGVjb2RlVXBkYXRlLFxuICBkZWNvZGVVcGRhdGVWMixcbiAgcmVsYXRpdmVQb3NpdGlvblRvSlNPTixcbiAgaXNEZWxldGVkLFxuICBpc1BhcmVudE9mLFxuICBlcXVhbFNuYXBzaG90cyxcbiAgUGVybWFuZW50VXNlckRhdGEsIC8vIEBUT0RPIGV4cGVyaW1lbnRhbFxuICB0cnlHYyxcbiAgdHJhbnNhY3QsXG4gIEFic3RyYWN0Q29ubmVjdG9yLFxuICBsb2dUeXBlLFxuICBtZXJnZVVwZGF0ZXMsXG4gIG1lcmdlVXBkYXRlc1YyLFxuICBwYXJzZVVwZGF0ZU1ldGEsXG4gIHBhcnNlVXBkYXRlTWV0YVYyLFxuICBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUsXG4gIGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyLFxuICBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uLFxuICBkZWNvZGVSZWxhdGl2ZVBvc2l0aW9uLFxuICBkaWZmVXBkYXRlLFxuICBkaWZmVXBkYXRlVjIsXG4gIGNvbnZlcnRVcGRhdGVGb3JtYXRWMVRvVjIsXG4gIGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEsXG4gIG9iZnVzY2F0ZVVwZGF0ZSxcbiAgb2JmdXNjYXRlVXBkYXRlVjIsXG4gIFVwZGF0ZUVuY29kZXJWMSxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBVcGRhdGVEZWNvZGVyVjEsXG4gIFVwZGF0ZURlY29kZXJWMixcbiAgZXF1YWxEZWxldGVTZXRzLFxuICBtZXJnZURlbGV0ZVNldHMsXG4gIHNuYXBzaG90Q29udGFpbnNVcGRhdGVcbn0gZnJvbSAnLi9pbnRlcm5hbHMuanMnXG5cbmNvbnN0IGdsbyA9IC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gID8gZ2xvYmFsVGhpc1xuICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9KVxuXG5jb25zdCBpbXBvcnRJZGVudGlmaWVyID0gJ19fICRZSlMkIF9fJ1xuXG5pZiAoZ2xvW2ltcG9ydElkZW50aWZpZXJdID09PSB0cnVlKSB7XG4gIC8qKlxuICAgKiBEZWFyIHJlYWRlciBvZiB0aGlzIG1lc3NhZ2UuIFBsZWFzZSB0YWtlIHRoaXMgc2VyaW91c2x5LlxuICAgKlxuICAgKiBJZiB5b3Ugc2VlIHRoaXMgbWVzc2FnZSwgbWFrZSBzdXJlIHRoYXQgeW91IG9ubHkgaW1wb3J0IG9uZSB2ZXJzaW9uIG9mIFlqcy4gSW4gbWFueSBjYXNlcyxcbiAgICogeW91ciBwYWNrYWdlIG1hbmFnZXIgaW5zdGFsbHMgdHdvIHZlcnNpb25zIG9mIFlqcyB0aGF0IGFyZSB1c2VkIGJ5IGRpZmZlcmVudCBwYWNrYWdlcyB3aXRoaW4geW91ciBwcm9qZWN0LlxuICAgKiBBbm90aGVyIHJlYXNvbiBmb3IgdGhpcyBtZXNzYWdlIGlzIHRoYXQgc29tZSBwYXJ0cyBvZiB5b3VyIHByb2plY3QgdXNlIHRoZSBjb21tb25qcyB2ZXJzaW9uIG9mIFlqc1xuICAgKiBhbmQgb3RoZXJzIHVzZSB0aGUgRWNtYVNjcmlwdCB2ZXJzaW9uIG9mIFlqcy5cbiAgICpcbiAgICogVGhpcyBvZnRlbiBsZWFkcyB0byBpc3N1ZXMgdGhhdCBhcmUgaGFyZCB0byBkZWJ1Zy4gV2Ugb2Z0ZW4gbmVlZCB0byBwZXJmb3JtIGNvbnN0cnVjdG9yIGNoZWNrcyxcbiAgICogZS5nLiBgc3RydWN0IGluc3RhbmNlb2YgR0NgLiBJZiB5b3UgaW1wb3J0ZWQgZGlmZmVyZW50IHZlcnNpb25zIG9mIFlqcywgaXQgaXMgaW1wb3NzaWJsZSBmb3IgdXMgdG9cbiAgICogZG8gdGhlIGNvbnN0cnVjdG9yIGNoZWNrcyBhbnltb3JlIC0gd2hpY2ggbWlnaHQgYnJlYWsgdGhlIENSRFQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNDM4XG4gICAqL1xuICBjb25zb2xlLmVycm9yKCdZanMgd2FzIGFscmVhZHkgaW1wb3J0ZWQuIFRoaXMgYnJlYWtzIGNvbnN0cnVjdG9yIGNoZWNrcyBhbmQgd2lsbCBsZWFkIHRvIGlzc3VlcyEgLSBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNDM4Jylcbn1cbmdsb1tpbXBvcnRJZGVudGlmaWVyXSA9IHRydWVcbiIsICJpbXBvcnQgKiBhcyBYWEggZnJvbSAneHhoYXNoanMnXG5cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gKCk6IHN0cmluZyA9PiB7XG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLnJhbmRvbVVVSUQoKVxufVxuXG5leHBvcnQgY29uc3QgcmFuZG9tVWludDMyID0gKCk6IG51bWJlciA9PiB7XG4gIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xufVxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSYW5kb21TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDIwKS5zdWJzdHJpbmcoMiwgOClcbn1cblxuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUhhc2ggPSAodGV4dDogc3RyaW5nKSA9PiB7IHJldHVybiBYWEguaDMyKHRleHQsIDB4QUJDRCkudG9TdHJpbmcoMTYpIH1cblxuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZSA9IChvYmo6IGFueSk6IHN0cmluZyA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gYFske29iai5tYXAoZWwgPT4gc2VyaWFsaXplKGVsKSkuam9pbignLCcpfV1gXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgbGV0IGFjYyA9ICcnXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgpXG4gICAgYWNjICs9IGB7JHtKU09OLnN0cmluZ2lmeShrZXlzKX1gXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY2MgKz0gYCR7c2VyaWFsaXplKG9ialtrZXlzW2ldXSl9LGBcbiAgICB9XG4gICAgcmV0dXJuIGAke2FjY319YFxuICB9XG4gIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeShvYmopfWBcbn0iLCAiaW1wb3J0IHsgQXBwLCBNb2RhbCwgTm90aWNlLCBTZXR0aW5nLCBURmlsZSwgV29ya3NwYWNlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmNsYXNzIFNob3dUZXh0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cblx0bWVzc2FnZTogc3RyaW5nXG4gIHRpdGxlOiBzdHJpbmdcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy50aXRsZSA9IHRpdGxlXG5cdH1cblxuXHRvbk9wZW4oKSB7XG5cdFx0dGhpcy50aXRsZUVsLnNldFRleHQodGhpcy50aXRsZSlcblx0XHR0aGlzLmNvbnRlbnRFbC5zZXRUZXh0KHRoaXMubWVzc2FnZSlcblx0fVxuXG5cdG9uQ2xvc2UoKSB7XG5cdFx0dGhpcy5jb250YWluZXJFbC5lbXB0eSgpXG5cdH1cbn1cblxuZXhwb3J0IGNvbnN0IHNob3dUZXh0TW9kYWwgPSAoYXBwOiBBcHAsIHRpdGxlOiBzdHJpbmcsIHRleHQ6IHN0cmluZykgPT4ge1xuICBuZXcgU2hvd1RleHRNb2RhbChhcHAsIHRpdGxlLCB0ZXh0KS5vcGVuKClcbn1cblxuZXhwb3J0IGNvbnN0IHNob3dOb3RpY2UgPSAodGV4dDogc3RyaW5nLCBkdXJhdGlvbj86IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xuXHRyZXR1cm4gbmV3IE5vdGljZSh0ZXh0LCBkdXJhdGlvbilcbn1cblxuXG5jbGFzcyBFbnRlclRleHRNb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuICBpbnB1dERlc2NyaXB0aW9uczogQXJyYXk8e25hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZ30+XG4gIGNiOiAocmVzdWx0OiBBcnJheTx7bmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfT4pID0+IGFueVxuICByZXN1bHQ6IEFycmF5PHtuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmd9PlxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBpbnB1dERlc2NyaXB0aW9uczogQXJyYXk8e25hbWU6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZ30+LCBjYjogKHJlc3VsdDogQXJyYXk8e25hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZ30+KSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5pbnB1dERlc2NyaXB0aW9ucyA9IGlucHV0RGVzY3JpcHRpb25zXG4gICAgdGhpcy5jYiA9IGNiXG4gICAgdGhpcy5yZXN1bHQgPSBpbnB1dERlc2NyaXB0aW9ucy5tYXAoZGVzY3JpcHRpb24gPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGVzY3JpcHRpb24ubmFtZSxcbiAgICAgICAgdmFsdWU6IFwiXCJcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmlucHV0RGVzY3JpcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmlucHV0RGVzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICAgIHNldHRpbmcuc2V0TmFtZShkZXNjcmlwdGlvbi5uYW1lKVxuICAgICAgc2V0dGluZy5zZXREZXNjKGRlc2NyaXB0aW9uLmRlc2NyaXB0aW9uKVxuICAgICAgc2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgICB0aGlzLnJlc3VsdFtpbmRleF0udmFsdWUgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b25zID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgYnV0dG9ucy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2FuY2VsXCIpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmNiKHRoaXMucmVzdWx0KVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgYnV0dG9ucy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiR29cIilcbiAgICAgIGJ1dHRvbi5zZXRDdGEoKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIG9uQ2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yTXVsdGlwbGVUZXh0SW5wdXRzID0gYXN5bmMgKGFwcDogQXBwLCBpbnB1dERlc2NyaXB0aW9uczogQXJyYXk8eyBuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcgfT4pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPEFycmF5PHsgbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIH0+IHwgdm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBuZXcgRW50ZXJUZXh0TW9kYWwoYXBwLCBpbnB1dERlc2NyaXB0aW9ucywgKHJlc3VsdCkgPT4ge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgfSkub3BlbigpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBvcGVuRmlsZUluTmV3VGFiID0gYXN5bmMgKGZpbGU6IFRGaWxlLCB3b3Jrc3BhY2U6IFdvcmtzcGFjZSkgPT4ge1xuICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoJ3RhYicpXG4gIGF3YWl0IGxlYWYub3BlbkZpbGUoZmlsZSlcbiAgcmV0dXJuIGxlYWZcbn1cblxuXG5cbmV4cG9ydCBjb25zdCBwaW5MZWFmID0gKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IHtcbiAgbGVhZi5zZXRQaW5uZWQodHJ1ZSlcbiAgc2hvd05vdGljZShgYXV0by1waW5uZWQgXCIke2xlYWYuZ2V0RGlzcGxheVRleHQoKX1cImApXG59XG5cbmV4cG9ydCBjb25zdCB1c2VyY29sb3JzID0gW1xuICB7IGRhcms6ICcjMzBiY2VkJywgbGlnaHQ6ICcjMzBiY2VkMzMnIH0sXG4gIHsgZGFyazogJyM2ZWViODMnLCBsaWdodDogJyM2ZWViODMzMycgfSxcbiAgeyBkYXJrOiAnI2ZmYmM0MicsIGxpZ2h0OiAnI2ZmYmM0MjMzJyB9LFxuICB7IGRhcms6ICcjZWNkNDQ0JywgbGlnaHQ6ICcjZWNkNDQ0MzMnIH0sXG4gIHsgZGFyazogJyNlZTYzNTInLCBsaWdodDogJyNlZTYzNTIzMycgfSxcbiAgeyBkYXJrOiAnIzlhYzJjOScsIGxpZ2h0OiAnIzlhYzJjOTMzJyB9LFxuICB7IGRhcms6ICcjOGFjYjg4JywgbGlnaHQ6ICcjOGFjYjg4MzMnIH0sXG4gIHsgZGFyazogJyMxYmU3ZmYnLCBsaWdodDogJyMxYmU3ZmYzMycgfVxuXSIsICJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBjbVZpZXcgZnJvbSAnQGNvZGVtaXJyb3IvdmlldydcbmltcG9ydCAqIGFzIGNtU3RhdGUgZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuaW1wb3J0IHsgWVJhbmdlIH0gZnJvbSAnLi95LXJhbmdlLmpzJ1xuaW1wb3J0IHsgeVN5bmMsIHlTeW5jRmFjZXQsIFlTeW5jQ29uZmlnIH0gZnJvbSAnLi95LXN5bmMuanMnXG5pbXBvcnQgeyB5UmVtb3RlU2VsZWN0aW9ucywgeVJlbW90ZVNlbGVjdGlvbnNUaGVtZSB9IGZyb20gJy4veS1yZW1vdGUtc2VsZWN0aW9ucy5qcydcbmltcG9ydCB7IHlVbmRvTWFuYWdlciwgeVVuZG9NYW5hZ2VyRmFjZXQsIFlVbmRvTWFuYWdlckNvbmZpZywgdW5kbywgcmVkbywgeVVuZG9NYW5hZ2VyS2V5bWFwIH0gZnJvbSAnLi95LXVuZG9tYW5hZ2VyLmpzJ1xuXG5leHBvcnQgeyBZUmFuZ2UsIHlSZW1vdGVTZWxlY3Rpb25zLCB5UmVtb3RlU2VsZWN0aW9uc1RoZW1lLCB5U3luYywgeVN5bmNGYWNldCwgWVN5bmNDb25maWcsIHlVbmRvTWFuYWdlcktleW1hcCB9XG5cbi8qKlxuICogQHBhcmFtIHtZLlRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge2FueX0gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge1kuVW5kb01hbmFnZXIgfCBmYWxzZX0gW29wdHMudW5kb01hbmFnZXJdIFNldCB1bmRvTWFuYWdlciB0byBmYWxzZSB0byBkaXNhYmxlIHRoZSB1bmRvLXJlZG8gcGx1Z2luXG4gKiBAcmV0dXJuIHtjbVN0YXRlLkV4dGVuc2lvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlDb2xsYWIgPSAoeXRleHQsIGF3YXJlbmVzcywgeyB1bmRvTWFuYWdlciA9IG5ldyBZLlVuZG9NYW5hZ2VyKHl0ZXh0KSB9ID0ge30pID0+IHtcbiAgY29uc3QgeVN5bmNDb25maWcgPSBuZXcgWVN5bmNDb25maWcoeXRleHQsIGF3YXJlbmVzcylcbiAgY29uc3QgcGx1Z2lucyA9IFtcbiAgICB5U3luY0ZhY2V0Lm9mKHlTeW5jQ29uZmlnKSxcbiAgICB5U3luY1xuICBdXG4gIGlmIChhd2FyZW5lc3MpIHtcbiAgICBwbHVnaW5zLnB1c2goXG4gICAgICB5UmVtb3RlU2VsZWN0aW9uc1RoZW1lLFxuICAgICAgeVJlbW90ZVNlbGVjdGlvbnNcbiAgICApXG4gIH1cbiAgaWYgKHVuZG9NYW5hZ2VyICE9PSBmYWxzZSkge1xuICAgIC8vIEJ5IGRlZmF1bHQsIG9ubHkgdHJhY2sgY2hhbmdlcyB0aGF0IGFyZSBwcm9kdWNlZCBieSB0aGUgc3luYyBwbHVnaW4gKGxvY2FsIGVkaXRzKVxuICAgIHBsdWdpbnMucHVzaChcbiAgICAgIHlVbmRvTWFuYWdlckZhY2V0Lm9mKG5ldyBZVW5kb01hbmFnZXJDb25maWcodW5kb01hbmFnZXIpKSxcbiAgICAgIHlVbmRvTWFuYWdlcixcbiAgICAgIGNtVmlldy5FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgICBiZWZvcmVpbnB1dCAoZSwgdmlldykge1xuICAgICAgICAgIGlmIChlLmlucHV0VHlwZSA9PT0gJ2hpc3RvcnlVbmRvJykgcmV0dXJuIHVuZG8odmlldylcbiAgICAgICAgICBpZiAoZS5pbnB1dFR5cGUgPT09ICdoaXN0b3J5UmVkbycpIHJldHVybiByZWRvKHZpZXcpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICB9XG4gIHJldHVybiBwbHVnaW5zXG59XG4iLCAiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbi8qKlxuICogRGVmaW5lcyBhIHJhbmdlIG9uIHRleHQgdXNpbmcgcmVsYXRpdmUgcG9zaXRpb25zIHRoYXQgY2FuIGJlIHRyYW5zZm9ybWVkIGJhY2sgdG9cbiAqIGFic29sdXRlIHBvc2l0aW9ucy4gKGh0dHBzOi8vZG9jcy55anMuZGV2L2FwaS9yZWxhdGl2ZS1wb3NpdGlvbnMpXG4gKi9cbmV4cG9ydCBjbGFzcyBZUmFuZ2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlJlbGF0aXZlUG9zaXRpb259IHlhbmNob3JcbiAgICogQHBhcmFtIHtZLlJlbGF0aXZlUG9zaXRpb259IHloZWFkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWFuY2hvciwgeWhlYWQpIHtcbiAgICB0aGlzLnlhbmNob3IgPSB5YW5jaG9yXG4gICAgdGhpcy55aGVhZCA9IHloZWFkXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2FueX1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHlhbmNob3I6IFkucmVsYXRpdmVQb3NpdGlvblRvSlNPTih0aGlzLnlhbmNob3IpLFxuICAgICAgeWhlYWQ6IFkucmVsYXRpdmVQb3NpdGlvblRvSlNPTih0aGlzLnloZWFkKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0ganNvblxuICAgKiBAcmV0dXJuIHtZUmFuZ2V9XG4gICAqL1xuICBzdGF0aWMgZnJvbUpTT04gKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IFlSYW5nZShZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihqc29uLnlhbmNob3IpLCBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihqc29uLnloZWFkKSlcbiAgfVxufVxuIiwgIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgKiBhcyBjbVN0YXRlIGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBjbVZpZXcgZnJvbSAnQGNvZGVtaXJyb3IvdmlldycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgWVJhbmdlIH0gZnJvbSAnLi95LXJhbmdlLmpzJ1xuXG5leHBvcnQgY2xhc3MgWVN5bmNDb25maWcge1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIGF3YXJlbmVzcykge1xuICAgIHRoaXMueXRleHQgPSB5dGV4dFxuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gICAgdGhpcy51bmRvTWFuYWdlciA9IG5ldyBZLlVuZG9NYW5hZ2VyKHl0ZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gYW4gYWJzb2x1dGUgaW5kZXggcG9zaXRpb24gdG8gYSBZanMtYmFzZWQgcmVsYXRpdmUgcG9zaXRpb25cbiAgICogKGh0dHBzOi8vZG9jcy55anMuZGV2L2FwaS9yZWxhdGl2ZS1wb3NpdGlvbnMpLlxuICAgKlxuICAgKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGNhbiBiZSB0cmFuc2Zvcm1lZCBiYWNrIHRvIGFuIGFic29sdXRlIHBvc2l0aW9uIGV2ZW4gYWZ0ZXIgdGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkLiBUaGUgcG9zaXRpb24gaXNcbiAgICogYXV0b21hdGljYWxseSBhZGFwdGVkLiBUaGlzIGRvZXMgbm90IHJlcXVpcmUgYW55IHBvc2l0aW9uIHRyYW5zZm9ybWF0aW9ucy4gUmVsYXRpdmUgcG9zaXRpb25zIGFyZSBjb21wdXRlZCBiYXNlZCBvblxuICAgKiB0aGUgaW50ZXJuYWwgWWpzIGRvY3VtZW50IG1vZGVsLiBQZWVycyB0aGF0IHNoYXJlIGNvbnRlbnQgdGhyb3VnaCBZanMgYXJlIGd1YXJhbnRlZWQgdGhhdCB0aGVpciBwb3NpdGlvbnMgd2lsbCBhbHdheXNcbiAgICogc3luY2VkIHVwIHdoZW4gdXNpbmcgcmVsYXR2ZSBwb3NpdGlvbnMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGltcG9ydCB7IHlTeW5jRmFjZXQgfSBmcm9tICd5LWNvZGVtaXJyb3InXG4gICAqXG4gICAqIC4uXG4gICAqIGNvbnN0IHlzeW5jID0gdmlldy5zdGF0ZS5mYWNldCh5U3luY0ZhY2V0KVxuICAgKiAvLyB0cmFuc2Zvcm0gYW4gYWJzb2x1dGUgaW5kZXggcG9zaXRpb24gdG8gYSB5cG9zXG4gICAqIGNvbnN0IHlwb3MgPSB5c3luYy5nZXRZUG9zKDMpXG4gICAqIC8vIHRyYW5zZm9ybSB0aGUgeXBvcyBiYWNrIHRvIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gICAqIHlzeW5jLmZyb21ZUG9zKHlwb3MpIC8vID0+IDNcbiAgICogYGBgXG4gICAqXG4gICAqIEl0IGNhbm5vdCBiZSBndWFyYW50ZWVkIHRoYXQgYWJzb2x1dGUgaW5kZXggcG9zaXRpb25zIGNhbiBiZSBzeW5jZWQgdXAgYmV0d2VlbiBwZWVycy5cbiAgICogVGhpcyBtaWdodCBsZWFkIHRvIHVuZGVzaXJlZCBiZWhhdmlvciB3aGVuIGltcGxlbWVudGluZyBmZWF0dXJlcyB0aGF0IHJlcXVpcmUgdGhhdCBhbGwgcGVlcnMgc2VlIHRoZVxuICAgKiBzYW1lIG1hcmtlZCByYW5nZSAoZS5nLiBhIGNvbW1lbnQgcGx1Z2luKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICAgKi9cbiAgdG9ZUG9zIChwb3MsIGFzc29jID0gMCkge1xuICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHRoaXMueXRleHQsIHBvcywgYXNzb2MpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtZLlJlbGF0aXZlUG9zaXRpb24gfCBPYmplY3R9IHJwb3NcbiAgICovXG4gIGZyb21ZUG9zIChycG9zKSB7XG4gICAgY29uc3QgcG9zID0gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04ocnBvcyksIHRoaXMueXRleHQuZG9jKVxuICAgIGlmIChwb3MgPT0gbnVsbCB8fCBwb3MudHlwZSAhPT0gdGhpcy55dGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbeS1jb2RlbWlycm9yXSBUaGUgcG9zaXRpb24geW91IHdhbnQgdG8gcmV0cmlldmUgd2FzIGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgZG9jdW1lbnQnKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBwb3MuaW5kZXgsXG4gICAgICBhc3NvYzogcG9zLmFzc29jXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21TdGF0ZS5TZWxlY3Rpb25SYW5nZX0gcmFuZ2VcbiAgICogQHJldHVybiB7WVJhbmdlfVxuICAgKi9cbiAgdG9ZUmFuZ2UgKHJhbmdlKSB7XG4gICAgY29uc3QgYXNzb2MgPSByYW5nZS5hc3NvY1xuICAgIGNvbnN0IHlhbmNob3IgPSB0aGlzLnRvWVBvcyhyYW5nZS5hbmNob3IsIGFzc29jKVxuICAgIGNvbnN0IHloZWFkID0gdGhpcy50b1lQb3MocmFuZ2UuaGVhZCwgYXNzb2MpXG4gICAgcmV0dXJuIG5ldyBZUmFuZ2UoeWFuY2hvciwgeWhlYWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtZUmFuZ2V9IHlyYW5nZVxuICAgKi9cbiAgZnJvbVlSYW5nZSAoeXJhbmdlKSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5mcm9tWVBvcyh5cmFuZ2UueWFuY2hvcilcbiAgICBjb25zdCBoZWFkID0gdGhpcy5mcm9tWVBvcyh5cmFuZ2UueWhlYWQpXG4gICAgaWYgKGFuY2hvci5wb3MgPT09IGhlYWQucG9zKSB7XG4gICAgICByZXR1cm4gY21TdGF0ZS5FZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQucG9zLCBoZWFkLmFzc29jKVxuICAgIH1cbiAgICByZXR1cm4gY21TdGF0ZS5FZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLnBvcywgaGVhZC5wb3MpXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5GYWNldDxZU3luY0NvbmZpZywgWVN5bmNDb25maWc+fVxuICovXG5leHBvcnQgY29uc3QgeVN5bmNGYWNldCA9IGNtU3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgY29tYmluZSAoaW5wdXRzKSB7XG4gICAgcmV0dXJuIGlucHV0c1tpbnB1dHMubGVuZ3RoIC0gMV1cbiAgfVxufSlcblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5Bbm5vdGF0aW9uVHlwZTxZU3luY0NvbmZpZz59XG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY0Fubm90YXRpb24gPSBjbVN0YXRlLkFubm90YXRpb24uZGVmaW5lKClcblxuLyoqXG4gKiBAZXh0ZW5kcyB7UGx1Z2luVmFsdWV9XG4gKi9cbmNsYXNzIFlTeW5jUGx1Z2luVmFsdWUge1xuICAvKipcbiAgICogQHBhcmFtIHtjbVZpZXcuRWRpdG9yVmlld30gdmlld1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHZpZXcpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5jb25mID0gdmlldy5zdGF0ZS5mYWNldCh5U3luY0ZhY2V0KVxuICAgIHRoaXMuX29ic2VydmVyID0gKGV2ZW50LCB0cikgPT4ge1xuICAgICAgaWYgKHRyLm9yaWdpbiAhPT0gdGhpcy5jb25mKSB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gZXZlbnQuZGVsdGFcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdXG4gICAgICAgIGxldCBwb3MgPSAwXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBkID0gZGVsdGFbaV1cbiAgICAgICAgICBpZiAoZC5pbnNlcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogcG9zLCBpbnNlcnQ6IGQuaW5zZXJ0IH0pXG4gICAgICAgICAgfSBlbHNlIGlmIChkLmRlbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBwb3MgKyBkLmRlbGV0ZSwgaW5zZXJ0OiAnJyB9KVxuICAgICAgICAgICAgcG9zICs9IGQuZGVsZXRlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyArPSBkLnJldGFpblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgYW5ub3RhdGlvbnM6IFt5U3luY0Fubm90YXRpb24ub2YodGhpcy5jb25mKV0gfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feXRleHQgPSB0aGlzLmNvbmYueXRleHRcbiAgICB0aGlzLl95dGV4dC5vYnNlcnZlKHRoaXMuX29ic2VydmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LlZpZXdVcGRhdGV9IHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlICh1cGRhdGUpIHtcbiAgICBpZiAoIXVwZGF0ZS5kb2NDaGFuZ2VkIHx8ICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aCA+IDAgJiYgdXBkYXRlLnRyYW5zYWN0aW9uc1swXS5hbm5vdGF0aW9uKHlTeW5jQW5ub3RhdGlvbikgPT09IHRoaXMuY29uZikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5dGV4dCA9IHRoaXMuY29uZi55dGV4dFxuICAgIHl0ZXh0LmRvYy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgdmFyaWFibGUgYWRqdXN0cyB0aGUgZnJvbUEgcG9zaXRpb24gdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIFkuVGV4dCB0eXBlLlxuICAgICAgICovXG4gICAgICBsZXQgYWRqID0gMFxuICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IsIGluc2VydCkgPT4ge1xuICAgICAgICBjb25zdCBpbnNlcnRUZXh0ID0gaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIGluc2VydC5sZW5ndGgsICdcXG4nKVxuICAgICAgICBpZiAoZnJvbUEgIT09IHRvQSkge1xuICAgICAgICAgIHl0ZXh0LmRlbGV0ZShmcm9tQSArIGFkaiwgdG9BIC0gZnJvbUEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydFRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHl0ZXh0Lmluc2VydChmcm9tQSArIGFkaiwgaW5zZXJ0VGV4dClcbiAgICAgICAgfVxuICAgICAgICBhZGogKz0gaW5zZXJ0VGV4dC5sZW5ndGggLSAodG9BIC0gZnJvbUEpXG4gICAgICB9KVxuICAgIH0sIHRoaXMuY29uZilcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX3l0ZXh0LnVub2JzZXJ2ZSh0aGlzLl9vYnNlcnZlcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgeVN5bmMgPSBjbVZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoWVN5bmNQbHVnaW5WYWx1ZSlcbiIsICJcbmltcG9ydCAqIGFzIGNtVmlldyBmcm9tICdAY29kZW1pcnJvci92aWV3J1xuXG5pbXBvcnQgKiBhcyBjbVN0YXRlIGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJ1xuaW1wb3J0ICogYXMgZG9tIGZyb20gJ2xpYjAvZG9tJ1xuaW1wb3J0ICogYXMgcGFpciBmcm9tICdsaWIwL3BhaXInXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcblxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyB5U3luY0ZhY2V0IH0gZnJvbSAnLi95LXN5bmMuanMnXG5cbmV4cG9ydCBjb25zdCB5UmVtb3RlU2VsZWN0aW9uc1RoZW1lID0gY21WaWV3LkVkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgJy5jbS15U2VsZWN0aW9uJzoge1xuICB9LFxuICAnLmNtLXlMaW5lU2VsZWN0aW9uJzoge1xuICAgIHBhZGRpbmc6IDAsXG4gICAgbWFyZ2luOiAnMHB4IDJweCAwcHggNHB4J1xuICB9LFxuICAnLmNtLXlTZWxlY3Rpb25DYXJldCc6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICBib3JkZXJMZWZ0OiAnMXB4IHNvbGlkIGJsYWNrJyxcbiAgICBib3JkZXJSaWdodDogJzFweCBzb2xpZCBibGFjaycsXG4gICAgbWFyZ2luTGVmdDogJy0xcHgnLFxuICAgIG1hcmdpblJpZ2h0OiAnLTFweCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgZGlzcGxheTogJ2lubGluZSdcbiAgfSxcbiAgJy5jbS15U2VsZWN0aW9uQ2FyZXREb3QnOiB7XG4gICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJy40ZW0nLFxuICAgIGhlaWdodDogJy40ZW0nLFxuICAgIHRvcDogJy0uMmVtJyxcbiAgICBsZWZ0OiAnLS4yZW0nLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ2luaGVyaXQnLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2Zvcm0gLjNzIGVhc2UtaW4tb3V0JyxcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICB9LFxuICAnLmNtLXlTZWxlY3Rpb25DYXJldDpob3ZlciA+IC5jbS15U2VsZWN0aW9uQ2FyZXREb3QnOiB7XG4gICAgdHJhbnNmb3JtT3JpZ2luOiAnYm90dG9tIGNlbnRlcicsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMCknXG4gIH0sXG4gICcuY20teVNlbGVjdGlvbkluZm8nOiB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAnLTEuMDVlbScsXG4gICAgbGVmdDogJy0xcHgnLFxuICAgIGZvbnRTaXplOiAnLjc1ZW0nLFxuICAgIGZvbnRGYW1pbHk6ICdzZXJpZicsXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcbiAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICBsaW5lSGVpZ2h0OiAnbm9ybWFsJyxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG4gICAgY29sb3I6ICd3aGl0ZScsXG4gICAgcGFkZGluZ0xlZnQ6ICcycHgnLFxuICAgIHBhZGRpbmdSaWdodDogJzJweCcsXG4gICAgekluZGV4OiAxMDEsXG4gICAgdHJhbnNpdGlvbjogJ29wYWNpdHkgLjNzIGVhc2UtaW4tb3V0JyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdpbmhlcml0JyxcbiAgICAvLyB0aGVzZSBzaG91bGQgYmUgc2VwYXJhdGVcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRyYW5zaXRpb25EZWxheTogJzBzJyxcbiAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJ1xuICB9LFxuICAnLmNtLXlTZWxlY3Rpb25DYXJldDpob3ZlciA+IC5jbS15U2VsZWN0aW9uSW5mbyc6IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIHRyYW5zaXRpb25EZWxheTogJzBzJ1xuICB9XG59KVxuXG4vKipcbiAqIEB0b2RvIHNwZWNpZnkgdGhlIHVzZXJzIHRoYXQgYWN0dWFsbHkgY2hhbmdlZC4gQ3VycmVudGx5LCB3ZSByZWNhbGN1bGF0ZSBwb3NpdGlvbnMgZm9yIGV2ZXJ5IHVzZXIuXG4gKiBAdHlwZSB7Y21TdGF0ZS5Bbm5vdGF0aW9uVHlwZTxBcnJheTxudW1iZXI+Pn1cbiAqL1xuY29uc3QgeVJlbW90ZVNlbGVjdGlvbnNBbm5vdGF0aW9uID0gY21TdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpXG5cbmNsYXNzIFlSZW1vdGVDYXJldFdpZGdldCBleHRlbmRzIGNtVmlldy5XaWRnZXRUeXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbG9yLCBuYW1lKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29sb3IgPSBjb2xvclxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgfVxuXG4gIHRvRE9NICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvbS5lbGVtZW50KCdzcGFuJywgW3BhaXIuY3JlYXRlKCdjbGFzcycsICdjbS15U2VsZWN0aW9uQ2FyZXQnKSwgcGFpci5jcmVhdGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7dGhpcy5jb2xvcn07IGJvcmRlci1jb2xvcjogJHt0aGlzLmNvbG9yfWApXSwgW1xuICAgICAgZG9tLnRleHQoJ1xcdTIwNjAnKSxcbiAgICAgIGRvbS5lbGVtZW50KCdkaXYnLCBbXG4gICAgICAgIHBhaXIuY3JlYXRlKCdjbGFzcycsICdjbS15U2VsZWN0aW9uQ2FyZXREb3QnKVxuICAgICAgXSksXG4gICAgICBkb20udGV4dCgnXFx1MjA2MCcpLFxuICAgICAgZG9tLmVsZW1lbnQoJ2RpdicsIFtcbiAgICAgICAgcGFpci5jcmVhdGUoJ2NsYXNzJywgJ2NtLXlTZWxlY3Rpb25JbmZvJylcbiAgICAgIF0sIFtcbiAgICAgICAgZG9tLnRleHQodGhpcy5uYW1lKVxuICAgICAgXSksXG4gICAgICBkb20udGV4dCgnXFx1MjA2MCcpXG4gICAgXSkpXG4gIH1cblxuICBlcSAod2lkZ2V0KSB7XG4gICAgcmV0dXJuIHdpZGdldC5jb2xvciA9PT0gdGhpcy5jb2xvclxuICB9XG5cbiAgY29tcGFyZSAod2lkZ2V0KSB7XG4gICAgcmV0dXJuIHdpZGdldC5jb2xvciA9PT0gdGhpcy5jb2xvclxuICB9XG5cbiAgdXBkYXRlRE9NICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldCBlc3RpbWF0ZWRIZWlnaHQgKCkgeyByZXR1cm4gLTEgfVxuXG4gIGlnbm9yZUV2ZW50ICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBZUmVtb3RlU2VsZWN0aW9uc1BsdWdpblZhbHVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LkVkaXRvclZpZXd9IHZpZXdcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2aWV3KSB7XG4gICAgdGhpcy5jb25mID0gdmlldy5zdGF0ZS5mYWNldCh5U3luY0ZhY2V0KVxuICAgIHRoaXMuX2xpc3RlbmVyID0gKHsgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgcywgdCkgPT4ge1xuICAgICAgY29uc3QgY2xpZW50cyA9IGFkZGVkLmNvbmNhdCh1cGRhdGVkKS5jb25jYXQocmVtb3ZlZClcbiAgICAgIGlmIChjbGllbnRzLmZpbmRJbmRleChpZCA9PiBpZCAhPT0gdGhpcy5jb25mLmF3YXJlbmVzcy5kb2MuY2xpZW50SUQpID49IDApIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGFubm90YXRpb25zOiBbeVJlbW90ZVNlbGVjdGlvbnNBbm5vdGF0aW9uLm9mKFtdKV0gfSlcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fYXdhcmVuZXNzID0gdGhpcy5jb25mLmF3YXJlbmVzc1xuICAgIHRoaXMuX2F3YXJlbmVzcy5vbignY2hhbmdlJywgdGhpcy5fbGlzdGVuZXIpXG4gICAgLyoqXG4gICAgICogQHR5cGUge2NtVmlldy5EZWNvcmF0aW9uU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBjbVN0YXRlLlJhbmdlU2V0Lm9mKFtdKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fYXdhcmVuZXNzLm9mZignY2hhbmdlJywgdGhpcy5fbGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtjbVZpZXcuVmlld1VwZGF0ZX0gdXBkYXRlXG4gICAqL1xuICB1cGRhdGUgKHVwZGF0ZSkge1xuICAgIGNvbnN0IHl0ZXh0ID0gdGhpcy5jb25mLnl0ZXh0XG4gICAgY29uc3QgeWRvYyA9IC8qKiBAdHlwZSB7WS5Eb2N9ICovICh5dGV4dC5kb2MpXG4gICAgY29uc3QgYXdhcmVuZXNzID0gdGhpcy5jb25mLmF3YXJlbmVzc1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxjbVN0YXRlLlJhbmdlPGNtVmlldy5EZWNvcmF0aW9uPj59XG4gICAgICovXG4gICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXVxuICAgIGNvbnN0IGxvY2FsQXdhcmVuZXNzU3RhdGUgPSB0aGlzLmNvbmYuYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKVxuXG4gICAgLy8gc2V0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZSAodXBkYXRlIGN1cnNvcnMpXG4gICAgaWYgKGxvY2FsQXdhcmVuZXNzU3RhdGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgaGFzRm9jdXMgPSB1cGRhdGUudmlldy5oYXNGb2N1cyAmJiB1cGRhdGUudmlldy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpXG4gICAgICBjb25zdCBzZWwgPSBoYXNGb2N1cyA/IHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbiA6IG51bGxcbiAgICAgIGNvbnN0IGN1cnJlbnRBbmNob3IgPSBsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvciA9PSBudWxsID8gbnVsbCA6IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yLmFuY2hvcilcbiAgICAgIGNvbnN0IGN1cnJlbnRIZWFkID0gbG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IgPT0gbnVsbCA/IG51bGwgOiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvci5oZWFkKVxuXG4gICAgICBpZiAoc2VsICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh5dGV4dCwgc2VsLmFuY2hvcilcbiAgICAgICAgY29uc3QgaGVhZCA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgoeXRleHQsIHNlbC5oZWFkKVxuICAgICAgICBpZiAobG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IgPT0gbnVsbCB8fCAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoY3VycmVudEFuY2hvciwgYW5jaG9yKSB8fCAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoY3VycmVudEhlYWQsIGhlYWQpKSB7XG4gICAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywge1xuICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgaGVhZFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IgIT0gbnVsbCAmJiBoYXNGb2N1cykge1xuICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCdjdXJzb3InLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBkZWNvcmF0aW9ucyAocmVtb3RlIHNlbGVjdGlvbnMpXG4gICAgYXdhcmVuZXNzLmdldFN0YXRlcygpLmZvckVhY2goKHN0YXRlLCBjbGllbnRpZCkgPT4ge1xuICAgICAgaWYgKGNsaWVudGlkID09PSBhd2FyZW5lc3MuZG9jLmNsaWVudElEKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgY3Vyc29yID0gc3RhdGUuY3Vyc29yXG4gICAgICBpZiAoY3Vyc29yID09IG51bGwgfHwgY3Vyc29yLmFuY2hvciA9PSBudWxsIHx8IGN1cnNvci5oZWFkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3IgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihjdXJzb3IuYW5jaG9yLCB5ZG9jKVxuICAgICAgY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKGN1cnNvci5oZWFkLCB5ZG9jKVxuICAgICAgaWYgKGFuY2hvciA9PSBudWxsIHx8IGhlYWQgPT0gbnVsbCB8fCBhbmNob3IudHlwZSAhPT0geXRleHQgfHwgaGVhZC50eXBlICE9PSB5dGV4dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29sb3IgPSAnIzMwYmNlZCcsIG5hbWUgPSAnQW5vbnltb3VzJyB9ID0gc3RhdGUudXNlciB8fCB7fVxuICAgICAgY29uc3QgY29sb3JMaWdodCA9IChzdGF0ZS51c2VyICYmIHN0YXRlLnVzZXIuY29sb3JMaWdodCkgfHwgY29sb3IgKyAnMzMnXG4gICAgICBjb25zdCBzdGFydCA9IG1hdGgubWluKGFuY2hvci5pbmRleCwgaGVhZC5pbmRleClcbiAgICAgIGNvbnN0IGVuZCA9IG1hdGgubWF4KGFuY2hvci5pbmRleCwgaGVhZC5pbmRleClcbiAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQpXG4gICAgICBjb25zdCBlbmRMaW5lID0gdXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVBdChlbmQpXG4gICAgICBpZiAoc3RhcnRMaW5lLm51bWJlciA9PT0gZW5kTGluZS5udW1iZXIpIHtcbiAgICAgICAgLy8gc2VsZWN0ZWQgY29udGVudCBpbiBhIHNpbmdsZSBsaW5lLlxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBzdGFydCxcbiAgICAgICAgICB0bzogZW5kLFxuICAgICAgICAgIHZhbHVlOiBjbVZpZXcuRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yTGlnaHR9YCB9LFxuICAgICAgICAgICAgY2xhc3M6ICdjbS15U2VsZWN0aW9uJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZWxlY3RlZCBjb250ZW50IGluIG11bHRpcGxlIGxpbmVzXG4gICAgICAgIC8vIGZpcnN0LCByZW5kZXIgdGV4dC1zZWxlY3Rpb24gaW4gdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICAgICAgZnJvbTogc3RhcnQsXG4gICAgICAgICAgdG86IHN0YXJ0TGluZS5mcm9tICsgc3RhcnRMaW5lLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZTogY21WaWV3LkRlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiBgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvckxpZ2h0fWAgfSxcbiAgICAgICAgICAgIGNsYXNzOiAnY20teVNlbGVjdGlvbidcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICAvLyByZW5kZXIgdGV4dC1zZWxlY3Rpb24gaW4gdGhlIGxhc3QgbGluZVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICBmcm9tOiBlbmRMaW5lLmZyb20sXG4gICAgICAgICAgdG86IGVuZCxcbiAgICAgICAgICB2YWx1ZTogY21WaWV3LkRlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiBgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvckxpZ2h0fWAgfSxcbiAgICAgICAgICAgIGNsYXNzOiAnY20teVNlbGVjdGlvbidcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lLm51bWJlciArIDE7IGkgPCBlbmRMaW5lLm51bWJlcjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGluZVBvcyA9IHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lKGkpLmZyb21cbiAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGZyb206IGxpbmVQb3MsXG4gICAgICAgICAgICB0bzogbGluZVBvcyxcbiAgICAgICAgICAgIHZhbHVlOiBjbVZpZXcuRGVjb3JhdGlvbi5saW5lKHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JMaWdodH1gLCBjbGFzczogJ2NtLXlMaW5lU2VsZWN0aW9uJyB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICBmcm9tOiBoZWFkLmluZGV4LFxuICAgICAgICB0bzogaGVhZC5pbmRleCxcbiAgICAgICAgdmFsdWU6IGNtVmlldy5EZWNvcmF0aW9uLndpZGdldCh7XG4gICAgICAgICAgc2lkZTogaGVhZC5pbmRleCAtIGFuY2hvci5pbmRleCA+IDAgPyAtMSA6IDEsIC8vIHRoZSBsb2NhbCBjdXJzb3Igc2hvdWxkIGJlIHJlbmRlcmVkIG91dHNpZGUgdGhlIHJlbW90ZSBzZWxlY3Rpb25cbiAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgd2lkZ2V0OiBuZXcgWVJlbW90ZUNhcmV0V2lkZ2V0KGNvbG9yLCBuYW1lKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBjbVZpZXcuRGVjb3JhdGlvbi5zZXQoZGVjb3JhdGlvbnMsIHRydWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHlSZW1vdGVTZWxlY3Rpb25zID0gY21WaWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKFlSZW1vdGVTZWxlY3Rpb25zUGx1Z2luVmFsdWUsIHtcbiAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSlcbiIsICJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgY21TdGF0ZSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSdcblxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnXG5pbXBvcnQgeyB5U3luY0ZhY2V0LCB5U3luY0Fubm90YXRpb24gfSBmcm9tICcuL3ktc3luYy5qcydcbmltcG9ydCB7IFlSYW5nZSB9IGZyb20gJy4veS1yYW5nZS5qcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgY3JlYXRlTXV0ZXggfSBmcm9tICdsaWIwL211dGV4J1xuXG5leHBvcnQgY2xhc3MgWVVuZG9NYW5hZ2VyQ29uZmlnIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5VbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1bmRvTWFuYWdlcikge1xuICAgIHRoaXMudW5kb01hbmFnZXIgPSB1bmRvTWFuYWdlclxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICovXG4gIGFkZFRyYWNrZWRPcmlnaW4gKG9yaWdpbikge1xuICAgIHRoaXMudW5kb01hbmFnZXIuYWRkVHJhY2tlZE9yaWdpbihvcmlnaW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgcmVtb3ZlVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy51bmRvTWFuYWdlci5yZW1vdmVUcmFja2VkT3JpZ2luKG9yaWdpbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgY2hhbmdlIHdhcyB1bmRvbmUuXG4gICAqL1xuICB1bmRvICgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvTWFuYWdlci51bmRvKCkgIT0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBjaGFuZ2Ugd2FzIHJlZG9uZS5cbiAgICovXG4gIHJlZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnVuZG9NYW5hZ2VyLnJlZG8oKSAhPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5GYWNldDxZVW5kb01hbmFnZXJDb25maWcsIFlVbmRvTWFuYWdlckNvbmZpZz59XG4gKi9cbmV4cG9ydCBjb25zdCB5VW5kb01hbmFnZXJGYWNldCA9IGNtU3RhdGUuRmFjZXQuZGVmaW5lKHtcbiAgY29tYmluZSAoaW5wdXRzKSB7XG4gICAgcmV0dXJuIGlucHV0c1tpbnB1dHMubGVuZ3RoIC0gMV1cbiAgfVxufSlcblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5Bbm5vdGF0aW9uVHlwZTxZVW5kb01hbmFnZXJDb25maWc+fVxuICovXG5leHBvcnQgY29uc3QgeVVuZG9NYW5hZ2VyQW5ub3RhdGlvbiA9IGNtU3RhdGUuQW5ub3RhdGlvbi5kZWZpbmUoKVxuXG4vKipcbiAqIEBleHRlbmRzIHtQbHVnaW5WYWx1ZX1cbiAqL1xuY2xhc3MgWVVuZG9NYW5hZ2VyUGx1Z2luVmFsdWUge1xuICAvKipcbiAgICogQHBhcmFtIHtjbVZpZXcuRWRpdG9yVmlld30gdmlld1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHZpZXcpIHtcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5jb25mID0gdmlldy5zdGF0ZS5mYWNldCh5VW5kb01hbmFnZXJGYWNldClcbiAgICB0aGlzLl91bmRvTWFuYWdlciA9IHRoaXMuY29uZi51bmRvTWFuYWdlclxuICAgIHRoaXMuc3luY0NvbmYgPSB2aWV3LnN0YXRlLmZhY2V0KHlTeW5jRmFjZXQpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBZUmFuZ2V9XG4gICAgICovXG4gICAgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuX211eCA9IGNyZWF0ZU11dGV4KClcblxuICAgIHRoaXMuX29uU3RhY2tJdGVtQWRkZWQgPSAoeyBzdGFja0l0ZW0sIGNoYW5nZWRQYXJlbnRUeXBlcyB9KSA9PiB7XG4gICAgICAvLyBvbmx5IHN0b3JlIG1ldGFkYXRhIGlmIHRoaXMgdHlwZSB3YXMgYWZmZWN0ZWRcbiAgICAgIGlmIChjaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHRoaXMuc3luY0NvbmYueXRleHQpICYmIHRoaXMuX2JlZm9yZUNoYW5nZVNlbGVjdGlvbiAmJiAhc3RhY2tJdGVtLm1ldGEuaGFzKHRoaXMpKSB7IC8vIGRvIG5vdCBvdmVyd3JpdGUgcHJldmlvdXMgc3RvcmVkIHNlbGVjdGlvblxuICAgICAgICBzdGFja0l0ZW0ubWV0YS5zZXQodGhpcywgdGhpcy5fYmVmb3JlQ2hhbmdlU2VsZWN0aW9uKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9vblN0YWNrSXRlbVBvcHBlZCA9ICh7IHN0YWNrSXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCBzZWwgPSBzdGFja0l0ZW0ubWV0YS5nZXQodGhpcylcbiAgICAgIGlmIChzZWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zeW5jQ29uZi5mcm9tWVJhbmdlKHNlbClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICAgIGVmZmVjdHM6IFtjbVZpZXcuRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhzZWxlY3Rpb24pXVxuICAgICAgICB9KSlcbiAgICAgICAgdGhpcy5fc3RvcmVTZWxlY3Rpb24oKVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEbyB0aGlzIHdpdGhvdXQgbXV0ZXgsIHNpbXBseSB1c2UgdGhlIHN5bmMgYW5ub3RhdGlvblxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgICAgLy8gc3RvcmUgdGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhlIGNoYW5nZSBpcyBhcHBsaWVkIHNvIHdlIGNhbiByZXN0b3JlIGl0IHdpdGggdGhlIHVuZG8gbWFuYWdlci5cbiAgICAgIHRoaXMuX2JlZm9yZUNoYW5nZVNlbGVjdGlvbiA9IHRoaXMuc3luY0NvbmYudG9ZUmFuZ2UodGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluKVxuICAgIH1cbiAgICB0aGlzLl91bmRvTWFuYWdlci5vbignc3RhY2staXRlbS1hZGRlZCcsIHRoaXMuX29uU3RhY2tJdGVtQWRkZWQpXG4gICAgdGhpcy5fdW5kb01hbmFnZXIub24oJ3N0YWNrLWl0ZW0tcG9wcGVkJywgdGhpcy5fb25TdGFja0l0ZW1Qb3BwZWQpXG4gICAgdGhpcy5fdW5kb01hbmFnZXIuYWRkVHJhY2tlZE9yaWdpbih0aGlzLnN5bmNDb25mKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LlZpZXdVcGRhdGV9IHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlICh1cGRhdGUpIHtcbiAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCAmJiAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDAgfHwgdXBkYXRlLnRyYW5zYWN0aW9uc1swXS5hbm5vdGF0aW9uKHlTeW5jQW5ub3RhdGlvbikgIT09IHRoaXMuc3luY0NvbmYpKSB7XG4gICAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2hlbiBZVW5kb01hbmFnZXJQbHVnaW4gaXMgaW5jbHVkZWQgYmVmb3JlIHRoZSBzeW5jIHBsdWdpblxuICAgICAgdGhpcy5fc3RvcmVTZWxlY3Rpb24oKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLm9mZignc3RhY2staXRlbS1hZGRlZCcsIHRoaXMuX29uU3RhY2tJdGVtQWRkZWQpXG4gICAgdGhpcy5fdW5kb01hbmFnZXIub2ZmKCdzdGFjay1pdGVtLXBvcHBlZCcsIHRoaXMuX29uU3RhY2tJdGVtUG9wcGVkKVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLnJlbW92ZVRyYWNrZWRPcmlnaW4odGhpcy5zeW5jQ29uZilcbiAgfVxufVxuZXhwb3J0IGNvbnN0IHlVbmRvTWFuYWdlciA9IGNtVmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhZVW5kb01hbmFnZXJQbHVnaW5WYWx1ZSlcblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5TdGF0ZUNvbW1hbmR9XG4gKi9cbmV4cG9ydCBjb25zdCB1bmRvID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+XG4gIHN0YXRlLmZhY2V0KHlVbmRvTWFuYWdlckZhY2V0KS51bmRvKCkgfHwgdHJ1ZVxuXG4vKipcbiAqIEB0eXBlIHtjbVN0YXRlLlN0YXRlQ29tbWFuZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlZG8gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT5cbiAgc3RhdGUuZmFjZXQoeVVuZG9NYW5hZ2VyRmFjZXQpLnJlZG8oKSB8fCB0cnVlXG5cbi8qKlxuICogQHBhcmFtIHtjbVN0YXRlLkVkaXRvclN0YXRlfSBzdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdW5kb0RlcHRoID0gc3RhdGUgPT4gc3RhdGUuZmFjZXQoeVVuZG9NYW5hZ2VyRmFjZXQpLnVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGhcblxuLyoqXG4gKiBAcGFyYW0ge2NtU3RhdGUuRWRpdG9yU3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByZWRvRGVwdGggPSBzdGF0ZSA9PiBzdGF0ZS5mYWNldCh5VW5kb01hbmFnZXJGYWNldCkudW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aFxuXG4vKipcbiAqIERlZmF1bHQga2V5IGJpbmRpZ3MgZm9yIHRoZSB1bmRvIG1hbmFnZXIuXG4gKiBAdHlwZSB7QXJyYXk8Y21WaWV3LktleUJpbmRpbmc+fVxuICovXG5leHBvcnQgY29uc3QgeVVuZG9NYW5hZ2VyS2V5bWFwID0gW1xuICB7IGtleTogJ01vZC16JywgcnVuOiB1bmRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICB7IGtleTogJ01vZC15JywgbWFjOiAnTW9kLVNoaWZ0LXonLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gIHsga2V5OiAnTW9kLVNoaWZ0LXonLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl1cbiIsICIvKipcbiAqIE11dHVhbCBleGNsdWRlIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXV0ZXhcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBtdXRleFxuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNiIE9ubHkgZXhlY3V0ZWQgd2hlbiB0aGlzIG11dGV4IGlzIG5vdCBpbiB0aGUgY3VycmVudCBzdGFja1xuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IFtlbHNlQ2JdIEV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBpbiB0aGUgY3VycmVudCBzdGFja1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHJldHVybiB7bXV0ZXh9IEEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU11dGV4ID0gKCkgPT4ge1xuICBsZXQgdG9rZW4gPSB0cnVlXG4gIHJldHVybiAoZiwgZykgPT4ge1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdG9rZW4gPSBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZigpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0b2tlbiA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZygpXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgb2JzZXJ2YWJsZSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbnR5cGUgRXZlbnRzPFZhbHVlPiA9IHtcbiAgYWRkOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBWYWx1ZSkgPT4gdm9pZCxcbiAgdXBkYXRlOiAoa2V5OiBzdHJpbmcsIG9sZFZhbHVlOiBWYWx1ZSwgbmV3VmFsdWU6IFZhbHVlKSA9PiB2b2lkLFxuICBkZWxldGU6IChrZXk6IHN0cmluZywgb2xkVmFsdWU6IFZhbHVlKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjbGFzcyBQZWVyZHJhZnRSZWNvcmQ8VmFsdWU+IGV4dGVuZHMgb2JzZXJ2YWJsZS5PYnNlcnZhYmxlVjI8RXZlbnRzPFZhbHVlPj4ge1xuICBwcml2YXRlIHJlY29yZDogUmVjb3JkPHN0cmluZywgVmFsdWU+ID0ge31cblxuICBwdWJsaWMgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogVmFsdWUpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMucmVjb3JkW2tleV1cbiAgICB0aGlzLnJlY29yZFtrZXldID0gdmFsdWVcbiAgICBpZiAob2xkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lbWl0KCdhZGQnLCBba2V5LCB2YWx1ZV0pXG4gICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBba2V5LCBvbGRWYWx1ZSwgdmFsdWVdKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQoa2V5OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRba2V5XVxuICB9XG5cbiAgcHVibGljIGRlbGV0ZShrZXk6IHN0cmluZykge1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5yZWNvcmRba2V5XVxuICAgIGRlbGV0ZSB0aGlzLnJlY29yZFtrZXldXG4gICAgdGhpcy5lbWl0KCdkZWxldGUnLCBba2V5LCBvbGRWYWx1ZV0pXG4gIH1cblxuICBwdWJsaWMgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVjb3JkKS5sZW5ndGhcbiAgfVxuXG4gIHB1YmxpYyBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWNvcmQpXG4gIH1cbn0iLCAiaW1wb3J0ICogYXMgb2JzZXJ2YWJsZSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbnR5cGUgRXZlbnRzID0ge1xuICBjaGFuZ2VJc1ByZXZpZXc6IChvbGRNb2RlOiBib29sZWFuLCBuZXdNb2RlOiBib29sZWFuKSA9PiB2b2lkLFxuICBjaGFuZ2VQYXRoOiAob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNsYXNzIFBlZXJkcmFmdExlYWYgZXh0ZW5kcyBvYnNlcnZhYmxlLk9ic2VydmFibGVWMjxFdmVudHM+IHtcbiAgcHJpdmF0ZSBfaXNQcmV2aWV3OiBib29sZWFuXG4gIHByaXZhdGUgX3BhdGg6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhdGg6IHN0cmluZywgaXNQcmV2aWV3OiBib29sZWFuKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2lzUHJldmlldyA9IGlzUHJldmlldyxcbiAgICB0aGlzLl9wYXRoID0gcGF0aFxuICB9XG5cbiAgZ2V0IGlzUHJldmlldyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUHJldmlld1xuICB9XG5cbiAgc2V0IGlzUHJldmlldyAodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvbGQgPSB0aGlzLl9pc1ByZXZpZXdcbiAgICB0aGlzLl9pc1ByZXZpZXcgPSB2YWx1ZVxuICAgIGlmICh2YWx1ZSAhPSBvbGQpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlSXNQcmV2aWV3JywgW29sZCwgdmFsdWVdKVxuICAgIH1cbiAgfVxuXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoXG4gIH1cblxuICBzZXQgcGF0aCAodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuX3BhdGhcbiAgICB0aGlzLl9wYXRoID0gdmFsdWVcbiAgICBpZiAodmFsdWUgIT0gb2xkKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZVBhdGgnLCBbb2xkLCB2YWx1ZV0pXG4gICAgfVxuICB9XG5cbn0iLCAiaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSBcInNyYy91dGlscy9wZWVyZHJhZnRSZWNvcmRcIjtcbmltcG9ydCB7IFBlZXJkcmFmdExlYWYgfSBmcm9tIFwiLi9wZWVyZHJhZnRMZWFmXCI7XG5pbXBvcnQgeyBNYXJrZG93blZpZXcsIFdvcmtzcGFjZSwgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY29uc3QgdXBkYXRlUGVlcmRyYWZ0V29ya3NwYWNlID0gKHdzOiBXb3Jrc3BhY2UsIHB3czogUGVlcmRyYWZ0UmVjb3JkPFBlZXJkcmFmdExlYWY+KSA9PiB7XG4gIGNvbnN0IGxlYWZzID0gd3MuZ2V0TGVhdmVzT2ZUeXBlKFwibWFya2Rvd25cIilcbiAgXG4gIGNvbnN0IG9sZExlYWZJZHMgPSBwd3Mua2V5c1xuICBjb25zdCBleGlzdGluZ0xlYWZJZHMgPSBsZWFmcy5tYXAobGVhZiA9PiB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJldHVybiBsZWFmLmlkIGFzIHN0cmluZ1xuICB9KVxuXG4gIGZvciAoY29uc3QgbGVhZiBvZiBsZWFmcykge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBsZWFmSWQgPSBsZWFmLmlkIGFzIHN0cmluZ1xuXG4gICAgY29uc3QgaXNQcmV2aWV3ID0gbGVhZi52aWV3LmNvbnRhaW5lckVsLmdldEF0dHJpYnV0ZShcImRhdGEtbW9kZVwiKSA9PT0gXCJwcmV2aWV3XCJcbiAgICBjb25zdCBwYXRoID0gKGxlYWYudmlldyBhcyAoTWFya2Rvd25WaWV3KSkuZmlsZT8ucGF0aCA/PyAnJ1xuXG4gICAgbGV0IHBsZWFmID0gcHdzLmdldChsZWFmSWQpXG4gICAgaWYgKHBsZWFmKSB7XG4gICAgICBwbGVhZi5pc1ByZXZpZXcgPSBpc1ByZXZpZXdcbiAgICAgIHBsZWFmLnBhdGggPSBwYXRoXG4gICAgfSBlbHNlIHtcbiAgICAgIHBsZWFmID0gbmV3IFBlZXJkcmFmdExlYWYocGF0aCwgaXNQcmV2aWV3KVxuICAgICAgcHdzLnNldChsZWFmSWQsIHBsZWFmKVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgb2xkTGVhZklkIG9mIG9sZExlYWZJZHMpIHsgXG4gICAgaWYoIWV4aXN0aW5nTGVhZklkcy5jb250YWlucyhvbGRMZWFmSWQpKSB7XG4gICAgICBwd3MuZGVsZXRlKG9sZExlYWZJZClcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnQgY29uc3QgZ2V0TGVhZnNCeVBhdGggPSAocGF0aDogc3RyaW5nLCBwd3M6IFBlZXJkcmFmdFJlY29yZDxQZWVyZHJhZnRMZWFmPikgPT4ge1xuICByZXR1cm4gcHdzLmtleXMubWFwKChrZXkpID0+IHtcbiAgICByZXR1cm4gcHdzLmdldChrZXkpXG4gIH0pLmZpbHRlcigobGVhZikgPT4ge1xuICAgIHJldHVybiBsZWFmLnBhdGggPT09IHBhdGhcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGdldExlYWZJZHNCeVBhdGggPSAocGF0aDogc3RyaW5nLCBwd3M6IFBlZXJkcmFmdFJlY29yZDxQZWVyZHJhZnRMZWFmPikgPT4ge1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgocGF0aClcbiAgcmV0dXJuIHB3cy5rZXlzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocHdzLmdldChrZXkpLnBhdGgpID09PSBub3JtYWxpemVkUGF0aFxuICB9KVxufSIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaW55IHdlYnNvY2tldCBjb25uZWN0aW9uIGhhbmRsZXIuXG4gKlxuICogSW1wbGVtZW50cyBleHBvbmVudGlhbCBiYWNrb2ZmIHJlY29ubmVjdHMsIHBpbmcvcG9uZywgYW5kIGEgbmljZSBldmVudCBzeXN0ZW0gdXNpbmcgW2xpYjAvb2JzZXJ2YWJsZV0uXG4gKlxuICogQG1vZHVsZSB3ZWJzb2NrZXRcbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi9vYnNlcnZhYmxlLmpzJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcblxuY29uc3QgcmVjb25uZWN0VGltZW91dEJhc2UgPSAxMjAwXG5jb25zdCBtYXhSZWNvbm5lY3RUaW1lb3V0ID0gMjUwMFxuLy8gQHRvZG8gLSB0aGlzIHNob3VsZCBkZXBlbmQgb24gYXdhcmVuZXNzLm91dGRhdGVkVGltZVxuY29uc3QgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEBwYXJhbSB7V2Vic29ja2V0Q2xpZW50fSB3c2NsaWVudFxuICovXG5jb25zdCBzZXR1cFdTID0gKHdzY2xpZW50KSA9PiB7XG4gIGlmICh3c2NsaWVudC5zaG91bGRDb25uZWN0ICYmIHdzY2xpZW50LndzID09PSBudWxsKSB7XG4gICAgY29uc3Qgd2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldCh3c2NsaWVudC51cmwpXG4gICAgY29uc3QgYmluYXJ5VHlwZSA9IHdzY2xpZW50LmJpbmFyeVR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIGxldCBwaW5nVGltZW91dCA9IG51bGxcbiAgICBpZiAoYmluYXJ5VHlwZSkge1xuICAgICAgd2Vic29ja2V0LmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlXG4gICAgfVxuICAgIHdzY2xpZW50LndzID0gd2Vic29ja2V0XG4gICAgd3NjbGllbnQuY29ubmVjdGluZyA9IHRydWVcbiAgICB3c2NsaWVudC5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIHdlYnNvY2tldC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICB3c2NsaWVudC5sYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YVxuICAgICAgY29uc3QgbWVzc2FnZSA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoZGF0YSkgOiBkYXRhXG4gICAgICBpZiAobWVzc2FnZSAmJiBtZXNzYWdlLnR5cGUgPT09ICdwb25nJykge1xuICAgICAgICBjbGVhclRpbWVvdXQocGluZ1RpbWVvdXQpXG4gICAgICAgIHBpbmdUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kUGluZywgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAyKVxuICAgICAgfVxuICAgICAgd3NjbGllbnQuZW1pdCgnbWVzc2FnZScsIFttZXNzYWdlLCB3c2NsaWVudF0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBlcnJvclxuICAgICAqL1xuICAgIGNvbnN0IG9uY2xvc2UgPSBlcnJvciA9PiB7XG4gICAgICBpZiAod3NjbGllbnQud3MgIT09IG51bGwpIHtcbiAgICAgICAgd3NjbGllbnQud3MgPSBudWxsXG4gICAgICAgIHdzY2xpZW50LmNvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgICBpZiAod3NjbGllbnQuY29ubmVjdGVkKSB7XG4gICAgICAgICAgd3NjbGllbnQuY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgICB3c2NsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgW3sgdHlwZTogJ2Rpc2Nvbm5lY3QnLCBlcnJvciB9LCB3c2NsaWVudF0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd3NjbGllbnQudW5zdWNjZXNzZnVsUmVjb25uZWN0cysrXG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBubyByZWNvbm5lY3QgdGltZW91dCBhbmQgaW5jcmVhc2UgdGltZW91dCBieVxuICAgICAgICAvLyBsb2cxMCh3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMpLlxuICAgICAgICAvLyBUaGUgaWRlYSBpcyB0byBpbmNyZWFzZSByZWNvbm5lY3QgdGltZW91dCBzbG93bHkgYW5kIGhhdmUgbm8gcmVjb25uZWN0XG4gICAgICAgIC8vIHRpbWVvdXQgYXQgdGhlIGJlZ2lubmluZyAobG9nKDEpID0gMClcbiAgICAgICAgc2V0VGltZW91dChzZXR1cFdTLCBtYXRoLm1pbihtYXRoLmxvZzEwKHdzY2xpZW50LnVuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgKyAxKSAqIHJlY29ubmVjdFRpbWVvdXRCYXNlLCBtYXhSZWNvbm5lY3RUaW1lb3V0KSwgd3NjbGllbnQpXG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQocGluZ1RpbWVvdXQpXG4gICAgfVxuICAgIGNvbnN0IHNlbmRQaW5nID0gKCkgPT4ge1xuICAgICAgaWYgKHdzY2xpZW50LndzID09PSB3ZWJzb2NrZXQpIHtcbiAgICAgICAgd3NjbGllbnQuc2VuZCh7XG4gICAgICAgICAgdHlwZTogJ3BpbmcnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHdlYnNvY2tldC5vbmNsb3NlID0gKCkgPT4gb25jbG9zZShudWxsKVxuICAgIHdlYnNvY2tldC5vbmVycm9yID0gZXJyb3IgPT4gb25jbG9zZShlcnJvcilcbiAgICB3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgd3NjbGllbnQubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgd3NjbGllbnQuY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICB3c2NsaWVudC5jb25uZWN0ZWQgPSB0cnVlXG4gICAgICB3c2NsaWVudC51bnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgICAgd3NjbGllbnQuZW1pdCgnY29ubmVjdCcsIFt7IHR5cGU6ICdjb25uZWN0JyB9LCB3c2NsaWVudF0pXG4gICAgICAvLyBzZXQgcGluZ1xuICAgICAgcGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRQaW5nLCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDIpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5leHBvcnQgY2xhc3MgV2Vic29ja2V0Q2xpZW50IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7J2FycmF5YnVmZmVyJyB8ICdibG9iJyB8IG51bGx9IFtvcHRzLmJpbmFyeVR5cGVdIFNldCBgd3MuYmluYXJ5VHlwZWBcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHsgYmluYXJ5VHlwZSB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy51cmwgPSB1cmxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2ViU29ja2V0P31cbiAgICAgKi9cbiAgICB0aGlzLndzID0gbnVsbFxuICAgIHRoaXMuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGUgfHwgbnVsbFxuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLmNvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMudW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBjb25uZWN0IHRvIG90aGVyIHBlZXJzIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkICYmIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IDwgdGltZS5nZXRVbml4VGltZSgpIC0gdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkKSB7XG4gICAgICAgIC8vIG5vIG1lc3NhZ2UgcmVjZWl2ZWQgaW4gYSBsb25nIHRpbWUgLSBub3QgZXZlbiB5b3VyIG93biBhd2FyZW5lc3NcbiAgICAgICAgLy8gdXBkYXRlcyAod2hpY2ggYXJlIHVwZGF0ZWQgZXZlcnkgMTUgc2Vjb25kcylcbiAgICAgICAgLyoqIEB0eXBlIHtXZWJTb2NrZXR9ICovICh0aGlzLndzKS5jbG9zZSgpXG4gICAgICB9XG4gICAgfSwgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAyKVxuICAgIHNldHVwV1ModGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gbWVzc2FnZVxuICAgKi9cbiAgc2VuZCAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLndzKSB7XG4gICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIGlmICh0aGlzLndzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlXG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZCAmJiB0aGlzLndzID09PSBudWxsKSB7XG4gICAgICBzZXR1cFdTKHRoaXMpXG4gICAgfVxuICB9XG59XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSGVscGVycyBmb3IgY3Jvc3MtdGFiIGNvbW11bmljYXRpb24gdXNpbmcgYnJvYWRjYXN0Y2hhbm5lbCB3aXRoIExvY2FsU3RvcmFnZSBmYWxsYmFjay5cbiAqXG4gKiBgYGBqc1xuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQTpcbiAqIGJyb2FkY2FzdGNoYW5uZWwuc3Vic2NyaWJlKCdteSBldmVudHMnLCBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKVxuICogYnJvYWRjYXN0Y2hhbm5lbC5wdWJsaXNoKCdteSBldmVudHMnLCAnSGVsbG8gd29ybGQhJykgLy8gPT4gQTogJ0hlbGxvIHdvcmxkIScgZmlyZXMgc3luY2hyb25vdXNseSBpbiBzYW1lIHRhYlxuICpcbiAqIC8vIEluIGJyb3dzZXIgd2luZG93IEI6XG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdoZWxsbyBmcm9tIHRhYiBCJykgLy8gPT4gQTogJ2hlbGxvIGZyb20gdGFiIEInXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGJyb2FkY2FzdGNoYW5uZWxcbiAqL1xuXG4vLyBAdG9kbyBiZWZvcmUgbmV4dCBtYWpvcjogdXNlIFVpbnQ4QXJyYXkgaW5zdGVhZCBhcyBidWZmZXIgb2JqZWN0XG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIHNldCBmcm9tICcuL3NldC5qcydcbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENoYW5uZWxcbiAqIEBwcm9wZXJ0eSB7U2V0PGZ1bmN0aW9uKGFueSwgYW55KTphbnk+fSBDaGFubmVsLnN1YnNcbiAqIEBwcm9wZXJ0eSB7YW55fSBDaGFubmVsLmJjXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgQ2hhbm5lbD59XG4gKi9cbmNvbnN0IGNoYW5uZWxzID0gbmV3IE1hcCgpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY2xhc3MgTG9jYWxTdG9yYWdlUG9seWZpbGwge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyb29tKSB7XG4gICAgdGhpcy5yb29tID0gcm9vbVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsfGZ1bmN0aW9uKHtkYXRhOkFycmF5QnVmZmVyfSk6dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLm9ubWVzc2FnZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gZVxuICAgICAqL1xuICAgIHRoaXMuX29uQ2hhbmdlID0gZSA9PiBlLmtleSA9PT0gcm9vbSAmJiB0aGlzLm9ubWVzc2FnZSAhPT0gbnVsbCAmJiB0aGlzLm9ubWVzc2FnZSh7IGRhdGE6IGJ1ZmZlci5mcm9tQmFzZTY0KGUubmV3VmFsdWUgfHwgJycpIH0pXG4gICAgc3RvcmFnZS5vbkNoYW5nZSh0aGlzLl9vbkNoYW5nZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZcbiAgICovXG4gIHBvc3RNZXNzYWdlIChidWYpIHtcbiAgICBzdG9yYWdlLnZhclN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJvb20sIGJ1ZmZlci50b0Jhc2U2NChidWZmZXIuY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlcihidWYpKSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBzdG9yYWdlLm9mZkNoYW5nZSh0aGlzLl9vbkNoYW5nZSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLy8gVXNlIEJyb2FkY2FzdENoYW5uZWwgb3IgUG9seWZpbGxcbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5jb25zdCBCQyA9IHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSAndW5kZWZpbmVkJyA/IExvY2FsU3RvcmFnZVBvbHlmaWxsIDogQnJvYWRjYXN0Q2hhbm5lbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcmV0dXJuIHtDaGFubmVsfVxuICovXG5jb25zdCBnZXRDaGFubmVsID0gcm9vbSA9PlxuICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbm5lbHMsIHJvb20sICgpID0+IHtcbiAgICBjb25zdCBzdWJzID0gc2V0LmNyZWF0ZSgpXG4gICAgY29uc3QgYmMgPSBuZXcgQkMocm9vbSlcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3tkYXRhOkFycmF5QnVmZmVyfX0gZVxuICAgICAqL1xuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgYmMub25tZXNzYWdlID0gZSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1YihlLmRhdGEsICdicm9hZGNhc3RjaGFubmVsJykpXG4gICAgcmV0dXJuIHtcbiAgICAgIGJjLCBzdWJzXG4gICAgfVxuICB9KVxuXG4vKipcbiAqIFN1YnNjcmliZSB0byBnbG9iYWwgYHB1Ymxpc2hgIGV2ZW50cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSwgYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHN1YnNjcmliZSA9IChyb29tLCBmKSA9PiB7XG4gIGdldENoYW5uZWwocm9vbSkuc3Vicy5hZGQoZilcbiAgcmV0dXJuIGZcbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGBwdWJsaXNoYCBnbG9iYWwgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LCBhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgdW5zdWJzY3JpYmUgPSAocm9vbSwgZikgPT4ge1xuICBjb25zdCBjaGFubmVsID0gZ2V0Q2hhbm5lbChyb29tKVxuICBjb25zdCB1bnN1YnNjcmliZWQgPSBjaGFubmVsLnN1YnMuZGVsZXRlKGYpXG4gIGlmICh1bnN1YnNjcmliZWQgJiYgY2hhbm5lbC5zdWJzLnNpemUgPT09IDApIHtcbiAgICBjaGFubmVsLmJjLmNsb3NlKClcbiAgICBjaGFubmVscy5kZWxldGUocm9vbSlcbiAgfVxuICByZXR1cm4gdW5zdWJzY3JpYmVkXG59XG5cbi8qKlxuICogUHVibGlzaCBkYXRhIHRvIGFsbCBzdWJzY3JpYmVycyAoaW5jbHVkaW5nIHN1YnNjcmliZXJzIG9uIHRoaXMgdGFiKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKiBAcGFyYW0ge2FueX0gW29yaWdpbl1cbiAqL1xuZXhwb3J0IGNvbnN0IHB1Ymxpc2ggPSAocm9vbSwgZGF0YSwgb3JpZ2luID0gbnVsbCkgPT4ge1xuICBjb25zdCBjID0gZ2V0Q2hhbm5lbChyb29tKVxuICBjLmJjLnBvc3RNZXNzYWdlKGRhdGEpXG4gIGMuc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZGF0YSwgb3JpZ2luKSlcbn1cbiIsICJpbXBvcnQgKiBhcyB3cyBmcm9tICdsaWIwL3dlYnNvY2tldCdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20nXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICdsaWIwL3Byb21pc2UnXG5pbXBvcnQgKiBhcyBiYyBmcm9tICdsaWIwL2Jyb2FkY2FzdGNoYW5uZWwnXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnbGliMC9idWZmZXInXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcblxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCBQZWVyIGZyb20gJ3NpbXBsZS1wZWVyL3NpbXBsZXBlZXIubWluLmpzJ1xuXG5pbXBvcnQgKiBhcyBzeW5jUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvc3luYydcbmltcG9ydCAqIGFzIGF3YXJlbmVzc1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL2F3YXJlbmVzcydcblxuaW1wb3J0ICogYXMgY3J5cHRvdXRpbHMgZnJvbSAnLi9jcnlwdG8uanMnXG5cbmNvbnN0IGxvZyA9IGxvZ2dpbmcuY3JlYXRlTW9kdWxlTG9nZ2VyKCd5LXdlYnJ0YycpXG5cbmNvbnN0IG1lc3NhZ2VTeW5jID0gMFxuY29uc3QgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzID0gM1xuY29uc3QgbWVzc2FnZUF3YXJlbmVzcyA9IDFcbmNvbnN0IG1lc3NhZ2VCY1BlZXJJZCA9IDRcblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgU2lnbmFsaW5nQ29ubj59XG4gKi9cbmNvbnN0IHNpZ25hbGluZ0Nvbm5zID0gbmV3IE1hcCgpXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsUm9vbT59XG4gKi9cbmNvbnN0IHJvb21zID0gbmV3IE1hcCgpXG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKi9cbmNvbnN0IGNoZWNrSXNTeW5jZWQgPSByb29tID0+IHtcbiAgbGV0IHN5bmNlZCA9IHRydWVcbiAgcm9vbS53ZWJydGNDb25ucy5mb3JFYWNoKHBlZXIgPT4ge1xuICAgIGlmICghcGVlci5zeW5jZWQpIHtcbiAgICAgIHN5bmNlZCA9IGZhbHNlXG4gICAgfVxuICB9KVxuICBpZiAoKCFzeW5jZWQgJiYgcm9vbS5zeW5jZWQpIHx8IChzeW5jZWQgJiYgIXJvb20uc3luY2VkKSkge1xuICAgIHJvb20uc3luY2VkID0gc3luY2VkXG4gICAgcm9vbS5wcm92aWRlci5lbWl0KCdzeW5jZWQnLCBbeyBzeW5jZWQgfV0pXG4gICAgbG9nKCdzeW5jZWQgJywgbG9nZ2luZy5CT0xELCByb29tLm5hbWUsIGxvZ2dpbmcuVU5CT0xELCAnIHdpdGggYWxsIHBlZXJzJylcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN5bmNlZENhbGxiYWNrXG4gKiBAcmV0dXJuIHtlbmNvZGluZy5FbmNvZGVyP31cbiAqL1xuY29uc3QgcmVhZE1lc3NhZ2UgPSAocm9vbSwgYnVmLCBzeW5jZWRDYWxsYmFjaykgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBpZiAocm9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBhd2FyZW5lc3MgPSByb29tLmF3YXJlbmVzc1xuICBjb25zdCBkb2MgPSByb29tLmRvY1xuICBsZXQgc2VuZFJlcGx5ID0gZmFsc2VcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVN5bmM6IHtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgZG9jLCByb29tKVxuICAgICAgaWYgKHN5bmNNZXNzYWdlVHlwZSA9PT0gc3luY1Byb3RvY29sLm1lc3NhZ2VZanNTeW5jU3RlcDIgJiYgIXJvb20uc3luY2VkKSB7XG4gICAgICAgIHN5bmNlZENhbGxiYWNrKClcbiAgICAgIH1cbiAgICAgIGlmIChzeW5jTWVzc2FnZVR5cGUgPT09IHN5bmNQcm90b2NvbC5tZXNzYWdlWWpzU3luY1N0ZXAxKSB7XG4gICAgICAgIHNlbmRSZXBseSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzOlxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKGF3YXJlbmVzcywgQXJyYXkuZnJvbShhd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSkpXG4gICAgICBzZW5kUmVwbHkgPSB0cnVlXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZUF3YXJlbmVzczpcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLmFwcGx5QXdhcmVuZXNzVXBkYXRlKGF3YXJlbmVzcywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHJvb20pXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZUJjUGVlcklkOiB7XG4gICAgICBjb25zdCBhZGQgPSBkZWNvZGluZy5yZWFkVWludDgoZGVjb2RlcikgPT09IDFcbiAgICAgIGNvbnN0IHBlZXJOYW1lID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgaWYgKHBlZXJOYW1lICE9PSByb29tLnBlZXJJZCAmJiAoKHJvb20uYmNDb25ucy5oYXMocGVlck5hbWUpICYmICFhZGQpIHx8ICghcm9vbS5iY0Nvbm5zLmhhcyhwZWVyTmFtZSkgJiYgYWRkKSkpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgICAgIGNvbnN0IGFkZGVkID0gW11cbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgIHJvb20uYmNDb25ucy5hZGQocGVlck5hbWUpXG4gICAgICAgICAgYWRkZWQucHVzaChwZWVyTmFtZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb29tLmJjQ29ubnMuZGVsZXRlKHBlZXJOYW1lKVxuICAgICAgICAgIHJlbW92ZWQucHVzaChwZWVyTmFtZSlcbiAgICAgICAgfVxuICAgICAgICByb29tLnByb3ZpZGVyLmVtaXQoJ3BlZXJzJywgW3tcbiAgICAgICAgICBhZGRlZCxcbiAgICAgICAgICByZW1vdmVkLFxuICAgICAgICAgIHdlYnJ0Y1BlZXJzOiBBcnJheS5mcm9tKHJvb20ud2VicnRjQ29ubnMua2V5cygpKSxcbiAgICAgICAgICBiY1BlZXJzOiBBcnJheS5mcm9tKHJvb20uYmNDb25ucylcbiAgICAgICAgfV0pXG4gICAgICAgIGJyb2FkY2FzdEJjUGVlcklkKHJvb20pXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGNvbXB1dGUgbWVzc2FnZScpXG4gICAgICByZXR1cm4gZW5jb2RlclxuICB9XG4gIGlmICghc2VuZFJlcGx5KSB7XG4gICAgLy8gbm90aGluZyBoYXMgYmVlbiB3cml0dGVuLCBubyBhbnN3ZXIgY3JlYXRlZFxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnJ0Y0Nvbm59IHBlZXJDb25uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7ZW5jb2RpbmcuRW5jb2Rlcj99XG4gKi9cbmNvbnN0IHJlYWRQZWVyTWVzc2FnZSA9IChwZWVyQ29ubiwgYnVmKSA9PiB7XG4gIGNvbnN0IHJvb20gPSBwZWVyQ29ubi5yb29tXG4gIGxvZygncmVjZWl2ZWQgbWVzc2FnZSBmcm9tICcsIGxvZ2dpbmcuQk9MRCwgcGVlckNvbm4ucmVtb3RlUGVlcklkLCBsb2dnaW5nLkdSRVksICcgKCcsIHJvb20ubmFtZSwgJyknLCBsb2dnaW5nLlVOQk9MRCwgbG9nZ2luZy5VTkNPTE9SKVxuICByZXR1cm4gcmVhZE1lc3NhZ2Uocm9vbSwgYnVmLCAoKSA9PiB7XG4gICAgcGVlckNvbm4uc3luY2VkID0gdHJ1ZVxuICAgIGxvZygnc3luY2VkICcsIGxvZ2dpbmcuQk9MRCwgcm9vbS5uYW1lLCBsb2dnaW5nLlVOQk9MRCwgJyB3aXRoICcsIGxvZ2dpbmcuQk9MRCwgcGVlckNvbm4ucmVtb3RlUGVlcklkKVxuICAgIGNoZWNrSXNTeW5jZWQocm9vbSlcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnJ0Y0Nvbm59IHdlYnJ0Y0Nvbm5cbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICovXG5jb25zdCBzZW5kV2VicnRjQ29ubiA9ICh3ZWJydGNDb25uLCBlbmNvZGVyKSA9PiB7XG4gIGxvZygnc2VuZCBtZXNzYWdlIHRvICcsIGxvZ2dpbmcuQk9MRCwgd2VicnRjQ29ubi5yZW1vdGVQZWVySWQsIGxvZ2dpbmcuVU5CT0xELCBsb2dnaW5nLkdSRVksICcgKCcsIHdlYnJ0Y0Nvbm4ucm9vbS5uYW1lLCAnKScsIGxvZ2dpbmcuVU5DT0xPUilcbiAgdHJ5IHtcbiAgICB3ZWJydGNDb25uLnBlZXIuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0V2VicnRjQ29ubiA9IChyb29tLCBtKSA9PiB7XG4gIGxvZygnYnJvYWRjYXN0IG1lc3NhZ2UgaW4gJywgbG9nZ2luZy5CT0xELCByb29tLm5hbWUsIGxvZ2dpbmcuVU5CT0xEKVxuICByb29tLndlYnJ0Y0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbm4ucGVlci5zZW5kKG0pXG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSlcbn1cblxuZXhwb3J0IGNsYXNzIFdlYnJ0Y0Nvbm4ge1xuICAvKipcbiAgICogQHBhcmFtIHtTaWduYWxpbmdDb25ufSBzaWduYWxpbmdDb25uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdGlhdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQZWVySWRcbiAgICogQHBhcmFtIHtSb29tfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc2lnbmFsaW5nQ29ubiwgaW5pdGlhdG9yLCByZW1vdGVQZWVySWQsIHJvb20pIHtcbiAgICBsb2coJ2VzdGFibGlzaGluZyBjb25uZWN0aW9uIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkKVxuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICB0aGlzLnJlbW90ZVBlZXJJZCA9IHJlbW90ZVBlZXJJZFxuICAgIHRoaXMuZ2xhcmVUb2tlbiA9IHVuZGVmaW5lZFxuICAgIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5wZWVyID0gbmV3IFBlZXIoeyBpbml0aWF0b3IsIC4uLnJvb20ucHJvdmlkZXIucGVlck9wdHMgfSlcbiAgICB0aGlzLnBlZXIub24oJ3NpZ25hbCcsIHNpZ25hbCA9PiB7XG4gICAgICBpZiAodGhpcy5nbGFyZVRva2VuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYWRkIHNvbWUgcmFuZG9tbmVzcyB0byB0aGUgdGltZXN0YW1wIG9mIHRoZSBvZmZlclxuICAgICAgICB0aGlzLmdsYXJlVG9rZW4gPSBEYXRlLm5vdygpICsgTWF0aC5yYW5kb20oKVxuICAgICAgfVxuICAgICAgcHVibGlzaFNpZ25hbGluZ01lc3NhZ2Uoc2lnbmFsaW5nQ29ubiwgcm9vbSwgeyB0bzogcmVtb3RlUGVlcklkLCBmcm9tOiByb29tLnBlZXJJZCwgdHlwZTogJ3NpZ25hbCcsIHRva2VuOiB0aGlzLmdsYXJlVG9rZW4sIHNpZ25hbCB9KVxuICAgIH0pXG4gICAgdGhpcy5wZWVyLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgbG9nKCdjb25uZWN0ZWQgdG8gJywgbG9nZ2luZy5CT0xELCByZW1vdGVQZWVySWQpXG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWVcbiAgICAgIC8vIHNlbmQgc3luYyBzdGVwIDFcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gcm9vbS5wcm92aWRlclxuICAgICAgY29uc3QgZG9jID0gcHJvdmlkZXIuZG9jXG4gICAgICBjb25zdCBhd2FyZW5lc3MgPSByb29tLmF3YXJlbmVzc1xuICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAxKGVuY29kZXIsIGRvYylcbiAgICAgIHNlbmRXZWJydGNDb25uKHRoaXMsIGVuY29kZXIpXG4gICAgICBjb25zdCBhd2FyZW5lc3NTdGF0ZXMgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKClcbiAgICAgIGlmIChhd2FyZW5lc3NTdGF0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIEFycmF5LmZyb20oYXdhcmVuZXNzU3RhdGVzLmtleXMoKSkpKVxuICAgICAgICBzZW5kV2VicnRjQ29ubih0aGlzLCBlbmNvZGVyKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5wZWVyLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZVxuICAgICAgaWYgKHJvb20ud2VicnRjQ29ubnMuaGFzKHRoaXMucmVtb3RlUGVlcklkKSkge1xuICAgICAgICByb29tLndlYnJ0Y0Nvbm5zLmRlbGV0ZSh0aGlzLnJlbW90ZVBlZXJJZClcbiAgICAgICAgcm9vbS5wcm92aWRlci5lbWl0KCdwZWVycycsIFt7XG4gICAgICAgICAgcmVtb3ZlZDogW3RoaXMucmVtb3RlUGVlcklkXSxcbiAgICAgICAgICBhZGRlZDogW10sXG4gICAgICAgICAgd2VicnRjUGVlcnM6IEFycmF5LmZyb20ocm9vbS53ZWJydGNDb25ucy5rZXlzKCkpLFxuICAgICAgICAgIGJjUGVlcnM6IEFycmF5LmZyb20ocm9vbS5iY0Nvbm5zKVxuICAgICAgICB9XSlcbiAgICAgIH1cbiAgICAgIGNoZWNrSXNTeW5jZWQocm9vbSlcbiAgICAgIHRoaXMucGVlci5kZXN0cm95KClcbiAgICAgIGxvZygnY2xvc2VkIGNvbm5lY3Rpb24gdG8gJywgbG9nZ2luZy5CT0xELCByZW1vdGVQZWVySWQpXG4gICAgICBhbm5vdW5jZVNpZ25hbGluZ0luZm8ocm9vbSlcbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgbG9nKCdFcnJvciBpbiBjb25uZWN0aW9uIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkLCAnOiAnLCBlcnIpXG4gICAgICBhbm5vdW5jZVNpZ25hbGluZ0luZm8ocm9vbSlcbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignZGF0YScsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgYW5zd2VyID0gcmVhZFBlZXJNZXNzYWdlKHRoaXMsIGRhdGEpXG4gICAgICBpZiAoYW5zd2VyICE9PSBudWxsKSB7XG4gICAgICAgIHNlbmRXZWJydGNDb25uKHRoaXMsIGFuc3dlcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5wZWVyLmRlc3Ryb3koKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0QmNNZXNzYWdlID0gKHJvb20sIG0pID0+IGNyeXB0b3V0aWxzLmVuY3J5cHQobSwgcm9vbS5rZXkpLnRoZW4oZGF0YSA9PlxuICByb29tLm11eCgoKSA9PlxuICAgIGJjLnB1Ymxpc2gocm9vbS5uYW1lLCBkYXRhKVxuICApXG4pXG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1cbiAqL1xuY29uc3QgYnJvYWRjYXN0Um9vbU1lc3NhZ2UgPSAocm9vbSwgbSkgPT4ge1xuICBpZiAocm9vbS5iY2Nvbm5lY3RlZCkge1xuICAgIGJyb2FkY2FzdEJjTWVzc2FnZShyb29tLCBtKVxuICB9XG4gIGJyb2FkY2FzdFdlYnJ0Y0Nvbm4ocm9vbSwgbSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Jvb219IHJvb21cbiAqL1xuY29uc3QgYW5ub3VuY2VTaWduYWxpbmdJbmZvID0gcm9vbSA9PiB7XG4gIHNpZ25hbGluZ0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgLy8gb25seSBzdWJzY3JpYmUgaWYgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCwgb3RoZXJ3aXNlIHRoZSBjb25uIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlcyB0byBhbGwgcm9vbXNcbiAgICBpZiAoY29ubi5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbm4uc2VuZCh7IHR5cGU6ICdzdWJzY3JpYmUnLCB0b3BpY3M6IFtyb29tLm5hbWVdIH0pXG4gICAgICBpZiAocm9vbS53ZWJydGNDb25ucy5zaXplIDwgcm9vbS5wcm92aWRlci5tYXhDb25ucykge1xuICAgICAgICBwdWJsaXNoU2lnbmFsaW5nTWVzc2FnZShjb25uLCByb29tLCB7IHR5cGU6ICdhbm5vdW5jZScsIGZyb206IHJvb20ucGVlcklkIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICovXG5jb25zdCBicm9hZGNhc3RCY1BlZXJJZCA9IHJvb20gPT4ge1xuICBpZiAocm9vbS5wcm92aWRlci5maWx0ZXJCY0Nvbm5zKSB7XG4gICAgLy8gYnJvYWRjYXN0IHBlZXJJZCB2aWEgYnJvYWRjYXN0Y2hhbm5lbFxuICAgIGNvbnN0IGVuY29kZXJQZWVySWRCYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyUGVlcklkQmMsIG1lc3NhZ2VCY1BlZXJJZClcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXJQZWVySWRCYywgMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyUGVlcklkQmMsIHJvb20ucGVlcklkKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZShyb29tLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclBlZXJJZEJjKSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUm9vbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICogQHBhcmFtIHtXZWJydGNQcm92aWRlcn0gcHJvdmlkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtDcnlwdG9LZXl8bnVsbH0ga2V5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBwcm92aWRlciwgbmFtZSwga2V5KSB7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGFzc3VtZSB0aGF0IHBlZXJJZCBpcyB1bmlxdWUuIFRoaXMgaXMgb25seSBtZWFudCBmb3Igc2VuZGluZyBzaWduYWxpbmcgbWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMucGVlcklkID0gcmFuZG9tLnV1aWR2NCgpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfVxuICAgICAqL1xuICAgIHRoaXMuYXdhcmVuZXNzID0gcHJvdmlkZXIuYXdhcmVuZXNzXG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICAvLyBAdG9kbyBtYWtlIGtleSBzZWNyZXQgYnkgc2NvcGluZ1xuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIFdlYnJ0Y0Nvbm4+fVxuICAgICAqL1xuICAgIHRoaXMud2VicnRjQ29ubnMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5iY0Nvbm5zID0gbmV3IFNldCgpXG4gICAgdGhpcy5tdXggPSBjcmVhdGVNdXRleCgpXG4gICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuX2JjU3Vic2NyaWJlciA9IGRhdGEgPT5cbiAgICAgIGNyeXB0b3V0aWxzLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkoZGF0YSksIGtleSkudGhlbihtID0+XG4gICAgICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgICAgICBjb25zdCByZXBseSA9IHJlYWRNZXNzYWdlKHRoaXMsIG0sICgpID0+IHt9KVxuICAgICAgICAgIGlmIChyZXBseSkge1xuICAgICAgICAgICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShyZXBseSkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gWWpzIHVwZGF0ZXMgYW5kIHNlbmRzIHRoZW0gdG8gcmVtb3RlIHBlZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBfb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fZG9jVXBkYXRlSGFuZGxlciA9ICh1cGRhdGUsIF9vcmlnaW4pID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVVwZGF0ZShlbmNvZGVyLCB1cGRhdGUpXG4gICAgICBicm9hZGNhc3RSb29tTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gQXdhcmVuZXNzIHVwZGF0ZXMgYW5kIHNlbmRzIHRoZW0gdG8gcmVtb3RlIHBlZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7YW55fSBfb3JpZ2luXG4gICAgICovXG4gICAgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlciA9ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIF9vcmlnaW4pID0+IHtcbiAgICAgIGNvbnN0IGNoYW5nZWRDbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQpLmNvbmNhdChyZW1vdmVkKVxuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzcyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3MsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzcywgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBjaGFuZ2VkQ2xpZW50cykpXG4gICAgICBicm9hZGNhc3RSb29tTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzcykpXG4gICAgfVxuXG4gICAgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGF3YXJlbmVzc1Byb3RvY29sLnJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLmF3YXJlbmVzcywgW2RvYy5jbGllbnRJRF0sICd3aW5kb3cgdW5sb2FkJylcbiAgICAgIHJvb21zLmZvckVhY2gocm9vbSA9PiB7XG4gICAgICAgIHJvb20uZGlzY29ubmVjdCgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHByb2Nlc3Mub24oJ2V4aXQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuZG9jLm9uKCd1cGRhdGUnLCB0aGlzLl9kb2NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuYXdhcmVuZXNzLm9uKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIC8vIHNpZ25hbCB0aHJvdWdoIGFsbCBhdmFpbGFibGUgc2lnbmFsaW5nIGNvbm5lY3Rpb25zXG4gICAgYW5ub3VuY2VTaWduYWxpbmdJbmZvKHRoaXMpXG4gICAgY29uc3Qgcm9vbU5hbWUgPSB0aGlzLm5hbWVcbiAgICBiYy5zdWJzY3JpYmUocm9vbU5hbWUsIHRoaXMuX2JjU3Vic2NyaWJlcilcbiAgICB0aGlzLmJjY29ubmVjdGVkID0gdHJ1ZVxuICAgIC8vIGJyb2FkY2FzdCBwZWVySWQgdmlhIGJyb2FkY2FzdGNoYW5uZWxcbiAgICBicm9hZGNhc3RCY1BlZXJJZCh0aGlzKVxuICAgIC8vIHdyaXRlIHN5bmMgc3RlcCAxXG4gICAgY29uc3QgZW5jb2RlclN5bmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclN5bmMsIG1lc3NhZ2VTeW5jKVxuICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyU3luYywgdGhpcy5kb2MpXG4gICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyU3luYykpXG4gICAgLy8gYnJvYWRjYXN0IGxvY2FsIHN0YXRlXG4gICAgY29uc3QgZW5jb2RlclN0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJTdGF0ZSwgbWVzc2FnZVN5bmMpXG4gICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAyKGVuY29kZXJTdGF0ZSwgdGhpcy5kb2MpXG4gICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyU3RhdGUpKVxuICAgIC8vIHdyaXRlIHF1ZXJ5QXdhcmVuZXNzXG4gICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1F1ZXJ5ID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NRdWVyeSwgbWVzc2FnZVF1ZXJ5QXdhcmVuZXNzKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1F1ZXJ5KSlcbiAgICAvLyBicm9hZGNhc3QgbG9jYWwgYXdhcmVuZXNzIHN0YXRlXG4gICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1N0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgbWVzc2FnZUF3YXJlbmVzcylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0pKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlckF3YXJlbmVzc1N0YXRlKSlcbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIC8vIHNpZ25hbCB0aHJvdWdoIGFsbCBhdmFpbGFibGUgc2lnbmFsaW5nIGNvbm5lY3Rpb25zXG4gICAgc2lnbmFsaW5nQ29ubnMuZm9yRWFjaChjb25uID0+IHtcbiAgICAgIGlmIChjb25uLmNvbm5lY3RlZCkge1xuICAgICAgICBjb25uLnNlbmQoeyB0eXBlOiAndW5zdWJzY3JpYmUnLCB0b3BpY3M6IFt0aGlzLm5hbWVdIH0pXG4gICAgICB9XG4gICAgfSlcbiAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sICdkaXNjb25uZWN0JylcbiAgICAvLyBicm9hZGNhc3QgcGVlcklkIHJlbW92YWwgdmlhIGJyb2FkY2FzdGNoYW5uZWxcbiAgICBjb25zdCBlbmNvZGVyUGVlcklkQmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclBlZXJJZEJjLCBtZXNzYWdlQmNQZWVySWQpXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyUGVlcklkQmMsIDApIC8vIHJlbW92ZSBwZWVySWQgZnJvbSBvdGhlciBiYyBwZWVyc1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXJQZWVySWRCYywgdGhpcy5wZWVySWQpXG4gICAgYnJvYWRjYXN0QmNNZXNzYWdlKHRoaXMsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyUGVlcklkQmMpKVxuXG4gICAgYmMudW5zdWJzY3JpYmUodGhpcy5uYW1lLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgdGhpcy5iY2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5kb2Mub2ZmKCd1cGRhdGUnLCB0aGlzLl9kb2NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuYXdhcmVuZXNzLm9mZigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLndlYnJ0Y0Nvbm5zLmZvckVhY2goY29ubiA9PiBjb25uLmRlc3Ryb3koKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcHJvY2Vzcy5vZmYoJ2V4aXQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHtXZWJydGNQcm92aWRlcn0gcHJvdmlkZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NyeXB0b0tleXxudWxsfSBrZXlcbiAqIEByZXR1cm4ge1Jvb219XG4gKi9cbmNvbnN0IG9wZW5Sb29tID0gKGRvYywgcHJvdmlkZXIsIG5hbWUsIGtleSkgPT4ge1xuICAvLyB0aGVyZSBtdXN0IG9ubHkgYmUgb25lIHJvb21cbiAgaWYgKHJvb21zLmhhcyhuYW1lKSkge1xuICAgIHRocm93IGVycm9yLmNyZWF0ZShgQSBZanMgRG9jIGNvbm5lY3RlZCB0byByb29tIFwiJHtuYW1lfVwiIGFscmVhZHkgZXhpc3RzIWApXG4gIH1cbiAgY29uc3Qgcm9vbSA9IG5ldyBSb29tKGRvYywgcHJvdmlkZXIsIG5hbWUsIGtleSlcbiAgcm9vbXMuc2V0KG5hbWUsIC8qKiBAdHlwZSB7Um9vbX0gKi8gKHJvb20pKVxuICByZXR1cm4gcm9vbVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U2lnbmFsaW5nQ29ubn0gY29ublxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICovXG5jb25zdCBwdWJsaXNoU2lnbmFsaW5nTWVzc2FnZSA9IChjb25uLCByb29tLCBkYXRhKSA9PiB7XG4gIGlmIChyb29tLmtleSkge1xuICAgIGNyeXB0b3V0aWxzLmVuY3J5cHRKc29uKGRhdGEsIHJvb20ua2V5KS50aGVuKGRhdGEgPT4ge1xuICAgICAgY29ubi5zZW5kKHsgdHlwZTogJ3B1Ymxpc2gnLCB0b3BpYzogcm9vbS5uYW1lLCBkYXRhOiBidWZmZXIudG9CYXNlNjQoZGF0YSkgfSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbm4uc2VuZCh7IHR5cGU6ICdwdWJsaXNoJywgdG9waWM6IHJvb20ubmFtZSwgZGF0YSB9KVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaWduYWxpbmdDb25uIGV4dGVuZHMgd3MuV2Vic29ja2V0Q2xpZW50IHtcbiAgY29uc3RydWN0b3IgKHVybCkge1xuICAgIHN1cGVyKHVybClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PFdlYnJ0Y1Byb3ZpZGVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBTZXQoKVxuICAgIHRoaXMub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBsb2coYGNvbm5lY3RlZCAoJHt1cmx9KWApXG4gICAgICBjb25zdCB0b3BpY3MgPSBBcnJheS5mcm9tKHJvb21zLmtleXMoKSlcbiAgICAgIHRoaXMuc2VuZCh7IHR5cGU6ICdzdWJzY3JpYmUnLCB0b3BpY3MgfSlcbiAgICAgIHJvb21zLmZvckVhY2gocm9vbSA9PlxuICAgICAgICBwdWJsaXNoU2lnbmFsaW5nTWVzc2FnZSh0aGlzLCByb29tLCB7IHR5cGU6ICdhbm5vdW5jZScsIGZyb206IHJvb20ucGVlcklkIH0pXG4gICAgICApXG4gICAgfSlcbiAgICB0aGlzLm9uKCdtZXNzYWdlJywgbSA9PiB7XG4gICAgICBzd2l0Y2ggKG0udHlwZSkge1xuICAgICAgICBjYXNlICdwdWJsaXNoJzoge1xuICAgICAgICAgIGNvbnN0IHJvb21OYW1lID0gbS50b3BpY1xuICAgICAgICAgIGNvbnN0IHJvb20gPSByb29tcy5nZXQocm9vbU5hbWUpXG4gICAgICAgICAgaWYgKHJvb20gPT0gbnVsbCB8fCB0eXBlb2Ygcm9vbU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZXhlY01lc3NhZ2UgPSBkYXRhID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHdlYnJ0Y0Nvbm5zID0gcm9vbS53ZWJydGNDb25uc1xuICAgICAgICAgICAgY29uc3QgcGVlcklkID0gcm9vbS5wZWVySWRcbiAgICAgICAgICAgIGlmIChkYXRhID09IG51bGwgfHwgZGF0YS5mcm9tID09PSBwZWVySWQgfHwgKGRhdGEudG8gIT09IHVuZGVmaW5lZCAmJiBkYXRhLnRvICE9PSBwZWVySWQpIHx8IHJvb20uYmNDb25ucy5oYXMoZGF0YS5mcm9tKSkge1xuICAgICAgICAgICAgICAvLyBpZ25vcmUgbWVzc2FnZXMgdGhhdCBhcmUgbm90IGFkZHJlc3NlZCB0byB0aGlzIGNvbm4sIG9yIGZyb20gY2xpZW50cyB0aGF0IGFyZSBjb25uZWN0ZWQgdmlhIGJyb2FkY2FzdGNoYW5uZWxcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbWl0UGVlckNoYW5nZSA9IHdlYnJ0Y0Nvbm5zLmhhcyhkYXRhLmZyb20pXG4gICAgICAgICAgICAgID8gKCkgPT4ge31cbiAgICAgICAgICAgICAgOiAoKSA9PlxuICAgICAgICAgICAgICAgIHJvb20ucHJvdmlkZXIuZW1pdCgncGVlcnMnLCBbe1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogW10sXG4gICAgICAgICAgICAgICAgICBhZGRlZDogW2RhdGEuZnJvbV0sXG4gICAgICAgICAgICAgICAgICB3ZWJydGNQZWVyczogQXJyYXkuZnJvbShyb29tLndlYnJ0Y0Nvbm5zLmtleXMoKSksXG4gICAgICAgICAgICAgICAgICBiY1BlZXJzOiBBcnJheS5mcm9tKHJvb20uYmNDb25ucylcbiAgICAgICAgICAgICAgICB9XSlcbiAgICAgICAgICAgIHN3aXRjaCAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2Fubm91bmNlJzpcbiAgICAgICAgICAgICAgICBpZiAod2VicnRjQ29ubnMuc2l6ZSA8IHJvb20ucHJvdmlkZXIubWF4Q29ubnMpIHtcbiAgICAgICAgICAgICAgICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh3ZWJydGNDb25ucywgZGF0YS5mcm9tLCAoKSA9PiBuZXcgV2VicnRjQ29ubih0aGlzLCB0cnVlLCBkYXRhLmZyb20sIHJvb20pKVxuICAgICAgICAgICAgICAgICAgZW1pdFBlZXJDaGFuZ2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdzaWduYWwnOlxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpZ25hbC50eXBlID09PSAnb2ZmZXInKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0Nvbm4gPSB3ZWJydGNDb25ucy5nZXQoZGF0YS5mcm9tKVxuICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nQ29ubikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVUb2tlbiA9IGRhdGEudG9rZW5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxUb2tlbiA9IGV4aXN0aW5nQ29ubi5nbGFyZVRva2VuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbFRva2VuICYmIGxvY2FsVG9rZW4gPiByZW1vdGVUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZygnb2ZmZXIgcmVqZWN0ZWQ6ICcsIGRhdGEuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkb24ndCByZWplY3QgdGhlIG9mZmVyLCB3ZSB3aWxsIGJlIGFjY2VwdGluZyBpdCBhbmQgYW5zd2VyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ29ubi5nbGFyZVRva2VuID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNpZ25hbC50eXBlID09PSAnYW5zd2VyJykge1xuICAgICAgICAgICAgICAgICAgbG9nKCdvZmZlciBhbnN3ZXJlZCBieTogJywgZGF0YS5mcm9tKVxuICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDb25uID0gd2VicnRjQ29ubnMuZ2V0KGRhdGEuZnJvbSlcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ29ubi5nbGFyZVRva2VuID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRvID09PSBwZWVySWQpIHtcbiAgICAgICAgICAgICAgICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh3ZWJydGNDb25ucywgZGF0YS5mcm9tLCAoKSA9PiBuZXcgV2VicnRjQ29ubih0aGlzLCBmYWxzZSwgZGF0YS5mcm9tLCByb29tKSkucGVlci5zaWduYWwoZGF0YS5zaWduYWwpXG4gICAgICAgICAgICAgICAgICBlbWl0UGVlckNoYW5nZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb29tLmtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNyeXB0b3V0aWxzLmRlY3J5cHRKc29uKGJ1ZmZlci5mcm9tQmFzZTY0KG0uZGF0YSksIHJvb20ua2V5KS50aGVuKGV4ZWNNZXNzYWdlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBleGVjTWVzc2FnZShtLmRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm9uKCdkaXNjb25uZWN0JywgKCkgPT4gbG9nKGBkaXNjb25uZWN0ICgke3VybH0pYCkpXG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm92aWRlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8c3RyaW5nPn0gW3NpZ25hbGluZ11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcGFzc3dvcmRdXG4gKiBAcHJvcGVydHkge2F3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzc30gW2F3YXJlbmVzc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4Q29ubnNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmaWx0ZXJCY0Nvbm5zXVxuICogQHByb3BlcnR5IHthbnl9IFtwZWVyT3B0c11cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7V2VicnRjUHJvdmlkZXJ9IHByb3ZpZGVyXG4gKi9cbmNvbnN0IGVtaXRTdGF0dXMgPSBwcm92aWRlciA9PiB7XG4gIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgY29ubmVjdGVkOiBwcm92aWRlci5jb25uZWN0ZWRcbiAgfV0pXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gV2VicnRjUHJvdmlkZXJFdmVudHNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oe2Nvbm5lY3RlZDpib29sZWFufSk6dm9pZH0gV2VicnRjUHJvdmlkZXJFdmVudC5zdGF0dXNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oe3N5bmNlZDpib29sZWFufSk6dm9pZH0gV2VicnRjUHJvdmlkZXJFdmVudC5zeW5jZWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oe2FkZGVkOkFycmF5PHN0cmluZz4scmVtb3ZlZDpBcnJheTxzdHJpbmc+LHdlYnJ0Y1BlZXJzOkFycmF5PHN0cmluZz4sYmNQZWVyczpBcnJheTxzdHJpbmc+fSk6dm9pZH0gV2VicnRjUHJvdmlkZXJFdmVudC5wZWVyc1xuICovXG5cbi8qKlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZVYyPFdlYnJ0Y1Byb3ZpZGVyRXZlbnRzPlxuICovXG5leHBvcnQgY2xhc3MgV2VicnRjUHJvdmlkZXIgZXh0ZW5kcyBPYnNlcnZhYmxlVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21OYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKiBAcGFyYW0ge1Byb3ZpZGVyT3B0aW9ucz99IG9wdHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChcbiAgICByb29tTmFtZSxcbiAgICBkb2MsXG4gICAge1xuICAgICAgc2lnbmFsaW5nID0gWyd3c3M6Ly95LXdlYnJ0Yy1ldS5mbHkuZGV2J10sXG4gICAgICBwYXNzd29yZCA9IG51bGwsXG4gICAgICBhd2FyZW5lc3MgPSBuZXcgYXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzKGRvYyksXG4gICAgICBtYXhDb25ucyA9IDIwICsgbWF0aC5mbG9vcihyYW5kb20ucmFuZCgpICogMTUpLCAvLyB0aGUgcmFuZG9tIGZhY3RvciByZWR1Y2VzIHRoZSBjaGFuY2UgdGhhdCBuIGNsaWVudHMgZm9ybSBhIGNsdXN0ZXJcbiAgICAgIGZpbHRlckJjQ29ubnMgPSB0cnVlLFxuICAgICAgcGVlck9wdHMgPSB7fSAvLyBzaW1wbGUtcGVlciBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9zaW1wbGUtcGVlciNwZWVyLS1uZXctcGVlcm9wdHNcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMucm9vbU5hbWUgPSByb29tTmFtZVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5maWx0ZXJCY0Nvbm5zID0gZmlsdGVyQmNDb25uc1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3N9XG4gICAgICovXG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3NcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuc2lnbmFsaW5nVXJscyA9IHNpZ25hbGluZ1xuICAgIHRoaXMuc2lnbmFsaW5nQ29ubnMgPSBbXVxuICAgIHRoaXMubWF4Q29ubnMgPSBtYXhDb25uc1xuICAgIHRoaXMucGVlck9wdHMgPSBwZWVyT3B0c1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlTGlrZTxDcnlwdG9LZXkgfCBudWxsPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHBhc3N3b3JkID8gY3J5cHRvdXRpbHMuZGVyaXZlS2V5KHBhc3N3b3JkLCByb29tTmFtZSkgOiAvKiogQHR5cGUge1Byb21pc2VMaWtlPG51bGw+fSAqLyAocHJvbWlzZS5yZXNvbHZlKG51bGwpKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSb29tfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yb29tID0gbnVsbFxuICAgIHRoaXMua2V5LnRoZW4oa2V5ID0+IHtcbiAgICAgIHRoaXMucm9vbSA9IG9wZW5Sb29tKGRvYywgdGhpcywgcm9vbU5hbWUsIGtleSlcbiAgICAgIGlmICh0aGlzLnNob3VsZENvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5yb29tLmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yb29tLmRpc2Nvbm5lY3QoKVxuICAgICAgfVxuICAgICAgZW1pdFN0YXR1cyh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5jb25uZWN0KClcbiAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKVxuICAgIGRvYy5vbignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcHJvdmlkZXIgaXMgbG9va2luZyBmb3Igb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIE90aGVyIHBlZXJzIGNhbiBiZSBmb3VuZCB2aWEgc2lnbmFsaW5nIHNlcnZlcnMgb3IgdmlhIGJyb2FkY2FzdGNoYW5uZWwgKGNyb3NzIGJyb3dzZXItdGFiXG4gICAqIGNvbW11bmljYXRpb24pLiBZb3UgbmV2ZXIga25vdyB3aGVuIHlvdSBhcmUgY29ubmVjdGVkIHRvIGFsbCBwZWVycy4gWW91IGFsc28gZG9uJ3Qga25vdyBpZlxuICAgKiB0aGVyZSBhcmUgb3RoZXIgcGVlcnMuIGNvbm5lY3RlZCBkb2Vzbid0IG1lYW4gdGhhdCB5b3UgYXJlIGNvbm5lY3RlZCB0byBhbnkgcGh5c2ljYWwgcGVlcnNcbiAgICogd29ya2luZyBvbiB0aGUgc2FtZSByZXNvdXJjZSBhcyB5b3UuIEl0IGRvZXMgbm90IGNoYW5nZSB1bmxlc3MgeW91IGNhbGwgcHJvdmlkZXIuZGlzY29ubmVjdCgpXG4gICAqXG4gICAqIGB0aGlzLm9uKCdzdGF0dXMnLCAoZXZlbnQpID0+IHsgY29uc29sZS5sb2coZXZlbnQuY29ubmVjdGVkKSB9KWBcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgY29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5yb29tICE9PSBudWxsICYmIHRoaXMuc2hvdWxkQ29ubmVjdFxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIHRoaXMuc2lnbmFsaW5nVXJscy5mb3JFYWNoKHVybCA9PiB7XG4gICAgICBjb25zdCBzaWduYWxpbmdDb25uID0gbWFwLnNldElmVW5kZWZpbmVkKHNpZ25hbGluZ0Nvbm5zLCB1cmwsICgpID0+IG5ldyBTaWduYWxpbmdDb25uKHVybCkpXG4gICAgICB0aGlzLnNpZ25hbGluZ0Nvbm5zLnB1c2goc2lnbmFsaW5nQ29ubilcbiAgICAgIHNpZ25hbGluZ0Nvbm4ucHJvdmlkZXJzLmFkZCh0aGlzKVxuICAgIH0pXG4gICAgaWYgKHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tLmNvbm5lY3QoKVxuICAgICAgZW1pdFN0YXR1cyh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlXG4gICAgdGhpcy5zaWduYWxpbmdDb25ucy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgICAgY29ubi5wcm92aWRlcnMuZGVsZXRlKHRoaXMpXG4gICAgICBpZiAoY29ubi5wcm92aWRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBjb25uLmRlc3Ryb3koKVxuICAgICAgICBzaWduYWxpbmdDb25ucy5kZWxldGUoY29ubi51cmwpXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAodGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20uZGlzY29ubmVjdCgpXG4gICAgICBlbWl0U3RhdHVzKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5kb2Mub2ZmKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICAgIC8vIG5lZWQgdG8gd2FpdCBmb3Iga2V5IGJlZm9yZSBkZWxldGluZyByb29tXG4gICAgdGhpcy5rZXkudGhlbigoKSA9PiB7XG4gICAgICAvKiogQHR5cGUge1Jvb219ICovICh0aGlzLnJvb20pLmRlc3Ryb3koKVxuICAgICAgcm9vbXMuZGVsZXRlKHRoaXMucm9vbU5hbWUpXG4gICAgfSlcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBzeW5jLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiBcdTIwMjIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiBcdTIwMjIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWxkIG9ubHkgcmVwbHkgdG8gcmVxdWVzdHMsIGFuZCBub3QgaW5pdGlhdGUgdGhlbS5cbiAqIFRoZXJlZm9yZSBpdCBpcyBuZWNlc3NhcnkgdGhhdCB0aGUgY2xpZW50IGluaXRpYXRlcyB0aGUgc3luYy5cbiAqXG4gKiBDb25zdHJ1Y3Rpb24gb2YgYSBtZXNzYWdlOlxuICogW21lc3NhZ2VUeXBlIDogdmFyVWludCwgbWVzc2FnZSBkZWZpbml0aW9uLi5dXG4gKlxuICogTm90ZTogQSBtZXNzYWdlIGRvZXMgbm90IGluY2x1ZGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb20gbmFtZS4gVGhpcyBtdXN0IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHVwcGVyIGxheWVyIHByb3RvY29sIVxuICpcbiAqIHN0cmluZ2lmeVttZXNzYWdlVHlwZV0gc3RyaW5naWZpZXMgYSBtZXNzYWdlIGRlZmluaXRpb24gKG1lc3NhZ2VUeXBlIGlzIGFscmVhZHkgcmVhZCBmcm9tIHRoZSBidWZmZmVyKVxuICovXG5cbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAxID0gMFxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDIgPSAxXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1VwZGF0ZSA9IDJcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW5jIHN0ZXAgMSBtZXNzYWdlIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBzaGFyZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAxID0gKGVuY29kZXIsIGRvYykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMSlcbiAgY29uc3Qgc3YgPSBZLmVuY29kZVN0YXRlVmVjdG9yKGRvYylcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHN2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkU3RhdGVWZWN0b3JdXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN5bmNTdGVwMiA9IChlbmNvZGVyLCBkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1N5bmNTdGVwMilcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MsIGVuY29kZWRTdGF0ZVZlY3RvcikpXG59XG5cbi8qKlxuICogUmVhZCBTeW5jU3RlcDEgbWVzc2FnZSBhbmQgcmVwbHkgd2l0aCBTeW5jU3RlcDIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIFRoZSByZXBseSB0byB0aGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDEgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jKSA9PlxuICB3cml0ZVN5bmNTdGVwMihlbmNvZGVyLCBkb2MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jU3RlcDIgPSAoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICB0cnkge1xuICAgIFkuYXBwbHlVcGRhdGUoZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgdHJhbnNhY3Rpb25PcmlnaW4pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZXZlbnQgaGFuZGxlcnNcbiAgICBjb25zb2xlLmVycm9yKCdDYXVnaHQgZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSBZanMgdXBkYXRlJywgZXJyb3IpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVwZGF0ZSA9IChlbmNvZGVyLCB1cGRhdGUpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNVcGRhdGUpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB1cGRhdGUpXG59XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFVwZGF0ZSA9IHJlYWRTeW5jU3RlcDJcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgQSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gYW5vdGhlciBjbGllbnRcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVwbHkgbWVzc2FnZS4gRG9lcyBub3QgbmVlZCB0byBiZSBzZW50IGlmIGVtcHR5LlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jTWVzc2FnZSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMTpcbiAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgZG9jKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDI6XG4gICAgICByZWFkU3luY1N0ZXAyKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1VwZGF0ZTpcbiAgICAgIHJlYWRVcGRhdGUoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnKVxuICB9XG4gIHJldHVybiBtZXNzYWdlVHlwZVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBhd2FyZW5lc3MtcHJvdG9jb2xcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuaW1wb3J0ICogYXMgZiBmcm9tICdsaWIwL2Z1bmN0aW9uJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuZXhwb3J0IGNvbnN0IG91dGRhdGVkVGltZW91dCA9IDMwMDAwXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YUNsaWVudFN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmNsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmxhc3RVcGRhdGVkIHVuaXggdGltZXN0YW1wXG4gKi9cblxuLyoqXG4gKiBUaGUgQXdhcmVuZXNzIGNsYXNzIGltcGxlbWVudHMgYSBzaW1wbGUgc2hhcmVkIHN0YXRlIHByb3RvY29sIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG5vbi1wZXJzaXN0ZW50IGRhdGEgbGlrZSBhd2FyZW5lc3MgaW5mb3JtYXRpb25cbiAqIChjdXJzb3IsIHVzZXJuYW1lLCBzdGF0dXMsIC4uKS4gRWFjaCBjbGllbnQgY2FuIHVwZGF0ZSBpdHMgb3duIGxvY2FsIHN0YXRlIGFuZCBsaXN0ZW4gdG8gc3RhdGUgY2hhbmdlcyBvZlxuICogcmVtb3RlIGNsaWVudHMuIEV2ZXJ5IGNsaWVudCBtYXkgc2V0IGEgc3RhdGUgb2YgYSByZW1vdGUgcGVlciB0byBgbnVsbGAgdG8gbWFyayB0aGUgY2xpZW50IGFzIG9mZmxpbmUuXG4gKlxuICogRWFjaCBjbGllbnQgaXMgaWRlbnRpZmllZCBieSBhIHVuaXF1ZSBjbGllbnQgaWQgKHNvbWV0aGluZyB3ZSBib3Jyb3cgZnJvbSBgZG9jLmNsaWVudElEYCkuIEEgY2xpZW50IGNhbiBvdmVycmlkZVxuICogaXRzIG93biBzdGF0ZSBieSBwcm9wYWdhdGluZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbmNyZWFzaW5nIHRpbWVzdGFtcCAoYGNsb2NrYCkuIElmIHN1Y2ggYSBtZXNzYWdlIGlzIHJlY2VpdmVkLCBpdCBpc1xuICogYXBwbGllZCBpZiB0aGUga25vd24gc3RhdGUgb2YgdGhhdCBjbGllbnQgaXMgb2xkZXIgdGhhbiB0aGUgbmV3IHN0YXRlIChgY2xvY2sgPCBuZXdDbG9ja2ApLiBJZiBhIGNsaWVudCB0aGlua3MgdGhhdFxuICogYSByZW1vdGUgY2xpZW50IGlzIG9mZmxpbmUsIGl0IG1heSBwcm9wYWdhdGUgYSBtZXNzYWdlIHdpdGhcbiAqIGB7IGNsb2NrOiBjdXJyZW50Q2xpZW50Q2xvY2ssIHN0YXRlOiBudWxsLCBjbGllbnQ6IHJlbW90ZUNsaWVudCB9YC4gSWYgc3VjaCBhXG4gKiBtZXNzYWdlIGlzIHJlY2VpdmVkLCBhbmQgdGhlIGtub3duIGNsb2NrIG9mIHRoYXQgY2xpZW50IGVxdWFscyB0aGUgcmVjZWl2ZWQgY2xvY2ssIGl0IHdpbGwgb3ZlcnJpZGUgdGhlIHN0YXRlIHdpdGggYG51bGxgLlxuICpcbiAqIEJlZm9yZSBhIGNsaWVudCBkaXNjb25uZWN0cywgaXQgc2hvdWxkIHByb3BhZ2F0ZSBhIGBudWxsYCBzdGF0ZSB3aXRoIGFuIHVwZGF0ZWQgY2xvY2suXG4gKlxuICogQXdhcmVuZXNzIHN0YXRlcyBtdXN0IGJlIHVwZGF0ZWQgZXZlcnkgMzAgc2Vjb25kcy4gT3RoZXJ3aXNlIHRoZSBBd2FyZW5lc3MgaW5zdGFuY2Ugd2lsbCBkZWxldGUgdGhlIGNsaWVudCBzdGF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxzdHJpbmc+fVxuICovXG5leHBvcnQgY2xhc3MgQXdhcmVuZXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50SUQgPSBkb2MuY2xpZW50SURcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50IGlkIHRvIGNsaWVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBhbnk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBNZXRhQ2xpZW50U3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgaWYgKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsICYmIChvdXRkYXRlZFRpbWVvdXQgLyAyIDw9IG5vdyAtIC8qKiBAdHlwZSB7e2xhc3RVcGRhdGVkOm51bWJlcn19ICovICh0aGlzLm1ldGEuZ2V0KHRoaXMuY2xpZW50SUQpKS5sYXN0VXBkYXRlZCkpIHtcbiAgICAgICAgLy8gcmVuZXcgbG9jYWwgY2xvY2tcbiAgICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpKVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVtb3ZlID0gW11cbiAgICAgIHRoaXMubWV0YS5mb3JFYWNoKChtZXRhLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICBpZiAoY2xpZW50aWQgIT09IHRoaXMuY2xpZW50SUQgJiYgb3V0ZGF0ZWRUaW1lb3V0IDw9IG5vdyAtIG1ldGEubGFzdFVwZGF0ZWQgJiYgdGhpcy5zdGF0ZXMuaGFzKGNsaWVudGlkKSkge1xuICAgICAgICAgIHJlbW92ZS5wdXNoKGNsaWVudGlkKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLCByZW1vdmUsICd0aW1lb3V0JylcbiAgICAgIH1cbiAgICB9LCBtYXRoLmZsb29yKG91dGRhdGVkVGltZW91dCAvIDEwKSkpXG4gICAgZG9jLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KClcbiAgICB9KVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7fSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUobnVsbClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9XG4gICAqL1xuICBnZXRMb2NhbFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXMuZ2V0KHRoaXMuY2xpZW50SUQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfSBzdGF0ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZSAoc3RhdGUpIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IHRoaXMuY2xpZW50SURcbiAgICBjb25zdCBjdXJyTG9jYWxNZXRhID0gdGhpcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjbG9jayA9IGN1cnJMb2NhbE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjdXJyTG9jYWxNZXRhLmNsb2NrICsgMVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSlcbiAgICB9XG4gICAgdGhpcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgY2xvY2ssXG4gICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgfSlcbiAgICBjb25zdCBhZGRlZCA9IFtdXG4gICAgY29uc3QgdXBkYXRlZCA9IFtdXG4gICAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgICBjb25zdCByZW1vdmVkID0gW11cbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICB9IGVsc2UgaWYgKHByZXZTdGF0ZSA9PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHByZXZTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSlcbiAgICB9XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlRmllbGQgKGZpZWxkLCB2YWx1ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRMb2NhbFN0YXRlKClcbiAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbZmllbGRdOiB2YWx1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TWFwPG51bWJlcixPYmplY3Q8c3RyaW5nLGFueT4+fVxuICAgKi9cbiAgZ2V0U3RhdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNcbiAgfVxufVxuXG4vKipcbiAqIE1hcmsgKHJlbW90ZSkgY2xpZW50cyBhcyBpbmFjdGl2ZSBhbmQgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbGlzdCBvZiBhY3RpdmUgcGVlcnMuXG4gKiBUaGlzIGNoYW5nZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdG8gcmVtb3RlIGNsaWVudHMuXG4gKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjbGllbnRzXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVBd2FyZW5lc3NTdGF0ZXMgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGlmIChhd2FyZW5lc3Muc3RhdGVzLmhhcyhjbGllbnRJRCkpIHtcbiAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQpIHtcbiAgICAgICAgY29uc3QgY3VyTWV0YSA9IC8qKiBAdHlwZSB7TWV0YUNsaWVudFN0YXRlfSAqLyAoYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKSlcbiAgICAgICAgYXdhcmVuZXNzLm1ldGEuc2V0KGNsaWVudElELCB7XG4gICAgICAgICAgY2xvY2s6IGN1ck1ldGEuY2xvY2sgKyAxLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7IGFkZGVkOiBbXSwgdXBkYXRlZDogW10sIHJlbW92ZWQgfSwgb3JpZ2luXSlcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUF3YXJlbmVzc1VwZGF0ZSA9IChhd2FyZW5lc3MsIGNsaWVudHMsIHN0YXRlcyA9IGF3YXJlbmVzcy5zdGF0ZXMpID0+IHtcbiAgY29uc3QgbGVuID0gY2xpZW50cy5sZW5ndGhcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBjbGllbnRzW2ldXG4gICAgY29uc3Qgc3RhdGUgPSBzdGF0ZXMuZ2V0KGNsaWVudElEKSB8fCBudWxsXG4gICAgY29uc3QgY2xvY2sgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpLmNsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbG9jaylcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIE1vZGlmeSB0aGUgY29udGVudCBvZiBhbiBhd2FyZW5lc3MgdXBkYXRlIGJlZm9yZSByZS1lbmNvZGluZyBpdCB0byBhbiBhd2FyZW5lc3MgdXBkYXRlLlxuICpcbiAqIFRoaXMgbWlnaHQgYmUgdXNlZnVsIHdoZW4geW91IGhhdmUgYSBjZW50cmFsIHNlcnZlciB0aGF0IHdhbnRzIHRvIGVuc3VyZSB0aGF0IGNsaWVudHNcbiAqIGNhbnQgaGlqYWNrIHNvbWVib2R5IGVsc2VzIGlkZW50aXR5LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6YW55fSBtb2RpZnlcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBtb2RpZnlBd2FyZW5lc3NVcGRhdGUgPSAodXBkYXRlLCBtb2RpZnkpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3QgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICAgIGNvbnN0IG1vZGlmaWVkU3RhdGUgPSBtb2RpZnkoc3RhdGUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGNsaWVudElEKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbG9jaylcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBKU09OLnN0cmluZ2lmeShtb2RpZmllZFN0YXRlKSlcbiAgfVxuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBvcmlnaW4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBlbWl0dGVkIGNoYW5nZSBldmVudFxuICovXG5leHBvcnQgY29uc3QgYXBwbHlBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCB1cGRhdGUsIG9yaWdpbikgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBhZGRlZCA9IFtdXG4gIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICBjb25zdCBmaWx0ZXJlZFVwZGF0ZWQgPSBbXVxuICBjb25zdCByZW1vdmVkID0gW11cbiAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICAgIGNvbnN0IGNsaWVudE1ldGEgPSBhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgcHJldlN0YXRlID0gYXdhcmVuZXNzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY3VyckNsb2NrID0gY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkID8gMCA6IGNsaWVudE1ldGEuY2xvY2tcbiAgICBpZiAoY3VyckNsb2NrIDwgY2xvY2sgfHwgKGN1cnJDbG9jayA9PT0gY2xvY2sgJiYgc3RhdGUgPT09IG51bGwgJiYgYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSkge1xuICAgICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5ldmVyIGxldCBhIHJlbW90ZSBjbGllbnQgcmVtb3ZlIHRoaXMgbG9jYWwgc3RhdGVcbiAgICAgICAgaWYgKGNsaWVudElEID09PSBhd2FyZW5lc3MuY2xpZW50SUQgJiYgYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gcmVtb3RlIGNsaWVudCByZW1vdmVkIHRoZSBsb2NhbCBzdGF0ZS4gRG8gbm90IHJlbW90ZSBzdGF0ZS4gQnJvYWRjYXN0IGEgbWVzc2FnZSBpbmRpY2F0aW5nXG4gICAgICAgICAgLy8gdGhhdCB0aGlzIGNsaWVudCBzdGlsbCBleGlzdHMgYnkgaW5jcmVhc2luZyB0aGUgY2xvY2tcbiAgICAgICAgICBjbG9jaysrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhcmVuZXNzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSlcbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICBjbG9jayxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWVzdGFtcFxuICAgICAgfSlcbiAgICAgIGlmIChjbGllbnRNZXRhID09PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH0gZWxzZSBpZiAoY2xpZW50TWV0YSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChzdGF0ZSwgcHJldlN0YXRlKSkge1xuICAgICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ2NoYW5nZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZDogZmlsdGVyZWRVcGRhdGVkLCByZW1vdmVkXG4gICAgfSwgb3JpZ2luXSlcbiAgfVxuICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCB1cGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgYXdhcmVuZXNzLmVtaXQoJ3VwZGF0ZScsIFt7XG4gICAgICBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJ2xpYjAvcHJvbWlzZSdcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnbGliMC9zdHJpbmcnXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlY3JldFxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21OYW1lXG4gKiBAcmV0dXJuIHtQcm9taXNlTGlrZTxDcnlwdG9LZXk+fVxuICovXG5leHBvcnQgY29uc3QgZGVyaXZlS2V5ID0gKHNlY3JldCwgcm9vbU5hbWUpID0+IHtcbiAgY29uc3Qgc2VjcmV0QnVmZmVyID0gc3RyaW5nLmVuY29kZVV0Zjgoc2VjcmV0KS5idWZmZXJcbiAgY29uc3Qgc2FsdCA9IHN0cmluZy5lbmNvZGVVdGY4KHJvb21OYW1lKS5idWZmZXJcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIHNlY3JldEJ1ZmZlcixcbiAgICAnUEJLREYyJyxcbiAgICBmYWxzZSxcbiAgICBbJ2Rlcml2ZUtleSddXG4gICkudGhlbihrZXlNYXRlcmlhbCA9PlxuICAgIGNyeXB0by5zdWJ0bGUuZGVyaXZlS2V5KFxuICAgICAge1xuICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgc2FsdCxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwLFxuICAgICAgICBoYXNoOiAnU0hBLTI1NidcbiAgICAgIH0sXG4gICAgICBrZXlNYXRlcmlhbCxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgICBsZW5ndGg6IDI1NlxuICAgICAgfSxcbiAgICAgIHRydWUsXG4gICAgICBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddXG4gICAgKVxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIGRhdGEgdG8gYmUgZW5jcnlwdGVkXG4gKiBAcGFyYW0ge0NyeXB0b0tleT99IGtleVxuICogQHJldHVybiB7UHJvbWlzZUxpa2U8VWludDhBcnJheT59IGVuY3J5cHRlZCwgYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5leHBvcnQgY29uc3QgZW5jcnlwdCA9IChkYXRhLCBrZXkpID0+IHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtQcm9taXNlTGlrZTxVaW50OEFycmF5Pn0gKi8gKHByb21pc2UucmVzb2x2ZShkYXRhKSlcbiAgfVxuICBjb25zdCBpdiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTIpKVxuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgIHtcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgIGl2XG4gICAgfSxcbiAgICBrZXksXG4gICAgZGF0YVxuICApLnRoZW4oY2lwaGVyID0+IHtcbiAgICBjb25zdCBlbmNyeXB0ZWREYXRhRW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY3J5cHRlZERhdGFFbmNvZGVyLCAnQUVTLUdDTScpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY3J5cHRlZERhdGFFbmNvZGVyLCBpdilcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUVuY29kZXIsIG5ldyBVaW50OEFycmF5KGNpcGhlcikpXG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNyeXB0ZWREYXRhRW5jb2RlcilcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBkYXRhIHRvIGJlIGVuY3J5cHRlZFxuICogQHBhcmFtIHtDcnlwdG9LZXk/fSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2VMaWtlPFVpbnQ4QXJyYXk+fSBlbmNyeXB0ZWQgZGF0YSwgaWYga2V5IGlzIHByb3ZpZGVkXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNyeXB0SnNvbiA9IChkYXRhLCBrZXkpID0+IHtcbiAgY29uc3QgZGF0YUVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVBbnkoZGF0YUVuY29kZXIsIGRhdGEpXG4gIHJldHVybiBlbmNyeXB0KGVuY29kaW5nLnRvVWludDhBcnJheShkYXRhRW5jb2RlciksIGtleSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7Q3J5cHRvS2V5P30ga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlTGlrZTxVaW50OEFycmF5Pn0gZGVjcnlwdGVkIGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgZGVjcnlwdCA9IChkYXRhLCBrZXkpID0+IHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtQcm9taXNlTGlrZTxVaW50OEFycmF5Pn0gKi8gKHByb21pc2UucmVzb2x2ZShkYXRhKSlcbiAgfVxuICBjb25zdCBkYXRhRGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGF0YSlcbiAgY29uc3QgYWxnb3JpdGhtID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkYXRhRGVjb2RlcilcbiAgaWYgKGFsZ29yaXRobSAhPT0gJ0FFUy1HQ00nKSB7XG4gICAgcHJvbWlzZS5yZWplY3QoZXJyb3IuY3JlYXRlKCdVbmtub3duIGVuY3J5cHRpb24gYWxnb3JpdGhtJykpXG4gIH1cbiAgY29uc3QgaXYgPSBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkYXRhRGVjb2RlcilcbiAgY29uc3QgY2lwaGVyID0gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGF0YURlY29kZXIpXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmRlY3J5cHQoXG4gICAge1xuICAgICAgbmFtZTogJ0FFUy1HQ00nLFxuICAgICAgaXZcbiAgICB9LFxuICAgIGtleSxcbiAgICBjaXBoZXJcbiAgKS50aGVuKGRhdGEgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge0NyeXB0b0tleT99IGtleVxuICogQHJldHVybiB7UHJvbWlzZUxpa2U8T2JqZWN0Pn0gZGVjcnlwdGVkIG9iamVjdFxuICovXG5leHBvcnQgY29uc3QgZGVjcnlwdEpzb24gPSAoZGF0YSwga2V5KSA9PlxuICBkZWNyeXB0KGRhdGEsIGtleSkudGhlbihkZWNyeXB0ZWRWYWx1ZSA9PlxuICAgIGRlY29kaW5nLnJlYWRBbnkoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihuZXcgVWludDhBcnJheShkZWNyeXB0ZWRWYWx1ZSkpKVxuICApXG4iLCAiaW1wb3J0IFBlZXJEcmFmdFBsdWdpbiBmcm9tICdzcmMvbWFpbidcbmltcG9ydCB7IFdlYnJ0Y1Byb3ZpZGVyIH0gZnJvbSAneS13ZWJydGMnXG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gXCJ5LWluZGV4ZWRkYlwiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IGNyZWF0ZVJhbmRvbUlkIH0gZnJvbSAnc3JjL3Rvb2xzJ1xuaW1wb3J0IHsgbm9ybWFsaXplUGF0aCB9IGZyb20gJ29ic2lkaWFuJ1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNoYXJlZEVudGl0eSB7XG5cbiAgc3RhdGljIERCX1BFUlNJU1RFTkNFX1BSRUZJWCA9IFwicGVlcmRyYWZ0X3BlcnNpc3RlbmNlX1wiXG5cbiAgeURvYzogWS5Eb2NcbiAgcHJvdGVjdGVkIF9zaGFyZUlkOiBzdHJpbmdcblxuICBwcm90ZWN0ZWQgX3dlYlJUQ1Byb3ZpZGVyPzogV2VicnRjUHJvdmlkZXJcbiAgcHJvdGVjdGVkIF93ZWJSVENUaW1lb3V0OiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG4gIHByb3RlY3RlZCBfaW5kZXhlZERCUHJvdmlkZXI/OiBJbmRleGVkZGJQZXJzaXN0ZW5jZVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgX3NoYXJlZEVudGl0ZXM6IEFycmF5PFNoYXJlZEVudGl0eT47XG5cbiAgcHJvdGVjdGVkIF9wYXRoOiBzdHJpbmdcblxuICBnZXQgc2hhcmVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hhcmVJZFxuICB9XG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGhcbiAgfVxuXG4gIGdldCBpbmRleGVkREJQcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhlZERCUHJvdmlkZXJcbiAgfVxuXG4gIGdldCB3ZWJSVENQcm92aWRlcigpe1xuICAgIHJldHVybiB0aGlzLl93ZWJSVENQcm92aWRlclxuICB9XG5cbiAgc3RhdGljIGZpbmRCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpXG4gICAgY29uc3QgZG9jcyA9IHRoaXMuX3NoYXJlZEVudGl0ZXMuZmlsdGVyKGRvYyA9PiB7XG4gICAgICByZXR1cm4gZG9jLnBhdGggPT09IG5vcm1hbGl6ZWRQYXRoXG4gICAgfSlcbiAgICBpZiAoZG9jcy5sZW5ndGggPj0gMSkge1xuICAgICAgcmV0dXJuIGRvY3NbMF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZpbmRCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkb2NzID0gdGhpcy5fc2hhcmVkRW50aXRlcy5maWx0ZXIoZG9jID0+IHtcbiAgICAgIHJldHVybiBkb2Muc2hhcmVJZCA9PT0gaWRcbiAgICB9KVxuICAgIGlmIChkb2NzLmxlbmd0aCA+PSAxKSB7XG4gICAgICByZXR1cm4gZG9jc1swXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0QWxsKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB0aGlzLl9zaGFyZWRFbnRpdGVzKSBhcyBBcnJheTxTaGFyZWRFbnRpdHk+XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHt9XG5cbiAgYWJzdHJhY3QgY2FsY3VsYXRlSGFzaCAoKTogc3RyaW5nXG5cbiAgaW5pdFNlcnZlcllEb2MoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4ocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCB0ZW1wSWQgPSBjcmVhdGVSYW5kb21JZCgpXG4gICAgICBjb25zdCBoYW5kbGVyID0gKHNlcnZlclRlbXBJZDogc3RyaW5nLCBpZDogc3RyaW5nLCBjaGVja3N1bTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChzZXJ2ZXJUZW1wSWQgPT09IHRlbXBJZCkge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMub2ZmKCduZXctZG9jLWNvbmZpcm1lZCcsIGhhbmRsZXIpXG4gICAgICAgICAgdGhpcy5fc2hhcmVJZCA9IGlkXG4gICAgICAgICAgcmVzb2x2ZShjaGVja3N1bSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5vbignbmV3LWRvYy1jb25maXJtZWQnLCBoYW5kbGVyKVxuICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5zZW5kTmV3RG9jdW1lbnQodGhpcywgdGVtcElkKVxuICAgIH0pXG4gIH1cblxuICBzeW5jV2l0aFNlcnZlcigpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPihyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoaWQ6IHN0cmluZywgaGFzaDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChpZCA9PT0gdGhpcy5zaGFyZUlkKSB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5vZmYoJ3N5bmNlZCcsIGhhbmRsZXIpXG4gICAgICAgICAgdGhpcy5wbHVnaW4ubG9nKFwic3luY2VkIFwiICsgdGhpcy5wYXRoKVxuICAgICAgICAgIHJlc29sdmUoaGFzaClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5vbignc3luY2VkJywgaGFuZGxlcilcbiAgICAgIFxuICAgICAgdGhpcy5wbHVnaW4uc2VydmVyU3luYy5zZW5kU3luY1N0ZXAxKHRoaXMpXG4gICAgICB0aGlzLnBsdWdpbi5sb2coXCJzeW5jaW5nIFwiICsgdGhpcy5wYXRoKVxuICAgIH0pXG4gIH1cblxuXG4gIHN0YXJ0V2ViUlRDU3luYyhpbml0PzogKHByb3ZpZGVyOiBXZWJydGNQcm92aWRlcikgPT4gYW55KSB7XG4gICAgdGhpcy5wbHVnaW4ubG9nKGBXZWJSVEMgZm9yICR7dGhpcy5wYXRofTogc3RhcnRgKVxuICAgIGlmICghdGhpcy5zaGFyZUlkKSByZXR1cm5cbiAgICBpZiAodGhpcy5fd2ViUlRDUHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyLmNvbm5lY3QoKVxuICAgICAgcmV0dXJuIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyXG4gICAgfVxuICAgIGNvbnN0IHdlYlJUQ1Byb3ZpZGVyID0gbmV3IFdlYnJ0Y1Byb3ZpZGVyKHRoaXMuX3NoYXJlSWQsIHRoaXMueURvYywgeyBzaWduYWxpbmc6IFt0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaWduYWxpbmddLCBwZWVyT3B0czogeyBpY2VTZXJ2ZXJzOiBbeyB1cmxzOiAnc3R1bjpmcmVldHVybi5uZXQ6NTM0OScgfSwgeyB1cmxzOiAndHVybnM6ZnJlZXR1cm4ubmV0OjUzNDknLCB1c2VybmFtZTogJ2ZyZWUnLCBjcmVkZW50aWFsOiAnZnJlZScgfSwgeyB1cmxzOiAnc3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMicgfSwgeyB1cmxzOiAnc3R1bjpnbG9iYWwuc3R1bi50d2lsaW8uY29tOjM0Nzg/dHJhbnNwb3J0PXVkcCcgfV0gfSB9KVxuICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyID0gd2ViUlRDUHJvdmlkZXJcbiAgICBpZiAoaW5pdCkge1xuICAgICAgaW5pdCh3ZWJSVENQcm92aWRlcilcbiAgICB9XG4gICAgcmV0dXJuIHdlYlJUQ1Byb3ZpZGVyXG4gIH1cblxuICBzdG9wV2ViUlRDU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX3dlYlJUQ1Byb3ZpZGVyKSByZXR1cm5cbiAgICB0aGlzLnBsdWdpbi5sb2coYFdlYlJUQyBmb3IgJHt0aGlzLnBhdGh9OiBzdG9wYClcbiAgICB0aGlzLl93ZWJSVENQcm92aWRlcj8uYXdhcmVuZXNzLmRlc3Ryb3koKVxuICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyPy5kaXNjb25uZWN0KClcbiAgICB0aGlzLl93ZWJSVENQcm92aWRlcj8uZGVzdHJveSgpXG4gICAgdGhpcy5fd2ViUlRDUHJvdmlkZXIgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGFzeW5jIHN0b3BJbmRleGVkREJTeW5jKCkge1xuICAgIGlmICghdGhpcy5faW5kZXhlZERCUHJvdmlkZXIpIHJldHVyblxuICAgIGF3YWl0IHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN0b3BXZWJSVENTeW5jKClcbiAgfVxuXG59IiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEhlbHBlcnMgdG8gd29yayB3aXRoIEluZGV4ZWREQi5cbiAqXG4gKiBAbW9kdWxlIGluZGV4ZWRkYlxuICovXG5cbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnLi9wcm9taXNlLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnLi9lcnJvci5qcydcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8qKlxuICogSURCIFJlcXVlc3QgdG8gUHJvbWlzZSB0cmFuc2Zvcm1lclxuICpcbiAqIEBwYXJhbSB7SURCUmVxdWVzdH0gcmVxdWVzdFxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgcnRvcCA9IHJlcXVlc3QgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAvLyBAdHMtaWdub3JlXG4gIHJlcXVlc3Qub25lcnJvciA9IGV2ZW50ID0+IHJlamVjdChuZXcgRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKSlcbiAgLy8gQHRzLWlnbm9yZVxuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdClcbn0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSURCRGF0YWJhc2UpOmFueX0gaW5pdERCIENhbGxlZCB3aGVuIHRoZSBkYXRhYmFzZSBpcyBmaXJzdCBjcmVhdGVkXG4gKiBAcmV0dXJuIHtQcm9taXNlPElEQkRhdGFiYXNlPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG9wZW5EQiA9IChuYW1lLCBpbml0REIpID0+IHByb21pc2UuY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKG5hbWUpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZXZlbnQgPT4gaW5pdERCKGV2ZW50LnRhcmdldC5yZXN1bHQpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25lcnJvciA9IGV2ZW50ID0+IHJlamVjdChlcnJvci5jcmVhdGUoZXZlbnQudGFyZ2V0LmVycm9yKSlcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEQkRhdGFiYXNlfVxuICAgICAqL1xuICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdFxuICAgIGRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHsgZGIuY2xvc2UoKSB9XG4gICAgcmVzb2x2ZShkYilcbiAgfVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgY29uc3QgZGVsZXRlREIgPSBuYW1lID0+IHJ0b3AoaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKG5hbWUpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCRGF0YWJhc2V9IGRiXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PHN0cmluZz58QXJyYXk8c3RyaW5nfElEQk9iamVjdFN0b3JlUGFyYW1ldGVyc3x1bmRlZmluZWQ+Pn0gZGVmaW5pdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3JlcyA9IChkYiwgZGVmaW5pdGlvbnMpID0+IGRlZmluaXRpb25zLmZvckVhY2goZCA9PlxuICAvLyBAdHMtaWdub3JlXG4gIGRiLmNyZWF0ZU9iamVjdFN0b3JlLmFwcGx5KGRiLCBkKVxuKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCRGF0YWJhc2V9IGRiXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHN0b3Jlc1xuICogQHBhcmFtIHtcInJlYWR3cml0ZVwifFwicmVhZG9ubHlcIn0gW2FjY2Vzc11cbiAqIEByZXR1cm4ge0FycmF5PElEQk9iamVjdFN0b3JlPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRyYW5zYWN0ID0gKGRiLCBzdG9yZXMsIGFjY2VzcyA9ICdyZWFkd3JpdGUnKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oc3RvcmVzLCBhY2Nlc3MpXG4gIHJldHVybiBzdG9yZXMubWFwKHN0b3JlID0+IGdldFN0b3JlKHRyYW5zYWN0aW9uLCBzdG9yZSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvdW50ID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgcnRvcChzdG9yZS5jb3VudChyYW5nZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55PiB9IGtleVxuICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldCA9IChzdG9yZSwga2V5KSA9PlxuICBydG9wKHN0b3JlLmdldChrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IElEQktleVJhbmdlIHwgQXJyYXk8YW55PiB9IGtleVxuICovXG5leHBvcnQgY29uc3QgZGVsID0gKHN0b3JlLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUuZGVsZXRlKGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYm9vbGVhbn0gaXRlbVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+fSBba2V5XVxuICovXG5leHBvcnQgY29uc3QgcHV0ID0gKHN0b3JlLCBpdGVtLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUucHV0KGl0ZW0sIGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYm9vbGVhbn0gIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pn0gIGtleVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgYWRkID0gKHN0b3JlLCBpdGVtLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUuYWRkKGl0ZW0sIGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSAgaXRlbVxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fSBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQga2V5XG4gKi9cbmV4cG9ydCBjb25zdCBhZGRBdXRvS2V5ID0gKHN0b3JlLCBpdGVtKSA9PlxuICBydG9wKHN0b3JlLmFkZChpdGVtKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF1cbiAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8YW55Pj59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBbGwgPSAoc3RvcmUsIHJhbmdlLCBsaW1pdCkgPT5cbiAgcnRvcChzdG9yZS5nZXRBbGwocmFuZ2UsIGxpbWl0KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF1cbiAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8YW55Pj59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBbGxLZXlzID0gKHN0b3JlLCByYW5nZSwgbGltaXQpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0QWxsS2V5cyhyYW5nZSwgbGltaXQpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IHF1ZXJ5XG4gKiBAcGFyYW0geyduZXh0J3wncHJldid8J25leHR1bmlxdWUnfCdwcmV2dW5pcXVlJ30gZGlyZWN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeUZpcnN0ID0gKHN0b3JlLCBxdWVyeSwgZGlyZWN0aW9uKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IGZpcnN0ID0gbnVsbFxuICByZXR1cm4gaXRlcmF0ZUtleXMoc3RvcmUsIHF1ZXJ5LCBrZXkgPT4ge1xuICAgIGZpcnN0ID0ga2V5XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0sIGRpcmVjdGlvbikudGhlbigoKSA9PiBmaXJzdClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZT99IFtyYW5nZV1cbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldExhc3RLZXkgPSAoc3RvcmUsIHJhbmdlID0gbnVsbCkgPT4gcXVlcnlGaXJzdChzdG9yZSwgcmFuZ2UsICdwcmV2JylcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZT99IFtyYW5nZV1cbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpcnN0S2V5ID0gKHN0b3JlLCByYW5nZSA9IG51bGwpID0+IHF1ZXJ5Rmlyc3Qoc3RvcmUsIHJhbmdlLCAnbmV4dCcpXG5cbi8qKlxuICogQHR5cGVkZWYgS2V5VmFsdWVQYWlyXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHthbnl9IGsga2V5XG4gKiBAcHJvcGVydHkge2FueX0gdiBWYWx1ZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEtleVZhbHVlUGFpcj4+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0QWxsS2V5c1ZhbHVlcyA9IChzdG9yZSwgcmFuZ2UsIGxpbWl0KSA9PlxuICAvLyBAdHMtaWdub3JlXG4gIHByb21pc2UuYWxsKFtnZXRBbGxLZXlzKHN0b3JlLCByYW5nZSwgbGltaXQpLCBnZXRBbGwoc3RvcmUsIHJhbmdlLCBsaW1pdCldKS50aGVuKChba3MsIHZzXSkgPT4ga3MubWFwKChrLCBpKSA9PiAoeyBrLCB2OiB2c1tpXSB9KSkpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHJlcXVlc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSURCQ3Vyc29yV2l0aFZhbHVlKTp2b2lkfGJvb2xlYW58UHJvbWlzZTx2b2lkfGJvb2xlYW4+fSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCBpdGVyYXRlT25SZXF1ZXN0ID0gKHJlcXVlc3QsIGYpID0+IHByb21pc2UuY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgcmVxdWVzdC5vbmVycm9yID0gcmVqZWN0XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gYXN5bmMgZXZlbnQgPT4ge1xuICAgIGNvbnN0IGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICBpZiAoY3Vyc29yID09PSBudWxsIHx8IChhd2FpdCBmKGN1cnNvcikpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cbiAgICBjdXJzb3IuY29udGludWUoKVxuICB9XG59KVxuXG4vKipcbiAqIEl0ZXJhdGUgb24ga2V5cyBhbmQgdmFsdWVzXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBrZXlyYW5nZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksYW55KTp2b2lkfGJvb2xlYW58UHJvbWlzZTx2b2lkfGJvb2xlYW4+fSBmIENhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgKHZhbHVlLCBrZXkpXG4gKiBAcGFyYW0geyduZXh0J3wncHJldid8J25leHR1bmlxdWUnfCdwcmV2dW5pcXVlJ30gZGlyZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKHN0b3JlLCBrZXlyYW5nZSwgZiwgZGlyZWN0aW9uID0gJ25leHQnKSA9PlxuICBpdGVyYXRlT25SZXF1ZXN0KHN0b3JlLm9wZW5DdXJzb3Ioa2V5cmFuZ2UsIGRpcmVjdGlvbiksIGN1cnNvciA9PiBmKGN1cnNvci52YWx1ZSwgY3Vyc29yLmtleSkpXG5cbi8qKlxuICogSXRlcmF0ZSBvbiB0aGUga2V5cyAobm8gdmFsdWVzKVxuICpcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IGtleXJhbmdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSk6dm9pZHxib29sZWFufFByb21pc2U8dm9pZHxib29sZWFuPn0gZiBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBrZXlcbiAqIEBwYXJhbSB7J25leHQnfCdwcmV2J3wnbmV4dHVuaXF1ZSd8J3ByZXZ1bmlxdWUnfSBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGVLZXlzID0gKHN0b3JlLCBrZXlyYW5nZSwgZiwgZGlyZWN0aW9uID0gJ25leHQnKSA9PlxuICBpdGVyYXRlT25SZXF1ZXN0KHN0b3JlLm9wZW5LZXlDdXJzb3Ioa2V5cmFuZ2UsIGRpcmVjdGlvbiksIGN1cnNvciA9PiBmKGN1cnNvci5rZXkpKVxuXG4vKipcbiAqIE9wZW4gc3RvcmUgZnJvbSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJREJUcmFuc2FjdGlvbn0gdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0b3JlXG4gKiBAcmV0dXJucyB7SURCT2JqZWN0U3RvcmV9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRTdG9yZSA9ICh0LCBzdG9yZSkgPT4gdC5vYmplY3RTdG9yZShzdG9yZSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG93ZXJcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBwZXJPcGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZUJvdW5kID0gKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pID0+IElEQktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW4pXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHVwcGVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVwcGVyT3BlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VVcHBlckJvdW5kID0gKHVwcGVyLCB1cHBlck9wZW4pID0+IElEQktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsIHVwcGVyT3BlbilcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG93ZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG93ZXJPcGVuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQgPSAobG93ZXIsIGxvd2VyT3BlbikgPT4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgbG93ZXJPcGVuKVxuXG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuIiwgImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0ICogYXMgaWRiIGZyb20gJ2xpYjAvaW5kZXhlZGRiJ1xuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICdsaWIwL3Byb21pc2UnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuXG5jb25zdCBjdXN0b21TdG9yZU5hbWUgPSAnY3VzdG9tJ1xuY29uc3QgdXBkYXRlc1N0b3JlTmFtZSA9ICd1cGRhdGVzJ1xuXG5leHBvcnQgY29uc3QgUFJFRkVSUkVEX1RSSU1fU0laRSA9IDUwMFxuXG4vKipcbiAqIEBwYXJhbSB7SW5kZXhlZGRiUGVyc2lzdGVuY2V9IGlkYlBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQk9iamVjdFN0b3JlKTp2b2lkfSBbYmVmb3JlQXBwbHlVcGRhdGVzQ2FsbGJhY2tdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQk9iamVjdFN0b3JlKTp2b2lkfSBbYWZ0ZXJBcHBseVVwZGF0ZXNDYWxsYmFja11cbiAqL1xuZXhwb3J0IGNvbnN0IGZldGNoVXBkYXRlcyA9IChpZGJQZXJzaXN0ZW5jZSwgYmVmb3JlQXBwbHlVcGRhdGVzQ2FsbGJhY2sgPSAoKSA9PiB7fSwgYWZ0ZXJBcHBseVVwZGF0ZXNDYWxsYmFjayA9ICgpID0+IHt9KSA9PiB7XG4gIGNvbnN0IFt1cGRhdGVzU3RvcmVdID0gaWRiLnRyYW5zYWN0KC8qKiBAdHlwZSB7SURCRGF0YWJhc2V9ICovIChpZGJQZXJzaXN0ZW5jZS5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSkgLy8gLCAncmVhZG9ubHknKVxuICByZXR1cm4gaWRiLmdldEFsbCh1cGRhdGVzU3RvcmUsIGlkYi5jcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQoaWRiUGVyc2lzdGVuY2UuX2RicmVmLCBmYWxzZSkpLnRoZW4odXBkYXRlcyA9PiB7XG4gICAgaWYgKCFpZGJQZXJzaXN0ZW5jZS5fZGVzdHJveWVkKSB7XG4gICAgICBiZWZvcmVBcHBseVVwZGF0ZXNDYWxsYmFjayh1cGRhdGVzU3RvcmUpXG4gICAgICBZLnRyYW5zYWN0KGlkYlBlcnNpc3RlbmNlLmRvYywgKCkgPT4ge1xuICAgICAgICB1cGRhdGVzLmZvckVhY2godmFsID0+IFkuYXBwbHlVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jLCB2YWwpKVxuICAgICAgfSwgaWRiUGVyc2lzdGVuY2UsIGZhbHNlKVxuICAgICAgYWZ0ZXJBcHBseVVwZGF0ZXNDYWxsYmFjayh1cGRhdGVzU3RvcmUpXG4gICAgfVxuICB9KVxuICAgIC50aGVuKCgpID0+IGlkYi5nZXRMYXN0S2V5KHVwZGF0ZXNTdG9yZSkudGhlbihsYXN0S2V5ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2RicmVmID0gbGFzdEtleSArIDEgfSkpXG4gICAgLnRoZW4oKCkgPT4gaWRiLmNvdW50KHVwZGF0ZXNTdG9yZSkudGhlbihjbnQgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID0gY250IH0pKVxuICAgIC50aGVuKCgpID0+IHVwZGF0ZXNTdG9yZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luZGV4ZWRkYlBlcnNpc3RlbmNlfSBpZGJQZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZVN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCBzdG9yZVN0YXRlID0gKGlkYlBlcnNpc3RlbmNlLCBmb3JjZVN0b3JlID0gdHJ1ZSkgPT5cbiAgZmV0Y2hVcGRhdGVzKGlkYlBlcnNpc3RlbmNlKVxuICAgIC50aGVuKHVwZGF0ZXNTdG9yZSA9PiB7XG4gICAgICBpZiAoZm9yY2VTdG9yZSB8fCBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID49IFBSRUZFUlJFRF9UUklNX1NJWkUpIHtcbiAgICAgICAgaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuZGVsKHVwZGF0ZXNTdG9yZSwgaWRiLmNyZWF0ZUlEQktleVJhbmdlVXBwZXJCb3VuZChpZGJQZXJzaXN0ZW5jZS5fZGJyZWYsIHRydWUpKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuY291bnQodXBkYXRlc1N0b3JlKS50aGVuKGNudCA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnNpemUgPSBjbnQgfSkpXG4gICAgICB9XG4gICAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgY29uc3QgY2xlYXJEb2N1bWVudCA9IG5hbWUgPT4gaWRiLmRlbGV0ZURCKG5hbWUpXG5cbi8qKlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkZGJQZXJzaXN0ZW5jZSBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuX2RicmVmID0gMFxuICAgIHRoaXMuX2Ric2l6ZSA9IDBcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJREJEYXRhYmFzZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGIgPSBudWxsXG4gICAgdGhpcy5zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMuX2RiID0gaWRiLm9wZW5EQihuYW1lLCBkYiA9PlxuICAgICAgaWRiLmNyZWF0ZVN0b3JlcyhkYiwgW1xuICAgICAgICBbJ3VwZGF0ZXMnLCB7IGF1dG9JbmNyZW1lbnQ6IHRydWUgfV0sXG4gICAgICAgIFsnY3VzdG9tJ11cbiAgICAgIF0pXG4gICAgKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPEluZGV4ZWRkYlBlcnNpc3RlbmNlPn1cbiAgICAgKi9cbiAgICB0aGlzLndoZW5TeW5jZWQgPSBwcm9taXNlLmNyZWF0ZShyZXNvbHZlID0+IHRoaXMub24oJ3N5bmNlZCcsICgpID0+IHJlc29sdmUodGhpcykpKVxuXG4gICAgdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICB0aGlzLmRiID0gZGJcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gdXBkYXRlc1N0b3JlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGJlZm9yZUFwcGx5VXBkYXRlc0NhbGxiYWNrID0gKHVwZGF0ZXNTdG9yZSkgPT4gaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKSlcbiAgICAgIGNvbnN0IGFmdGVyQXBwbHlVcGRhdGVzQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVybiB0aGlzXG4gICAgICAgIHRoaXMuc3luY2VkID0gdHJ1ZVxuICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIFt0aGlzXSlcbiAgICAgIH1cbiAgICAgIGZldGNoVXBkYXRlcyh0aGlzLCBiZWZvcmVBcHBseVVwZGF0ZXNDYWxsYmFjaywgYWZ0ZXJBcHBseVVwZGF0ZXNDYWxsYmFjaylcbiAgICB9KVxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgaW4gbXMgdW50aWxsIGRhdGEgaXMgbWVyZ2VkIGFuZCBwZXJzaXN0ZWQgaW4gaWRiLlxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlVGltZW91dCA9IDEwMDBcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gICAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX3N0b3JlVXBkYXRlID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgICBpZiAodGhpcy5kYiAmJiBvcmlnaW4gIT09IHRoaXMpIHtcbiAgICAgICAgY29uc3QgW3VwZGF0ZXNTdG9yZV0gPSBpZGIudHJhbnNhY3QoLyoqIEB0eXBlIHtJREJEYXRhYmFzZX0gKi8gKHRoaXMuZGIpLCBbdXBkYXRlc1N0b3JlTmFtZV0pXG4gICAgICAgIGlkYi5hZGRBdXRvS2V5KHVwZGF0ZXNTdG9yZSwgdXBkYXRlKVxuICAgICAgICBpZiAoKyt0aGlzLl9kYnNpemUgPj0gUFJFRkVSUkVEX1RSSU1fU0laRSkge1xuICAgICAgICAgIC8vIGRlYm91bmNlIHN0b3JlIGNhbGxcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcmVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9yZVRpbWVvdXRJZClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc3RvcmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHN0b3JlU3RhdGUodGhpcywgZmFsc2UpXG4gICAgICAgICAgICB0aGlzLl9zdG9yZVRpbWVvdXRJZCA9IG51bGxcbiAgICAgICAgICB9LCB0aGlzLl9zdG9yZVRpbWVvdXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZG9jLm9uKCd1cGRhdGUnLCB0aGlzLl9zdG9yZVVwZGF0ZSlcbiAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLmRlc3Ryb3kuYmluZCh0aGlzKVxuICAgIGRvYy5vbignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLl9zdG9yZVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0b3JlVGltZW91dElkKVxuICAgIH1cbiAgICB0aGlzLmRvYy5vZmYoJ3VwZGF0ZScsIHRoaXMuX3N0b3JlVXBkYXRlKVxuICAgIHRoaXMuZG9jLm9mZignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgZGIuY2xvc2UoKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhpcyBpbnN0YW5jZSBhbmQgcmVtb3ZlcyBhbGwgZGF0YSBmcm9tIGluZGV4ZWRkYi5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGNsZWFyRGF0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWRiLmRlbGV0ZURCKHRoaXMubmFtZSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSBrZXlcbiAgICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBhbnk+fVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBjb25zdCBbY3VzdG9tXSA9IGlkYi50cmFuc2FjdChkYiwgW2N1c3RvbVN0b3JlTmFtZV0sICdyZWFkb25seScpXG4gICAgICByZXR1cm4gaWRiLmdldChjdXN0b20sIGtleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGV9IHZhbHVlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlPn1cbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGNvbnN0IFtjdXN0b21dID0gaWRiLnRyYW5zYWN0KGRiLCBbY3VzdG9tU3RvcmVOYW1lXSlcbiAgICAgIHJldHVybiBpZGIucHV0KGN1c3RvbSwgdmFsdWUsIGtleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSBrZXlcbiAgICogQHJldHVybiB7UHJvbWlzZTx1bmRlZmluZWQ+fVxuICAgKi9cbiAgZGVsIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBjb25zdCBbY3VzdG9tXSA9IGlkYi50cmFuc2FjdChkYiwgW2N1c3RvbVN0b3JlTmFtZV0pXG4gICAgICByZXR1cm4gaWRiLmRlbChjdXN0b20sIGtleSlcbiAgICB9KVxuICB9XG59XG4iLCAiaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwic3JjL3BlZXJkcmFmdFBsdWdpblwiXG5cbmV4cG9ydCBjb25zdCBhZGRJc1NoYXJlZENsYXNzID0gKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgY29uc3QgZmlsZUV4cGxvcmVycyA9IHBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZSgnZmlsZS1leHBsb3JlcicpXG4gIGZpbGVFeHBsb3JlcnMuZm9yRWFjaChmaWxlRXhwbG9yZXIgPT4ge1xuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IGZpbGVJdGVtID0gZmlsZUV4cGxvcmVyLnZpZXcuZmlsZUl0ZW1zW3BhdGhdO1xuICAgIGlmICghZmlsZUl0ZW0pIHJldHVyblxuICAgIGNvbnN0IGVsID0gZmlsZUl0ZW0uaW5uZXJFbCBhcyBIVE1MRWxlbWVudFxuICAgIGVsLmFkZENsYXNzKCdwZC1leHBsb3Jlci1zaGFyZWQnKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlSXNTaGFyZWRDbGFzcyA9IChwYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IGZpbGVFeHBsb3JlcnMgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ2ZpbGUtZXhwbG9yZXInKVxuICBmaWxlRXhwbG9yZXJzLmZvckVhY2goZmlsZUV4cGxvcmVyID0+IHtcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBmaWxlSXRlbSA9IGZpbGVFeHBsb3Jlci52aWV3LmZpbGVJdGVtc1twYXRoXTtcbiAgICBpZiAoIWZpbGVJdGVtKSByZXR1cm5cbiAgICBjb25zdCBlbCA9IGZpbGVJdGVtLmlubmVyRWwgYXMgSFRNTEVsZW1lbnRcbiAgICBlbC5yZW1vdmVDbGFzcygncGQtZXhwbG9yZXItc2hhcmVkJylcbiAgfSlcbn0iLCAiaW1wb3J0IHsgVEFic3RyYWN0RmlsZSwgVEZpbGUsIFRGb2xkZXIsIG5vcm1hbGl6ZVBhdGggfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCIuLi91aVwiO1xuaW1wb3J0IHsgY2FsY3VsYXRlSGFzaCwgZ2VuZXJhdGVSYW5kb21TdHJpbmcsIHNlcmlhbGl6ZSB9IGZyb20gXCIuLi90b29sc1wiO1xuaW1wb3J0IHsgU2hhcmVkRW50aXR5IH0gZnJvbSBcIi4vc2hhcmVkRW50aXR5XCI7XG5pbXBvcnQgUGVlckRyYWZ0UGx1Z2luIGZyb20gXCJzcmMvbWFpblwiO1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWREb2N1bWVudFwiO1xuaW1wb3J0IHsgUGVybWFuZW50U2hhcmVGb2xkZXIgfSBmcm9tIFwic3JjL3Blcm1hbmVudFNoYXJlU3RvcmVcIjtcbmltcG9ydCB7IEluZGV4ZWRkYlBlcnNpc3RlbmNlIH0gZnJvbSBcInktaW5kZXhlZGRiXCI7XG5pbXBvcnQgeyBhZGRJc1NoYXJlZENsYXNzLCByZW1vdmVJc1NoYXJlZENsYXNzIH0gZnJvbSBcInNyYy93b3Jrc3BhY2UvZXhwbG9yZXJWaWV3XCI7XG5pbXBvcnQgeyBhZGQsIGdldEZvbGRlckJ5UGF0aCwgbW92ZUZvbGRlciwgcmVtb3ZlRm9sZGVyIH0gZnJvbSBcInNyYy9wZXJtYW5lbnRTaGFyZVN0b3JlRlNcIjtcbmltcG9ydCB7IG9wZW5Gb2xkZXJPcHRpb25zIH0gZnJvbSBcInNyYy91aS9mb2xkZXJPcHRpb25zXCI7XG5pbXBvcnQgeyBvcGVuTG9naW5Nb2RhbCB9IGZyb20gXCJzcmMvdWkvbG9naW5cIjtcblxuY29uc3QgaGFuZGxlVXBkYXRlID0gKGV2OiBZLllNYXBFdmVudDx1bmtub3duPiwgdHg6IFkuVHJhbnNhY3Rpb24sIGZvbGRlcjogU2hhcmVkRm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikgPT4ge1xuXG4gIGlmICghKFtwbHVnaW4uc2VydmVyU3luYywgZm9sZGVyLndlYlJUQ1Byb3ZpZGVyPy5yb29tXS5pbmNsdWRlcyh0eC5vcmlnaW4pKSkgcmV0dXJuXG5cbiAgY29uc3QgY2hhbmdlZEtleXMgPSBldi5jaGFuZ2VzLmtleXNcblxuICBjaGFuZ2VkS2V5cy5mb3JFYWNoKGFzeW5jIChkYXRhLCBrZXkpID0+IHtcbiAgICBwbHVnaW4ubG9nKFwiQWN0aW9uOiBcIiArIGRhdGEuYWN0aW9uICsgXCJmb3IgXCIgKyBrZXkgKyBcIiAtLT4gXCIgKyB0eC5kb2MuZ2V0TWFwKFwiZG9jdW1lbnRzXCIpLmdldChrZXkpIGFzIHN0cmluZylcblxuICAgIGlmIChkYXRhLmFjdGlvbiA9PT0gXCJhZGRcIikge1xuICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gdHguZG9jLmdldE1hcChcImRvY3VtZW50c1wiKS5nZXQoa2V5KSBhcyBzdHJpbmdcbiAgICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGguam9pbihmb2xkZXIucGF0aCwgcmVsYXRpdmVQYXRoKVxuICAgICAgY29uc3QgZmlsZSA9IHBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGFic29sdXRlUGF0aClcbiAgICAgIGlmIChmaWxlKSB7XG5cbiAgICAgICAgLy8gc2FmZXR5IGNoZWNrIGlmIGZzIGFscmVhZHkgaW4gc3luY1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoa2V5KVxuICAgICAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdEb2MuZmlsZS5wYXRoID09PSBmaWxlLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICBwbHVnaW4ubG9nKFwiUmVjZWl2ZWQgdXBkYXRlLCBidXQgRlMgaXMgYWxyZWFkeSBpbiBjb3JyZWN0IHN0YXRlXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgb2NjdXIgOi0oXG4gICAgICAgICAgICBzaG93Tm90aWNlKFwiVGhlcmUgaXMgc29tZXRoaW5nIHdyb25nIHdpdGggeW91ciBzeW5jZWQgZmlsZSBcIiArIGZpbGUucGF0aCArIFwiLiBDb25zaWRlciByZS1jcmVhdGluZyB0aGUgc3luY2VkIGZvbGRlciBmcm9tIHNlcnZlci5cIilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvd05vdGljZShcIkZpbGUgXCIgKyBmaWxlLnBhdGggKyBcIiBhbHJlYWR5IGV4aXN0cy4gUmVuYW1pbmcgbG9jYWwgZmlsZS5cIilcblxuICAgICAgICAgIGNvbnN0IGFsdGVyZWRQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShyZWxhdGl2ZVBhdGgpLCBwYXRoLmJhc2VuYW1lKHJlbGF0aXZlUGF0aCwgcGF0aC5leHRuYW1lKHJlbGF0aXZlUGF0aCkpICsgXCJfXCIgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpICsgcGF0aC5leHRuYW1lKHJlbGF0aXZlUGF0aCkpXG4gICAgICAgICAgY29uc3QgYWx0ZXJlZEFic29sdXRlUGF0aCA9IHBhdGguam9pbihmb2xkZXIucm9vdC5wYXRoLCBhbHRlcmVkUGF0aClcbiAgICAgICAgICBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoZmlsZSwgYWx0ZXJlZEFic29sdXRlUGF0aClcbiAgICAgICAgICBTaGFyZWREb2N1bWVudC5mcm9tSWRBbmRQYXRoKGtleSwgYWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJDcmVhdGluZyBuZXcgc2hhcmVkIGRvY3VtZW50OiBcIiArIGFic29sdXRlUGF0aClcbiAgICAgICAgYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLnBhcnNlKGFic29sdXRlUGF0aCkuZGlyLCBwbHVnaW4pXG4gICAgICAgIGF3YWl0IFNoYXJlZERvY3VtZW50LmZyb21JZEFuZFBhdGgoa2V5LCBhYnNvbHV0ZVBhdGgsIHBsdWdpbilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uID09PSBcInVwZGF0ZVwiKSB7XG4gICAgICBjb25zdCBuZXdQYXRoID0gdHguZG9jLmdldE1hcChcImRvY3VtZW50c1wiKS5nZXQoa2V5KSBhcyBzdHJpbmdcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoa2V5KVxuICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICBzaG93Tm90aWNlKFwiRG9jdW1lbnQgYXQgXCIgKyBuZXdQYXRoICsgXCIgZG9lc24ndCBleGlzdCBpbiB5b3VyIHZhdWx0LiBDb25zaWRlciByZS1jcmVhdGluZyB0aGUgc3luY2VkIGZvbGRlciBmcm9tIHNlcnZlci5cIilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBwbHVnaW4ubG9nKFwiVXBkYXRlIFwiICsgZG9jdW1lbnQucGF0aCArIFwiICAgXCIgKyBrZXkpXG4gICAgICBjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChkb2N1bWVudC5wYXRoKVxuICAgICAgaWYgKCFmb2xkZXIpIHJldHVyblxuICAgICAgbGV0IG5ld0Fic29sdXRlUGF0aCA9IHBhdGguam9pbihmb2xkZXIucm9vdC5wYXRoLCBuZXdQYXRoKVxuICAgICAgYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLnBhcnNlKG5ld0Fic29sdXRlUGF0aCkuZGlyLCBwbHVnaW4pXG5cbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG5ld0Fic29sdXRlUGF0aClcbiAgICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGluIHN5bmMgYWxyZWFkeVxuICAgICAgICBpZiAoYWxyZWFkeUV4aXN0cy5zaGFyZUlkID09PSBrZXkpIHtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgIHBsdWdpbi5sb2coXCJSZWNlaXZlZCB1cGRhdGUsIGJ1dCBGUyBpcyBhbHJlYWR5IGluIGNvcnJlY3Qgc3RhdGUuXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvd05vdGljZShcIkZpbGUgXCIgKyBuZXdQYXRoICsgXCIgYWxyZWFkeSBleGlzdHMuIFJlbmFtaW5nIGxvY2FsIGZpbGUuXCIpXG4gICAgICAgICAgY29uc3QgYWx0ZXJlZFBhdGggPSBwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKG5ld1BhdGgpLCBwYXRoLmJhc2VuYW1lKG5ld1BhdGgsIHBhdGguZXh0bmFtZShuZXdQYXRoKSkgKyBcIl9cIiArIGdlbmVyYXRlUmFuZG9tU3RyaW5nKCkgKyBwYXRoLmV4dG5hbWUobmV3UGF0aCkpXG4gICAgICAgICAgY29uc3QgYWx0ZXJlZEFic29sdXRlUGF0aCA9IHBhdGguam9pbihmb2xkZXIucm9vdC5wYXRoLCBhbHRlcmVkUGF0aClcbiAgICAgICAgICBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoYWxyZWFkeUV4aXN0cy5maWxlLCBhbHRlcmVkQWJzb2x1dGVQYXRoKVxuICAgICAgICAgIFNoYXJlZERvY3VtZW50LmZyb21JZEFuZFBhdGgoa2V5LCBhbHRlcmVkQWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IHBsdWdpbi5hcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShkb2N1bWVudC5maWxlLCBuZXdBYnNvbHV0ZVBhdGgpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gXCJkZWxldGVcIikge1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChrZXkpXG4gICAgICBpZiAoIWRvY3VtZW50KSByZXR1cm5cbiAgICAgIHBsdWdpbi5sb2coXCJEZWxldGUgXCIgKyBkb2N1bWVudC5wYXRoICsgXCIgICBcIiArIGtleSlcbiAgICAgIGNvbnN0IGZpbGUgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkb2N1bWVudC5wYXRoKVxuICAgICAgaWYgKCFmaWxlKSByZXR1cm5cbiAgICAgIHBsdWdpbi5hcHAudmF1bHQuZGVsZXRlKGZpbGUpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY2xhc3MgU2hhcmVkRm9sZGVyIGV4dGVuZHMgU2hhcmVkRW50aXR5IHtcblxuICByb290OiBURm9sZGVyXG4gIHByb3RlY3RlZCBzdGF0aWMgX3NoYXJlZEVudGl0ZXM6IEFycmF5PFNoYXJlZEZvbGRlcj4gPSBuZXcgQXJyYXk8U2hhcmVkRm9sZGVyPigpXG5cbiAgc3RhdGljIGFzeW5jIGZyb21URm9sZGVyKHJvb3Q6IFRGb2xkZXIsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgc2hvd05vdGljZShgSW5pdGl0aWFsaXppbmcgc2hhcmUgZm9yICR7cm9vdC5wYXRofS5gKVxuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5nZXRBbGxGaWxlc0luRm9sZGVyKHJvb3QpXG5cbiAgICAvLyBjaGVjayBpZiBkb2NzIGZvciBzb21lIG9mIHRoZW0gYXJlIGFscmVhZHkgdGhlcmVcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGlmIChTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aCkpIHtcbiAgICAgICAgc2hvd05vdGljZShcIllvdSBjYW4gbm90IHNoYXJlIGEgZGlyZWN0b3J5IHRoYXQgYWxyZWFkeSBoYXMgc2hhcmVkIGZpbGVzIGluIGl0IChyaWdodCBub3cpLlwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZighcGx1Z2luLnNlcnZlclN5bmMuYXV0aGVudGljYXRlZCkge1xuICAgICAgc2hvd05vdGljZShcIlBsZWFzZSBsb2cgaW4gdG8gUGVlcmRyYWZ0IGZpcnN0LlwiKVxuICAgICAgY29uc3QgYXV0aCA9IGF3YWl0IG9wZW5Mb2dpbk1vZGFsKHBsdWdpbilcbiAgICAgIGlmICghYXV0aCkgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZG9jcyA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVzLm1hcCgoZmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIFNoYXJlZERvY3VtZW50LmZyb21URmlsZShmaWxlLCB7XG4gICAgICAgIHBlcm1hbmVudDogdHJ1ZVxuICAgICAgfSwgcGx1Z2luKVxuICAgIH0pKVxuXG4gICAgY29uc3QgZm9sZGVyID0gbmV3IFNoYXJlZEZvbGRlcihyb290LCBwbHVnaW4pXG5cbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGZvbGRlci5hZGREb2N1bWVudChkb2MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9sZGVyLnlEb2MuZ2V0VGV4dChcIm9yaWdpbmFsRm9sZGVybmFtZVwiKS5pbnNlcnQoMCwgcm9vdC5uYW1lKVxuXG4gICAgYXdhaXQgZm9sZGVyLmluaXRTZXJ2ZXJZRG9jKClcblxuICAgIGF3YWl0IGFkZChmb2xkZXIsIHBsdWdpbilcbiAgICBhd2FpdCBmb2xkZXIuc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICBmb2xkZXIuc3RhcnRXZWJSVENTeW5jKClcblxuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCArICcvdGVhbS8nICsgZm9sZGVyLnNoYXJlSWQpXG4gICAgc2hvd05vdGljZShgRm9sZGVyICR7Zm9sZGVyLnBhdGh9IHdpdGggJHtkb2NzLmxlbmd0aH0gZG9jdW1lbnRzIHNoYXJlZC4gVVJMIGNvcGllZCB0byB5b3VyIGNsaXBib2FyZC5gLCAwKVxuICAgIG9wZW5Gb2xkZXJPcHRpb25zKHBsdWdpbi5hcHAsIGZvbGRlcilcbiAgICByZXR1cm4gZm9sZGVyXG4gIH1cblxuICBnZXRTaGFyZVVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi90ZWFtL1wiICsgdGhpcy5zaGFyZUlkXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgcmVjcmVhdGUoZm9sZGVyOiBTaGFyZWRGb2xkZXIsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBmb2xkZXIucm9vdC5wYXRoXG4gICAgYXdhaXQgZm9sZGVyLnVuc2hhcmUoKVxuICAgIGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuZGVsZXRlKGZvbGRlci5yb290LCB0cnVlKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZyb21TaGFyZVVSTChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyAnL3RlYW0vJyArIGZvbGRlci5zaGFyZUlkLCBwbHVnaW4sIGxvY2F0aW9uKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21TaGFyZVVSTCh1cmw6IHN0cmluZywgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4sIGxvY2F0aW9uPzogc3RyaW5nKTogUHJvbWlzZTxTaGFyZWRGb2xkZXIgfCB2b2lkPiB7XG4gICAgY29uc3QgaWQgPSB1cmwuc3BsaXQoJy8nKS5wb3AoKVxuICAgIGlmICghaWQgfHwgIWlkLm1hdGNoKCdeWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17NH0tWzAtOWEtZl17MTJ9JCcpKSB7XG4gICAgICBzaG93Tm90aWNlKFwiTm8gdmFsaWQgcGVlcmRyYWZ0IGxpbmtcIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBmb2xkZXJQYXRoID0gbG9jYXRpb25cbiAgICBjb25zdCBwcmVGZXRjaGVkRG9jID0gYXdhaXQgcGx1Z2luLnNlcnZlclN5bmMucmVxdWVzdERvY3VtZW50KGlkKVxuXG5cbiAgICBpZiAoIWZvbGRlclBhdGgpIHtcbiAgICAgIGxldCBpbml0aWFsUm9vdE5hbWUgPSBgX3BlZXJkcmFmdF90ZWFtX2ZvbGRlcl8ke2dlbmVyYXRlUmFuZG9tU3RyaW5nKCl9YFxuICAgICAgY29uc3QgZG9jRm9sZGVybmFtZSA9IHByZUZldGNoZWREb2MuZ2V0VGV4dChcIm9yaWdpbmFsRm9sZGVybmFtZVwiKS50b1N0cmluZygpXG4gICAgICBpZiAoZG9jRm9sZGVybmFtZSAhPSAnJykge1xuICAgICAgICBjb25zdCBmb2xkZXJFeGlzdHMgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoLmpvaW4ocGx1Z2luLnNldHRpbmdzLnJvb3QsIGRvY0ZvbGRlcm5hbWUpKVxuICAgICAgICBpZiAoIWZvbGRlckV4aXN0cykge1xuICAgICAgICAgIGluaXRpYWxSb290TmFtZSA9IGRvY0ZvbGRlcm5hbWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0aWFsUm9vdE5hbWUgPSBgX3BlZXJkcmFmdF8ke2dlbmVyYXRlUmFuZG9tU3RyaW5nKCl9XyR7ZG9jRm9sZGVybmFtZX1gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9sZGVyUGF0aCA9IHBhdGguam9pbihwbHVnaW4uc2V0dGluZ3Mucm9vdCwgaW5pdGlhbFJvb3ROYW1lKVxuICAgIH1cblxuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgoZm9sZGVyUGF0aCEsIHBsdWdpbilcblxuICAgIGlmICghZm9sZGVyKSB7XG4gICAgICBzaG93Tm90aWNlKFwiQ291bGQgbm90IGNyZWF0ZSBmb2xkZXIgXCIgKyBmb2xkZXJQYXRoKVxuICAgICAgcmV0dXJuXG4gICAgfTtcblxuICAgIGNvbnN0IHBhdGhzOiBBcnJheTxzdHJpbmc+ID0gW11cbiAgICBjb25zdCBkb2N1bWVudE1hcCA9IHByZUZldGNoZWREb2MuZ2V0TWFwKFwiZG9jdW1lbnRzXCIpIGFzIFkuTWFwPHN0cmluZz5cblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZG9jdW1lbnRNYXAuZW50cmllcygpKSB7XG4gICAgICBsZXQgZG9jUGF0aCA9IGVudHJ5WzFdXG4gICAgICBjb25zdCBhYnNQYXRoID0gcGF0aC5qb2luKGZvbGRlclBhdGghLCBkb2NQYXRoKVxuICAgICAgLy8gcmVwYWlyIGluY29uc2lzdGVudCBzZXJ2ZXIgdmVyc2lvblxuICAgICAgaWYgKGRvY1BhdGggJiYgcGF0aHMuaW5jbHVkZXMobm9ybWFsaXplUGF0aChkb2NQYXRoKSkpIHtcbiAgICAgICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoZW50cnlbMF0pXG4gICAgICAgIGlmIChleGlzdGluZ0RvYykge1xuICAgICAgICAgIGlmIChleGlzdGluZ0RvYy5wYXRoID09PSBhYnNQYXRoKSB7XG4gICAgICAgICAgICBwbHVnaW4ubG9nKFwiYWxyZWFkeSBzeW5jZWRcIilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGx1Z2luLmFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKGV4aXN0aW5nRG9jLmZpbGUsIGFic1BhdGgpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY1BhdGggPSBub3JtYWxpemVQYXRoKHBhdGguam9pbihwYXRoLmRpcm5hbWUoZG9jUGF0aCksIHBhdGguYmFzZW5hbWUoZG9jUGF0aCwgcGF0aC5leHRuYW1lKGRvY1BhdGgpKSArIFwiX1wiICsgZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSArIHBhdGguZXh0bmFtZShkb2NQYXRoKSkpXG4gICAgICAgICAgZG9jdW1lbnRNYXAuc2V0KGVudHJ5WzBdLCBkb2NQYXRoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tSWRBbmRQYXRoKGVudHJ5WzBdLCBhYnNQYXRoLCBwbHVnaW4pXG4gICAgICBwYXRocy5wdXNoKG5vcm1hbGl6ZVBhdGgoZG9jUGF0aCkpXG4gICAgfVxuXG4gICAgY29uc3Qgc0ZvbGRlciA9IG5ldyBTaGFyZWRGb2xkZXIoZm9sZGVyLCBwbHVnaW4sIHByZUZldGNoZWREb2MpXG4gICAgc0ZvbGRlci5fc2hhcmVJZCA9IGlkXG5cbiAgICBhd2FpdCBhZGQoc0ZvbGRlciwgcGx1Z2luKVxuICAgIGF3YWl0IHNGb2xkZXIuc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICBpZiAoc0ZvbGRlci5pbmRleGVkREJQcm92aWRlcikge1xuICAgICAgaWYgKCFzRm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyLnN5bmNlZCkgYXdhaXQgc0ZvbGRlci5pbmRleGVkREJQcm92aWRlci53aGVuU3luY2VkXG4gICAgICBzRm9sZGVyLnN5bmNXaXRoU2VydmVyKClcbiAgICAgIHNGb2xkZXIuc3RhcnRXZWJSVENTeW5jKClcbiAgICB9XG4gICAgcmV0dXJuIHNGb2xkZXJcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tUGVybWFuZW50U2hhcmVGb2xkZXIocHNmOiBQZXJtYW5lbnRTaGFyZUZvbGRlciwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBpZiAodGhpcy5maW5kQnlQYXRoKHBzZi5wYXRoKSkgcmV0dXJuXG4gICAgbGV0IHRGb2xkZXI6IHZvaWQgfCBudWxsIHwgVEFic3RyYWN0RmlsZVxuICAgIHRGb2xkZXIgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwc2YucGF0aClcbiAgICBpZiAodEZvbGRlciBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICBzaG93Tm90aWNlKFwiRXhwZWN0ZWQgXCIgKyBwc2YucGF0aCArIFwiIHRvIGJlIGEgZm9sZGVyLCBidXQgaXQgaXMgYSBmaWxlP1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghKHRGb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuICAgICAgc2hvd05vdGljZShcIlNoYXJlZCBmb2xkZXIgXCIgKyBwc2YucGF0aCArIFwiIG5vdCBmb3VuZC4gQ3JlYXRpbmcgaXQgbm93LlwiKVxuICAgICAgdEZvbGRlciA9IGF3YWl0IHRoaXMuZ2V0T3JDcmVhdGVQYXRoKHBzZi5wYXRoLCBwbHVnaW4pXG4gICAgfVxuICAgIGlmICghKHRGb2xkZXIgaW5zdGFuY2VvZiBURm9sZGVyKSkge1xuICAgICAgc2hvd05vdGljZShcIkNvdWxkIG5vdCBjcmVhdGUgZm9sZGVyIFwiICsgcHNmLnBhdGggKyBcIi5cIilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZvbGRlciA9IG5ldyBTaGFyZWRGb2xkZXIodEZvbGRlciwgcGx1Z2luKVxuICAgIGZvbGRlci5fc2hhcmVJZCA9IHBzZi5zaGFyZUlkXG4gICAgY29uc3QgbG9jYWwgPSBhd2FpdCBmb2xkZXIuc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICBpZiAobG9jYWwpIHtcbiAgICAgIGlmIChsb2NhbC5zeW5jZWQgfHwgYXdhaXQgbG9jYWwud2hlblN5bmNlZCkge1xuICAgICAgICBmb2xkZXIuc3luY1dpdGhTZXJ2ZXIoKVxuICAgICAgICBmb2xkZXIuc3RhcnRXZWJSVENTeW5jKClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvbGRlclxuICB9XG5cbiAgc3RhdGljIGZpbmRCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN1cGVyLmZpbmRCeVBhdGgocGF0aCkgYXMgU2hhcmVkRm9sZGVyIHwgdW5kZWZpbmVkXG4gIH1cblxuICBzdGF0aWMgZmluZEJ5SWQoaWQ6IHN0cmluZykge1xuICAgIHJldHVybiBzdXBlci5maW5kQnlJZChpZCkgYXMgU2hhcmVkRm9sZGVyIHwgdW5kZWZpbmVkXG4gIH1cblxuXG4gIHN0YXRpYyBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldEFsbCgpIGFzIEFycmF5PFNoYXJlZEZvbGRlcj5cbiAgfVxuXG4gIHN0YXRpYyBnZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGRpcjogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKGRpcilcbiAgICBjb25zdCBmb2xkZXJzID0gdGhpcy5nZXRBbGwoKVxuICAgIGZvciAoY29uc3QgZm9sZGVyIG9mIGZvbGRlcnMpIHtcbiAgICAgIGlmIChmb2xkZXIucm9vdC5wYXRoID09PSBub3JtYWxpemVkUGF0aCkgcmV0dXJuXG4gICAgICBpZiAoZm9sZGVyLmlzUGF0aFN1YlBhdGgobm9ybWFsaXplZFBhdGgpKSByZXR1cm4gZm9sZGVyXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihyb290OiBURm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbiwgeWRvYz86IFkuRG9jKSB7XG4gICAgc3VwZXIocGx1Z2luKVxuICAgIHRoaXMucm9vdCA9IHJvb3RcbiAgICB0aGlzLl9wYXRoID0gcm9vdC5wYXRoXG4gICAgdGhpcy55RG9jID0geWRvYyA/PyBuZXcgWS5Eb2MoKVxuICAgIHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkub2JzZXJ2ZSgoZXYsIHR4KSA9PiB7XG4gICAgICBoYW5kbGVVcGRhdGUoZXYsIHR4LCB0aGlzLCBwbHVnaW4pXG4gICAgfSlcbiAgICB0aGlzLnlEb2Mub24oXCJ1cGRhdGVcIiwgKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiBhbnksIHlEb2M6IFkuRG9jLCB0cjogWS5UcmFuc2FjdGlvbikgPT4ge1xuICAgICAgaWYgKHRyLmxvY2FsICYmIHRoaXMuc2hhcmVJZCkge1xuICAgICAgICBwbHVnaW4uc2VydmVyU3luYy5zZW5kVXBkYXRlKHRoaXMsIHVwZGF0ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIFNoYXJlZEZvbGRlci5fc2hhcmVkRW50aXRlcy5wdXNoKHRoaXMpXG4gICAgYWRkSXNTaGFyZWRDbGFzcyh0aGlzLnBhdGgsIHBsdWdpbilcbiAgfVxuXG4gIGdldERvY3NGcmFnbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy55RG9jLmdldE1hcCgnZG9jdW1lbnRzJykgYXMgWS5NYXA8c3RyaW5nPlxuICB9XG5cblxuICBnZXREb2NCeVJlbGF0aXZlUGF0aChkaXI6IHN0cmluZykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChkaXIpXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmdldERvY3NGcmFnbWVudCgpLmVudHJpZXMoKSBhcyBJdGVyYWJsZUl0ZXJhdG9yPFtrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZ10+KSB7XG4gICAgICBpZiAoZW50cnlbMV0gPT09IG5vcm1hbGl6ZWRQYXRoKSByZXR1cm4gZW50cnlbMF1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVQYXRoKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3Qgb2xkUGF0aFJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZSh0aGlzLnJvb3QucGF0aCwgb2xkUGF0aClcbiAgICBjb25zdCBuZXdQYXRoUmVsYXRpdmUgPSBwYXRoLnJlbGF0aXZlKHRoaXMucm9vdC5wYXRoLCBuZXdQYXRoKVxuXG4gICAgY29uc3QgaWQgPSB0aGlzLmdldERvY0J5UmVsYXRpdmVQYXRoKG9sZFBhdGhSZWxhdGl2ZSlcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkuc2V0KGlkLCBub3JtYWxpemVQYXRoKG5ld1BhdGhSZWxhdGl2ZSkpXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG5cbiAgY2FsY3VsYXRlSGFzaCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemUoQXJyYXkuZnJvbSh0aGlzLmdldERvY3NGcmFnbWVudCgpKSlcbiAgICByZXR1cm4gY2FsY3VsYXRlSGFzaChzZXJpYWxpemVkKVxuICB9XG5cbiAgZ2V0T3JpZ2luYWxGb2xkZXJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnlEb2MuZ2V0VGV4dChcIm9yaWdpbmFsRm9sZGVybmFtZVwiKS50b1N0cmluZygpXG4gIH1cblxuICBzZXRPcmlnaW5hbEZvbGRlck5hbWUobmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMueURvYy5nZXRUZXh0KFwib3JpZ2luYWxGb2xkZXJuYW1lXCIpXG4gICAgdGV4dC5kZWxldGUoMCwgdGV4dC5sZW5ndGgpXG4gICAgdGV4dC5pbnNlcnQoMCwgbmFtZSlcbiAgfVxuXG4gIGdldEF1dG9GaWxsUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMueURvYy5nZXRUZXh0KFwiYXV0b0ZpbGxQcm9wZXJ0eVwiKS50b1N0cmluZygpXG4gIH1cblxuICBzZXRBdXRvRmlsbFByb3BlcnR5KHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBwcm9wID0gdGhpcy55RG9jLmdldFRleHQoXCJhdXRvRmlsbFByb3BlcnR5XCIpXG4gICAgcHJvcC5kZWxldGUoMCwgcHJvcC5sZW5ndGgpXG4gICAgcHJvcC5pbnNlcnQoMCwgcHJvcGVydHkpXG4gIH1cblxuICBhc3luYyB1cGRhdGVQcm9wZXJ0aWVzT2ZBbGxEb2N1bWVudHMob2xkUHJvcGVydHlOYW1lPzogc3RyaW5nKSB7XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuZ2V0QXV0b0ZpbGxQcm9wZXJ0eSgpXG4gICAgaWYgKCFwcm9wIHx8IHByb3AgPT09IFwiXCIpIHJldHVyblxuICAgIGNvbnN0IGRvY3MgPSB0aGlzLmdldERvY3NGcmFnbWVudCgpXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBkb2NzKSB7XG4gICAgICBjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChlbnRyeVswXSlcbiAgICAgIGlmICghZG9jKSByZXR1cm5cbiAgICAgIGRvYy51cGRhdGVQcm9wZXJ0eShwcm9wLCBkb2MuZ2V0U2hhcmVVUkwoKSwgb2xkUHJvcGVydHlOYW1lKVxuICAgIH1cbiAgfVxuXG4gIGFkZERvY3VtZW50KGRvYzogU2hhcmVkRG9jdW1lbnQpIHtcbiAgICAvLyBkb2Vzbid0IGV4aXN0IHlldFxuICAgIGlmICh0aGlzLmdldERvY3NGcmFnbWVudCgpLmdldChkb2Muc2hhcmVJZCkpIHJldHVyblxuICAgIC8vIGNoZWNrIGlmIGRvYyBpcyB1bmRlciByb290XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSh0aGlzLnJvb3QucGF0aCwgZG9jLnBhdGgpXG4gICAgaWYgKHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKSByZXR1cm5cbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLnNldChkb2Muc2hhcmVJZCwgcmVsYXRpdmVQYXRoKVxuICB9XG5cbiAgcmVtb3ZlRG9jdW1lbnQoZG9jOiBTaGFyZWREb2N1bWVudCkge1xuICAgIHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkuZGVsZXRlKGRvYy5zaGFyZUlkKVxuICAgIGNvbnN0IGRlbGV0ZWQgPSB0aGlzLnlEb2MuZ2V0QXJyYXkoXCJkZWxldGVkXCIpIGFzIFkuQXJyYXk8c3RyaW5nPlxuICAgIGlmICghZGVsZXRlZC50b0FycmF5KCkuaW5jbHVkZXMoZG9jLnNoYXJlSWQpKXtcbiAgICAgIGRlbGV0ZWQucHVzaChbZG9jLnNoYXJlSWRdKVxuICAgIH1cbiAgfVxuXG4gIGlzUGF0aFN1YlBhdGgoZm9sZGVyOiBzdHJpbmcpIHtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBwYXRoLnJlbGF0aXZlKHRoaXMucm9vdC5wYXRoLCBmb2xkZXIpXG4gICAgcmV0dXJuICEocmVsYXRpdmVQYXRoLnN0YXJ0c1dpdGgoJy4uJykpXG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRBbGxGaWxlc0luRm9sZGVyKGZvbGRlcjogVEZvbGRlcik6IEFycmF5PFRGaWxlPiB7XG4gICAgY29uc3QgZmlsZXMgPSBmb2xkZXIuY2hpbGRyZW4uZmxhdE1hcCgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgIGlmIChjaGlsZC5leHRlbnNpb24gPT09IFwibWRcIikge1xuICAgICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbEZpbGVzSW5Gb2xkZXIoY2hpbGQpXG4gICAgICB9XG4gICAgICByZXR1cm4gW11cbiAgICB9KVxuICAgIHJldHVybiBmaWxlc1xuICB9XG5cbiAgYXN5bmMgc2V0TmV3Rm9sZGVyTG9jYXRpb24oZm9sZGVyOiBURm9sZGVyKSB7XG4gICAgY29uc3Qgb2xkUGF0aCA9IHRoaXMuX3BhdGhcbiAgICB0aGlzLnJvb3QgPSBmb2xkZXJcbiAgICB0aGlzLl9wYXRoID0gbm9ybWFsaXplUGF0aChmb2xkZXIucGF0aClcbiAgICBtb3ZlRm9sZGVyKG9sZFBhdGgsIGZvbGRlci5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG4gIGFzeW5jIGdldE9yQ3JlYXRlRmlsZShyZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IGFic29sdXRlUGF0aCA9IHBhdGguam9pbih0aGlzLnJvb3QucGF0aCwgcmVsYXRpdmVQYXRoKVxuICAgIGxldCBmaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhYnNvbHV0ZVBhdGgpXG4gICAgaWYgKGZpbGUgJiYgZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSByZXR1cm4gZmlsZVxuXG4gICAgY29uc3QgZm9sZGVyID0gYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLnBhcnNlKGFic29sdXRlUGF0aCkuZGlyLCB0aGlzLnBsdWdpbilcbiAgICBpZiAoIWZvbGRlcikge1xuICAgICAgc2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIHNoYXJlc1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKGFic29sdXRlUGF0aCwgJycpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZ2V0T3JDcmVhdGVQYXRoKGFic29sdXRlUGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbik6IFByb21pc2U8VEZvbGRlciB8IHZvaWQ+IHtcbiAgICBsZXQgZm9sZGVyID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm9ybWFsaXplUGF0aChhYnNvbHV0ZVBhdGgpKVxuICAgIGlmIChmb2xkZXIgJiYgZm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikgcmV0dXJuIGZvbGRlclxuICAgIGNvbnN0IHNlZ21lbnRzID0gYWJzb2x1dGVQYXRoLnNwbGl0KHBhdGguc2VwKVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBzZWdtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHN1YlBhdGggPSBzZWdtZW50cy5zbGljZSgwLCBpbmRleCArIDEpLmpvaW4ocGF0aC5zZXApXG4gICAgICBmb2xkZXIgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKHN1YlBhdGgpKVxuICAgICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgICAgZm9sZGVyID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIobm9ybWFsaXplUGF0aChzdWJQYXRoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvbGRlciBhcyBURm9sZGVyXG4gIH1cblxuICBpc0ZpbGVJblN5bmNPYmplY3QoZmlsZTogVEZpbGUpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZS5wYXRoKVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgKHRoaXMuZ2V0RG9jc0ZyYWdtZW50KCkgYXMgWS5NYXA8c3RyaW5nPikudmFsdWVzKCkpIHtcbiAgICAgIGlmIChub3JtYWxpemVkUGF0aCA9PT0gcGF0aC5qb2luKHRoaXMucm9vdC5wYXRoLCB2YWx1ZSkpIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgc3RhcnRXZWJSVENTeW5jKCkge1xuICAgIHJldHVybiBzdXBlci5zdGFydFdlYlJUQ1N5bmMoKHByb3ZpZGVyKSA9PiB7XG5cbiAgICAgIGNvbnN0IGhhbmRsZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgIC8vIHRoaXMuc3RvcFdlYlJUQ1N5bmMoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl93ZWJSVENUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlVGltZW91dCwgNjAwMDApXG4gICAgICBwcm92aWRlci5kb2Mub24oJ3VwZGF0ZScsIGFzeW5jICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55LCBkb2M6IFkuRG9jLCB0cjogWS5UcmFuc2FjdGlvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fd2ViUlRDVGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl93ZWJSVENUaW1lb3V0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dlYlJUQ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCA2MDAwMClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0SW5kZXhlZERCU3luYygpIHtcbiAgICBpZiAodGhpcy5faW5kZXhlZERCUHJvdmlkZXIpIHJldHVybiB0aGlzLl9pbmRleGVkREJQcm92aWRlclxuICAgIGNvbnN0IGlkID0gZ2V0Rm9sZGVyQnlQYXRoKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pPy5wZXJzaXN0ZW5jZUlkXG4gICAgaWYgKCFpZCkgcmV0dXJuXG4gICAgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIgPSBuZXcgSW5kZXhlZGRiUGVyc2lzdGVuY2UoU2hhcmVkRW50aXR5LkRCX1BFUlNJU1RFTkNFX1BSRUZJWCArIGlkLCB0aGlzLnlEb2MpXG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyXG4gIH1cblxuICBhc3luYyB1bnNoYXJlKCkge1xuICAgIGNvbnN0IGRiRW50cnkgPSBnZXRGb2xkZXJCeVBhdGgodGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgICBpZiAoZGJFbnRyeSkge1xuICAgICAgcmVtb3ZlRm9sZGVyKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyKSB7XG4gICAgICBhd2FpdCB0aGlzLl9pbmRleGVkREJQcm92aWRlci5jbGVhckRhdGEoKVxuICAgICAgYXdhaXQgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIuZGVzdHJveSgpXG4gICAgfVxuXG5cbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLmZvckVhY2goKHBhdGg6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nKSA9PiB7XG4gICAgICBTaGFyZWREb2N1bWVudC5maW5kQnlJZChzaGFyZUlkKT8udW5zaGFyZSgpXG4gICAgfSlcblxuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgcmVtb3ZlSXNTaGFyZWRDbGFzcyh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KClcbiAgICBTaGFyZWRGb2xkZXIuX3NoYXJlZEVudGl0ZXMuc3BsaWNlKFNoYXJlZEZvbGRlci5fc2hhcmVkRW50aXRlcy5pbmRleE9mKHRoaXMpLCAxKVxuICB9XG5cbn0iLCAiaW1wb3J0IHsgTW9kYWwsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgZGVib3VuY2UsIG5vcm1hbGl6ZVBhdGgsIHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHNob3dUZXh0TW9kYWwgfSBmcm9tIFwiLi91aVwiO1xuaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwiLi9wZWVyZHJhZnRQbHVnaW5cIjtcbmltcG9ydCB7IHByb21wdEZvckZvbGRlclNlbGVjdGlvbiB9IGZyb20gXCIuL3VpL3NlbGVjdEZvbGRlclwiO1xuaW1wb3J0IHsgUGVybWFuZW50U2hhcmVTdG9yZUluZGV4ZWREQiB9IGZyb20gXCIuL3Blcm1hbmVudFNoYXJlU3RvcmVcIjtcbmltcG9ydCB7IGxvZ291dCB9IGZyb20gXCIuL2xvZ2luXCI7XG5pbXBvcnQgeyBvcGVuTG9naW5Nb2RhbCB9IGZyb20gXCIuL3VpL2xvZ2luXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0dGluZ3Mge1xuICBzaWduYWxpbmc6IHN0cmluZyxcbiAgc3luYzogc3RyaW5nLFxuICBzdWJzY3JpcHRpb25BUEk6IHN0cmluZyxcbiAgY29ubmVjdEFQSTogc3RyaW5nLFxuICBzZXNzaW9uQVBJOiBzdHJpbmdcbiAgYWN0aXZlczogc3RyaW5nLFxuICBiYXNlUGF0aDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIG9pZDogc3RyaW5nLFxuICBwbGFuOiB7XG4gICAgdHlwZTogXCJob2JieVwiIHwgXCJwcm9mZXNzaW9uYWxcIiB8IFwidGVhbVwiXG4gICAgZW1haWw/OiBzdHJpbmdcbiAgfSxcbiAgcm9vdDogc3RyaW5nLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBkZWJ1ZzogYm9vbGVhbixcbiAgdmVyc2lvbjogc3RyaW5nLFxuICBzZXJ2ZXJTaGFyZXM6IHtcbiAgICBmb2xkZXJzOiBNYXA8c3RyaW5nLCB7IHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIH0+XG4gICAgZmlsZXM6IE1hcDxzdHJpbmcsIHsgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcgfT5cbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBPbWl0PFNldHRpbmdzLCBcIm9pZFwiPiA9IHtcbiAgYmFzZVBhdGg6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcFwiLFxuICBzdWJzY3JpcHRpb25BUEk6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9zdWJzY3JpcHRpb25cIixcbiAgY29ubmVjdEFQSTogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3N1YnNjcmlwdGlvbi9jb25uZWN0XCIsXG4gIHNlc3Npb25BUEk6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9zZXNzaW9uXCIsXG4gIHN5bmM6IFwid3NzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3luY1wiLFxuICBzaWduYWxpbmc6IFwid3NzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc2lnbmFsXCIsXG4gIGFjdGl2ZXM6IFwid3NzOi8vd3d3LnBlZXJkcmFmdC5hcHAvYWN0aXZlc1wiLFxuICBuYW1lOiBcIlwiLFxuICByb290OiBcIlwiLFxuICBwbGFuOiB7XG4gICAgdHlwZTogXCJob2JieVwiLFxuICAgIGVtYWlsOiBcIlwiXG4gIH0sXG4gIGR1cmF0aW9uOiAwLFxuICBkZWJ1ZzogZmFsc2UsXG4gIHZlcnNpb246ICcnLFxuICBzZXJ2ZXJTaGFyZXM6IHtcbiAgICBmaWxlczogbmV3IE1hcDxzdHJpbmcsIHsgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcgfT4oKSxcbiAgICBmb2xkZXJzOiBuZXcgTWFwPHN0cmluZywgeyBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyB9PigpXG4gIH1cbn1cblxuY29uc3QgRk9SQ0VfU0VUVElOR1M6IFBhcnRpYWw8U2V0dGluZ3M+ID0ge1xuLypcbiAgYmFzZVBhdGg6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsXG4gIHN1YnNjcmlwdGlvbkFQSTogXCJodHRwOi8vbG9jYWxob3N0OjUxNzMvc3Vic2NyaXB0aW9uXCIsXG4gIGNvbm5lY3RBUEk6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczL3N1YnNjcmlwdGlvbi9jb25uZWN0XCIsXG4gIHNlc3Npb25BUEk6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczL3Nlc3Npb25cIixcbiAgc3luYzogXCJ3czovL2xvY2FsaG9zdDo1MTczL3N5bmNcIixcbiAgc2lnbmFsaW5nOiBcIndzOi8vbG9jYWxob3N0OjUxNzMvc2lnbmFsXCIsXG4gIGFjdGl2ZXM6IFwid3M6Ly9sb2NhbGhvc3Q6NTE3My9hY3RpdmVzXCJcbiovXG4gIGJhc2VQYXRoOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHBcIixcbiAgc3Vic2NyaXB0aW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3Vic2NyaXB0aW9uXCIsXG4gIGNvbm5lY3RBUEk6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9zdWJzY3JpcHRpb24vY29ubmVjdFwiLFxuICBzZXNzaW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc2Vzc2lvblwiLFxuICBzeW5jOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3N5bmNcIixcbiAgc2lnbmFsaW5nOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3NpZ25hbFwiLFxuICBhY3RpdmVzOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL2FjdGl2ZXNcIixcblxufVxuXG5leHBvcnQgY29uc3QgbWlncmF0ZVNldHRpbmdzID0gYXN5bmMgKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IG9sZFNldHRpbmdzID0gYXdhaXQgZ2V0U2V0dGluZ3MocGx1Z2luKVxuXG4gIGNvbnN0IG5ld1NldHRpbmdzOiBTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIG9sZFNldHRpbmdzLCBGT1JDRV9TRVRUSU5HUywge1xuICAgIHZlcnNpb246IHBsdWdpbi5tYW5pZmVzdC52ZXJzaW9uXG4gIH0pXG4gIC8vQHRzLWV4cGVjdC1lcnJvclxuICBuZXdTZXR0aW5ncy5vaWQgPSBvbGRTZXR0aW5ncz8ub2lkID8/IHBsdWdpbi5hcHAuYXBwSWRcblxuICBjb25zdCBmaWxlcyA9IG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlc1xuICBmb3IgKGNvbnN0IGtleSBvZiBmaWxlcy5rZXlzKCkpIHtcbiAgICBpZiAoa2V5LmNvbnRhaW5zKCdcXFxcJykpIHtcbiAgICAgIGZpbGVzLnNldChub3JtYWxpemVQYXRoKGtleSksIGZpbGVzLmdldChrZXkpISlcbiAgICAgIGZpbGVzLmRlbGV0ZShrZXkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9sZGVycyA9IG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzXG4gIGZvciAoY29uc3Qga2V5IG9mIGZvbGRlcnMua2V5cygpKSB7XG4gICAgaWYgKGtleS5jb250YWlucygnXFxcXCcpKSB7XG4gICAgICBmb2xkZXJzLnNldChub3JtYWxpemVQYXRoKGtleSksIGZvbGRlcnMuZ2V0KGtleSkhKVxuICAgICAgZm9sZGVycy5kZWxldGUoa2V5KVxuICAgIH1cbiAgfVxuXG4gIGlmIChvbGRTZXR0aW5ncz8ub2lkICYmIG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5zaXplID09PSAwICYmIG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLnNpemUgPT09IDApIHtcbiAgICBjb25zdCBkYiA9IG5ldyBQZXJtYW5lbnRTaGFyZVN0b3JlSW5kZXhlZERCKG9sZFNldHRpbmdzLm9pZClcbiAgICBjb25zdCBkb2NzID0gYXdhaXQgZGIuZ2V0QWxsRG9jcygpXG4gICAgZG9jcy5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuc2V0KG5vcm1hbGl6ZVBhdGgoZG9jLnBhdGgpLCB7IHBlcnNpc3RlbmNlSWQ6IGRvYy5wZXJzaXN0ZW5jZUlkLCBzaGFyZUlkOiBkb2Muc2hhcmVJZCB9KVxuICAgIH0pXG4gICAgY29uc3QgZm9sZGVycyA9IGF3YWl0IGRiLmdldEFsbEZvbGRlcnMoKVxuICAgIGZvbGRlcnMuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgbmV3U2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMuc2V0KG5vcm1hbGl6ZVBhdGgoZG9jLnBhdGgpLCB7IHBlcnNpc3RlbmNlSWQ6IGRvYy5wZXJzaXN0ZW5jZUlkLCBzaGFyZUlkOiBkb2Muc2hhcmVJZCB9KVxuICAgIH0pXG4gICAgc2F2ZVNldHRpbmdzKG5ld1NldHRpbmdzLCBwbHVnaW4pXG4gICAgYXdhaXQgZGIuZGVsZXRlREIoKVxuICB9XG5cbiAgc2F2ZVNldHRpbmdzKG5ld1NldHRpbmdzLCBwbHVnaW4pXG5cbiAgaWYgKG9sZFNldHRpbmdzICYmIG9sZFNldHRpbmdzLnZlcnNpb24gIT0gbmV3U2V0dGluZ3MudmVyc2lvbikge1xuICAgIHNob3dUZXh0TW9kYWwocGx1Z2luLmFwcCwgJ1BlZXJkcmFmdCB1cGRhdGVkJywgJ0EgbmV3IHZlcnNpb24gb2YgUGVlcmRyYWZ0IHdhcyBpbnN0YWxsZWQuIFBsZWFzZSByZXN0YXJ0IE9ic2lkaWFuIGJlZm9yZSB5b3UgdXNlIFBlZXJkcmFmdCBhZ2Fpbi4nKVxuICB9XG5cbiAgcmV0dXJuIG5ld1NldHRpbmdzXG5cbn1cblxuZXhwb3J0IGNvbnN0IGdldFNldHRpbmdzID0gYXN5bmMgKHBsdWdpbjogUGx1Z2luKSA9PiB7XG4gIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgcGx1Z2luLmxvYWREYXRhKCkgYXMgU2V0dGluZ3NcbiAgaWYgKHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3Muc2VydmVyU2hhcmVzID0ge1xuICAgICAgZmlsZXM6IG5ldyBNYXAoc2V0dGluZ3Muc2VydmVyU2hhcmVzPy5maWxlcyksXG4gICAgICBmb2xkZXJzOiBuZXcgTWFwKHNldHRpbmdzLnNlcnZlclNoYXJlcz8uZm9sZGVycylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNldHRpbmdzXG59XG5cblxuZXhwb3J0IGNvbnN0IHNhdmVTZXR0aW5ncyA9IGRlYm91bmNlKGFzeW5jIChzZXR0aW5nczogU2V0dGluZ3MsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG5cbiAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKVxuXG4gIHNlcmlhbGl6ZWQuc2VydmVyU2hhcmVzID0ge1xuICAgIGZpbGVzOiBBcnJheS5mcm9tKHNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5lbnRyaWVzKCkpLFxuICAgIGZvbGRlcnM6IEFycmF5LmZyb20oc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMuZW50cmllcygpKVxuICB9XG5cbiAgYXdhaXQgcGx1Z2luLnNhdmVEYXRhKHNlcmlhbGl6ZWQpXG59LCAxMDAwLCB0cnVlKVxuXG5leHBvcnQgY29uc3QgcmVuZGVyU2V0dGluZ3MgPSBhc3luYyAoZWw6IEhUTUxFbGVtZW50LCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBlbC5lbXB0eSgpO1xuXG4gIGNvbnN0IHNldHRpbmdzID0gcGx1Z2luLnNldHRpbmdzXG5cbiAgZWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiR2VuZXJhbFwiIH0pO1xuXG4gIG5ldyBTZXR0aW5nKGVsKVxuICAgIC5zZXROYW1lKFwiRGlzcGxheSBOYW1lXCIpXG4gICAgLnNldERlc2MoXCJUaGlzIG5hbWUgd2lsbCBiZSBzaG93biB0byB5b3VyIGNvbGxhYm9yYXRvcnNcIilcbiAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgdGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5uYW1lKVxuICAgICAgdGV4dC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgc2V0dGluZ3MubmFtZSA9IHZhbHVlXG4gICAgICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncywgcGx1Z2luKTtcbiAgICAgIH0pXG4gICAgfSlcblxuICBjb25zdCBwYXRoU2V0dGluZyA9IG5ldyBTZXR0aW5nKGVsKVxuICBwYXRoU2V0dGluZy5zZXROYW1lKFwiUm9vdCBGb2xkZXJcIilcbiAgcGF0aFNldHRpbmcuc2V0RGVzYyhcIldoZW4geW91IGltcG9ydCBhIHNoYXJlIGZyb20gc29tZW9uZSBlbHNlIGl0IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGZvbGRlci5cIilcbiAgcGF0aFNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICB0ZXh0LnNldFZhbHVlKHNldHRpbmdzLnJvb3QpXG4gICAgdGV4dC5vbkNoYW5nZShhc3luYyB2YWx1ZSA9PiB7XG4gICAgICBzZXR0aW5ncy5yb290ID0gdmFsdWVcbiAgICAgIHNhdmVTZXR0aW5ncyhzZXR0aW5ncywgcGx1Z2luKVxuICAgIH0pXG5cbiAgICBwYXRoU2V0dGluZy5hZGRFeHRyYUJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEljb24oJ3NlYXJjaCcpXG4gICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IHByb21wdEZvckZvbGRlclNlbGVjdGlvbihwbHVnaW4uYXBwKVxuICAgICAgICBpZiAoZm9sZGVyKSB7XG4gICAgICAgICAgdGV4dC5zZXRWYWx1ZShmb2xkZXIucGF0aClcbiAgICAgICAgICBzZXR0aW5ncy5yb290ID0gZm9sZGVyLnBhdGhcbiAgICAgICAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KVxuXG4gIGVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIllvdXIgQWNjb3VudFwiIH0pXG5cbiAgaWYgKHBsdWdpbi5zZXJ2ZXJTeW5jLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGBZb3UgYXJlIGxvZ2dlZCBpbiBhcyAke3BsdWdpbi5zZXR0aW5ncy5wbGFuLmVtYWlsfS5gIH0pXG4gICAgZWwuY3JlYXRlRWwoXCJwXCIpXG4gICAgY29uc3QgZGl2ID0gZWwuY3JlYXRlRWwoXCJkaXZcIilcbiAgICBkaXYuY3JlYXRlU3Bhbih7IHRleHQ6IFwiWW91IGFyZSBvbiB0aGUgXCJ9KS5jcmVhdGVFbCgnYicsIHsgdGV4dDogIHBsdWdpbi5zZXR0aW5ncy5wbGFuLnR5cGV9KVxuICAgIGRpdi5jcmVhdGVTcGFuKHsgdGV4dDogXCIgcGxhbi5cIn0pXG4gICAgZWwuY3JlYXRlRWwoXCJwXCIpXG5cbiAgICBpZiAocGx1Z2luLnNldHRpbmdzLnBsYW4udHlwZSA9PT0gXCJob2JieVwiKSB7XG4gICAgICBuZXcgU2V0dGluZyhlbClcbiAgICAgICAgLnNldE5hbWUoXCJNYW5hZ2UgeW91ciBzdWJzY3JpcHRpb25cIilcbiAgICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiVXBncmFkZSB0byBwcm9cIilcbiAgICAgICAgICBidXR0b24uc2V0Q3RhKClcbiAgICAgICAgICBidXR0b24ub25DbGljaygoZSkgPT4ge1xuICAgICAgICAgICAgd2luZG93Lm9wZW4oYGh0dHBzOi8vcGVlcmRyYWZ0LmFwcC9jaGVja291dD9lbWFpbD0ke3BsdWdpbi5zZXR0aW5ncy5wbGFuLmVtYWlsfWApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBuZXcgU2V0dGluZyhlbClcbiAgICAgIC5zZXROYW1lKFwiTG9nIG91dFwiKVxuICAgICAgLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkxvZyBvdXRcIilcbiAgICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICBhd2FpdCBsb2dvdXQocGx1Z2luKVxuICAgICAgICAgIHJlbmRlclNldHRpbmdzKGVsLCBwbHVnaW4pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9IGVsc2Uge1xuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogYFlvdSBhcmUgbm90IGxvZ2dlZCBpbi5gIH0pXG4gICAgZWwuY3JlYXRlRWwoXCJwXCIpXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBgVG8gaW5pdGlhdGUgbmV3IHNoYXJlZCBkb2N1bWVudHMgb3IgZm9sZGVycyB5b3UgbmVlZCB0byBsb2cgaW4gdG8geW91ciBQZWVyZHJhZnQgYWNjb3VudC4gSWYgeW91IG9ubHkgd29yayBvbiBzaGFyZWQgZG9jdW1lbnRzIGFuZCBmb2xkZXJzIGNyZWF0ZWQgYnkgb3RoZXJzLCB5b3UgZG9uJ3QgbmVlZCBhbiBhY2NvdW50LmAgfSlcbiAgICBlbC5jcmVhdGVFbChcInBcIilcblxuICAgIG5ldyBTZXR0aW5nKGVsKVxuICAgICAgLnNldE5hbWUoXCJMb2cgaW4gb3IgY3JlYXRlIGFjY291bnRcIilcbiAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJMb2cgaW4gb3IgY3JlYXRlIGFjY291bnRcIilcbiAgICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICBhd2FpdCBvcGVuTG9naW5Nb2RhbChwbHVnaW4pXG4gICAgICAgICAgcmVuZGVyU2V0dGluZ3MoZWwsIHBsdWdpbilcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICBlbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJIZWxwXCIgfSlcbiAgY29uc3QgZGl2ID0gZWwuY3JlYXRlRGl2KClcbiAgZGl2LmNyZWF0ZVNwYW4oeyB0ZXh0OiBcIklmIHlvdSBuZWVkIGFueSBoZWxwLCBcIiB9KVxuICBkaXYuY3JlYXRlRWwoXCJhXCIsIHtcbiAgICB0ZXh0OiBcImdldCBpbiB0b3VjaFwiLFxuICAgIGF0dHI6IHtcbiAgICAgIGhyZWY6IFwibWFpbHRvOmRvbWluaWtAcGVlcmRyYWZ0LmFwcFwiXG4gICAgfVxuICB9KVxuICBkaXYuY3JlYXRlU3Bhbih7IHRleHQ6ICcuJyB9KVxuXG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXR0aW5nc1RhYiA9IChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gICAgYXN5bmMgZGlzcGxheSgpIHtcbiAgICAgIGF3YWl0IHJlbmRlclNldHRpbmdzKHRoaXMuY29udGFpbmVyRWwsIHBsdWdpbilcbiAgICB9XG4gIH0ocGx1Z2luLmFwcCwgcGx1Z2luKVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU2V0dGluZ3NNb2RhbCA9IChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgTW9kYWwge1xuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmNvbnRlbnRFbFxuICAgICAgZWwuZW1wdHkoKTtcblxuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCBnZXRTZXR0aW5ncyhwbHVnaW4pXG5cbiAgICAgIGVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIldoYXQncyB5b3VyIG5hbWU/XCIgfSk7XG5cbiAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgU2V0dGluZyhlbClcbiAgICAgIHNldHRpbmcuc2V0TmFtZShcIk5hbWVcIilcbiAgICAgIHNldHRpbmcuc2V0RGVzYyhcIlRoaXMgbmFtZSB3aWxsIGJlIHNob3duIHRvIHlvdXIgY29sbGFib3JhdG9yc1wiKVxuICAgICAgc2V0dGluZy5hZGRUZXh0KCh0ZXh0KSA9PiB7XG4gICAgICAgIHRleHQuc2V0VmFsdWUoc2V0dGluZ3MubmFtZSlcbiAgICAgICAgdGV4dC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICBzZXR0aW5ncy5uYW1lID0gdmFsdWVcbiAgICAgICAgICBhd2FpdCBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbik7XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpXG4gICAgfVxuXG4gIH0ocGx1Z2luLmFwcClcbn0iLCAiaW1wb3J0IHsgQXBwLCBTdWdnZXN0TW9kYWwsIFRGaWxlLCBURm9sZGVyLCBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5leHBvcnQgY2xhc3MgU2VsZWN0Rm9sZGVyTW9kYWwgZXh0ZW5kcyBTdWdnZXN0TW9kYWw8VEZvbGRlcj4ge1xuXG4gIGZvbGRlcnM6IEFycmF5PFRGb2xkZXI+XG4gIGNiOiAoZm9sZGVyOiBURm9sZGVyKSA9PiBhbnlcbiAgc2VsZWN0ZWRGb2xkZXI6IFRGb2xkZXJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY2I6IChmaWxlOiBURm9sZGVyKSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5jYiA9IGNiXG5cbiAgICB0aGlzLmZvbGRlcnMgPSBbXVxuICAgIFZhdWx0LnJlY3Vyc2VDaGlsZHJlbihhcHAudmF1bHQuZ2V0Um9vdCgpLCAoZmlsZSkgPT4ge1xuICAgICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB0aGlzLmZvbGRlcnMucHVzaChmaWxlKVxuICAgIH0pXG4gICAgLy8gcmVtb3ZlIHJvb3QgJiBzb3J0XG4gICAgdGhpcy5mb2xkZXJzLnNoaWZ0KClcbiAgICB0aGlzLmZvbGRlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgcmV0dXJuIGEucGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoYi5wYXRoLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgfSlcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBzdXBlci5vbk9wZW4oKVxuICAgIHRoaXMuaW5wdXRFbC5wbGFjZWhvbGRlciA9IFwiQ2hvb3NlIGEgbG9jYXRpb25cIlxuICB9XG5cbiAgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IFRGb2xkZXJbXSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZGVycy5maWx0ZXIoZm9sZGVyID0+IHtcbiAgICAgIHJldHVybiBmb2xkZXIucGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlclN1Z2dlc3Rpb24odmFsdWU6IFRGb2xkZXIsIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGVsLnNldFRleHQodmFsdWUucGF0aClcbiAgfVxuXG4gIHNlbGVjdFN1Z2dlc3Rpb24odmFsdWU6IFRGb2xkZXIsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGVkRm9sZGVyID0gdmFsdWVcbiAgICBzdXBlci5zZWxlY3RTdWdnZXN0aW9uKHZhbHVlLCBldnQpXG4gIH1cblxuICBvbkNob29zZVN1Z2dlc3Rpb24oaXRlbTogVEZvbGRlciwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICB9XG5cbiAgb25DbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNiKHRoaXMuc2VsZWN0ZWRGb2xkZXIpXG4gIH1cblxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yRm9sZGVyU2VsZWN0aW9uID0gYXN5bmMgKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxURm9sZGVyIHwgdm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBuZXcgU2VsZWN0Rm9sZGVyTW9kYWwoYXBwLCAoZm9sZGVyKSA9PiB7XG4gICAgICByZXNvbHZlKGZvbGRlcilcbiAgICB9KS5vcGVuKClcbiAgfSlcbn0iLCAiZGVjbGFyZSB2YXIgZ2xvYmFsO1xuZXhwb3J0IGNvbnN0IF9nbG9iYWw6IGFueSA9XG4gICAgdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6XG4gICAgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOlxuICAgIGdsb2JhbDtcbiIsICLvu79pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSBcIi4uL2dsb2JhbHMvZ2xvYmFsXCI7XG5leHBvcnQgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzO1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiAhX2dsb2JhbC5Qcm9taXNlKXtcbiAgICAvLyBJbiBqc2RvbSwgdGhpcyBpdCBjYW4gYmUgdGhlIGNhc2UgdGhhdCBQcm9taXNlIGlzIG5vdCBwdXQgb24gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgLy8gSWYgc28sIHdlIG5lZWQgdG8gcGF0Y2ggdGhlIGdsb2JhbCBvYmplY3QgZm9yIHRoZSByZXN0IG9mIHRoZSBjb2RlIHRvIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgLy8gT3RoZXIgZGV4aWUgY29kZSBleHBlY3RzIFByb21pc2UgdG8gYmUgb24gdGhlIGdsb2JhbCBvYmplY3QgKGxpa2Ugbm9ybWFsIGJyb3dzZXIgZW52aXJvbm1lbnRzKVxuICAgIF9nbG9iYWwuUHJvbWlzZSA9IFByb21pc2U7XG59XG5leHBvcnQgeyBfZ2xvYmFsIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZDxUIGV4dGVuZHMgb2JqZWN0LFggZXh0ZW5kcyBvYmplY3Q+KG9iajogVCwgZXh0ZW5zaW9uOiBYKTogVCAmIFggIHtcbiAgICBpZiAodHlwZW9mIGV4dGVuc2lvbiAhPT0gJ29iamVjdCcpIHJldHVybiBvYmogYXMgVCAmIFg7XG4gICAga2V5cyhleHRlbnNpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmogYXMgVCAmIFg7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmV4cG9ydCBjb25zdCBfaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBfaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BzIChwcm90bywgZXh0ZW5zaW9uKSB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIGV4dGVuc2lvbiA9IGV4dGVuc2lvbihnZXRQcm90byhwcm90bykpO1xuICAgICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiA/IGtleXMgOiBSZWZsZWN0Lm93bktleXMpKGV4dGVuc2lvbikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzZXRQcm9wKHByb3RvLCBrZXksIGV4dGVuc2lvbltrZXldKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcChvYmosIHByb3AsIGZ1bmN0aW9uT3JHZXRTZXQsIG9wdGlvbnM/KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCBleHRlbmQoZnVuY3Rpb25PckdldFNldCAmJiBoYXNPd24oZnVuY3Rpb25PckdldFNldCwgXCJnZXRcIikgJiYgdHlwZW9mIGZ1bmN0aW9uT3JHZXRTZXQuZ2V0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAge2dldDogZnVuY3Rpb25PckdldFNldC5nZXQsIHNldDogZnVuY3Rpb25PckdldFNldC5zZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOlxuICAgICAgICB7dmFsdWU6IGZ1bmN0aW9uT3JHZXRTZXQsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWV9LCBvcHRpb25zKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmUoQ2hpbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBmdW5jdGlvbiAoUGFyZW50KSB7XG4gICAgICAgICAgICBDaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgc2V0UHJvcChDaGlsZC5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgQ2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBleHRlbmQ6IHByb3BzLmJpbmQobnVsbCwgQ2hpbGQucHJvdG90eXBlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkge1xuICAgIGNvbnN0IHBkID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCk7XG4gICAgbGV0IHByb3RvO1xuICAgIHJldHVybiBwZCB8fCAocHJvdG8gPSBnZXRQcm90byhvYmopKSAmJiBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgKHByb3RvLCBwcm9wKTtcbn1cblxuY29uc3QgX3NsaWNlID0gW10uc2xpY2U7XG5leHBvcnQgZnVuY3Rpb24gc2xpY2UoYXJncywgc3RhcnQ/LCBlbmQ/KSB7XG4gICAgcmV0dXJuIF9zbGljZS5jYWxsKGFyZ3MsIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGUob3JpZ0Z1bmMsIG92ZXJyaWRlZEZhY3RvcnkpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVkRmFjdG9yeShvcmlnRnVuYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQgKGIpIHtcbiAgICBpZiAoIWIpIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBGYWlsZWRcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2FwKGZuKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChfZ2xvYmFsLnNldEltbWVkaWF0ZSkgc2V0SW1tZWRpYXRlKGZuKTsgZWxzZSBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZUFycmF5KGEpIHtcbiAgICByZXR1cm4gYS5maWx0ZXIoKHZhbHVlLCBpbmRleCwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXgpO1xufVxuXG4vKiogR2VuZXJhdGUgYW4gb2JqZWN0IChoYXNoIG1hcCkgYmFzZWQgb24gZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0gZXh0cmFjdG9yIEZ1bmN0aW9uIHRha2luZyBhbiBhcnJheSBpdGVtIGFuZCBpdHMgaW5kZXggYW5kIHJldHVybmluZyBhbiBhcnJheSBvZiAyIGl0ZW1zIChba2V5LCB2YWx1ZV0pIHRvXG4gKiAgICAgICAgaW5zdGVydCBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdCBmb3IgZWFjaCBpdGVtIGluIHRoZSBhcnJheS4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZVxuICogICAgICAgIGN1cnJlbnQgaXRlbSB3b250IGFmZmVjdCB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9PYmplY3Q8VCxSPiAoYXJyYXk6IFRbXSwgZXh0cmFjdG9yOiAoeDpULCBpZHg6IG51bWJlcik9PltzdHJpbmcsIFJdKToge1tuYW1lOiBzdHJpbmddOiBSfSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgocmVzdWx0LCBpdGVtLCBpKSA9PiB7XG4gICAgICAgIHZhciBuYW1lQW5kVmFsdWUgPSBleHRyYWN0b3IoaXRlbSwgaSk7XG4gICAgICAgIGlmIChuYW1lQW5kVmFsdWUpIHJlc3VsdFtuYW1lQW5kVmFsdWVbMF1dID0gbmFtZUFuZFZhbHVlWzFdO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeWNhdGNoZXIoZm4sIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5Q2F0Y2goZm46ICguLi5hcmdzOiBhbnlbXSk9PnZvaWQsIG9uZXJyb3IsIGFyZ3M/KSA6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIG9uZXJyb3IgJiYgb25lcnJvcihleCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi8jc3RlcHMtZm9yLWV4dHJhY3RpbmctYS1rZXktZnJvbS1hLXZhbHVlLXVzaW5nLWEta2V5LXBhdGhcbiAgICBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnICYmIGhhc093bihvYmosIGtleVBhdGgpKSByZXR1cm4gb2JqW2tleVBhdGhdOyAvLyBUaGlzIGxpbmUgaXMgbW92ZWQgZnJvbSBsYXN0IHRvIGZpcnN0IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZS5cbiAgICBpZiAoIWtleVBhdGgpIHJldHVybiBvYmo7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcnYgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0pO1xuICAgICAgICAgICAgcnYucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgIGlmIChwZXJpb2QgIT09IC0xKSB7XG4gICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtrZXlQYXRoLnN1YnN0cigwLCBwZXJpb2QpXTtcbiAgICAgICAgcmV0dXJuIGlubmVyT2JqID09IG51bGwgPyB1bmRlZmluZWQgOiBnZXRCeUtleVBhdGgoaW5uZXJPYmosIGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHZhbHVlKSB7XG4gICAgaWYgKCFvYmogfHwga2V5UGF0aCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgaWYgKCdpc0Zyb3plbicgaW4gT2JqZWN0ICYmIE9iamVjdC5pc0Zyb3plbihvYmopKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiBrZXlQYXRoKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICdsZW5ndGgnIGluIHZhbHVlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlQYXRoLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aFtpXSwgdmFsdWVbaV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBlcmlvZCA9IGtleVBhdGguaW5kZXhPZignLicpO1xuICAgICAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdLZXlQYXRoID0ga2V5UGF0aC5zdWJzdHIocGVyaW9kICsgMSk7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nS2V5UGF0aCA9PT0gXCJcIilcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChjdXJyZW50S2V5UGF0aCkpKSBvYmouc3BsaWNlKGN1cnJlbnRLZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBkZWxldGUgb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Ugb2JqW2N1cnJlbnRLZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyT2JqID0gb2JqW2N1cnJlbnRLZXlQYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyT2JqIHx8ICFoYXNPd24ob2JqLCBjdXJyZW50S2V5UGF0aCkpIGlubmVyT2JqID0gKG9ialtjdXJyZW50S2V5UGF0aF0gPSB7fSk7XG4gICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGlubmVyT2JqLCByZW1haW5pbmdLZXlQYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KG9iaikgJiYgIWlzTmFOKHBhcnNlSW50KGtleVBhdGgpKSkgb2JqLnNwbGljZShrZXlQYXRoLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgICAgICAgICB9IGVsc2Ugb2JqW2tleVBhdGhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxCeUtleVBhdGgob2JqLCBrZXlQYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJylcbiAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgdW5kZWZpbmVkKTtcbiAgICBlbHNlIGlmICgnbGVuZ3RoJyBpbiBrZXlQYXRoKVxuICAgICAgICBbXS5tYXAuY2FsbChrZXlQYXRoLCBmdW5jdGlvbihrcCkge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKG9iaiwga3AsIHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG9iaikge1xuICAgIHZhciBydiA9IHt9O1xuICAgIGZvciAodmFyIG0gaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNPd24ob2JqLCBtKSkgcnZbbV0gPSBvYmpbbV07XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cblxuY29uc3QgY29uY2F0ID0gW10uY29uY2F0O1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48VD4gKGE6IChUIHwgVFtdKVtdKSA6IFRbXSB7XG4gICAgcmV0dXJuIGNvbmNhdC5hcHBseShbXSwgYSk7XG59XG5cbi8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSS9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobVxuY29uc3QgaW50cmluc2ljVHlwZU5hbWVzID1cbiAgICBcIkJpZ1VpbnQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQXJyYXksQm9vbGVhbixTdHJpbmcsRGF0ZSxSZWdFeHAsQmxvYixGaWxlLEZpbGVMaXN0LEZpbGVTeXN0ZW1GaWxlSGFuZGxlLEZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUsQXJyYXlCdWZmZXIsRGF0YVZpZXcsVWludDhDbGFtcGVkQXJyYXksSW1hZ2VCaXRtYXAsSW1hZ2VEYXRhLE1hcCxTZXQsQ3J5cHRvS2V5XCJcbiAgICAuc3BsaXQoJywnKS5jb25jYXQoXG4gICAgICAgIGZsYXR0ZW4oWzgsMTYsMzIsNjRdLm1hcChudW09PltcIkludFwiLFwiVWludFwiLFwiRmxvYXRcIl0ubWFwKHQ9PnQrbnVtK1wiQXJyYXlcIikpKVxuICAgICkuZmlsdGVyKHQ9Pl9nbG9iYWxbdF0pO1xuY29uc3QgaW50cmluc2ljVHlwZXMgPSBpbnRyaW5zaWNUeXBlTmFtZXMubWFwKHQ9Pl9nbG9iYWxbdF0pO1xuZXhwb3J0IGNvbnN0IGludHJpbnNpY1R5cGVOYW1lU2V0ID0gYXJyYXlUb09iamVjdChpbnRyaW5zaWNUeXBlTmFtZXMsIHg9Plt4LHRydWVdKTtcblxubGV0IGNpcmN1bGFyUmVmczogbnVsbCB8IFdlYWtNYXA8YW55LGFueT4gPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZTxUPihhbnk6IFQpOiBUIHtcbiAgICBjaXJjdWxhclJlZnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBydiA9IGlubmVyRGVlcENsb25lKGFueSk7XG4gICAgY2lyY3VsYXJSZWZzID0gbnVsbDtcbiAgICByZXR1cm4gcnY7XG59XG5cbmZ1bmN0aW9uIGlubmVyRGVlcENsb25lPFQ+KGFueTogVCk6IFQge1xuICAgIGlmICghYW55IHx8IHR5cGVvZiBhbnkgIT09ICdvYmplY3QnKSByZXR1cm4gYW55O1xuICAgIGxldCBydiA9IGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuZ2V0KGFueSk7IC8vIFJlc29sdmUgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGlmIChydikgcmV0dXJuIHJ2O1xuICAgIGlmIChpc0FycmF5KGFueSkpIHtcbiAgICAgICAgcnYgPSBbXTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYW55Lmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgcnYucHVzaChpbm5lckRlZXBDbG9uZShhbnlbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW50cmluc2ljVHlwZXMuaW5kZXhPZihhbnkuY29uc3RydWN0b3IpID49IDApIHtcbiAgICAgICAgcnYgPSBhbnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byhhbnkpO1xuICAgICAgICBydiA9IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgICAgY2lyY3VsYXJSZWZzICYmIGNpcmN1bGFyUmVmcy5zZXQoYW55LCBydik7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gYW55KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duKGFueSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBydltwcm9wXSA9IGlubmVyRGVlcENsb25lKGFueVtwcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuXG5jb25zdCB7dG9TdHJpbmd9ID0ge307XG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmdUYWcobzogT2JqZWN0KSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xufVxuXG4vLyBJZiBmaXJzdCBhcmd1bWVudCBpcyBpdGVyYWJsZSBvciBhcnJheS1saWtlLCByZXR1cm4gaXQgYXMgYW4gYXJyYXlcbmV4cG9ydCBjb25zdCBpdGVyYXRvclN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID9cbiAgICBTeW1ib2wuaXRlcmF0b3IgOlxuICAgICdAQGl0ZXJhdG9yJztcbmV4cG9ydCBjb25zdCBnZXRJdGVyYXRvck9mID0gdHlwZW9mIGl0ZXJhdG9yU3ltYm9sID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpO1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgKGkgPSB4W2l0ZXJhdG9yU3ltYm9sXSkgJiYgaS5hcHBseSh4KTtcbn0gOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuZXhwb3J0IGNvbnN0IGFzeW5jSXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yXCIpXG4gICAgOiAnQGFzeW5jSXRlcmF0b3InO1xuXG5leHBvcnQgY29uc3QgTk9fQ0hBUl9BUlJBWSA9IHt9O1xuLy8gVGFrZXMgb25lIG9yIHNldmVyYWwgYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIGFycmF5IGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgY3JpdGVyYXM6XG4vLyAqIElmIHNldmVyYWwgYXJndW1lbnRzIHByb3ZpZGVkLCByZXR1cm4gYXJndW1lbnRzIGNvbnZlcnRlZCB0byBhbiBhcnJheSBpbiBhIHdheSB0aGF0XG4vLyAgIHN0aWxsIGFsbG93cyBqYXZhc2NyaXB0IGVuZ2luZSB0byBvcHRpbWl6ZSB0aGUgY29kZS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCByZXR1cm4gYSBjbG9uZSBvZiBpdC5cbi8vICogSWYgdGhpcy1wb2ludGVyIGVxdWFscyBOT19DSEFSX0FSUkFZLCBkb24ndCBhY2NlcHQgc3RyaW5ncyBhcyB2YWxpZCBpdGVyYWJsZXMgYXMgYSBzcGVjaWFsXG4vLyAgIGNhc2UgdG8gdGhlIHR3byBidWxsZXRzIGJlbG93LlxuLy8gKiBJZiBzaW5nbGUgYXJndW1lbnQgaXMgYW4gaXRlcmFibGUsIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5LlxuLy8gKiBJZiBzaW5nbGUgYXJndW1lbnQgaXMgYXJyYXktbGlrZSAoaGFzIGxlbmd0aCBvZiB0eXBlIG51bWJlciksIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXlPZiAoYXJyYXlMaWtlKSB7XG4gICAgdmFyIGksIGEsIHgsIGl0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGFycmF5TGlrZSkpIHJldHVybiBhcnJheUxpa2Uuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMgPT09IE5PX0NIQVJfQVJSQVkgJiYgdHlwZW9mIGFycmF5TGlrZSA9PT0gJ3N0cmluZycpIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaWYgKChpdCA9IGdldEl0ZXJhdG9yT2YoYXJyYXlMaWtlKSkpIHtcbiAgICAgICAgICAgIGEgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICgoeCA9IGl0Lm5leHQoKSksICF4LmRvbmUpIGEucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheUxpa2UgPT0gbnVsbCkgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgICAgICBpID0gYXJyYXlMaWtlLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYSA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIGFbaV0gPSBhcnJheUxpa2VbaV07XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgfVxuICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkgYVtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydCBjb25zdCBpc0FzeW5jRnVuY3Rpb24gPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJ1xuICAgID8gKGZuOiBGdW5jdGlvbikgPT4gZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nXG4gICAgOiAoKT0+ZmFsc2U7XG4iLCAiLy8gQnkgZGVmYXVsdCwgZGVidWcgd2lsbCBiZSB0cnVlIG9ubHkgaWYgcGxhdGZvcm0gaXMgYSB3ZWIgcGxhdGZvcm0gYW5kIGl0cyBwYWdlIGlzIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbi8vIFdoZW4gZGVidWcgPSB0cnVlLCBlcnJvcidzIHN0YWNrcyB3aWxsIGNvbnRhaW4gYXN5bmNyb25pYyBsb25nIHN0YWNrcy5cbmV4cG9ydCB2YXIgZGVidWcgPSB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHVzZSBkZWJ1ZyBtb2RlIGlmIHNlcnZlZCBmcm9tIGxvY2FsaG9zdC5cbiAgICAgICAgL14oaHR0cHxodHRwcyk6XFwvXFwvKGxvY2FsaG9zdHwxMjdcXC4wXFwuMFxcLjEpLy50ZXN0KGxvY2F0aW9uLmhyZWYpO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWcodmFsdWUsIGZpbHRlcikge1xuICAgIGRlYnVnID0gdmFsdWU7XG4gICAgbGlicmFyeUZpbHRlciA9IGZpbHRlcjtcbn1cblxuZXhwb3J0IHZhciBsaWJyYXJ5RmlsdGVyID0gKCkgPT4gdHJ1ZTtcblxuZXhwb3J0IGNvbnN0IE5FRURTX1RIUk9XX0ZPUl9TVEFDSyA9ICFuZXcgRXJyb3IoXCJcIikuc3RhY2s7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvcldpdGhTdGFjaygpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAoTkVFRFNfVEhST1dfRk9SX1NUQUNLKSB0cnkge1xuICAgICAgICAvLyBEb2luZyBzb21ldGhpbmcgbmF1Z2h0eSBpbiBzdHJpY3QgbW9kZSBoZXJlIHRvIHRyaWdnZXIgYSBzcGVjaWZpYyBlcnJvclxuICAgICAgICAvLyB0aGF0IGNhbiBiZSBleHBsaWNpdGVseSBpZ25vcmVkIGluIGRlYnVnZ2VyJ3MgZXhjZXB0aW9uIHNldHRpbmdzLlxuICAgICAgICAvLyBJZiB3ZSdkIGp1c3QgdGhyb3cgbmV3IEVycm9yKCkgaGVyZSwgSUUncyBkZWJ1Z2dlcidzIGV4Y2VwdGlvbiBzZXR0aW5nc1xuICAgICAgICAvLyB3aWxsIGp1c3QgY29uc2lkZXIgaXQgYXMgXCJleGNlcHRpb24gdGhyb3duIGJ5IGphdmFzY3JpcHQgY29kZVwiIHdoaWNoIGlzXG4gICAgICAgIC8vIHNvbWV0aGluZyB5b3Ugd291bGRuJ3Qgd2FudCBpdCB0byBpZ25vcmUuXG4gICAgICAgIGdldEVycm9yV2l0aFN0YWNrLmFyZ3VtZW50cztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIEZhbGxiYWNrIGlmIGFib3ZlIGxpbmUgZG9uJ3QgdGhyb3cuXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlTdGFjayhleGNlcHRpb24sIG51bUlnbm9yZWRGcmFtZXMpIHtcbiAgICB2YXIgc3RhY2sgPSBleGNlcHRpb24uc3RhY2s7XG4gICAgaWYgKCFzdGFjaykgcmV0dXJuIFwiXCI7XG4gICAgbnVtSWdub3JlZEZyYW1lcyA9IChudW1JZ25vcmVkRnJhbWVzIHx8IDApO1xuICAgIGlmIChzdGFjay5pbmRleE9mKGV4Y2VwdGlvbi5uYW1lKSA9PT0gMClcbiAgICAgICAgbnVtSWdub3JlZEZyYW1lcyArPSAoZXhjZXB0aW9uLm5hbWUgKyBleGNlcHRpb24ubWVzc2FnZSkuc3BsaXQoJ1xcbicpLmxlbmd0aDtcbiAgICByZXR1cm4gc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgICAgIC5zbGljZShudW1JZ25vcmVkRnJhbWVzKVxuICAgICAgICAuZmlsdGVyKGxpYnJhcnlGaWx0ZXIpXG4gICAgICAgIC5tYXAoZnJhbWUgPT4gXCJcXG5cIiArIGZyYW1lKVxuICAgICAgICAuam9pbignJyk7XG59XG5cbi8vIFRPRE86IFJlcGxhY2UgdGhpcyBpbiBmYXZvciBvZiBhIGRlY29yYXRvciBpbnN0ZWFkLlxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQ8VD4gKHdoYXQ6IHN0cmluZywgZm46ICguLi5hcmdzKT0+VCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHt3aGF0fSBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9EZXByZWNhdGlvbnMuICR7cHJldHR5U3RhY2soZ2V0RXJyb3JXaXRoU3RhY2soKSwgMSl9YCk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gYXMgKC4uLmFyZ3MpPT5UXG59XG4iLCAiaW1wb3J0IHsgZGVyaXZlLCBzZXRQcm9wIH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldEVycm9yV2l0aFN0YWNrLCBwcmV0dHlTdGFjayB9IGZyb20gJy4uL2hlbHBlcnMvZGVidWcnO1xuXG52YXIgZGV4aWVFcnJvck5hbWVzID0gW1xuICAgICdNb2RpZnknLFxuICAgICdCdWxrJyxcbiAgICAnT3BlbkZhaWxlZCcsXG4gICAgJ1ZlcnNpb25DaGFuZ2UnLFxuICAgICdTY2hlbWEnLFxuICAgICdVcGdyYWRlJyxcbiAgICAnSW52YWxpZFRhYmxlJyxcbiAgICAnTWlzc2luZ0FQSScsXG4gICAgJ05vU3VjaERhdGFiYXNlJyxcbiAgICAnSW52YWxpZEFyZ3VtZW50JyxcbiAgICAnU3ViVHJhbnNhY3Rpb24nLFxuICAgICdVbnN1cHBvcnRlZCcsXG4gICAgJ0ludGVybmFsJyxcbiAgICAnRGF0YWJhc2VDbG9zZWQnLFxuICAgICdQcmVtYXR1cmVDb21taXQnLFxuICAgICdGb3JlaWduQXdhaXQnXG5dO1xuXG52YXIgaWRiRG9tRXJyb3JOYW1lcyA9IFtcbiAgICAnVW5rbm93bicsXG4gICAgJ0NvbnN0cmFpbnQnLFxuICAgICdEYXRhJyxcbiAgICAnVHJhbnNhY3Rpb25JbmFjdGl2ZScsXG4gICAgJ1JlYWRPbmx5JyxcbiAgICAnVmVyc2lvbicsXG4gICAgJ05vdEZvdW5kJyxcbiAgICAnSW52YWxpZFN0YXRlJyxcbiAgICAnSW52YWxpZEFjY2VzcycsXG4gICAgJ0Fib3J0JyxcbiAgICAnVGltZW91dCcsXG4gICAgJ1F1b3RhRXhjZWVkZWQnLFxuICAgICdTeW50YXgnLFxuICAgICdEYXRhQ2xvbmUnXG5dO1xuXG52YXIgZXJyb3JMaXN0ID0gZGV4aWVFcnJvck5hbWVzLmNvbmNhdChpZGJEb21FcnJvck5hbWVzKTtcblxudmFyIGRlZmF1bHRUZXh0cyA9IHtcbiAgICBWZXJzaW9uQ2hhbmdlZDogXCJEYXRhYmFzZSB2ZXJzaW9uIGNoYW5nZWQgYnkgb3RoZXIgZGF0YWJhc2UgY29ubmVjdGlvblwiLFxuICAgIERhdGFiYXNlQ2xvc2VkOiBcIkRhdGFiYXNlIGhhcyBiZWVuIGNsb3NlZFwiLFxuICAgIEFib3J0OiBcIlRyYW5zYWN0aW9uIGFib3J0ZWRcIixcbiAgICBUcmFuc2FjdGlvbkluYWN0aXZlOiBcIlRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGNvbXBsZXRlZCBvciBmYWlsZWRcIixcbiAgICBNaXNzaW5nQVBJOiBcIkluZGV4ZWREQiBBUEkgbWlzc2luZy4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vdGlueXVybC5jb20veTJ1dXZza2JcIlxufTtcblxuLy9cbi8vIERleGllRXJyb3IgLSBiYXNlIGNsYXNzIG9mIGFsbCBvdXQgZXhjZXB0aW9ucy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gRGV4aWVFcnJvciAobmFtZSwgbXNnKSB7XG4gICAgLy8gUmVhc29uIHdlIGRvbid0IHVzZSBFUzYgY2xhc3NlcyBpcyBiZWNhdXNlOlxuICAgIC8vIDEuIEl0IGJsb2F0cyB0cmFuc3BpbGVkIGNvZGUgYW5kIGluY3JlYXNlcyBzaXplIG9mIG1pbmlmaWVkIGNvZGUuXG4gICAgLy8gMi4gSXQgZG9lc24ndCBnaXZlIHVzIG11Y2ggaW4gdGhpcyBjYXNlLlxuICAgIC8vIDMuIEl0IHdvdWxkIHJlcXVpcmUgc3ViIGNsYXNzZXMgdG8gY2FsbCBzdXBlcigpLCB3aGljaFxuICAgIC8vICAgIGlzIG5vdCBuZWVkZWQgd2hlbiBkZXJpdmluZyBmcm9tIEVycm9yLlxuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnO1xufVxuXG5kZXJpdmUoRGV4aWVFcnJvcikuZnJvbShFcnJvcikuZXh0ZW5kKHtcbiAgICBzdGFjazoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YWNrIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuX3N0YWNrID0gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgcHJldHR5U3RhY2sodGhpcy5fZSwgMikpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfVxufSk7XG5cbmZ1bmN0aW9uIGdldE11bHRpRXJyb3JNZXNzYWdlIChtc2csIGZhaWx1cmVzKSB7XG4gICAgcmV0dXJuIG1zZyArIFwiLiBFcnJvcnM6IFwiICsgT2JqZWN0LmtleXMoZmFpbHVyZXMpXG4gICAgICAgIC5tYXAoa2V5PT5mYWlsdXJlc1trZXldLnRvU3RyaW5nKCkpXG4gICAgICAgIC5maWx0ZXIoKHYsaSxzKT0+cy5pbmRleE9mKHYpID09PSBpKSAvLyBPbmx5IHVuaXF1ZSBlcnJvciBzdHJpbmdzXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cblxuLy9cbi8vIE1vZGlmeUVycm9yIC0gdGhyb3duIGluIENvbGxlY3Rpb24ubW9kaWZ5KClcbi8vIFNwZWNpZmljIGNvbnN0cnVjdG9yIGJlY2F1c2UgaXQgY29udGFpbnMgbWVtYmVycyBmYWlsdXJlcyBhbmQgZmFpbGVkS2V5cy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gTW9kaWZ5RXJyb3IgKG1zZywgZmFpbHVyZXMsIHN1Y2Nlc3NDb3VudCwgZmFpbGVkS2V5cykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMuZmFpbHVyZXMgPSBmYWlsdXJlcztcbiAgICB0aGlzLmZhaWxlZEtleXMgPSBmYWlsZWRLZXlzO1xuICAgIHRoaXMuc3VjY2Vzc0NvdW50ID0gc3VjY2Vzc0NvdW50O1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKE1vZGlmeUVycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXG5leHBvcnQgZnVuY3Rpb24gQnVsa0Vycm9yIChtc2csIGZhaWx1cmVzKSB7XG4gICAgdGhpcy5fZSA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgdGhpcy5uYW1lID0gXCJCdWxrRXJyb3JcIjtcbiAgICB0aGlzLmZhaWx1cmVzID0gT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSk7XG4gICAgdGhpcy5mYWlsdXJlc0J5UG9zID0gZmFpbHVyZXM7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TXVsdGlFcnJvck1lc3NhZ2UobXNnLCBmYWlsdXJlcyk7XG59XG5kZXJpdmUoQnVsa0Vycm9yKS5mcm9tKERleGllRXJyb3IpO1xuXG4vL1xuLy9cbi8vIER5bmFtaWNhbGx5IGdlbmVyYXRlIGVycm9yIG5hbWVzIGFuZCBleGNlcHRpb24gY2xhc3NlcyBiYXNlZFxuLy8gb24gdGhlIG5hbWVzIGluIGVycm9yTGlzdC5cbi8vXG4vL1xuXG4vLyBNYXAgb2Yge0Vycm9yTmFtZSAtPiBFcnJvck5hbWUgKyBcIkVycm9yXCJ9XG5leHBvcnQgdmFyIGVycm5hbWVzID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLG5hbWUpPT4ob2JqW25hbWVdPW5hbWUrXCJFcnJvclwiLG9iaikse30pO1xuXG4vLyBOZWVkIGFuIGFsaWFzIGZvciBEZXhpZUVycm9yIGJlY2F1c2Ugd2UncmUgZ29ubmEgY3JlYXRlIHN1YmNsYXNzZXMgd2l0aCB0aGUgc2FtZSBuYW1lLlxuY29uc3QgQmFzZUV4Y2VwdGlvbiA9IERleGllRXJyb3I7XG4vLyBNYXAgb2Yge0Vycm9yTmFtZSAtPiBleGNlcHRpb24gY29uc3RydWN0b3J9XG5leHBvcnQgdmFyIGV4Y2VwdGlvbnMgPSBlcnJvckxpc3QucmVkdWNlKChvYmosbmFtZSk9PntcbiAgICAvLyBMZXQgdGhlIG5hbWUgYmUgXCJEZXhpZUVycm9yXCIgYmVjYXVzZSB0aGlzIG5hbWUgbWF5XG4gICAgLy8gYmUgc2hvd24gaW4gY2FsbCBzdGFjayBhbmQgd2hlbiBkZWJ1Z2dpbmcuIERleGllRXJyb3IgaXNcbiAgICAvLyB0aGUgbW9zdCB0cnVlIG5hbWUgYmVjYXVzZSBpdCBkZXJpdmVzIGZyb20gRGV4aWVFcnJvcixcbiAgICAvLyBhbmQgd2UgY2Fubm90IGNoYW5nZSBGdW5jdGlvbi5uYW1lIHByb2dyYW1hdGljYWxseSB3aXRob3V0XG4gICAgLy8gZHluYW1pY2FsbHkgY3JlYXRlIGEgRnVuY3Rpb24gb2JqZWN0LCB3aGljaCB3b3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gJ2V2YWwtZXZpbCcuXG4gICAgdmFyIGZ1bGxOYW1lID0gbmFtZSArIFwiRXJyb3JcIjtcbiAgICBmdW5jdGlvbiBEZXhpZUVycm9yIChtc2dPcklubmVyLCBpbm5lcil7XG4gICAgICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLm5hbWUgPSBmdWxsTmFtZTtcbiAgICAgICAgaWYgKCFtc2dPcklubmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBkZWZhdWx0VGV4dHNbbmFtZV0gfHwgZnVsbE5hbWU7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXJ9JHshaW5uZXIgPyAnJyA6ICdcXG4gJyArIGlubmVyfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gaW5uZXIgfHwgbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbXNnT3JJbm5lciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21zZ09ySW5uZXIubmFtZX0gJHttc2dPcklubmVyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRoaXMuaW5uZXIgPSBtc2dPcklubmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlcml2ZShEZXhpZUVycm9yKS5mcm9tKEJhc2VFeGNlcHRpb24pO1xuICAgIG9ialtuYW1lXT1EZXhpZUVycm9yO1xuICAgIHJldHVybiBvYmo7XG59LHt9KTtcblxuLy8gVXNlIEVDTUFTQ1JJUFQgc3RhbmRhcmQgZXhjZXB0aW9ucyB3aGVyZSBhcHBsaWNhYmxlOlxuZXhjZXB0aW9ucy5TeW50YXggPSBTeW50YXhFcnJvcjtcbmV4Y2VwdGlvbnMuVHlwZSA9IFR5cGVFcnJvcjtcbmV4Y2VwdGlvbnMuUmFuZ2UgPSBSYW5nZUVycm9yO1xuXG5leHBvcnQgdmFyIGV4Y2VwdGlvbk1hcCA9IGlkYkRvbUVycm9yTmFtZXMucmVkdWNlKChvYmosIG5hbWUpPT57XG4gICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwRXJyb3IgKGRvbUVycm9yLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFkb21FcnJvciB8fCBkb21FcnJvciBpbnN0YW5jZW9mIERleGllRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvciB8fCAhZG9tRXJyb3IubmFtZSB8fCAhZXhjZXB0aW9uTWFwW2RvbUVycm9yLm5hbWVdKVxuICAgICAgICByZXR1cm4gZG9tRXJyb3I7XG4gICAgdmFyIHJ2ID0gbmV3IGV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXShtZXNzYWdlIHx8IGRvbUVycm9yLm1lc3NhZ2UsIGRvbUVycm9yKTtcbiAgICBpZiAoXCJzdGFja1wiIGluIGRvbUVycm9yKSB7XG4gICAgICAgIC8vIERlcml2ZSBzdGFjayBmcm9tIGlubmVyIGV4Y2VwdGlvbiBpZiBpdCBoYXMgYSBzdGFja1xuICAgICAgICBzZXRQcm9wKHJ2LCBcInN0YWNrXCIsIHtnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbm5lci5zdGFjaztcbiAgICAgICAgfX0pO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmV4cG9ydCB2YXIgZnVsbE5hbWVFeGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLCBuYW1lKT0+e1xuICAgIGlmIChbXCJTeW50YXhcIixcIlR5cGVcIixcIlJhbmdlXCJdLmluZGV4T2YobmFtZSkgPT09IC0xKVxuICAgICAgICBvYmpbbmFtZSArIFwiRXJyb3JcIl0gPSBleGNlcHRpb25zW25hbWVdO1xuICAgIHJldHVybiBvYmo7XG59LCB7fSk7XG5cbmZ1bGxOYW1lRXhjZXB0aW9ucy5Nb2RpZnlFcnJvciA9IE1vZGlmeUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkRleGllRXJyb3IgPSBEZXhpZUVycm9yO1xuZnVsbE5hbWVFeGNlcHRpb25zLkJ1bGtFcnJvciA9IEJ1bGtFcnJvcjtcbiIsICJpbXBvcnQge2V4dGVuZH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3AoKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBtaXJyb3IodmFsKSB7IHJldHVybiB2YWw7IH1cbmV4cG9ydCBmdW5jdGlvbiBwdXJlRnVuY3Rpb25DaGFpbihmMSwgZjIpIHtcbiAgICAvLyBFbmFibGVzIGNoYWluZWQgZXZlbnRzIHRoYXQgdGFrZXMgT05FIGFyZ3VtZW50IGFuZCByZXR1cm5zIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uIGluIGNoYWluLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwicmVhZGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT0gbnVsbCB8fCBmMSA9PT0gbWlycm9yKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIGYyKGYxKHZhbCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsQm90aChvbjEsIG9uMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9va0NyZWF0aW5nQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIHNldmVyYWwgYXJndW1lbnRzIGFuZCBtYXkgbW9kaWZ5IGZpcnN0IGFyZ3VtZW50IGJ5IG1ha2luZyBhIG1vZGlmaWNhdGlvbiBhbmQgdGhlbiByZXR1cm5pbmcgdGhlIHNhbWUgaW5zdGFuY2UuXG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHVzZWQgaW4gdGhlIGhvb2soXCJjcmVhdGluZ1wiKSBldmVudC5cbiAgICBpZiAoZjEgPT09IG5vcCkgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIGFyZ3VtZW50c1swXSA9IHJlcztcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdmFyIHJlczIgPSBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAob25zdWNjZXNzKSB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzID8gY2FsbEJvdGgob25zdWNjZXNzLCB0aGlzLm9uc3VjY2VzcykgOiBvbnN1Y2Nlc3M7XG4gICAgICAgIGlmIChvbmVycm9yKSB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IgPyBjYWxsQm90aChvbmVycm9yLCB0aGlzLm9uZXJyb3IpIDogb25lcnJvcjtcbiAgICAgICAgcmV0dXJuIHJlczIgIT09IHVuZGVmaW5lZCA/IHJlczIgOiByZXM7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tEZWxldGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIG9uc3VjY2VzcyA9IHRoaXMub25zdWNjZXNzLCAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbnN1Y2Nlc3NcbiAgICAgICAgICAgIG9uZXJyb3IgPSB0aGlzLm9uZXJyb3I7ICAgICAvLyBJbiBjYXNlIGV2ZW50IGxpc3RlbmVyIGhhcyBzZXQgdGhpcy5vbmVycm9yXG4gICAgICAgIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tVcGRhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZmljYXRpb25zKSB7XG4gICAgICAgIHZhciByZXMgPSBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBleHRlbmQobW9kaWZpY2F0aW9ucywgcmVzKTsgLy8gSWYgZjEgcmV0dXJucyBuZXcgbW9kaWZpY2F0aW9ucywgZXh0ZW5kIGNhbGxlcidzIG1vZGlmaWNhdGlvbnMgd2l0aCB0aGUgcmVzdWx0IGJlZm9yZSBjYWxsaW5nIG5leHQgaW4gY2hhaW4uXG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAgICAgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25lcnJvclxuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAocmVzMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVzMikgOlxuICAgICAgICAgICAgKGV4dGVuZChyZXMsIHJlczIpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vblN0b3BwYWJsZUV2ZW50Q2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNhYmxlQ2hhaW4oZjEsIGYyKSB7XG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciB0aGl6ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIHJldHVybiByZXMudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXosIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbiIsICIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcgRGF2aWQgRmFobGFuZGVyXG4gKiBBcGFjaGUgTGljZW5zZSBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0LCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuaW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsJztcbmltcG9ydCB7dHJ5Q2F0Y2gsIHByb3BzLCBzZXRQcm9wLCBfZ2xvYmFsLFxuICAgIGdldFByb3BlcnR5RGVzY3JpcHRvciwgZ2V0QXJyYXlPZiwgZXh0ZW5kLCBnZXRQcm90b30gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7bm9wLCBjYWxsQm90aCwgbWlycm9yfSBmcm9tICcuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7ZGVidWcsIHByZXR0eVN0YWNrLCBnZXRFcnJvcldpdGhTdGFja30gZnJvbSAnLi9kZWJ1Zyc7XG5pbXBvcnQge2V4Y2VwdGlvbnN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbi8vXG4vLyBQcm9taXNlIGFuZCBab25lIChQU0QpIGZvciBEZXhpZSBsaWJyYXJ5XG4vL1xuLy8gSSBzdGFydGVkIG91dCB3cml0aW5nIHRoaXMgUHJvbWlzZSBjbGFzcyBieSBjb3B5aW5nIHByb21pc2UtbGlnaHQgKGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcy9wcm9taXNlLWxpZ2h0KSBieVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RheWxvcmhha2VzIC0gYW4gQSsgYW5kIEVDTUFTQ1JJUFQgNiBjb21wbGlhbnQgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbi5cbi8vXG4vLyBJbiBwcmV2aW91cyB2ZXJzaW9ucyB0aGlzIHdhcyBmaXhlZCBieSBub3QgY2FsbGluZyBzZXRUaW1lb3V0IHdoZW4ga25vd2luZyB0aGF0IHRoZSByZXNvbHZlKCkgb3IgcmVqZWN0KCkgY2FtZSBmcm9tIGFub3RoZXJcbi8vIHRpY2suIEluIERleGllIHYxLjQuMCwgSSd2ZSByZXdyaXR0ZW4gdGhlIFByb21pc2UgY2xhc3MgZW50aXJlbHkuIEp1c3Qgc29tZSBmcmFnbWVudHMgb2YgcHJvbWlzZS1saWdodCBpcyBsZWZ0LiBJIHVzZVxuLy8gYW5vdGhlciBzdHJhdGVneSBub3cgdGhhdCBzaW1wbGlmaWVzIGV2ZXJ5dGhpbmcgYSBsb3Q6IHRvIGFsd2F5cyBleGVjdXRlIGNhbGxiYWNrcyBpbiBhIG5ldyBtaWNyby10YXNrLCBidXQgaGF2ZSBhbiBvd24gbWljcm8tdGFza1xuLy8gZW5naW5lIHRoYXQgaXMgaW5kZXhlZERCIGNvbXBsaWFudCBhY3Jvc3MgYWxsIGJyb3dzZXJzLlxuLy8gUHJvbWlzZSBjbGFzcyBoYXMgYWxzbyBiZWVuIG9wdGltaXplZCBhIGxvdCB3aXRoIGluc3BpcmF0aW9uIGZyb20gYmx1ZWJpcmQgLSB0byBhdm9pZCBjbG9zdXJlcyBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuLy8gQWxzbyB3aXRoIGluc3BpcmF0aW9uIGZyb20gYmx1ZWJpcmQsIGFzeW5jcm9uaWMgc3RhY2tzIGluIGRlYnVnIG1vZGUuXG4vL1xuLy8gU3BlY2lmaWMgbm9uLXN0YW5kYXJkIGZlYXR1cmVzIG9mIHRoaXMgUHJvbWlzZSBjbGFzczpcbi8vICogQ3VzdG9tIHpvbmUgc3VwcG9ydCAoYS5rLmEuIFBTRCkgd2l0aCBhYmlsaXR5IHRvIGtlZXAgem9uZXMgYWxzbyB3aGVuIHVzaW5nIG5hdGl2ZSBwcm9taXNlcyBhcyB3ZWxsIGFzXG4vLyAgIG5hdGl2ZSBhc3luYyAvIGF3YWl0LlxuLy8gKiBQcm9taXNlLmZvbGxvdygpIG1ldGhvZCBidWlsdCB1cG9uIHRoZSBjdXN0b20gem9uZSBlbmdpbmUsIHRoYXQgYWxsb3dzIHVzZXIgdG8gdHJhY2sgYWxsIHByb21pc2VzIGNyZWF0ZWQgZnJvbSBjdXJyZW50IHN0YWNrIGZyYW1lXG4vLyAgIGFuZCBiZWxvdyArIGFsbCBwcm9taXNlcyB0aGF0IHRob3NlIHByb21pc2VzIGNyZWF0ZXMgb3IgYXdhaXRzLlxuLy8gKiBEZXRlY3QgYW55IHVuaGFuZGxlZCBwcm9taXNlIGluIGEgUFNELXNjb3BlIChQU0Qub251bmhhbmRsZWQpLiBcbi8vXG4vLyBEYXZpZCBGYWhsYW5kZXIsIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyXG4vL1xuXG4vLyBKdXN0IGEgcG9pbnRlciB0aGF0IG9ubHkgdGhpcyBtb2R1bGUga25vd3MgYWJvdXQuXG4vLyBVc2VkIGluIFByb21pc2UgY29uc3RydWN0b3IgdG8gZW11bGF0ZSBhIHByaXZhdGUgY29uc3RydWN0b3IuXG52YXIgSU5URVJOQUwgPSB7fTtcblxuLy8gQXN5bmMgc3RhY2tzIChsb25nIHN0YWNrcykgbXVzdCBub3QgZ3JvdyBpbmZpbml0ZWx5LlxuY29uc3RcbiAgICBMT05HX1NUQUNLU19DTElQX0xJTUlUID0gMTAwLFxuICAgIC8vIFdoZW4gY2FsbGluZyBlcnJvci5zdGFjayBvciBwcm9taXNlLnN0YWNrLCBsaW1pdCB0aGUgbnVtYmVyIG9mIGFzeW5jcm9uaWMgc3RhY2tzIHRvIHByaW50IG91dC4gXG4gICAgTUFYX0xPTkdfU1RBQ0tTID0gMjAsXG4gICAgWk9ORV9FQ0hPX0xJTUlUID0gMTAwLFxuICAgIFtyZXNvbHZlZE5hdGl2ZVByb21pc2UsIG5hdGl2ZVByb21pc2VQcm90bywgcmVzb2x2ZWRHbG9iYWxQcm9taXNlXSA9IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/XG4gICAgICAgIFtdIDpcbiAgICAgICAgKCgpPT57XG4gICAgICAgICAgICBsZXQgZ2xvYmFsUCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnIHx8ICFjcnlwdG8uc3VidGxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBbZ2xvYmFsUCwgZ2V0UHJvdG8oZ2xvYmFsUCksIGdsb2JhbFBdO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuYXRpdmUgcHJvbWlzZSAoYXMgd2luZG93LlByb21pc2UgbWF5IGhhdmUgYmVlbiBwYXRjaGVkKVxuICAgICAgICAgICAgY29uc3QgbmF0aXZlUCA9IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTUxMlwiLCBuZXcgVWludDhBcnJheShbMF0pKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbmF0aXZlUCxcbiAgICAgICAgICAgICAgICBnZXRQcm90byhuYXRpdmVQKSxcbiAgICAgICAgICAgICAgICBnbG9iYWxQXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSgpLFxuICAgIG5hdGl2ZVByb21pc2VUaGVuID0gbmF0aXZlUHJvbWlzZVByb3RvICYmIG5hdGl2ZVByb21pc2VQcm90by50aGVuO1xuXG5leHBvcnQgY29uc3QgTmF0aXZlUHJvbWlzZSA9IHJlc29sdmVkTmF0aXZlUHJvbWlzZSAmJiByZXNvbHZlZE5hdGl2ZVByb21pc2UuY29uc3RydWN0b3I7XG5jb25zdCBwYXRjaEdsb2JhbFByb21pc2UgPSAhIXJlc29sdmVkR2xvYmFsUHJvbWlzZTtcblxudmFyIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xuXG4vKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB1c2VkIG9ubHkgZm9yIHRoZSB2ZXJ5IGZpcnN0IHByb21pc2UgaW4gYSBwcm9taXNlIGNoYWluLlxuICAgQXMgc29vbiBhcyB0aGVuIHByb21pc2UgaXMgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQsIGFsbCBuZXh0IHRhc2tzIHdpbGwgYmUgZXhlY3V0ZWQgaW4gbWljcm8gdGlja3NcbiAgIGVtdWxhdGVkIGluIHRoaXMgbW9kdWxlLiBGb3IgaW5kZXhlZERCIGNvbXBhdGliaWxpdHksIHRoaXMgbWVhbnMgdGhhdCBldmVyeSBtZXRob2QgbmVlZHMgdG8gXG4gICBleGVjdXRlIGF0IGxlYXN0IG9uZSBwcm9taXNlIGJlZm9yZSBkb2luZyBhbiBpbmRleGVkREIgb3BlcmF0aW9uLiBEZXhpZSB3aWxsIGFsd2F5cyBjYWxsIFxuICAgZGIucmVhZHkoKS50aGVuKCkgZm9yIGV2ZXJ5IG9wZXJhdGlvbiB0byBtYWtlIHN1cmUgdGhlIGluZGV4ZWREQiBldmVudCBpcyBzdGFydGVkIGluIGFuXG4gICBpbmRleGVkREItY29tcGF0aWJsZSBlbXVsYXRlZCBtaWNybyB0YXNrIGxvb3AuXG4qL1xudmFyIHNjaGVkdWxlUGh5c2ljYWxUaWNrID0gcmVzb2x2ZWRHbG9iYWxQcm9taXNlID9cbiAgICAoKSA9PiB7cmVzb2x2ZWRHbG9iYWxQcm9taXNlLnRoZW4ocGh5c2ljYWxUaWNrKTt9XG4gICAgOlxuICAgIF9nbG9iYWwuc2V0SW1tZWRpYXRlID8gXG4gICAgICAgIC8vIHNldEltbWVkaWF0ZSBzdXBwb3J0ZWQuIFRob3NlIG1vZGVybiBwbGF0Zm9ybXMgYWxzbyBzdXBwb3J0cyBGdW5jdGlvbi5iaW5kKCkuXG4gICAgICAgIHNldEltbWVkaWF0ZS5iaW5kKG51bGwsIHBoeXNpY2FsVGljaykgOlxuICAgICAgICBfZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgP1xuICAgICAgICAgICAgLy8gTXV0YXRpb25PYnNlcnZlciBzdXBwb3J0ZWRcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgaGlkZGVuRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICAobmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwaHlzaWNhbFRpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRGl2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSkub2JzZXJ2ZShoaWRkZW5EaXYsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBoaWRkZW5EaXYuc2V0QXR0cmlidXRlKCdpJywgJzEnKTtcbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3Igc2V0SW1tZWRpYXRlIG9yIE11dGF0aW9uT2JzZXJ2ZXIuIE5vIHdvcnJ5LCBzZXRUaW1lb3V0IGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyBvbmNlIHRpbWUuIEV2ZXJ5IHRpY2sgdGhhdCBmb2xsb3dzIHdpbGwgYmUgb3VyIGVtdWxhdGVkIG1pY3JvIHRpY2suXG4gICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHVzZXMgc2V0VGltZW91dC5iaW5kKG51bGwsIDAsIHBoeXNpY2FsVGljaykgaWYgaXQgd2FzbnQgZm9yIHRoYXQgRkYxMyBhbmQgYmVsb3cgaGFzIGEgYnVnIFxuICAgICAgICAgICAgKCk9PntzZXRUaW1lb3V0KHBoeXNpY2FsVGljaywwKTt9O1xuXG4vLyBDb25maWd1cmFibGUgdGhyb3VnaCBQcm9taXNlLnNjaGVkdWxlci5cbi8vIERvbid0IGV4cG9ydCBiZWNhdXNlIGl0IHdvdWxkIGJlIHVuc2FmZSB0byBsZXQgdW5rbm93blxuLy8gY29kZSBjYWxsIGl0IHVubGVzcyB0aGV5IGRvIHRyeS4uY2F0Y2ggd2l0aGluIHRoZWlyIGNhbGxiYWNrLlxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggZ2V0dGVyIG9mIFByb21pc2Uuc2NoZWR1bGVyIHRob3VnaCxcbi8vIGJ1dCB1c2VycyBtdXN0IG5vdCBkbyBQcm9taXNlLnNjaGVkdWxlciA9IG15RnVuY1RoYXRUaHJvd3NFeGNlcHRpb25cbnZhciBhc2FwID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcmdzKSB7XG4gICAgbWljcm90aWNrUXVldWUucHVzaChbY2FsbGJhY2ssIGFyZ3NdKTtcbiAgICBpZiAobmVlZHNOZXdQaHlzaWNhbFRpY2spIHtcbiAgICAgICAgc2NoZWR1bGVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICB9XG59O1xuXG52YXIgaXNPdXRzaWRlTWljcm9UaWNrID0gdHJ1ZSwgLy8gVHJ1ZSB3aGVuIE5PVCBpbiBhIHZpcnR1YWwgbWljcm9UaWNrLlxuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZSwgLy8gVHJ1ZSB3aGVuIGEgcHVzaCB0byBtaWNyb3RpY2tRdWV1ZSBtdXN0IGFsc28gc2NoZWR1bGVQaHlzaWNhbFRpY2soKVxuICAgIHVuaGFuZGxlZEVycm9ycyA9IFtdLCAvLyBSZWplY3RlZCBwcm9taXNlcyB0aGF0IGhhcyBvY2N1cmVkLiBVc2VkIGZvciB0cmlnZ2VyaW5nICd1bmhhbmRsZWRyZWplY3Rpb24nLlxuICAgIHJlamVjdGluZ0Vycm9ycyA9IFtdLCAvLyBUcmFja3MgaWYgZXJyb3JzIGFyZSBiZWluZyByZS1yZWplY3RlZCBkdXJpbmcgb25SZWplY3RlZCBjYWxsYmFjay5cbiAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbCxcbiAgICByZWplY3Rpb25NYXBwZXIgPSBtaXJyb3I7IC8vIFJlbW92ZSBpbiBuZXh0IG1ham9yIHdoZW4gcmVtb3ZpbmcgZXJyb3IgbWFwcGluZyBvZiBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnNcbiAgICBcbmV4cG9ydCB2YXIgZ2xvYmFsUFNEID0ge1xuICAgIGlkOiAnZ2xvYmFsJyxcbiAgICBnbG9iYWw6IHRydWUsXG4gICAgcmVmOiAwLFxuICAgIHVuaGFuZGxlZHM6IFtdLFxuICAgIG9udW5oYW5kbGVkOiBnbG9iYWxFcnJvcixcbiAgICBwZ3A6IGZhbHNlLFxuICAgIGVudjoge30sXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bmhhbmRsZWRzLmZvckVhY2godWggPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxFcnJvcih1aFswXSwgdWhbMV0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZXhwb3J0IHZhciBQU0QgPSBnbG9iYWxQU0Q7XG5cbmV4cG9ydCB2YXIgbWljcm90aWNrUXVldWUgPSBbXTsgLy8gQ2FsbGJhY2tzIHRvIGNhbGwgaW4gdGhpcyBvciBuZXh0IHBoeXNpY2FsIHRpY2suXG5leHBvcnQgdmFyIG51bVNjaGVkdWxlZENhbGxzID0gMDsgLy8gTnVtYmVyIG9mIGxpc3RlbmVyLWNhbGxzIGxlZnQgdG8gZG8gaW4gdGhpcyBwaHlzaWNhbCB0aWNrLlxuZXhwb3J0IHZhciB0aWNrRmluYWxpemVycyA9IFtdOyAvLyBGaW5hbGl6ZXJzIHRvIGNhbGwgd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBhc3luYyBjYWxscyBzY2hlZHVsZWQgd2l0aGluIGN1cnJlbnQgcGh5c2ljYWwgdGljay5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGV4aWVQcm9taXNlKGZuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7ICAgIFxuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMub251bmNhdGNoZWQgPSBub3A7IC8vIERlcHJlY2F0ZSBpbiBuZXh0IG1ham9yLiBOb3QgbmVlZGVkLiBCZXR0ZXIgdG8gdXNlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgIFxuICAgIC8vIEEgbGlicmFyeSBtYXkgc2V0IGBwcm9taXNlLl9saWIgPSB0cnVlO2AgYWZ0ZXIgcHJvbWlzZSBpcyBjcmVhdGVkIHRvIG1ha2UgcmVzb2x2ZSgpIG9yIHJlamVjdCgpXG4gICAgLy8gZXhlY3V0ZSB0aGUgbWljcm90YXNrIGVuZ2luZSBpbXBsaWNpdGVseSB3aXRoaW4gdGhlIGNhbGwgdG8gcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFRvIHJlbWFpbiBBKyBjb21wbGlhbnQsIGEgbGlicmFyeSBtdXN0IG9ubHkgc2V0IGBfbGliPXRydWVgIGlmIGl0IGNhbiBndWFyYW50ZWUgdGhhdCB0aGUgc3RhY2tcbiAgICAvLyBvbmx5IGNvbnRhaW5zIGxpYnJhcnkgY29kZSB3aGVuIGNhbGxpbmcgcmVzb2x2ZSgpIG9yIHJlamVjdCgpLlxuICAgIC8vIFJVTEUgT0YgVEhVTUI6IE9OTFkgc2V0IF9saWIgPSB0cnVlIGZvciBwcm9taXNlcyBleHBsaWNpdGVseSByZXNvbHZpbmcvcmVqZWN0aW5nIGRpcmVjdGx5IGZyb21cbiAgICAvLyBnbG9iYWwgc2NvcGUgKGV2ZW50IGhhbmRsZXIsIHRpbWVyIGV0YykhXG4gICAgdGhpcy5fbGliID0gZmFsc2U7XG4gICAgLy8gQ3VycmVudCBhc3luYyBzY29wZVxuICAgIHZhciBwc2QgPSAodGhpcy5fUFNEID0gUFNEKTtcblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICB0aGlzLl9zdGFja0hvbGRlciA9IGdldEVycm9yV2l0aFN0YWNrKCk7XG4gICAgICAgIHRoaXMuX3ByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1QcmV2ID0gMDsgLy8gTnVtYmVyIG9mIHByZXZpb3VzIHByb21pc2VzIChmb3IgbG9uZyBzdGFja3MpXG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGZuICE9PSBJTlRFUk5BTCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgLy8gUHJpdmF0ZSBjb25zdHJ1Y3RvciAoSU5URVJOQUwsIHN0YXRlLCB2YWx1ZSkuXG4gICAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBieSBQcm9taXNlLnJlc29sdmUoKSBhbmQgUHJvbWlzZS5yZWplY3QoKS5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0aW9uKHRoaXMsIHRoaXMuX3ZhbHVlKTsgLy8gTWFwIGVycm9yLCBzZXQgc3RhY2sgYW5kIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IoKS5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLl9zdGF0ZSA9IG51bGw7IC8vIG51bGwgKD1wZW5kaW5nKSwgZmFsc2UgKD1yZWplY3RlZCkgb3IgdHJ1ZSAoPXJlc29sdmVkKVxuICAgIHRoaXMuX3ZhbHVlID0gbnVsbDsgLy8gZXJyb3Igb3IgcmVzdWx0XG4gICAgKytwc2QucmVmOyAvLyBSZWZjb3VudGluZyBjdXJyZW50IHNjb3BlXG4gICAgZXhlY3V0ZVByb21pc2VUYXNrKHRoaXMsIGZuKTtcbn1cblxuLy8gUHJlcGFyZSBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gcHV0IG9udG8gUHJvbWlzZS5wcm90b3R5cGUudGhlblxuY29uc3QgdGhlblByb3AgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBzZCA9IFBTRCwgbWljcm9UYXNrSWQgPSB0b3RhbEVjaG9lcztcblxuICAgICAgICBmdW5jdGlvbiB0aGVuIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIHBvc3NpYmxlQXdhaXQgPSAhcHNkLmdsb2JhbCAmJiAocHNkICE9PSBQU0QgfHwgbWljcm9UYXNrSWQgIT09IHRvdGFsRWNob2VzKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBwb3NzaWJsZUF3YWl0ICYmICFkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgdmFyIHJ2ID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcih0aGlzLCBuZXcgTGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25GdWxmaWxsZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgcHNkLCBwb3NzaWJsZUF3YWl0LCBjbGVhbnVwKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBwc2QpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVidWcgJiYgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBydjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoZW4ucHJvdG90eXBlID0gSU5URVJOQUw7IC8vIEZvciBpZGVtcG90ZW5zZSwgc2VlIHNldHRlciBiZWxvdy5cblxuICAgICAgICByZXR1cm4gdGhlbjtcbiAgICB9LFxuICAgIC8vIEJlIGlkZW1wb3RlbnQgYW5kIGFsbG93IGFub3RoZXIgZnJhbWV3b3JrIChzdWNoIGFzIHpvbmUuanMgb3IgYW5vdGhlciBpbnN0YW5jZSBvZiBhIERleGllLlByb21pc2UgbW9kdWxlKSB0byByZXBsYWNlIFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICAvLyBhbmQgd2hlbiB0aGF0IGZyYW1ld29yayB3YW50cyB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSwgd2UgbXVzdCBpZGVudGlmeSB0aGF0IGFuZCByZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZXNjcmlwdG9yLlxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHNldFByb3AgKHRoaXMsICd0aGVuJywgdmFsdWUgJiYgdmFsdWUucHJvdG90eXBlID09PSBJTlRFUk5BTCA/XG4gICAgICAgICAgICB0aGVuUHJvcCA6IC8vIFJlc3RvcmUgdG8gb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsgLy8gR2V0dGVyIHJldHVybmluZyBwcm92aWRlZCB2YWx1ZSAoYmVoYXZlcyBsaWtlIHZhbHVlIGlzIGp1c3QgY2hhbmdlZClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogdGhlblByb3Auc2V0IC8vIEtlZXAgYSBzZXR0ZXIgdGhhdCBpcyBwcmVwYXJlZCB0byByZXN0b3JlIG9yaWdpbmFsLlxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnByb3BzKERleGllUHJvbWlzZS5wcm90b3R5cGUsIHtcbiAgICB0aGVuOiB0aGVuUHJvcCwgLy8gRGVmaW5lZCBhYm92ZS5cbiAgICBfdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIEEgbGl0dGxlIHRpbmllciB2ZXJzaW9uIG9mIHRoZW4oKSB0aGF0IGRvbid0IGhhdmUgdG8gY3JlYXRlIGEgcmVzdWx0aW5nIHByb21pc2UuXG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKG51bGwsIG51bGwsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBQU0QpKTsgICAgICAgIFxuICAgIH0sXG5cbiAgICBjYXRjaDogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIC8vIEZpcnN0IGFyZ3VtZW50IGlzIHRoZSBFcnJvciB0eXBlIHRvIGNhdGNoXG4gICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgaGFuZGxlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IGl0cyBjb25zdHJ1Y3RvciB0eXBlIChzaW1pbGFyIHRvIGphdmEgLyBjKysgLyBjIylcbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaChUeXBlRXJyb3IsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIHR5cGUgPyBoYW5kbGVyKGVycikgOiBQcm9taXNlUmVqZWN0KGVycikpXG4gICAgICAgIDogdGhpcy50aGVuKG51bGwsIGVyciA9PlxuICAgICAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIGJ5IHRoZSBlcnJvci5uYW1lIHByb3BlcnR5LiBNYWtlcyBzZW5zZSBmb3IgaW5kZXhlZERCIHdoZXJlIGVycm9yIHR5cGVcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBET01FcnJvciBidXQgd2hlcmUgZS5uYW1lIHRlbGxzIHRoZSBhY3R1YWwgZXJyb3IgdHlwZS5cbiAgICAgICAgICAgIC8vIFNhbXBsZTogcHJvbWlzZS5jYXRjaCgnQ29uc3RyYWludEVycm9yJywgZnVuY3Rpb24gKGUpIHsgLi4uIH0pO1xuICAgICAgICAgICAgZXJyICYmIGVyci5uYW1lID09PSB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKTtcbiAgICB9LFxuXG4gICAgZmluYWxseTogZnVuY3Rpb24gKG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHN0YWNrOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhY2spIHJldHVybiB0aGlzLl9zdGFjaztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2tzID0gZ2V0U3RhY2sgKHRoaXMsIFtdLCBNQVhfTE9OR19TVEFDS1MpO1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IHN0YWNrcy5qb2luKFwiXFxuRnJvbSBwcmV2aW91czogXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gbnVsbCkgdGhpcy5fc3RhY2sgPSBzdGFjazsgLy8gU3RhY2sgbWF5IGJlIHVwZGF0ZWQgb24gcmVqZWN0LlxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZW91dDogZnVuY3Rpb24gKG1zLCBtc2cpIHtcbiAgICAgICAgcmV0dXJuIG1zIDwgSW5maW5pdHkgP1xuICAgICAgICAgICAgbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBleGNlcHRpb25zLlRpbWVvdXQobXNnKSksIG1zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KS5maW5hbGx5KGNsZWFyVGltZW91dC5iaW5kKG51bGwsIGhhbmRsZSkpO1xuICAgICAgICAgICAgfSkgOiB0aGlzO1xuICAgIH1cbn0pO1xuXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgIHNldFByb3AoRGV4aWVQcm9taXNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCAnRGV4aWUuUHJvbWlzZScpO1xuXG4vLyBOb3cgdGhhdCBQcm9taXNlLnByb3RvdHlwZSBpcyBkZWZpbmVkLCB3ZSBoYXZlIGFsbCBpdCB0YWtlcyB0byBzZXQgZ2xvYmFsUFNELmVudi5cbi8vIEVudmlyb25tZW50IGdsb2JhbHMgc25hcHNob3R0ZWQgb24gbGVhdmluZyBnbG9iYWwgem9uZVxuZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cbmZ1bmN0aW9uIExpc3RlbmVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QsIHpvbmUpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICAgIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICB0aGlzLnBzZCA9IHpvbmU7XG59XG5cbi8vIFByb21pc2UgU3RhdGljIFByb3BlcnRpZXNcbnByb3BzIChEZXhpZVByb21pc2UsIHtcbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKSAvLyBTdXBwb3J0cyBpdGVyYWJsZXMsIGltcGxpY2l0IGFyZ3VtZW50cyBhbmQgYXJyYXktbGlrZS5cbiAgICAgICAgICAgIC5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTsgLy8gSGFuZGxlIHBhcmFsbGVsbCBhc3luYy9hd2FpdHMgXG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKGEsaSkgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUoYSkudGhlbih4ID0+IHtcbiAgICAgICAgICAgICAgICB2YWx1ZXNbaV0gPSB4O1xuICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHJlc29sdmU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgbGlua1RvUHJldmlvdXNQcm9taXNlKHJ2LCBjdXJyZW50RnVsZmlsbGVyKTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH0sXG4gICAgXG4gICAgcmVqZWN0OiBQcm9taXNlUmVqZWN0LFxuICAgIFxuICAgIHJhY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzLm1hcCh2YWx1ZSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIFBTRDoge1xuICAgICAgICBnZXQ6ICgpPT5QU0QsXG4gICAgICAgIHNldDogdmFsdWUgPT4gUFNEID0gdmFsdWVcbiAgICB9LFxuXG4gICAgdG90YWxFY2hvZXM6IHtnZXQ6ICgpPT50b3RhbEVjaG9lc30sXG5cbiAgICAvL3Rhc2s6IHtnZXQ6ICgpPT50YXNrfSxcbiAgICBcbiAgICBuZXdQU0Q6IG5ld1Njb3BlLFxuICAgIFxuICAgIHVzZVBTRDogdXNlUFNELFxuICAgIFxuICAgIHNjaGVkdWxlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IGFzYXAsXG4gICAgICAgIHNldDogdmFsdWUgPT4ge2FzYXAgPSB2YWx1ZX1cbiAgICB9LFxuICAgIFxuICAgIHJlamVjdGlvbk1hcHBlcjoge1xuICAgICAgICBnZXQ6ICgpID0+IHJlamVjdGlvbk1hcHBlcixcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7cmVqZWN0aW9uTWFwcGVyID0gdmFsdWU7fSAvLyBNYXAgcmVqZWN0IGZhaWx1cmVzXG4gICAgfSxcbiAgICAgICAgICAgIFxuICAgIGZvbGxvdzogKGZuLCB6b25lUHJvcHMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ld1Njb3BlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcHNkID0gUFNEO1xuICAgICAgICAgICAgICAgIHBzZC51bmhhbmRsZWRzID0gW107IC8vIEZvciB1bmhhbmRsZWQgc3RhbmRhcmQtIG9yIDNyZCBwYXJ0eSBQcm9taXNlcy4gQ2hlY2tlZCBhdCBwc2QuZmluYWxpemUoKVxuICAgICAgICAgICAgICAgIHBzZC5vbnVuaGFuZGxlZCA9IHJlamVjdDsgLy8gVHJpZ2dlcmVkIGRpcmVjdGx5IG9uIHVuaGFuZGxlZCBwcm9taXNlcyBvZiB0aGlzIGxpYnJhcnkuXG4gICAgICAgICAgICAgICAgcHNkLmZpbmFsaXplID0gY2FsbEJvdGgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmhhbmRsZWQgc3RhbmRhcmQgb3IgM3JkIHBhcnQgcHJvbWlzZXMgYXJlIHB1dCBpbiBQU0QudW5oYW5kbGVkcyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbWluZWQgdXBvbiBzY29wZSBjb21wbGV0aW9uIHdoaWxlIHVuaGFuZGxlZCByZWplY3Rpb25zIGluIHRoaXMgUHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHRyaWdnZXIgZGlyZWN0bHkgdGhyb3VnaCBwc2Qub251bmhhbmRsZWRcbiAgICAgICAgICAgICAgICAgICAgcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljaygoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmhhbmRsZWRzLmxlbmd0aCA9PT0gMCA/IHJlc29sdmUoKSA6IHJlamVjdCh0aGlzLnVuaGFuZGxlZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBwc2QuZmluYWxpemUpO1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9LCB6b25lUHJvcHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5pZiAoTmF0aXZlUHJvbWlzZSkge1xuICAgIGlmIChOYXRpdmVQcm9taXNlLmFsbFNldHRsZWQpIHNldFByb3AgKERleGllUHJvbWlzZSwgXCJhbGxTZXR0bGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVByb21pc2VzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oXG4gICAgICAgICAgICAgICAgdmFsdWUgPT4gcmVzdWx0c1tpXSA9IHtzdGF0dXM6IFwiZnVsZmlsbGVkXCIsIHZhbHVlfSxcbiAgICAgICAgICAgICAgICByZWFzb24gPT4gcmVzdWx0c1tpXSA9IHtzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29ufSlcbiAgICAgICAgICAgICAgICAudGhlbigoKT0+LS1yZW1haW5pbmcgfHwgcmVzb2x2ZShyZXN1bHRzKSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbnkgJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSAndW5kZWZpbmVkJykgc2V0UHJvcChEZXhpZVByb21pc2UsIFwiYW55XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBwb3NzaWJsZVByb21pc2VzID0gZ2V0QXJyYXlPZi5hcHBseShudWxsLCBhcmd1bWVudHMpLm1hcChvblBvc3NpYmxlUGFyYWxsZWxsQXN5bmMpO1xuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10pKTtcbiAgICAgICAgICAgIGxldCByZW1haW5pbmcgPSBwb3NzaWJsZVByb21pc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbmV3IEFycmF5KHJlbWFpbmluZyk7XG4gICAgICAgICAgICBwb3NzaWJsZVByb21pc2VzLmZvckVhY2goKHAsIGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKHApLnRoZW4oXG4gICAgICAgICAgICAgICAgdmFsdWUgPT4gcmVzb2x2ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgZmFpbHVyZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzW2ldID0gZmFpbHVyZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXJlbWFpbmluZykgcmVqZWN0KG5ldyBBZ2dyZWdhdGVFcnJvcihmYWlsdXJlcykpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbi8qKlxuKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbipcbiogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuKi9cbmZ1bmN0aW9uIGV4ZWN1dGVQcm9taXNlVGFzayAocHJvbWlzZSwgZm4pIHtcbiAgICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgdHJ5IHtcbiAgICAgICAgZm4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKSByZXR1cm47IC8vIEFscmVhZHkgc2V0dGxlZFxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBwcm9taXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpO1xuICAgICAgICAgICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVQcm9taXNlVGFzayhwcm9taXNlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGV4aWVQcm9taXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLl90aGVuKHJlc29sdmUsIHJlamVjdCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLl9zdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZVRpY2spIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH0sIGhhbmRsZVJlamVjdGlvbi5iaW5kKG51bGwsIHByb21pc2UpKTsgLy8gSWYgRnVuY3Rpb24uYmluZCBpcyBub3Qgc3VwcG9ydGVkLiBFeGNlcHRpb24gaXMgaGFuZGxlZCBpbiBjYXRjaCBiZWxvd1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGhhbmRsZVJlamVjdGlvbihwcm9taXNlLCBleCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVSZWplY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJlamVjdGluZ0Vycm9ycy5wdXNoKHJlYXNvbik7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBudWxsKSByZXR1cm47XG4gICAgdmFyIHNob3VsZEV4ZWN1dGVUaWNrID0gcHJvbWlzZS5fbGliICYmIGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICByZWFzb24gPSByZWplY3Rpb25NYXBwZXIocmVhc29uKTtcbiAgICBwcm9taXNlLl9zdGF0ZSA9IGZhbHNlO1xuICAgIHByb21pc2UuX3ZhbHVlID0gcmVhc29uO1xuICAgIGRlYnVnICYmIHJlYXNvbiAhPT0gbnVsbCAmJiB0eXBlb2YgcmVhc29uID09PSAnb2JqZWN0JyAmJiAhcmVhc29uLl9wcm9taXNlICYmIHRyeUNhdGNoKCgpPT57XG4gICAgICAgIHZhciBvcmlnUHJvcCA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihyZWFzb24sIFwic3RhY2tcIik7ICAgICAgICBcbiAgICAgICAgcmVhc29uLl9wcm9taXNlID0gcHJvbWlzZTsgICAgXG4gICAgICAgIHNldFByb3AocmVhc29uLCBcInN0YWNrXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT5cbiAgICAgICAgICAgICAgICBzdGFja19iZWluZ19nZW5lcmF0ZWQgP1xuICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcCAmJiAob3JpZ1Byb3AuZ2V0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AuZ2V0LmFwcGx5KHJlYXNvbikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnUHJvcC52YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlLnN0YWNrXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIEFkZCB0aGUgZmFpbHVyZSB0byBhIGxpc3Qgb2YgcG9zc2libHkgdW5jYXVnaHQgZXJyb3JzXG4gICAgYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKTtcbiAgICBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMocHJvbWlzZSk7XG4gICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVBbGxMaXN0ZW5lcnMgKHByb21pc2UpIHtcbiAgICAvL2RlYnVnICYmIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShwcm9taXNlKTtcbiAgICB2YXIgbGlzdGVuZXJzID0gcHJvbWlzZS5fbGlzdGVuZXJzO1xuICAgIHByb21pc2UuX2xpc3RlbmVycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcHNkID0gcHJvbWlzZS5fUFNEO1xuICAgIC0tcHNkLnJlZiB8fCBwc2QuZmluYWxpemUoKTsgLy8gaWYgcHNkLnJlZiByZWFjaGVzIHplcm8sIGNhbGwgcHNkLmZpbmFsaXplKCk7XG4gICAgaWYgKG51bVNjaGVkdWxlZENhbGxzID09PSAwKSB7XG4gICAgICAgIC8vIElmIG51bVNjaGVkdWxlZENhbGxzIGlzIDAsIGl0IG1lYW5zIHRoYXQgb3VyIHN0YWNrIGlzIG5vdCBpbiBhIGNhbGxiYWNrIG9mIGEgc2NoZWR1bGVkIGNhbGwsXG4gICAgICAgIC8vIGFuZCB0aGF0IG5vIGRlZmVycmVkcyB3aGVyZSBsaXN0ZW5pbmcgdG8gdGhpcyByZWplY3Rpb24gb3Igc3VjY2Vzcy5cbiAgICAgICAgLy8gU2luY2UgdGhlcmUgaXMgYSByaXNrIHRoYXQgb3VyIHN0YWNrIGNhbiBjb250YWluIGFwcGxpY2F0aW9uIGNvZGUgdGhhdCBtYXlcbiAgICAgICAgLy8gZG8gc3R1ZmYgYWZ0ZXIgdGhpcyBjb2RlIGlzIGZpbmlzaGVkIHRoYXQgbWF5IGdlbmVyYXRlIG5ldyBjYWxscywgd2UgY2Fubm90XG4gICAgICAgIC8vIGNhbGwgZmluYWxpemVycyBoZXJlLlxuICAgICAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgICAgICBhc2FwKCgpPT57XG4gICAgICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMCkgZmluYWxpemVQaHlzaWNhbFRpY2soKTsgLy8gV2lsbCBkZXRlY3QgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVUb0xpc3RlbmVyKHByb21pc2UsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHByb21pc2UuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjYiA9IHByb21pc2UuX3N0YXRlID8gbGlzdGVuZXIub25GdWxmaWxsZWQgOiBsaXN0ZW5lci5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIExpc3RlbmVyIGRvZXNudCBoYXZlIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBiZWluZyB0cmlnZ2VyZWQgKG9uRnVsZmlsbGVkIG9yIG9uUmVqZWN0KSBzbyBsZXRzIGZvcndhcmQgdGhlIGV2ZW50IHRvIGFueSBldmVudHVhbCBsaXN0ZW5lcnMgb24gdGhlIFByb21pc2UgaW5zdGFuY2UgcmV0dXJuZWQgYnkgdGhlbigpIG9yIGNhdGNoKClcbiAgICAgICAgcmV0dXJuIChwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLnJlc29sdmUgOiBsaXN0ZW5lci5yZWplY3QpIChwcm9taXNlLl92YWx1ZSk7XG4gICAgfVxuICAgICsrbGlzdGVuZXIucHNkLnJlZjtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAgKGNhbGxMaXN0ZW5lciwgW2NiLCBwcm9taXNlLCBsaXN0ZW5lcl0pO1xufVxuXG5mdW5jdGlvbiBjYWxsTGlzdGVuZXIgKGNiLCBwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFNldCBzdGF0aWMgdmFyaWFibGUgY3VycmVudEZ1bGZpbGxlciB0byB0aGUgcHJvbWlzZSB0aGF0IGlzIGJlaW5nIGZ1bGxmaWxsZWQsXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgY29ubmVjdCB0aGUgY2hhaW4gb2YgcHJvbWlzZXMgKGZvciBsb25nIHN0YWNrcyBzdXBwb3J0KVxuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gcHJvbWlzZTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGwgY2FsbGJhY2sgYW5kIHJlc29sdmUgb3VyIGxpc3RlbmVyIHdpdGggaXQncyByZXR1cm4gdmFsdWUuXG4gICAgICAgIHZhciByZXQsIHZhbHVlID0gcHJvbWlzZS5fdmFsdWU7XG4gICAgICAgICAgICBcbiAgICAgICAgaWYgKHByb21pc2UuX3N0YXRlKSB7XG4gICAgICAgICAgICAvLyBjYiBpcyBvblJlc29sdmVkXG4gICAgICAgICAgICByZXQgPSBjYiAodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2IgaXMgb25SZWplY3RlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5sZW5ndGgpIHJlamVjdGluZ0Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgcmV0ID0gY2IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlamVjdGluZ0Vycm9ycy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgbWFya0Vycm9yQXNIYW5kbGVkKHByb21pc2UpOyAvLyBDYWxsYmFjayBkaWRudCBkbyBQcm9taXNlLnJlamVjdChlcnIpIG5vciByZWplY3QoZXJyKSBvbnRvIGFub3RoZXIgcHJvbWlzZS5cbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lci5yZXNvbHZlKHJldCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIGluIGNhbGxiYWNrLiBSZWplY3Qgb3VyIGxpc3RlbmVyLlxuICAgICAgICBsaXN0ZW5lci5yZWplY3QoZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBlbnYgYW5kIGN1cnJlbnRGdWxmaWxsZXIuXG4gICAgICAgIGN1cnJlbnRGdWxmaWxsZXIgPSBudWxsO1xuICAgICAgICBpZiAoLS1udW1TY2hlZHVsZWRDYWxscyA9PT0gMCkgZmluYWxpemVQaHlzaWNhbFRpY2soKTtcbiAgICAgICAgLS1saXN0ZW5lci5wc2QucmVmIHx8IGxpc3RlbmVyLnBzZC5maW5hbGl6ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2sgKHByb21pc2UsIHN0YWNrcywgbGltaXQpIHtcbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gbGltaXQpIHJldHVybiBzdGFja3M7XG4gICAgdmFyIHN0YWNrID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS5fc3RhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHZhciBmYWlsdXJlID0gcHJvbWlzZS5fdmFsdWUsXG4gICAgICAgICAgICBlcnJvck5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZhaWx1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZS5uYW1lIHx8IFwiRXJyb3JcIjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmYWlsdXJlLm1lc3NhZ2UgfHwgZmFpbHVyZTtcbiAgICAgICAgICAgIHN0YWNrID0gcHJldHR5U3RhY2soZmFpbHVyZSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvck5hbWUgPSBmYWlsdXJlOyAvLyBJZiBlcnJvciBpcyB1bmRlZmluZWQgb3IgbnVsbCwgc2hvdyB0aGF0LlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2tzLnB1c2goZXJyb3JOYW1lICsgKG1lc3NhZ2UgPyBcIjogXCIgKyBtZXNzYWdlIDogXCJcIikgKyBzdGFjayk7XG4gICAgfVxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKHByb21pc2UuX3N0YWNrSG9sZGVyLCAyKTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHN0YWNrcy5pbmRleE9mKHN0YWNrKSA9PT0gLTEpIHN0YWNrcy5wdXNoKHN0YWNrKTtcbiAgICAgICAgaWYgKHByb21pc2UuX3ByZXYpIGdldFN0YWNrKHByb21pc2UuX3ByZXYsIHN0YWNrcywgbGltaXQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSwgcHJldikge1xuICAgIC8vIFN1cHBvcnQgbG9uZyBzdGFja3MgYnkgbGlua2luZyB0byBwcmV2aW91cyBjb21wbGV0ZWQgcHJvbWlzZS5cbiAgICB2YXIgbnVtUHJldiA9IHByZXYgPyBwcmV2Ll9udW1QcmV2ICsgMSA6IDA7XG4gICAgaWYgKG51bVByZXYgPCBMT05HX1NUQUNLU19DTElQX0xJTUlUKSB7IC8vIFByb2hpYml0IGluZmluaXRlIFByb21pc2UgbG9vcHMgdG8gZ2V0IGFuIGluZmluaXRlIGxvbmcgbWVtb3J5IGNvbnN1bWluZyBcInRhaWxcIi5cbiAgICAgICAgcHJvbWlzZS5fcHJldiA9IHByZXY7XG4gICAgICAgIHByb21pc2UuX251bVByZXYgPSBudW1QcmV2O1xuICAgIH1cbn1cblxuLyogVGhlIGNhbGxiYWNrIHRvIHNjaGVkdWxlIHdpdGggc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLlxuICAgSXQgcnVucyBhIHZpcnR1YWwgbWljcm90aWNrIGFuZCBleGVjdXRlcyBhbnkgY2FsbGJhY2sgcmVnaXN0ZXJlZCBpbiBtaWNyb3RpY2tRdWV1ZS5cbiAqL1xuZnVuY3Rpb24gcGh5c2ljYWxUaWNrKCkge1xuICAgIGJlZ2luTWljcm9UaWNrU2NvcGUoKSAmJiBlbmRNaWNyb1RpY2tTY29wZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVnaW5NaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgd2FzUm9vdEV4ZWMgPSBpc091dHNpZGVNaWNyb1RpY2s7XG4gICAgaXNPdXRzaWRlTWljcm9UaWNrID0gZmFsc2U7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSBmYWxzZTtcbiAgICByZXR1cm4gd2FzUm9vdEV4ZWM7XG59XG5cbi8qIEV4ZWN1dGVzIG1pY3JvLXRpY2tzIHdpdGhvdXQgZG9pbmcgdHJ5Li5jYXRjaC5cbiAgIFRoaXMgY2FuIGJlIHBvc3NpYmxlIGJlY2F1c2Ugd2Ugb25seSB1c2UgdGhpcyBpbnRlcm5hbGx5IGFuZFxuICAgdGhlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGFyZSBleGNlcHRpb24tc2FmZSAodGhleSBkbyB0cnkuLmNhdGNoXG4gICBpbnRlcm5hbGx5IGJlZm9yZSBjYWxsaW5nIGFueSBleHRlcm5hbCBtZXRob2QpLiBJZiByZWdpc3RlcmluZ1xuICAgZnVuY3Rpb25zIGluIHRoZSBtaWNyb3RpY2tRdWV1ZSB0aGF0IGFyZSBub3QgZXhjZXB0aW9uLXNhZmUsIHRoaXNcbiAgIHdvdWxkIGRlc3Ryb3kgdGhlIGZyYW1ld29yayBhbmQgbWFrZSBpdCBpbnN0YWJsZS4gU28gd2UgZG9uJ3QgZXhwb3J0XG4gICBvdXIgYXNhcCBtZXRob2QuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGVuZE1pY3JvVGlja1Njb3BlKCkge1xuICAgIHZhciBjYWxsYmFja3MsIGksIGw7XG4gICAgZG8ge1xuICAgICAgICB3aGlsZSAobWljcm90aWNrUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzID0gbWljcm90aWNrUXVldWU7XG4gICAgICAgICAgICBtaWNyb3RpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgbCA9IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjYWxsYmFja3NbaV07XG4gICAgICAgICAgICAgICAgaXRlbVswXS5hcHBseShudWxsLCBpdGVtWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWU7XG4gICAgbmVlZHNOZXdQaHlzaWNhbFRpY2sgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVBoeXNpY2FsVGljaygpIHtcbiAgICB2YXIgdW5oYW5kbGVkRXJycyA9IHVuaGFuZGxlZEVycm9ycztcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXTtcbiAgICB1bmhhbmRsZWRFcnJzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuX1BTRC5vbnVuaGFuZGxlZC5jYWxsKG51bGwsIHAuX3ZhbHVlLCBwKTtcbiAgICB9KTtcbiAgICB2YXIgZmluYWxpemVycyA9IHRpY2tGaW5hbGl6ZXJzLnNsaWNlKDApOyAvLyBDbG9uZSBmaXJzdCBiZWNhdXNlIGZpbmFsaXplciBtYXkgcmVtb3ZlIGl0c2VsZiBmcm9tIGxpc3QuXG4gICAgdmFyIGkgPSBmaW5hbGl6ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgZmluYWxpemVyc1stLWldKCk7ICAgIFxufVxuXG5mdW5jdGlvbiBydW5fYXRfZW5kX29mX3RoaXNfb3JfbmV4dF9waHlzaWNhbF90aWNrIChmbikge1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplcigpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGlja0ZpbmFsaXplcnMuc3BsaWNlKHRpY2tGaW5hbGl6ZXJzLmluZGV4T2YoZmluYWxpemVyKSwgMSk7XG4gICAgfVxuICAgIHRpY2tGaW5hbGl6ZXJzLnB1c2goZmluYWxpemVyKTtcbiAgICArK251bVNjaGVkdWxlZENhbGxzO1xuICAgIGFzYXAoKCk9PntcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKHByb21pc2UpIHtcbiAgICAvLyBPbmx5IGFkZCB0byB1bmhhbmRsZWRFcnJvcnMgaWYgbm90IGFscmVhZHkgdGhlcmUuIFRoZSBmaXJzdCBvbmUgdG8gYWRkIHRvIHRoaXMgbGlzdFxuICAgIC8vIHdpbGwgYmUgdXBvbiB0aGUgZmlyc3QgcmVqZWN0aW9uIHNvIHRoYXQgdGhlIHJvb3QgY2F1c2UgKGZpcnN0IHByb21pc2UgaW4gdGhlXG4gICAgLy8gcmVqZWN0aW9uIGNoYWluKSBpcyB0aGUgb25lIGxpc3RlZC5cbiAgICBpZiAoIXVuaGFuZGxlZEVycm9ycy5zb21lKHAgPT4gcC5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSlcbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnB1c2gocHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKSB7XG4gICAgLy8gQ2FsbGVkIHdoZW4gYSByZWplY3QgaGFuZGxlZCBpcyBhY3R1YWxseSBiZWluZyBjYWxsZWQuXG4gICAgLy8gU2VhcmNoIGluIHVuaGFuZGxlZEVycm9ycyBmb3IgYW55IHByb21pc2Ugd2hvcyBfdmFsdWUgaXMgdGhpcyBwcm9taXNlX3ZhbHVlIChsaXN0XG4gICAgLy8gY29udGFpbnMgb25seSByZWplY3RlZCBwcm9taXNlcywgYW5kIG9ubHkgb25lIGl0ZW0gcGVyIGVycm9yKVxuICAgIHZhciBpID0gdW5oYW5kbGVkRXJyb3JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkgaWYgKHVuaGFuZGxlZEVycm9yc1stLWldLl92YWx1ZSA9PT0gcHJvbWlzZS5fdmFsdWUpIHtcbiAgICAgICAgLy8gRm91bmQgYSBwcm9taXNlIHRoYXQgZmFpbGVkIHdpdGggdGhpcyBzYW1lIGVycm9yIG9iamVjdCBwb2ludGVyLFxuICAgICAgICAvLyBSZW1vdmUgdGhhdCBzaW5jZSB0aGVyZSBpcyBhIGxpc3RlbmVyIHRoYXQgYWN0dWFsbHkgdGFrZXMgY2FyZSBvZiBpdC5cbiAgICAgICAgdW5oYW5kbGVkRXJyb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gUHJvbWlzZVJlamVjdCAocmVhc29uKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoSU5URVJOQUwsIGZhbHNlLCByZWFzb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcCAoZm4sIGVycm9yQ2F0Y2hlcikge1xuICAgIHZhciBwc2QgPSBQU0Q7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCksXG4gICAgICAgICAgICBvdXRlclNjb3BlID0gUFNEO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckNhdGNoZXIgJiYgZXJyb3JDYXRjaGVyKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh3YXNSb290RXhlYykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuLy9cbi8vIHZhcmlhYmxlcyB1c2VkIGZvciBuYXRpdmUgYXdhaXQgc3VwcG9ydFxuLy9cbmNvbnN0IHRhc2sgPSB7IGF3YWl0czogMCwgZWNob2VzOiAwLCBpZDogMH07IC8vIFRoZSBvbmdvaW5nIG1hY3JvLXRhc2sgd2hlbiB1c2luZyB6b25lLWVjaG9pbmcuXG52YXIgdGFza0NvdW50ZXIgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtYWNybyB0YXNrcy5cbnZhciB6b25lU3RhY2sgPSBbXTsgLy8gU3RhY2sgb2YgbGVmdCB6b25lcyB0byByZXN0b3JlIGFzeW5jaHJvbmljYWxseS5cbnZhciB6b25lRWNob2VzID0gMDsgLy8gem9uZUVjaG9lcyBpcyBhIG11c3QgaW4gb3JkZXIgdG8gcGVyc2lzdCB6b25lcyBiZXR3ZWVuIG5hdGl2ZSBhd2FpdCBleHByZXNzaW9ucy5cbnZhciB0b3RhbEVjaG9lcyA9IDA7IC8vIElEIGNvdW50ZXIgZm9yIG1pY3JvLXRhc2tzLiBVc2VkIHRvIGRldGVjdCBwb3NzaWJsZSBuYXRpdmUgYXdhaXQgaW4gb3VyIFByb21pc2UucHJvdG90eXBlLnRoZW4uXG5cblxudmFyIHpvbmVfaWRfY291bnRlciA9IDA7XG5leHBvcnQgZnVuY3Rpb24gbmV3U2NvcGUgKGZuLCBwcm9wcywgYTEsIGEyKSB7XG4gICAgdmFyIHBhcmVudCA9IFBTRCxcbiAgICAgICAgcHNkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIHBzZC5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcHNkLnJlZiA9IDA7XG4gICAgcHNkLmdsb2JhbCA9IGZhbHNlO1xuICAgIHBzZC5pZCA9ICsrem9uZV9pZF9jb3VudGVyO1xuICAgIC8vIFByZXBhcmUgZm9yIHByb21pc2UgcGF0Y2hpbmcgKGRvbmUgaW4gdXNlUFNEKTpcbiAgICB2YXIgZ2xvYmFsRW52ID0gZ2xvYmFsUFNELmVudjtcbiAgICBwc2QuZW52ID0gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICBQcm9taXNlOiBEZXhpZVByb21pc2UsIC8vIENoYW5naW5nIHdpbmRvdy5Qcm9taXNlIGNvdWxkIGJlIG9taXR0ZWQgZm9yIENocm9tZSBhbmQgRWRnZSwgd2hlcmUgSURCK1Byb21pc2UgcGxheXMgd2VsbCFcbiAgICAgICAgUHJvbWlzZVByb3A6IHt2YWx1ZTogRGV4aWVQcm9taXNlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgYWxsOiBEZXhpZVByb21pc2UuYWxsLFxuICAgICAgICByYWNlOiBEZXhpZVByb21pc2UucmFjZSxcbiAgICAgICAgYWxsU2V0dGxlZDogRGV4aWVQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogRGV4aWVQcm9taXNlLmFueSxcbiAgICAgICAgcmVzb2x2ZTogRGV4aWVQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogRGV4aWVQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbiAoZ2xvYmFsRW52Lm50aGVuLCBwc2QpLCAvLyBuYXRpdmUgdGhlblxuICAgICAgICBndGhlbjogZ2V0UGF0Y2hlZFByb21pc2VUaGVuIChnbG9iYWxFbnYuZ3RoZW4sIHBzZCkgLy8gZ2xvYmFsIHRoZW5cbiAgICB9IDoge307XG4gICAgaWYgKHByb3BzKSBleHRlbmQocHNkLCBwcm9wcyk7XG4gICAgXG4gICAgLy8gdW5oYW5kbGVkcyBhbmQgb251bmhhbmRsZWQgc2hvdWxkIG5vdCBiZSBzcGVjaWZpY2FsbHkgc2V0IGhlcmUuXG4gICAgLy8gTGVhdmUgdGhlbSBvbiBwYXJlbnQgcHJvdG90eXBlLlxuICAgIC8vIHVuaGFuZGxlZHMucHVzaChlcnIpIHdpbGwgcHVzaCB0byBwYXJlbnQncyBwcm90b3R5cGVcbiAgICAvLyBvbnVuaGFuZGxlZCgpIHdpbGwgY2FsbCBwYXJlbnRzIG9udW5oYW5kbGVkICh3aXRoIHRoaXMgc2NvcGUncyB0aGlzLXBvaW50ZXIgdGhvdWdoISlcbiAgICArK3BhcmVudC5yZWY7XG4gICAgcHNkLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAtLXRoaXMucGFyZW50LnJlZiB8fCB0aGlzLnBhcmVudC5maW5hbGl6ZSgpO1xuICAgIH1cbiAgICB2YXIgcnYgPSB1c2VQU0QgKHBzZCwgZm4sIGExLCBhMik7XG4gICAgaWYgKHBzZC5yZWYgPT09IDApIHBzZC5maW5hbGl6ZSgpO1xuICAgIHJldHVybiBydjtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2FsbCBpZiBzY29wZUZ1bmMgcmV0dXJucyBOYXRpdmVQcm9taXNlXG4vLyBBbHNvIGZvciBlYWNoIE5hdGl2ZVByb21pc2UgaW4gdGhlIGFyZ3VtZW50cyB0byBQcm9taXNlLmFsbCgpXG5leHBvcnQgZnVuY3Rpb24gaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmlkKSB0YXNrLmlkID0gKyt0YXNrQ291bnRlcjtcbiAgICArK3Rhc2suYXdhaXRzO1xuICAgIHRhc2suZWNob2VzICs9IFpPTkVfRUNIT19MSU1JVDtcbiAgICByZXR1cm4gdGFzay5pZDtcbn1cblxuLy8gRnVuY3Rpb24gdG8gY2FsbCB3aGVuICd0aGVuJyBjYWxscyBiYWNrIG9uIGEgbmF0aXZlIHByb21pc2Ugd2hlcmUgb25Bd2FpdEV4cGVjdGVkKCkgaGFkIGJlZW4gY2FsbGVkLlxuLy8gQWxzbyBjYWxsIHRoaXMgd2hlbiBhIG5hdGl2ZSBhd2FpdCBjYWxscyB0aGVuIG1ldGhvZCBvbiBhIHByb21pc2UuIEluIHRoYXQgY2FzZSwgZG9uJ3Qgc3VwcGx5XG4vLyBzb3VyY2VUYXNrSWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGtub3cgaXQgcmVmZXJzIHRvIGN1cnJlbnQgdGFzay5cbmV4cG9ydCBmdW5jdGlvbiBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpIHtcbiAgICBpZiAoIXRhc2suYXdhaXRzKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKC0tdGFzay5hd2FpdHMgPT09IDApIHRhc2suaWQgPSAwO1xuICAgIHRhc2suZWNob2VzID0gdGFzay5hd2FpdHMgKiBaT05FX0VDSE9fTElNSVQ7IC8vIFdpbGwgcmVzZXQgZWNob2VzIHRvIDAgaWYgYXdhaXRzIGlzIDAuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmlmICgoJycrbmF0aXZlUHJvbWlzZVRoZW4pLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSA9PT0gLTEpIHtcbiAgICAvLyBJZiB0aGUgbmF0aXZlIHByb21pc2UnIHByb3RvdHlwZSBpcyBwYXRjaGVkLCB3ZSBjYW5ub3QgcmVseSBvbiB6b25lIGVjaG9pbmcuXG4gICAgLy8gRGlzYWJsZSB0aGF0IGhlcmU6XG4gICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyA9IG5vcDtcbn1cblxuLy8gQ2FsbCBmcm9tIFByb21pc2UuYWxsKCkgYW5kIFByb21pc2UucmFjZSgpXG5leHBvcnQgZnVuY3Rpb24gb25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jIChwb3NzaWJsZVByb21pc2UpIHtcbiAgICBpZiAodGFzay5lY2hvZXMgJiYgcG9zc2libGVQcm9taXNlICYmIHBvc3NpYmxlUHJvbWlzZS5jb25zdHJ1Y3RvciA9PT0gTmF0aXZlUHJvbWlzZSkge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpOyBcbiAgICAgICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZS50aGVuKHggPT4ge1xuICAgICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9LCBlID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gem9uZUVudGVyRWNobyh0YXJnZXRab25lKSB7XG4gICAgKyt0b3RhbEVjaG9lcztcbiAgICAvL2NvbnNvbGUubG9nKFwiVG90YWwgZWNob2VzIFwiLCB0b3RhbEVjaG9lcyk7XG4gICAgaWYgKCF0YXNrLmVjaG9lcyB8fCAtLXRhc2suZWNob2VzID09PSAwKSB7XG4gICAgICAgIHRhc2suZWNob2VzID0gdGFzay5pZCA9IDA7IC8vIENhbmNlbCB6b25lIGVjaG9pbmcuXG4gICAgfVxuXG4gICAgem9uZVN0YWNrLnB1c2goUFNEKTtcbiAgICBzd2l0Y2hUb1pvbmUodGFyZ2V0Wm9uZSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHpvbmVMZWF2ZUVjaG8oKSB7XG4gICAgdmFyIHpvbmUgPSB6b25lU3RhY2tbem9uZVN0YWNrLmxlbmd0aC0xXTtcbiAgICB6b25lU3RhY2sucG9wKCk7XG4gICAgc3dpdGNoVG9ab25lKHpvbmUsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gc3dpdGNoVG9ab25lICh0YXJnZXRab25lLCBiRW50ZXJpbmdab25lKSB7XG4gICAgdmFyIGN1cnJlbnRab25lID0gUFNEO1xuICAgIGlmIChiRW50ZXJpbmdab25lID8gdGFzay5lY2hvZXMgJiYgKCF6b25lRWNob2VzKysgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSA6IHpvbmVFY2hvZXMgJiYgKCEtLXpvbmVFY2hvZXMgfHwgdGFyZ2V0Wm9uZSAhPT0gUFNEKSkge1xuICAgICAgICAvLyBFbnRlciBvciBsZWF2ZSB6b25lIGFzeW5jaHJvbmljYWxseSBhcyB3ZWxsLCBzbyB0aGF0IHRhc2tzIGluaXRpYXRlZCBkdXJpbmcgY3VycmVudCB0aWNrXG4gICAgICAgIC8vIHdpbGwgYmUgc3Vycm91bmRlZCBieSB0aGUgem9uZSB3aGVuIHRoZXkgYXJlIGludm9rZWQuXG4gICAgICAgIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soYkVudGVyaW5nWm9uZSA/IHpvbmVFbnRlckVjaG8uYmluZChudWxsLCB0YXJnZXRab25lKSA6IHpvbmVMZWF2ZUVjaG8pO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Wm9uZSA9PT0gUFNEKSByZXR1cm47XG5cbiAgICBQU0QgPSB0YXJnZXRab25lOyAvLyBUaGUgYWN0dWFsIHpvbmUgc3dpdGNoIG9jY3VycyBhdCB0aGlzIGxpbmUuXG5cbiAgICAvLyBTbmFwc2hvdCBvbiBldmVyeSBsZWF2ZSBmcm9tIGdsb2JhbCB6b25lLlxuICAgIGlmIChjdXJyZW50Wm9uZSA9PT0gZ2xvYmFsUFNEKSBnbG9iYWxQU0QuZW52ID0gc25hcFNob3QoKTtcblxuICAgIGlmIChwYXRjaEdsb2JhbFByb21pc2UpIHtcbiAgICAgICAgLy8gTGV0J3MgcGF0Y2ggdGhlIGdsb2JhbCBhbmQgbmF0aXZlIFByb21pc2VzIChtYXkgYmUgc2FtZSBvciBtYXkgYmUgZGlmZmVyZW50KVxuICAgICAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IGdsb2JhbFBTRC5lbnYuUHJvbWlzZTtcbiAgICAgICAgLy8gU3dpY2ggZW52aXJvbm1lbnRzIChtYXkgYmUgUFNELXpvbmUgb3IgdGhlIGdsb2JhbCB6b25lLiBCb3RoIGFwcGx5LilcbiAgICAgICAgdmFyIHRhcmdldEVudiA9IHRhcmdldFpvbmUuZW52O1xuXG4gICAgICAgIC8vIENoYW5nZSBQcm9taXNlLnByb3RvdHlwZS50aGVuIGZvciBuYXRpdmUgYW5kIGdsb2JhbCBQcm9taXNlICh0aGV5IE1BWSBkaWZmZXIgb24gcG9seWZpbGxlZCBlbnZpcm9ubWVudHMsIGJ1dCBib3RoIGNhbiBiZSBhY2Nlc3NlZClcbiAgICAgICAgLy8gTXVzdCBiZSBkb25lIG9uIGVhY2ggem9uZSBjaGFuZ2UgYmVjYXVzZSB0aGUgcGF0Y2hlZCBtZXRob2QgY29udGFpbnMgdGFyZ2V0Wm9uZSBpbiBpdHMgY2xvc3VyZS5cbiAgICAgICAgbmF0aXZlUHJvbWlzZVByb3RvLnRoZW4gPSB0YXJnZXRFbnYubnRoZW47XG4gICAgICAgIEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW4gPSB0YXJnZXRFbnYuZ3RoZW47XG5cbiAgICAgICAgaWYgKGN1cnJlbnRab25lLmdsb2JhbCB8fCB0YXJnZXRab25lLmdsb2JhbCkge1xuICAgICAgICAgICAgLy8gTGVhdmluZyBvciBlbnRlcmluZyBnbG9iYWwgem9uZS4gSXQncyB0aW1lIHRvIHBhdGNoIC8gcmVzdG9yZSBnbG9iYWwgUHJvbWlzZS5cblxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgUHJvbWlzZSB0byB3aW5kb3cuUHJvbWlzZSBzbyB0aGF0IHRyYW5zaWxlZCBhc3luYyBmdW5jdGlvbnMgd2lsbCB3b3JrIG9uIEZpcmVmb3gsIFNhZmFyaSBhbmQgSUUsIGFzIHdlbGwgYXMgd2l0aCBab25lanMgYW5kIGFuZ3VsYXIuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2dsb2JhbCwgJ1Byb21pc2UnLCB0YXJnZXRFbnYuUHJvbWlzZVByb3ApO1xuXG4gICAgICAgICAgICAvLyBTdXBwb3J0IFByb21pc2UuYWxsKCkgZXRjIHRvIHdvcmsgaW5kZXhlZERCLXNhZmUgYWxzbyB3aGVuIHBlb3BsZSBhcmUgaW5jbHVkaW5nIGVzNi1wcm9taXNlIGFzIGEgbW9kdWxlICh0aGV5IG1pZ2h0XG4gICAgICAgICAgICAvLyBub3QgYmUgYWNjZXNzaW5nIGdsb2JhbC5Qcm9taXNlIGJ1dCBhIGxvY2FsIHJlZmVyZW5jZSB0byBpdClcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UuYWxsID0gdGFyZ2V0RW52LmFsbDtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmFjZSA9IHRhcmdldEVudi5yYWNlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZXNvbHZlID0gdGFyZ2V0RW52LnJlc29sdmU7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJlamVjdCA9IHRhcmdldEVudi5yZWplY3Q7XG4gICAgICAgICAgICBpZiAodGFyZ2V0RW52LmFsbFNldHRsZWQpIEdsb2JhbFByb21pc2UuYWxsU2V0dGxlZCA9IHRhcmdldEVudi5hbGxTZXR0bGVkO1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbnkpIEdsb2JhbFByb21pc2UuYW55ID0gdGFyZ2V0RW52LmFueTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc25hcFNob3QgKCkge1xuICAgIHZhciBHbG9iYWxQcm9taXNlID0gX2dsb2JhbC5Qcm9taXNlO1xuICAgIHJldHVybiBwYXRjaEdsb2JhbFByb21pc2UgPyB7XG4gICAgICAgIFByb21pc2U6IEdsb2JhbFByb21pc2UsXG4gICAgICAgIFByb21pc2VQcm9wOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF9nbG9iYWwsIFwiUHJvbWlzZVwiKSxcbiAgICAgICAgYWxsOiBHbG9iYWxQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogR2xvYmFsUHJvbWlzZS5yYWNlLFxuICAgICAgICBhbGxTZXR0bGVkOiBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQsXG4gICAgICAgIGFueTogR2xvYmFsUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IEdsb2JhbFByb21pc2UucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiBHbG9iYWxQcm9taXNlLnJlamVjdCxcbiAgICAgICAgbnRoZW46IG5hdGl2ZVByb21pc2VQcm90by50aGVuLFxuICAgICAgICBndGhlbjogR2xvYmFsUHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIH0gOiB7fTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBTRCAocHNkLCBmbiwgYTEsIGEyLCBhMykge1xuICAgIHZhciBvdXRlclNjb3BlID0gUFNEO1xuICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShwc2QsIHRydWUpO1xuICAgICAgICByZXR1cm4gZm4oYTEsIGEyLCBhMyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyU2NvcGUsIGZhbHNlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVOYXRpdmVNaWNyb1Rhc2sgKGpvYikge1xuICAgIC8vXG4gICAgLy8gUHJlY29uZGl0aW9uOiBuYXRpdmVQcm9taXNlVGhlbiAhPT0gdW5kZWZpbmVkXG4gICAgLy9cbiAgICBuYXRpdmVQcm9taXNlVGhlbi5jYWxsKHJlc29sdmVkTmF0aXZlUHJvbWlzZSwgam9iKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChmbiwgem9uZSwgcG9zc2libGVBd2FpdCwgY2xlYW51cCkge1xuICAgIHJldHVybiB0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyWm9uZSA9IFBTRDtcbiAgICAgICAgaWYgKHBvc3NpYmxlQXdhaXQpIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIHN3aXRjaFRvWm9uZSh6b25lLCB0cnVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKG91dGVyWm9uZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNsZWFudXApIGVucXVldWVOYXRpdmVNaWNyb1Rhc2soZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0Y2hlZFByb21pc2VUaGVuIChvcmlnVGhlbiwgem9uZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gb3JpZ1RoZW4uY2FsbCh0aGlzLFxuICAgICAgICAgICAgbmF0aXZlQXdhaXRDb21wYXRpYmxlV3JhcChvblJlc29sdmVkLCB6b25lKSxcbiAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZWplY3RlZCwgem9uZSkpO1xuICAgIH07XG59XG5cbmNvbnN0IFVOSEFORExFRFJFSkVDVElPTiA9IFwidW5oYW5kbGVkcmVqZWN0aW9uXCI7XG5cbmZ1bmN0aW9uIGdsb2JhbEVycm9yKGVyciwgcHJvbWlzZSkge1xuICAgIHZhciBydjtcbiAgICB0cnkge1xuICAgICAgICBydiA9IHByb21pc2Uub251bmNhdGNoZWQoZXJyKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChydiAhPT0gZmFsc2UpIHRyeSB7XG4gICAgICAgIHZhciBldmVudCwgZXZlbnREYXRhID0ge3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogZXJyfTtcbiAgICAgICAgaWYgKF9nbG9iYWwuZG9jdW1lbnQgJiYgZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0RXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChfZ2xvYmFsLkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChVTkhBTkRMRURSRUpFQ1RJT04sIHtkZXRhaWw6IGV2ZW50RGF0YX0pO1xuICAgICAgICAgICAgZXh0ZW5kKGV2ZW50LCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCAmJiBfZ2xvYmFsLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFfZ2xvYmFsLlByb21pc2VSZWplY3Rpb25FdmVudCAmJiBfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKVxuICAgICAgICAgICAgICAgIC8vIE5vIG5hdGl2ZSBzdXBwb3J0IGZvciBQcm9taXNlUmVqZWN0aW9uRXZlbnQgYnV0IHVzZXIgaGFzIHNldCB3aW5kb3cub251bmhhbmRsZWRyZWplY3Rpb24uIE1hbnVhbGx5IGNhbGwgaXQuXG4gICAgICAgICAgICAgICAgdHJ5IHtfZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKGV2ZW50KTt9IGNhdGNoIChfKSB7fVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWJ1ZyAmJiBldmVudCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmhhbmRsZWQgcmVqZWN0aW9uOiAke2Vyci5zdGFjayB8fCBlcnJ9YCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7fVxufVxuXG5leHBvcnQgdmFyIHJlamVjdGlvbiA9IERleGllUHJvbWlzZS5yZWplY3Q7XG5cbmV4cG9ydCB7RGV4aWVQcm9taXNlfTtcbiIsICJpbXBvcnQgeyBQU0QsIHJlamVjdGlvbiwgbmV3U2NvcGUgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBEZXhpZU9wdGlvbnMgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RleGllLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgeyBlcnJuYW1lcywgZXhjZXB0aW9ucyB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gXCIuL2NoYWluaW5nLWZ1bmN0aW9uc1wiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vY2xhc3Nlcy90cmFuc2FjdGlvblwiO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9jbGFzc2VzL2RleGllJztcblxuLyogR2VuZXJhdGUgYSB0ZW1wb3JhcnkgdHJhbnNhY3Rpb24gd2hlbiBkYiBvcGVyYXRpb25zIGFyZSBkb25lIG91dHNpZGUgYSB0cmFuc2FjdGlvbiBzY29wZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gdGVtcFRyYW5zYWN0aW9uIChcbiAgZGI6IERleGllLFxuICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICBmbjogKHJlc29sdmUsIHJlamVjdCwgdHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBhbnkpXG4gIC8vIExhc3QgYXJndW1lbnQgaXMgXCJ3cml0ZUxvY2tlZFwiLiBCdXQgdGhpcyBkb2VzbnQgYXBwbHkgdG8gb25lc2hvdCBkaXJlY3QgZGIgb3BlcmF0aW9ucywgc28gd2UgaWdub3JlIGl0Llxue1xuICBpZiAoIWRiLmlkYmRiIHx8ICghZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSAmJiAoIVBTRC5sZXRUaHJvdWdoICYmICFkYi5fdmlwKSkpIHtcbiAgICBpZiAoZGIuX3N0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgLy8gZGIuaWRiZGIgaXMgZmFsc3kgYnV0IG9wZW5Db21wbGV0ZSBpcyB0cnVlLiBNdXN0IGhhdmUgYmVlbiBhbiBleGNlcHRpb24gZHVyaW4gb3Blbi5cbiAgICAgIC8vIERvbid0IHdhaXQgZm9yIG9wZW5Db21wbGV0ZSBhcyBpdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3AuXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgIH1cbiAgICBpZiAoIWRiLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICBpZiAoIWRiLl9vcHRpb25zLmF1dG9PcGVuKVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKCkpO1xuICAgICAgZGIub3BlbigpLmNhdGNoKG5vcCk7IC8vIE9wZW4gaW4gYmFja2dyb3VuZC4gSWYgaWYgZmFpbHMsIGl0IHdpbGwgYmUgY2F0Y2hlZCBieSB0aGUgZmluYWwgcHJvbWlzZSBhbnl3YXkuXG4gICAgfVxuICAgIHJldHVybiBkYi5fc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbigoKSA9PiB0ZW1wVHJhbnNhY3Rpb24oZGIsIG1vZGUsIHN0b3JlTmFtZXMsIGZuKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKG1vZGUsIHN0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zLmNyZWF0ZSgpO1xuICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgZGIuX2Nsb3NlKCk7XG4gICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKT0+dGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihleCk7XG4gICAgfVxuICAgIHJldHVybiB0cmFucy5fcHJvbWlzZShtb2RlLCAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4geyAvLyBPUFRJTUlaQVRJT04gUE9TU0lCTEU/IG5ld1Njb3BlKCkgbm90IG5lZWRlZCBiZWNhdXNlIGl0J3MgYWxyZWFkeSBkb25lIGluIF9wcm9taXNlLlxuICAgICAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICAgICAgcmV0dXJuIGZuKHJlc29sdmUsIHJlamVjdCwgdHJhbnMpO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gSW5zdGVhZCBvZiByZXNvbHZpbmcgdmFsdWUgZGlyZWN0bHksIHdhaXQgd2l0aCByZXNvbHZpbmcgaXQgdW50aWwgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgIC8vIE90aGVyd2lzZSB0aGUgZGF0YSB3b3VsZCBub3QgYmUgaW4gdGhlIERCIGlmIHJlcXVlc3RpbmcgaXQgaW4gdGhlIHRoZW4oKSBvcGVyYXRpb24uXG4gICAgICAvLyBTcGVjaWZpY2FsbHksIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiB3aWxsIHdvcms6XG4gICAgICAvL1xuICAgICAgLy8gICBkYi5mcmllbmRzLnB1dCh7bmFtZTogXCJBcm5lXCJ9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgICAgIGRiLmZyaWVuZHMud2hlcmUoXCJuYW1lXCIpLmVxdWFscyhcIkFybmVcIikuY291bnQoZnVuY3Rpb24oY291bnQpIHtcbiAgICAgIC8vICAgICAgICAgICBhc3NlcnQgKGNvdW50ID09PSAxKTtcbiAgICAgIC8vICAgICAgIH0pO1xuICAgICAgLy8gICB9KTtcbiAgICAgIC8vXG4gICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiByZXN1bHQpO1xuICAgIH0pOy8qLmNhdGNoKGVyciA9PiB7IC8vIERvbid0IGRvIHRoaXMgYXMgb2Ygbm93LiBJZiB3b3VsZCBhZmZlY3QgYnVsay0gYW5kIG1vZGlmeSBtZXRob2RzIGluIGEgd2F5IHRoYXQgY291bGQgYmUgbW9yZSBpbnR1aXRpdmUuIEJ1dCB3YWl0ISBNYXliZSBjaGFuZ2UgaW4gbmV4dCBtYWpvci5cbiAgICAgICAgICB0cmFucy5fcmVqZWN0KGVycik7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlcnIpO1xuICAgICAgfSk7Ki9cbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2NsYXNzZXMvZGV4aWVcIjtcblxuZXhwb3J0IGNvbnN0IERFWElFX1ZFUlNJT04gPSAne3ZlcnNpb259JzsgLy8gUmVwbGFjZWQgYnkgYnVpbGQtc2NyaXB0LlxuZXhwb3J0IGNvbnN0IG1heFN0cmluZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNjU1MzUpO1xuZXhwb3J0IGNvbnN0IG1pbktleSA9IC1JbmZpbml0eTsgLy8gbWluS2V5IGNhbiBiZSBjb25zdGFudC4gbWF4S2V5IG11c3QgYmUgYSBwcm9wIG9mIERleGllIChfbWF4S2V5KVxuZXhwb3J0IGNvbnN0IElOVkFMSURfS0VZX0FSR1VNRU5UID1cbiAgXCJJbnZhbGlkIGtleSBwcm92aWRlZC4gS2V5cyBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLCBudW1iZXIsIERhdGUgb3IgQXJyYXk8c3RyaW5nIHwgbnVtYmVyIHwgRGF0ZT4uXCI7XG5leHBvcnQgY29uc3QgU1RSSU5HX0VYUEVDVEVEID0gXCJTdHJpbmcgZXhwZWN0ZWQuXCI7XG5leHBvcnQgY29uc3QgY29ubmVjdGlvbnM6IERleGllW10gPSBbXTtcbmV4cG9ydCBjb25zdCBpc0lFT3JFZGdlID1cbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgLyhNU0lFfFRyaWRlbnR8RWRnZSkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5leHBvcnQgY29uc3QgaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZyA9IGlzSUVPckVkZ2U7XG5leHBvcnQgY29uc3QgaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UgPSBpc0lFT3JFZGdlO1xuZXhwb3J0IGNvbnN0IGRleGllU3RhY2tGcmFtZUZpbHRlciA9IGZyYW1lID0+ICEvKGRleGllXFwuanN8ZGV4aWVcXC5taW5cXC5qcykvLnRlc3QoZnJhbWUpO1xuZXhwb3J0IGNvbnN0IERCTkFNRVNfREIgPSAnX19kYm5hbWVzJztcbmV4cG9ydCBjb25zdCBSRUFET05MWSA9ICdyZWFkb25seSc7XG5leHBvcnQgY29uc3QgUkVBRFdSSVRFID0gJ3JlYWR3cml0ZSc7XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmUoZmlsdGVyMSwgZmlsdGVyMikge1xuICByZXR1cm4gZmlsdGVyMSA/XG4gICAgICBmaWx0ZXIyID9cbiAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXIxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgJiYgZmlsdGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IDpcbiAgICAgICAgICBmaWx0ZXIxIDpcbiAgICAgIGZpbHRlcjI7XG59XG4iLCAiaW1wb3J0IHsgREJDb3JlS2V5UmFuZ2UsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuXG5leHBvcnQgY29uc3QgQW55UmFuZ2U6IERCQ29yZUtleVJhbmdlID0ge1xuICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuQW55LFxuICBsb3dlcjogLUluZmluaXR5LFxuICBsb3dlck9wZW46IGZhbHNlLFxuICB1cHBlcjogW1tdXSxcbiAgdXBwZXJPcGVuOiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgTmV2ZXJSYW5nZTogREJDb3JlS2V5UmFuZ2UgPSB7XG4gIHR5cGU6IERCQ29yZVJhbmdlVHlwZS5OZXZlcixcbiAgbG93ZXI6IC1JbmZpbml0eSxcbiAgbG93ZXJPcGVuOiB0cnVlLFxuICB1cHBlcjogLUluZmluaXR5LFxuICB1cHBlck9wZW46IHRydWVcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUsIGRlbEJ5S2V5UGF0aCwgZ2V0QnlLZXlQYXRoIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBuZWVkZWQgc2luY2Ugb2JqIGNvdWxkIGJlIGEgY3VzdG9tLWNsYXNzIGluc3RhbmNlIHdpdGggYW5cbi8vIHVuaW5pdGlhbGl6ZWQga2V5UGF0aC4gU2VlIHRoZSBmb2xsb3dpbmcgY29tbWVudCBmb3IgbW9yZSBjb250ZXh0OlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzEyODAjaXNzdWVjb21tZW50LTgyMzU1Nzg4MVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGg6IHN0cmluZyB8IEFycmF5TGlrZTxzdHJpbmc+KSB7XG4gIC8vIFdvcmthcm91bmQgb25seSBuZWVkZWQgZm9yIHBsYWluIG5vbi1kb3R0ZWQga2V5UGF0aHNcbiAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSBcInN0cmluZ1wiICYmICEvXFwuLy50ZXN0KGtleVBhdGgpIFxuICA/IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGlmIChvYmpba2V5UGF0aF0gPT09IHVuZGVmaW5lZCAmJiAoa2V5UGF0aCBpbiBvYmopKSB7XG4gICAgICAvLyBwcm9wZXJ0eSBleGlzdHMgYnV0IGlzIHVuZGVmaW5lZC4gVGhpcyB3aWxsIG5vdCBiZSBsaWtlZCBieSBJbmRleGVkZGIuXG4gICAgICAvLyBOZWVkIHRvIHJlbW92ZSB0aGUgcHJvcGVydHkgYmVmb3JlIGFkZGluZyBpdCBidXQgd2UgbmVlZCB0byBjbG9uZSBpdCBiZWZvcmVcbiAgICAgIC8vIGRvaW5nIHRoYXQgdG8gbm90IGJlIGludHJ1c2l2ZS5cbiAgICAgIG9iaiA9IGRlZXBDbG9uZShvYmopO1xuICAgICAgZGVsZXRlIG9ialtrZXlQYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICA6IChvYmo6IG9iamVjdCkgPT4gb2JqO1xufSIsICJpbXBvcnQgeyBCdWxrRXJyb3IsIGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgVGFibGUgYXMgSVRhYmxlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBUYWJsZUhvb2tzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLWhvb2tzJztcbmltcG9ydCB7IERleGllUHJvbWlzZSBhcyBQcm9taXNlLCBQU0QsIG5ld1Njb3BlLCB3cmFwLCByZWplY3Rpb24sIGJlZ2luTWljcm9UaWNrU2NvcGUsIGVuZE1pY3JvVGlja1Njb3BlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyB0ZW1wVHJhbnNhY3Rpb24gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdGVtcC10cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBpc0FycmF5LCBrZXlzLCBnZXRCeUtleVBhdGgsIGhhc093biwgc2V0QnlLZXlQYXRoLCBkZWVwQ2xvbmUsIHRyeUNhdGNoLCBhcnJheVRvT2JqZWN0LCBleHRlbmQgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tYmluZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lJztcbmltcG9ydCB7IFByb21pc2VFeHRlbmRlZCB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvcHJvbWlzZS1leHRlbmRlZFwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgREJDb3JlVGFibGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IEFueVJhbmdlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2tleXJhbmdlJztcbmltcG9ydCB7IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXknO1xuXG4vKiogY2xhc3MgVGFibGVcbiAqIFxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZVxuICovXG5leHBvcnQgY2xhc3MgVGFibGUgaW1wbGVtZW50cyBJVGFibGU8YW55LCBJbmRleGFibGVUeXBlPiB7XG4gIGRiOiBEZXhpZTtcbiAgX3R4PzogVHJhbnNhY3Rpb247XG4gIG5hbWU6IHN0cmluZztcbiAgc2NoZW1hOiBUYWJsZVNjaGVtYTtcbiAgaG9vazogVGFibGVIb29rcztcbiAgY29yZTogREJDb3JlVGFibGU7XG5cbiAgX3RyYW5zKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkLFxuICAgIHdyaXRlTG9ja2VkPzogYm9vbGVhbiB8IHN0cmluZykgOiBQcm9taXNlRXh0ZW5kZWQ8YW55PlxuICB7XG4gICAgY29uc3QgdHJhbnM6IFRyYW5zYWN0aW9uID0gdGhpcy5fdHggfHwgUFNELnRyYW5zO1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMubmFtZTtcbiAgICBcbiAgICBmdW5jdGlvbiBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbihyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCF0cmFucy5zY2hlbWFbdGFibGVOYW1lXSlcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgcmV0dXJuIGZuKHRyYW5zLmlkYnRyYW5zLCB0cmFucyk7XG4gICAgfVxuICAgIC8vIFN1cnJvdW5kIGFsbCBpbiBhIG1pY3JvdGljayBzY29wZS5cbiAgICAvLyBSZWFzb246IEJyb3dzZXJzIChtb2Rlcm4gU2FmYXJpICsgb2xkZXIgb3RoZXJzKVxuICAgIC8vIHN0aWxsIGFzIG9mIDIwMTgtMTAtMTAgaGFzIHByb2JsZW1zIGtlZXBpbmcgYSB0cmFuc2FjdGlvblxuICAgIC8vIGFsaXZlIGJldHdlZW4gbWljcm8gdGlja3MuIFNhZmFyaSBiZWNhdXNlIGlmIHRyYW5zYWN0aW9uXG4gICAgLy8gaXMgY3JlYXRlZCBidXQgbm90IHVzZWQgaW4gc2FtZSBtaWNyb3RpY2ssIGl0IHdpbGwgZ29cbiAgICAvLyBhd2F5LiBUaGF0IHNwZWNpZmljIGlzc3VlIGNvdWxkIGJlIHNvbHZlZCBpbiBEQkNvcmVcbiAgICAvLyBieSBvcGVuaW5nIHRoZSB0cmFuc2FjdGlvbiBqdXN0IGJlZm9yZSB1c2luZyBpdCBpbnN0ZWFkLlxuICAgIC8vIEJ1dCBvbGRlciBGaXJlZm94ZXMgYW5kIElFMTEgKHdpdGggUHJvbWlzZSBwb2x5ZmlsbHMpXG4gICAgLy8gd2lsbCBzdGlsbCBoYXZlIHByb2JzLlxuICAgIC8vIFRoZSBiZWdpbk1pY3JvdGlja1Njb3BlKCkvZW5kTWljcm90aWNrU2NvcGUoKSB3b3Jrc1xuICAgIC8vIGluIGNvb3BlcmF0aW9uIHdpdGggRGV4aWUuUHJvbWlzZSB0byBvcmNoZXN0cmF0ZVxuICAgIC8vIHRoZSBtaWNyby10aWNrcyBpbiBlbmRNaWNyb3RpY2tTY29wZSgpIHJhdGhlciB0aGFuXG4gICAgLy8gaW4gbmF0aXZlIGVuZ2luZS5cbiAgICBjb25zdCB3YXNSb290RXhlYyA9IGJlZ2luTWljcm9UaWNrU2NvcGUoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRyYW5zICYmIHRyYW5zLmRiID09PSB0aGlzLmRiID9cbiAgICAgICAgdHJhbnMgPT09IFBTRC50cmFucyA/XG4gICAgICAgICAgdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSA6XG4gICAgICAgICAgbmV3U2NvcGUoKCkgPT4gdHJhbnMuX3Byb21pc2UobW9kZSwgY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24sIHdyaXRlTG9ja2VkKSwgeyB0cmFuczogdHJhbnMsIHRyYW5zbGVzczogUFNELnRyYW5zbGVzcyB8fCBQU0QgfSkgOlxuICAgICAgICB0ZW1wVHJhbnNhY3Rpb24odGhpcy5kYiwgbW9kZSwgW3RoaXMubmFtZV0sIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHdhc1Jvb3RFeGVjKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUYWJsZS5nZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5nZXQoKVxuICAgKiBcbiAgICoqL1xuICBnZXQoa2V5T3JDcml0LCBjYj8pIHtcbiAgICBpZiAoa2V5T3JDcml0ICYmIGtleU9yQ3JpdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoa2V5T3JDcml0IGFzIHsgW2tleTogc3RyaW5nXTogSW5kZXhhYmxlVHlwZSB9KS5maXJzdChjYik7XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWRvbmx5JywgKHRyYW5zKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLmdldCh7dHJhbnMsIGtleToga2V5T3JDcml0fSlcbiAgICAgICAgLnRoZW4ocmVzID0+IHRoaXMuaG9vay5yZWFkaW5nLmZpcmUocmVzKSk7XG4gICAgfSkudGhlbihjYik7XG4gIH1cblxuICAvKiogVGFibGUud2hlcmUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS53aGVyZSgpXG4gICAqIFxuICAgKiovXG4gIHdoZXJlKGluZGV4T3JDcml0OiBzdHJpbmcgfCBzdHJpbmdbXSB8IHsgW2tleTogc3RyaW5nXTogSW5kZXhhYmxlVHlwZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleE9yQ3JpdCA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaW5kZXhPckNyaXQpO1xuICAgIGlmIChpc0FycmF5KGluZGV4T3JDcml0KSlcbiAgICAgIHJldHVybiBuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzLCBgWyR7aW5kZXhPckNyaXQuam9pbignKycpfV1gKTtcbiAgICAvLyBpbmRleE9yQ3JpdCBpcyBhbiBvYmplY3QgbWFwIG9mIHtba2V5UGF0aF06dmFsdWV9IFxuICAgIGNvbnN0IGtleVBhdGhzID0ga2V5cyhpbmRleE9yQ3JpdCk7XG4gICAgaWYgKGtleVBhdGhzLmxlbmd0aCA9PT0gMSlcbiAgICAgIC8vIE9ubHkgb25lIGNyaXRlcmEuIFRoaXMgd2FzIHRoZSBlYXN5IGNhc2U6XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAud2hlcmUoa2V5UGF0aHNbMF0pXG4gICAgICAgIC5lcXVhbHMoaW5kZXhPckNyaXRba2V5UGF0aHNbMF1dKTtcblxuICAgIC8vIE11bHRpcGxlIGNyaXRlcmlhcy5cbiAgICAvLyBMZXQncyB0cnkgZmluZGluZyBhIGNvbXBvdW5kIGluZGV4IHRoYXQgbWF0Y2hlcyBhbGwga2V5UGF0aHMgaW5cbiAgICAvLyBhcmJyaXRhcnkgb3JkZXI6XG4gICAgY29uc3QgY29tcG91bmRJbmRleCA9IHRoaXMuc2NoZW1hLmluZGV4ZXMuY29uY2F0KHRoaXMuc2NoZW1hLnByaW1LZXkpLmZpbHRlcihpeCA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGl4LmNvbXBvdW5kICYmXG4gICAgICAgIGtleVBhdGhzLmV2ZXJ5KGtleVBhdGggPT4gaXgua2V5UGF0aC5pbmRleE9mKGtleVBhdGgpID49IDApKSB7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGtleVBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoa2V5UGF0aHMuaW5kZXhPZihpeC5rZXlQYXRoW2ldKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSkuc29ydCgoYSxiKSA9PiBhLmtleVBhdGgubGVuZ3RoIC0gYi5rZXlQYXRoLmxlbmd0aClbMF07XG4gICAgICAgICAgICBcbiAgICBpZiAoY29tcG91bmRJbmRleCAmJiB0aGlzLmRiLl9tYXhLZXkgIT09IG1heFN0cmluZykge1xuICAgICAgLy8gQ29vbCEgV2UgZm91bmQgc3VjaCBjb21wb3VuZCBpbmRleFxuICAgICAgLy8gYW5kIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBjb21wb3VuZCBpbmRleGVzIChtYXhLZXkgIT09IG1heFN0cmluZykhXG4gICAgICBjb25zdCBrZXlQYXRoc0luVmFsaWRPcmRlciA9IChjb21wb3VuZEluZGV4LmtleVBhdGggYXMgc3RyaW5nW10pLnNsaWNlKDAsIGtleVBhdGhzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgICAgICAud2hlcmUoa2V5UGF0aHNJblZhbGlkT3JkZXIpXG4gICAgICAgIC5lcXVhbHMoa2V5UGF0aHNJblZhbGlkT3JkZXIubWFwKGtwID0+IGluZGV4T3JDcml0W2twXSkpO1xuICAgIH1cblxuICAgIGlmICghY29tcG91bmRJbmRleCAmJiBkZWJ1ZykgY29uc29sZS53YXJuKFxuICAgICAgYFRoZSBxdWVyeSAke0pTT04uc3RyaW5naWZ5KGluZGV4T3JDcml0KX0gb24gJHt0aGlzLm5hbWV9IHdvdWxkIGJlbmVmaXQgb2YgYSBgICtcbiAgICAgIGBjb21wb3VuZCBpbmRleCBbJHtrZXlQYXRocy5qb2luKCcrJyl9XWApO1xuXG4gICAgLy8gT2ssIG5vdyBsZXQncyBmYWxsYmFjayB0byBmaW5kaW5nIGF0IGxlYXN0IG9uZSBtYXRjaGluZyBpbmRleFxuICAgIC8vIGFuZCBmaWx0ZXIgdGhlIHJlc3QuXG4gICAgY29uc3QgeyBpZHhCeU5hbWUgfSA9IHRoaXMuc2NoZW1hO1xuICAgIGNvbnN0IGlkYiA9IHRoaXMuZGIuX2RlcHMuaW5kZXhlZERCO1xuXG4gICAgZnVuY3Rpb24gZXF1YWxzIChhLCBiKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gaWRiLmNtcChhLGIpID09PSAwOyAvLyBXb3JrcyB3aXRoIGFsbCBpbmRleGFibGUgdHlwZXMgaW5jbHVkaW5nIGJpbmFyeSBrZXlzLlxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgW2lkeCwgZmlsdGVyRnVuY3Rpb25dID0ga2V5UGF0aHMucmVkdWNlKChbcHJldkluZGV4LCBwcmV2RmlsdGVyRm5dLCBrZXlQYXRoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGlkeEJ5TmFtZVtrZXlQYXRoXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5kZXhPckNyaXRba2V5UGF0aF07XG4gICAgICByZXR1cm4gW1xuICAgICAgICBwcmV2SW5kZXggfHwgaW5kZXgsIC8vIGlkeDo6PVBpY2sgaW5kZXggb2YgZmlyc3QgbWF0Y2hpbmcga2V5cGF0aFxuICAgICAgICBwcmV2SW5kZXggfHwgIWluZGV4ID8gLy8gZmlsdGVyOjo9bnVsbCBpZiBub3QgbmVlZGVkLCBvdGhlcndpc2UgY29tYmluZSBmdW5jdGlvbiBmaWx0ZXJcbiAgICAgICAgICBjb21iaW5lKFxuICAgICAgICAgICAgcHJldkZpbHRlckZuLFxuICAgICAgICAgICAgaW5kZXggJiYgaW5kZXgubXVsdGkgP1xuICAgICAgICAgICAgICB4ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gZ2V0QnlLZXlQYXRoKHgsIGtleVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHByb3ApICYmIHByb3Auc29tZShpdGVtID0+IGVxdWFscyh2YWx1ZSwgaXRlbSkpO1xuICAgICAgICAgICAgICB9IDogeCA9PiBlcXVhbHModmFsdWUsIGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKSkpXG4gICAgICAgICAgOiBwcmV2RmlsdGVyRm5cbiAgICAgIF07XG4gICAgfSwgW251bGwsIG51bGxdKTtcblxuICAgIHJldHVybiBpZHggP1xuICAgICAgdGhpcy53aGVyZShpZHgubmFtZSkuZXF1YWxzKGluZGV4T3JDcml0W2lkeC5rZXlQYXRoXSlcbiAgICAgICAgLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOlxuICAgICAgY29tcG91bmRJbmRleCA/XG4gICAgICAgIHRoaXMuZmlsdGVyKGZpbHRlckZ1bmN0aW9uKSA6IC8vIEhhcyBjb21wb3VuZCBidXQgYnJvd3NlciBiYWQuIEFsbG93IGZpbHRlci5cbiAgICAgICAgdGhpcy53aGVyZShrZXlQYXRocykuZXF1YWxzKCcnKTsgLy8gTm8gaW5kZXggYXQgYWxsLiBGYWlsIGxhemlseSB3aXRoIFwiW2ErYitjXSBpcyBub3QgaW5kZXhlZFwiXG4gIH1cblxuICAvKiogVGFibGUuZmlsdGVyKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZmlsdGVyKClcbiAgICogXG4gICAqKi9cbiAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uOiAob2JqOiBhbnkpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5hbmQoZmlsdGVyRnVuY3Rpb24pO1xuICB9XG5cbiAgLyoqIFRhYmxlLmNvdW50KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuY291bnQoKVxuICAgKiBcbiAgICoqL1xuICBjb3VudCh0aGVuU2hvcnRjdXQ/OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5jb3VudCh0aGVuU2hvcnRjdXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLm9mZnNldCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLm9mZnNldCgpXG4gICAqIFxuICAgKiovXG4gIG9mZnNldChvZmZzZXQ6IG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLm9mZnNldChvZmZzZXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmxpbWl0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUubGltaXQoKVxuICAgKiBcbiAgICoqL1xuICBsaW1pdChudW1Sb3dzOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5saW1pdChudW1Sb3dzKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5lYWNoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZWFjaCgpXG4gICAqIFxuICAgKiovXG4gIGVhY2goY2FsbGJhY2s6IChvYmo6IGFueSwgY3Vyc29yOiB7IGtleTogSW5kZXhhYmxlVHlwZSwgcHJpbWFyeUtleTogSW5kZXhhYmxlVHlwZSB9KSA9PiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5lYWNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS50b0FycmF5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUudG9BcnJheSgpXG4gICAqIFxuICAgKiovXG4gIHRvQXJyYXkodGhlblNob3J0Y3V0PzogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkudG9BcnJheSh0aGVuU2hvcnRjdXQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLnRvQ29sbGVjdGlvbigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLnRvQ29sbGVjdGlvbigpXG4gICAqIFxuICAgKiovXG4gIHRvQ29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihuZXcgdGhpcy5kYi5XaGVyZUNsYXVzZSh0aGlzKSk7XG4gIH1cblxuICAvKiogVGFibGUub3JkZXJCeSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLm9yZGVyQnkoKVxuICAgKiBcbiAgICoqL1xuICBvcmRlckJ5KGluZGV4OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgIHJldHVybiBuZXcgdGhpcy5kYi5Db2xsZWN0aW9uKFxuICAgICAgbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgaXNBcnJheShpbmRleCkgP1xuICAgICAgICBgWyR7aW5kZXguam9pbignKycpfV1gIDpcbiAgICAgICAgaW5kZXgpKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5yZXZlcnNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUucmV2ZXJzZSgpXG4gICAqIFxuICAgKiovXG4gIHJldmVyc2UoKTogQ29sbGVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgLyoqIFRhYmxlLm1hcFRvQ2xhc3MoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5tYXBUb0NsYXNzKClcbiAgICogXG4gICAqKi9cbiAgbWFwVG9DbGFzcyhjb25zdHJ1Y3RvcjogRnVuY3Rpb24pIHtcbiAgICB0aGlzLnNjaGVtYS5tYXBwZWRDbGFzcyA9IGNvbnN0cnVjdG9yO1xuICAgIC8vIE5vdywgc3Vic2NyaWJlIHRvIHRoZSB3aGVuKFwicmVhZGluZ1wiKSBldmVudCB0byBtYWtlIGFsbCBvYmplY3RzIHRoYXQgY29tZSBvdXQgZnJvbSB0aGlzIHRhYmxlIGluaGVyaXQgZnJvbSBnaXZlbiBjbGFzc1xuICAgIC8vIG5vIG1hdHRlciB3aGljaCBtZXRob2QgdG8gdXNlIGZvciByZWFkaW5nIChUYWJsZS5nZXQoKSBvciBUYWJsZS53aGVyZSguLi4pLi4uIClcbiAgICBjb25zdCByZWFkSG9vayA9IG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajsgLy8gTm8gdmFsaWQgb2JqZWN0LiAoVmFsdWUgaXMgbnVsbCkuIFJldHVybiBhcyBpcy5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdGhhdCBkZXJpdmVzIGZyb20gY29uc3RydWN0b3I6XG4gICAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAvLyBDbG9uZSBtZW1iZXJzOlxuICAgICAgZm9yICh2YXIgbSBpbiBvYmopIGlmIChoYXNPd24ob2JqLCBtKSkgdHJ5IHsgcmVzW21dID0gb2JqW21dOyB9IGNhdGNoIChfKSB7IH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNjaGVtYS5yZWFkSG9vaykge1xuICAgICAgdGhpcy5ob29rLnJlYWRpbmcudW5zdWJzY3JpYmUodGhpcy5zY2hlbWEucmVhZEhvb2spO1xuICAgIH1cbiAgICB0aGlzLnNjaGVtYS5yZWFkSG9vayA9IHJlYWRIb29rO1xuICAgIHRoaXMuaG9vayhcInJlYWRpbmdcIiwgcmVhZEhvb2spO1xuICAgIHJldHVybiBjb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBkZWZpbmVDbGFzcygpIHtcbiAgICBmdW5jdGlvbiBDbGFzcyAoY29udGVudCl7XG4gICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5tYXBUb0NsYXNzKENsYXNzKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5hZGQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5hZGQoKVxuICAgKiBcbiAgICoqL1xuICBhZGQob2JqLCBrZXk/OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGU+IHtcbiAgICBjb25zdCB7YXV0bywga2V5UGF0aH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5ICE9IG51bGwgPyBba2V5XSA6IG51bGwsIHZhbHVlczogW29ialRvQWRkXX0pO1xuICAgIH0pLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgdGhpcywgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgICB0cnl7c2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7fWNhdGNoKF8pe307XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS51cGRhdGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS51cGRhdGUoKVxuICAgKiBcbiAgICoqL1xuICB1cGRhdGUoa2V5T3JPYmplY3QsIG1vZGlmaWNhdGlvbnM6IHsgW2tleVBhdGg6IHN0cmluZ106IGFueTsgfSB8ICgob2JqOiBhbnksIGN0eDp7dmFsdWU6IGFueSwgcHJpbUtleTogSW5kZXhhYmxlVHlwZX0pID0+IHZvaWQgfCBib29sZWFuKSk6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgICBpZiAodHlwZW9mIGtleU9yT2JqZWN0ID09PSAnb2JqZWN0JyAmJiAhaXNBcnJheShrZXlPck9iamVjdCkpIHtcbiAgICAgIGNvbnN0IGtleSA9IGdldEJ5S2V5UGF0aChrZXlPck9iamVjdCwgdGhpcy5zY2hlbWEucHJpbUtleS5rZXlQYXRoKTtcbiAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXG4gICAgICAgIFwiR2l2ZW4gb2JqZWN0IGRvZXMgbm90IGNvbnRhaW4gaXRzIHByaW1hcnkga2V5XCIpKTtcbiAgICAgIC8vIG9iamVjdCB0byBtb2RpZnkuIEFsc28gbW9kaWZ5IGdpdmVuIG9iamVjdCB3aXRoIHRoZSBtb2RpZmljYXRpb25zOlxuICAgICAgLy8gVGhpcyBwYXJ0IHNob3VsZCBiZSBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgbXV0YXRpbmcgZ2l2ZW4gb2JqZWN0LCBwbGVhc2Ugd2FpdCB0byBhIG5ldyBtYWpvciBiZWZvcmUgcmVtb3ZpbmcgaXQsXG4gICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmljYXRpb25zICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBrZXlzKG1vZGlmaWNhdGlvbnMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICBzZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIGtleVBhdGgsIG1vZGlmaWNhdGlvbnNba2V5UGF0aF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vdyBzaW5jZSB3ZSBzdXBwb3J0IGZ1bmN0aW9uIGFyZ3VtZW50LCB3ZSBzaG91bGQgaGF2ZSBhIHNpbWlsYXIgYmVoYXZpb3IgaGVyZSBhcyB3ZWxsXG4gICAgICAgICAgLy8gKGFzIGxvbmcgYXMgd2UgZG8gdGhpcyBtdXRhYmlsaXR5IHN0dWZmIG9uIHRoZSBnaXZlbiBvYmplY3QpXG4gICAgICAgICAgbW9kaWZpY2F0aW9ucyhrZXlPck9iamVjdCwge3ZhbHVlOiBrZXlPck9iamVjdCwgcHJpbUtleToga2V5fSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBNYXliZSBnaXZlbiBvYmplY3Qgd2FzIGZyb3plbi5cbiAgICAgICAgLy8gVGhpcyBwYXJ0IGlzIG5vdCBlc3NlbnRpYWwuIEp1c3QgbW92ZSBvbiBhcyBub3RoaW5nIGhhcHBlbmVkLi4uXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5KS5tb2RpZnkobW9kaWZpY2F0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleSB0byBtb2RpZnlcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKFwiOmlkXCIpLmVxdWFscyhrZXlPck9iamVjdCkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUYWJsZS5wdXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5wdXQoKVxuICAgKiBcbiAgICoqL1xuICBwdXQob2JqLCBrZXk/OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGU+IHtcbiAgICBjb25zdCB7YXV0bywga2V5UGF0aH0gPSB0aGlzLnNjaGVtYS5wcmltS2V5O1xuICAgIGxldCBvYmpUb0FkZCA9IG9iajtcbiAgICBpZiAoa2V5UGF0aCAmJiBhdXRvKSB7XG4gICAgICBvYmpUb0FkZCA9IHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKG9iaik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFucyhcbiAgICAgICdyZWFkd3JpdGUnLFxuICAgICAgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdwdXQnLCB2YWx1ZXM6IFtvYmpUb0FkZF0sIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiByZXMubGFzdFJlc3VsdClcbiAgICAudGhlbihsYXN0UmVzdWx0ID0+IHtcbiAgICAgIGlmIChrZXlQYXRoKSB7XG4gICAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgLy8gSWYgZXZlciBmZWVsaW5nIHRvbyBiYWQgYWJvdXQgdGhpcywgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgICAvLyBhbmQgZG9jdW1lbnQgdGhlIGNoYW5nZSB0aG9yb3VnaGx5LlxuICAgICAgICB0cnl7c2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCwgbGFzdFJlc3VsdCk7fWNhdGNoKF8pe307XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5kZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBkZWxldGUoa2V5OiBJbmRleGFibGVUeXBlKTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IFtrZXldfSkpXG4gICAgLnRoZW4ocmVzID0+IHJlcy5udW1GYWlsdXJlcyA/IFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSkgOiB1bmRlZmluZWQpO1xuICB9XG5cbiAgLyoqIFRhYmxlLmNsZWFyKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuY2xlYXIoKVxuICAgKiBcbiAgICoqL1xuICBjbGVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsXG4gICAgICB0cmFucyA9PiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IEFueVJhbmdlfSkpXG4gICAgICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrR2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0dldCgpXG4gICAqIFxuICAgKiBAcGFyYW0ga2V5cyBcbiAgICovXG4gIGJ1bGtHZXQoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUuZ2V0TWFueSh7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHRyYW5zXG4gICAgICB9KS50aGVuKHJlc3VsdCA9PiByZXN1bHQubWFwKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5idWxrQWRkKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYnVsa0FkZCgpXG4gICAqIFxuICAgKiovXG4gIGJ1bGtBZGQoXG4gICAgb2JqZWN0czogYW55W10sXG4gICAga2V5c09yT3B0aW9ucz86IFJlYWRvbmx5QXJyYXk8SW5kZXhhYmxlVHlwZT4gfCB7IGFsbEtleXM/OiBib29sZWFuIH0sXG4gICAgb3B0aW9ucz86IHsgYWxsS2V5cz86IGJvb2xlYW4gfVxuICApIHsgICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtBZGQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvQWRkID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKFxuICAgICAgICB7dHJhbnMsIHR5cGU6ICdhZGQnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXSwgdmFsdWVzOiBvYmplY3RzVG9BZGQsIHdhbnRSZXN1bHRzfVxuICAgICAgKVxuICAgICAgICAudGhlbigoe251bUZhaWx1cmVzLCByZXN1bHRzLGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtBZGQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa1B1dCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtQdXQoKVxuICAgKiBcbiAgICoqL1xuICBidWxrUHV0KFxuICAgIG9iamVjdHM6IGFueVtdLFxuICAgIGtleXNPck9wdGlvbnM/OiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+IHwgeyBhbGxLZXlzPzogYm9vbGVhbiB9LFxuICAgIG9wdGlvbnM/OiB7IGFsbEtleXM/OiBib29sZWFuIH1cbiAgKSB7ICAgXG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5c09yT3B0aW9ucykgPyBrZXlzT3JPcHRpb25zIDogdW5kZWZpbmVkO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IChrZXlzID8gdW5kZWZpbmVkIDoga2V5c09yT3B0aW9ucyBhcyB7IGFsbEtleXM/OiBib29sZWFuIH0pO1xuICAgIGNvbnN0IHdhbnRSZXN1bHRzID0gb3B0aW9ucyA/IG9wdGlvbnMuYWxsS2V5cyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZHdyaXRlJywgdHJhbnMgPT4ge1xuICAgICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICAgIGlmIChrZXlQYXRoICYmIGtleXMpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcImJ1bGtQdXQoKToga2V5cyBhcmd1bWVudCBpbnZhbGlkIG9uIHRhYmxlcyB3aXRoIGluYm91bmQga2V5c1wiKTtcbiAgICAgIGlmIChrZXlzICYmIGtleXMubGVuZ3RoICE9PSBvYmplY3RzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG9iamVjdHMgYW5kIGtleXMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcblxuICAgICAgY29uc3QgbnVtT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoOyAvLyBQaWNrIGxlbmd0aCBoZXJlIHRvIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbiBvZiBvYmplY3RzIGxhdGVyXG4gICAgICBsZXQgb2JqZWN0c1RvUHV0ID0ga2V5UGF0aCAmJiBhdXRvID9cbiAgICAgICAgb2JqZWN0cy5tYXAod29ya2Fyb3VuZEZvclVuZGVmaW5lZFByaW1LZXkoa2V5UGF0aCkpIDpcbiAgICAgICAgb2JqZWN0cztcblxuICAgICAgcmV0dXJuIHRoaXMuY29yZS5tdXRhdGUoXG4gICAgICAgIHt0cmFucywgdHlwZTogJ3B1dCcsIGtleXM6IGtleXMgYXMgSW5kZXhhYmxlVHlwZVtdLCB2YWx1ZXM6IG9iamVjdHNUb1B1dCwgd2FudFJlc3VsdHN9XG4gICAgICApXG4gICAgICAgIC50aGVuKCh7bnVtRmFpbHVyZXMsIHJlc3VsdHMsIGxhc3RSZXN1bHQsIGZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbnRSZXN1bHRzID8gcmVzdWx0cyA6IGxhc3RSZXN1bHQ7XG4gICAgICAgICAgaWYgKG51bUZhaWx1cmVzID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIHRocm93IG5ldyBCdWxrRXJyb3IoXG4gICAgICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtQdXQoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1PYmplY3RzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa0RlbGV0ZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtEZWxldGUoKVxuICAgKiBcbiAgICoqL1xuICBidWxrRGVsZXRlKGtleXM6IFJlYWRvbmx5QXJyYXk8SW5kZXhhYmxlVHlwZT4pOiBQcm9taXNlRXh0ZW5kZWQ8dm9pZD4ge1xuICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZScsIGtleXM6IGtleXMgYXMgSW5kZXhhYmxlVHlwZVtdfSk7XG4gICAgfSkudGhlbigoe251bUZhaWx1cmVzLCBsYXN0UmVzdWx0LCBmYWlsdXJlc30pID0+IHtcbiAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMCkgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFxuICAgICAgICBgJHt0aGlzLm5hbWV9LmJ1bGtEZWxldGUoKTogJHtudW1GYWlsdXJlc30gb2YgJHtudW1LZXlzfSBvcGVyYXRpb25zIGZhaWxlZGAsIGZhaWx1cmVzKTtcbiAgICB9KTtcbiAgfVxufVxuIiwgImltcG9ydCB7a2V5cywgaXNBcnJheSwgYXNhcH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7bm9wLCBtaXJyb3IsIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWlufSBmcm9tICcuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7ZXhjZXB0aW9uc30gZnJvbSAnLi4vZXJyb3JzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXZlbnRzKGN0eCkge1xuICAgIHZhciBldnMgPSB7fTtcbiAgICB2YXIgcnYgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUuIElmIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYW4ganVzdCB0aGUgc3Vic2NyaWJlciB3YXMgcHJvdmlkZWQsIGZvcndhcmQgdGhlbSBhcyB3ZWxsLlxuICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgICAgICAgICAgIHdoaWxlICgtLWkpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZXZzW2V2ZW50TmFtZV0uc3Vic2NyaWJlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gaW50ZXJmYWNlIGFsbG93aW5nIHRvIGZpcmUgb3IgdW5zdWJzY3JpYmUgZnJvbSBldmVudFxuICAgICAgICAgICAgcmV0dXJuIGV2c1tldmVudE5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBydi5hZGRFdmVudFR5cGUgPSBhZGQ7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGFkZChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcnY7XG5cbiAgICBmdW5jdGlvbiBhZGQoZXZlbnROYW1lLCBjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnKSByZXR1cm4gYWRkQ29uZmlndXJlZEV2ZW50cyhldmVudE5hbWUpO1xuICAgICAgICBpZiAoIWNoYWluRnVuY3Rpb24pIGNoYWluRnVuY3Rpb24gPSByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbjtcbiAgICAgICAgaWYgKCFkZWZhdWx0RnVuY3Rpb24pIGRlZmF1bHRGdW5jdGlvbiA9IG5vcDtcblxuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgICAgIGZpcmU6IGRlZmF1bHRGdW5jdGlvbixcbiAgICAgICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3Vic2NyaWJlcnMuaW5kZXhPZihjYikgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNoYWluRnVuY3Rpb24oY29udGV4dC5maXJlLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzID0gY29udGV4dC5zdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbiAhPT0gY2I7IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlyZSA9IGNvbnRleHQuc3Vic2NyaWJlcnMucmVkdWNlKGNoYWluRnVuY3Rpb24sIGRlZmF1bHRGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGV2c1tldmVudE5hbWVdID0gcnZbZXZlbnROYW1lXSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENvbmZpZ3VyZWRFdmVudHMoY2ZnKSB7XG4gICAgICAgIC8vIGV2ZW50cyh0aGlzLCB7cmVhZGluZzogW2Z1bmN0aW9uQ2hhaW4sIG5vcF19KTtcbiAgICAgICAga2V5cyhjZmcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBjZmdbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYWRkKGV2ZW50TmFtZSwgY2ZnW2V2ZW50TmFtZV1bMF0sIGNmZ1tldmVudE5hbWVdWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJncyA9PT0gJ2FzYXAnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmF0aGVyIHRoYW4gYXBwcm9hY2hpbmcgZXZlbnQgc3Vic2NyaXB0aW9uIHVzaW5nIGEgZnVuY3Rpb25hbCBhcHByb2FjaCwgd2UgaGVyZSBkbyBpdCBpbiBhIGZvci1sb29wIHdoZXJlIHN1YnNjcmliZXIgaXMgZXhlY3V0ZWQgaW4gaXRzIG93biBzdGFja1xuICAgICAgICAgICAgICAgIC8vIGVuYWJsaW5nIHRoYXQgYW55IGV4Y2VwdGlvbiB0aGF0IG9jY3VyIHdvbnQgZGlzdHVyYiB0aGUgaW5pdGlhdG9yIGFuZCBhbHNvIG5vdCBuZXNjZXNzYXJ5IGJlIGNhdGNoZWQgYW5kIGZvcmdvdHRlbi5cbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGFkZChldmVudE5hbWUsIG1pcnJvciwgZnVuY3Rpb24gZmlyZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1hemF0aW9uLXNhZmUgY2xvbmluZyBvZiBhcmd1bWVudHMgaW50byBhcmdzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBlYWNoIHN1YnNjcmliZXI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzYXAoZnVuY3Rpb24gZmlyZUV2ZW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgZXZlbnQgY29uZmlnXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgYXJyYXlUb09iamVjdCwgZGVyaXZlIH0gZnJvbSAnLi91dGlscyc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFRDb25zdHJ1Y3Rvcj4gKHByb3RvdHlwZTogT2JqZWN0LCBjb25zdHJ1Y3RvcjogRnVuY3Rpb24pIHtcbiAgLypjb25zdCBwcm9wZXJ0eURlc2NyaXB0b3JNYXAgPSBhcnJheVRvT2JqZWN0KFxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvdHlwZSksXG4gICAgcHJvcEtleSA9PiBbcHJvcEtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BLZXkpXSk7XG5cbiAgLy8gQm90aCBkZXJpdmUgYW5kIGNsb25lIHRoZSBwcm90b3R5cGUuXG4gIC8vICAgZGVyaXZlOiBTbyB0aGF0IHggaW5zdGFuY2VvZiBUIHJldHVybnMgdHJ1ZSB3aGVuIFQgaXMgdGhlIGNsYXNzIHRlbXBsYXRlLlxuICAvLyAgIGNsb25lOiBPcHRpbWl6ZXMgbWV0aG9kIGFjY2VzcyBhIGJpdCAoYnV0IGFjdHVhbGx5IG5vdCBuZXNjZXNzYXJ5KVxuICBjb25zdCBkZXJpdmVkUHJvdG90eXBlQ2xvbmUgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydHlEZXNjcmlwdG9yTWFwKTtcbiAgZGVyaXZlZFByb3RvdHlwZUNsb25lLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGRlcml2ZWRQcm90b3R5cGVDbG9uZTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yIGFzIGFueSBhcyBUQ29uc3RydWN0b3I7Ki9cblxuICAvLyBLZWVwIHRoZSBhYm92ZSBjb2RlIGluIGNhc2Ugd2Ugd2FudCB0byBjbG9uZSBBTkQgZGVyaXZlIHRoZSBwYXJlbnQgcHJvdG90eXBlLlxuICAvLyBSZWFzb24gd291bGQgYmUgb3B0aW1pemF0aW9uIG9mIHByb3BlcnR5IGFjY2Vzcy5cbiAgLy8gVGhlIGNvZGUgYmVsb3cgd2lsbCBvbmx5IGNyZWF0ZSBhIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgZnJvbSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAvLyB0byBnaXZlbiBwcm90b3R5cGUuXG4gIGRlcml2ZShjb25zdHJ1Y3RvcikuZnJvbSh7cHJvdG90eXBlfSk7XG4gIHJldHVybiBjb25zdHJ1Y3RvciBhcyBhbnkgYXMgVENvbnN0cnVjdG9yOyAgXG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWEnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBob29rQ3JlYXRpbmdDaGFpbiwgcHVyZUZ1bmN0aW9uQ2hhaW4sIG5vcCwgbWlycm9yLCBob29rVXBkYXRpbmdDaGFpbiwgaG9va0RlbGV0aW5nQ2hhaW4gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7IFRhYmxlSG9va3MgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtaG9va3MnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDb25zdHJ1Y3RvciB7XG4gIG5ldyAobmFtZTogc3RyaW5nLCB0YWJsZVNjaGVtYTogVGFibGVTY2hlbWEsIG9wdGlvbmFsVHJhbnM/OiBUcmFuc2FjdGlvbikgOiBUYWJsZTtcbiAgcHJvdG90eXBlOiBUYWJsZTtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFRhYmxlIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFibGVDb25zdHJ1Y3RvciAoZGI6IERleGllKSB7XG4gIHJldHVybiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxUYWJsZUNvbnN0cnVjdG9yPihcbiAgICBUYWJsZS5wcm90b3R5cGUsXG5cbiAgICBmdW5jdGlvbiBUYWJsZSAodGhpczogVGFibGUsIG5hbWU6IHN0cmluZywgdGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCB0cmFucz86IFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl90eCA9IHRyYW5zO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHRoaXMuc2NoZW1hID0gdGFibGVTY2hlbWE7XG4gICAgICB0aGlzLmhvb2sgPSBkYi5fYWxsVGFibGVzW25hbWVdID8gZGIuX2FsbFRhYmxlc1tuYW1lXS5ob29rIDogRXZlbnRzKG51bGwsIHtcbiAgICAgICAgXCJjcmVhdGluZ1wiOiBbaG9va0NyZWF0aW5nQ2hhaW4sIG5vcF0sXG4gICAgICAgIFwicmVhZGluZ1wiOiBbcHVyZUZ1bmN0aW9uQ2hhaW4sIG1pcnJvcl0sXG4gICAgICAgIFwidXBkYXRpbmdcIjogW2hvb2tVcGRhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICBcImRlbGV0aW5nXCI6IFtob29rRGVsZXRpbmdDaGFpbiwgbm9wXVxuICAgICAgfSkgYXMgVGFibGVIb29rcztcbiAgICB9XG5cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBjb21iaW5lIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lXCI7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSBcIi4uLy4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgaGFzT3duIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBEQkNvcmVDdXJzb3IsIERCQ29yZVRhYmxlLCBEQkNvcmVUcmFuc2FjdGlvbiwgREJDb3JlVGFibGVTY2hlbWEsIERCQ29yZVJhbmdlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgbm9wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5cbnR5cGUgQ29sbGVjdGlvbkNvbnRleHQgPSBDb2xsZWN0aW9uW1wiX2N0eFwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5LZXlSYW5nZSAoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgaWdub3JlTGltaXRGaWx0ZXI/OiBib29sZWFuKSB7XG4gIHJldHVybiAhKGN0eC5maWx0ZXIgfHwgY3R4LmFsZ29yaXRobSB8fCBjdHgub3IpICYmXG4gICAgICAoaWdub3JlTGltaXRGaWx0ZXIgPyBjdHguanVzdExpbWl0IDogIWN0eC5yZXBsYXlGaWx0ZXIpO1xufSAgICBcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZpbHRlcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmbjogRnVuY3Rpb24pIHtcbiAgY3R4LmZpbHRlciA9IGNvbWJpbmUoY3R4LmZpbHRlciwgZm4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkUmVwbGF5RmlsdGVyIChjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmYWN0b3J5LCBpc0xpbWl0RmlsdGVyPykge1xuICB2YXIgY3VyciA9IGN0eC5yZXBsYXlGaWx0ZXI7XG4gIGN0eC5yZXBsYXlGaWx0ZXIgPSBjdXJyID8gKCk9PmNvbWJpbmUoY3VycigpLCBmYWN0b3J5KCkpIDogZmFjdG9yeTtcbiAgY3R4Lmp1c3RMaW1pdCA9IGlzTGltaXRGaWx0ZXIgJiYgIWN1cnI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNYXRjaEZpbHRlcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBmbikge1xuICBjdHguaXNNYXRjaCA9IGNvbWJpbmUoY3R4LmlzTWF0Y2gsIGZuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4T3JTdG9yZShjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBjb3JlU2NoZW1hOiBEQkNvcmVUYWJsZVNjaGVtYSkge1xuICAvLyBUT0RPOiBSZXdyaXRlIHRoaXMuIE5vIG5lZWQgdG8ga25vdyBjdHguaXNQcmltS2V5LiBjdHguaW5kZXggc2hvdWxkIGhvbGQgdGhlIGtleXBhdGguXG4gIC8vIFN0aWxsLCB0aHJvdyBpZiBub3QgZm91bmQhXG4gIGlmIChjdHguaXNQcmltS2V5KSByZXR1cm4gY29yZVNjaGVtYS5wcmltYXJ5S2V5O1xuICBjb25zdCBpbmRleCA9IGNvcmVTY2hlbWEuZ2V0SW5kZXhCeUtleVBhdGgoY3R4LmluZGV4KTtcbiAgaWYgKCFpbmRleCkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiS2V5UGF0aCBcIiArIGN0eC5pbmRleCArIFwiIG9uIG9iamVjdCBzdG9yZSBcIiArIGNvcmVTY2hlbWEubmFtZSArIFwiIGlzIG5vdCBpbmRleGVkXCIpO1xuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcGVuQ3Vyc29yKGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIGNvcmVUYWJsZTogREJDb3JlVGFibGUsIHRyYW5zOiBEQkNvcmVUcmFuc2FjdGlvbikge1xuICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpO1xuICByZXR1cm4gY29yZVRhYmxlLm9wZW5DdXJzb3Ioe1xuICAgIHRyYW5zLFxuICAgIHZhbHVlczogIWN0eC5rZXlzT25seSxcbiAgICByZXZlcnNlOiBjdHguZGlyID09PSAncHJldicsXG4gICAgdW5pcXVlOiAhIWN0eC51bmlxdWUsXG4gICAgcXVlcnk6IHtcbiAgICAgIGluZGV4LCBcbiAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXRlciAoXG4gIGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIFxuICBmbjogKGl0ZW0sIGN1cnNvcjogREJDb3JlQ3Vyc29yLCBhZHZhbmNlOiBGdW5jdGlvbik9PnZvaWQsXG4gIGNvcmVUcmFuczogREJDb3JlVHJhbnNhY3Rpb24sXG4gIGNvcmVUYWJsZTogREJDb3JlVGFibGUpOiBQcm9taXNlPGFueT5cbntcbiAgY29uc3QgZmlsdGVyID0gY3R4LnJlcGxheUZpbHRlciA/IGNvbWJpbmUoY3R4LmZpbHRlciwgY3R4LnJlcGxheUZpbHRlcigpKSA6IGN0eC5maWx0ZXI7XG4gIGlmICghY3R4Lm9yKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZShcbiAgICAgICAgb3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSxcbiAgICAgICAgY29tYmluZShjdHguYWxnb3JpdGhtLCBmaWx0ZXIpLCBmbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpO1xuICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2V0ID0ge307XG5cbiAgICAgIGNvbnN0IHVuaW9uID0gKGl0ZW06IGFueSwgY3Vyc29yOiBEQkNvcmVDdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoY3Vyc29yLCBhZHZhbmNlLCByZXN1bHQ9PmN1cnNvci5zdG9wKHJlc3VsdCksIGVyciA9PiBjdXJzb3IuZmFpbChlcnIpKSkge1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUtleSA9IGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICB2YXIga2V5ID0gJycgKyBwcmltYXJ5S2V5O1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSBrZXkgPSAnJyArIG5ldyBVaW50OEFycmF5KHByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICBpZiAoIWhhc093bihzZXQsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgIHNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGZuKGl0ZW0sIGN1cnNvciwgYWR2YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGN0eC5vci5faXRlcmF0ZSh1bmlvbiwgY29yZVRyYW5zKSxcbiAgICAgICAgaXRlcmF0ZShvcGVuQ3Vyc29yKGN0eCwgY29yZVRhYmxlLCBjb3JlVHJhbnMpLCBjdHguYWxnb3JpdGhtLCB1bmlvbiwgIWN0eC5rZXlzT25seSAmJiBjdHgudmFsdWVNYXBwZXIpXG4gICAgICBdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlKGN1cnNvclByb21pc2U6IFByb21pc2U8REJDb3JlQ3Vyc29yPiwgZmlsdGVyLCBmbiwgdmFsdWVNYXBwZXIpOiBQcm9taXNlPGFueT4ge1xuICBcbiAgLy8gQXBwbHkgdmFsdWVNYXBwZXIgKGhvb2soJ3JlYWRpbmcnKSBvciBtYXBwcGVkIGNsYXNzKVxuICB2YXIgbWFwcGVkRm4gPSB2YWx1ZU1hcHBlciA/ICh4LGMsYSkgPT4gZm4odmFsdWVNYXBwZXIoeCksYyxhKSA6IGZuO1xuICAvLyBXcmFwIGZuIHdpdGggUFNEIGFuZCBtaWNyb3RpY2sgc3R1ZmYgZnJvbSBQcm9taXNlLlxuICB2YXIgd3JhcHBlZEZuID0gd3JhcChtYXBwZWRGbik7XG4gIFxuICByZXR1cm4gY3Vyc29yUHJvbWlzZS50aGVuKGN1cnNvciA9PiB7XG4gICAgaWYgKGN1cnNvcikge1xuICAgICAgcmV0dXJuIGN1cnNvci5zdGFydCgoKT0+e1xuICAgICAgICB2YXIgYyA9ICgpPT5jdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZXIgPT4gYyA9IGFkdmFuY2VyLCB2YWw9PntjdXJzb3Iuc3RvcCh2YWwpO2M9bm9wfSwgZSA9PiB7Y3Vyc29yLmZhaWwoZSk7YyA9IG5vcDt9KSlcbiAgICAgICAgICB3cmFwcGVkRm4oY3Vyc29yLnZhbHVlLCBjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlcik7XG4gICAgICAgIGMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG4iLCAiLy8gSW1wbGVtZW50YXRpb24gb2YgaHR0cHM6Ly93d3cudzMub3JnL1RSL0luZGV4ZWREQi0zLyNjb21wYXJlLXR3by1rZXlzXG5cbmltcG9ydCB7IHRvU3RyaW5nVGFnIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIC4uLiB3aXRoIHRoZSBhZGp1c3RtZW50IHRvIHJldHVybiBOYU4gaW5zdGVhZCBvZiB0aHJvd2luZy5cbmV4cG9ydCBmdW5jdGlvbiBjbXAoYTogYW55LCBiOiBhbnkpOiBudW1iZXIge1xuICB0cnkge1xuICAgIGNvbnN0IHRhID0gdHlwZShhKTtcbiAgICBjb25zdCB0YiA9IHR5cGUoYik7XG4gICAgaWYgKHRhICE9PSB0Yikge1xuICAgICAgaWYgKHRhID09PSAnQXJyYXknKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiA9PT0gJ0FycmF5JykgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRhID09PSAnYmluYXJ5JykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdiaW5hcnknKSByZXR1cm4gLTE7XG4gICAgICBpZiAodGEgPT09ICdzdHJpbmcnKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiA9PT0gJ3N0cmluZycpIHJldHVybiAtMTtcbiAgICAgIGlmICh0YSA9PT0gJ0RhdGUnKSByZXR1cm4gMTtcbiAgICAgIGlmICh0YiAhPT0gJ0RhdGUnKSByZXR1cm4gTmFOO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRhKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG4gICAgICBjYXNlICdiaW5hcnknOiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlVWludDhBcnJheXMoZ2V0VWludDhBcnJheShhKSwgZ2V0VWludDhBcnJheShiKSk7XG4gICAgICB9XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIHJldHVybiBjb21wYXJlQXJyYXlzKGEsIGIpO1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gTmFOOyAvLyBSZXR1cm4gdmFsdWUgaWYgYW55IGdpdmVuIGFyZ3MgYXJlIHZhbGlkIGtleXMuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGE6IGFueVtdLCBiOiBhbnlbXSk6IG51bWJlciB7XG4gIGNvbnN0IGFsID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJsID0gYi5sZW5ndGg7XG4gIGNvbnN0IGwgPSBhbCA8IGJsID8gYWwgOiBibDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcbiAgICBjb25zdCByZXMgPSBjbXAoYVtpXSwgYltpXSk7XG4gICAgaWYgKHJlcyAhPT0gMCkgcmV0dXJuIHJlcztcbiAgfVxuICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVWludDhBcnJheXMoXG4gIGE6IFVpbnQ4QXJyYXksXG4gIGI6IFVpbnQ4QXJyYXlcbikge1xuICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBhW2ldIDwgYltpXSA/IC0xIDogMTtcbiAgfVxuICByZXR1cm4gYWwgPT09IGJsID8gMCA6IGFsIDwgYmwgPyAtMSA6IDE7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREItMy8ja2V5LXR5cGVcbmZ1bmN0aW9uIHR5cGUoeDogYW55KSB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgaWYgKHQgIT09ICdvYmplY3QnKSByZXR1cm4gdDtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh4KSkgcmV0dXJuICdiaW5hcnknO1xuICBjb25zdCB0c1RhZyA9IHRvU3RyaW5nVGFnKHgpOyAvLyBDYW5ub3QgdXNlIGluc3RhbmNlb2YgaW4gU2FmYXJpXG4gIHJldHVybiB0c1RhZyA9PT0gJ0FycmF5QnVmZmVyJyA/ICdiaW5hcnknIDogKHRzVGFnIGFzICdBcnJheScgfCAnRGF0ZScpO1xufVxuXG50eXBlIEJpbmFyeVR5cGUgPVxuICB8IEFycmF5QnVmZmVyXG4gIHwgRGF0YVZpZXdcbiAgfCBVaW50OENsYW1wZWRBcnJheVxuICB8IEFycmF5QnVmZmVyVmlld1xuICB8IFVpbnQ4QXJyYXlcbiAgfCBJbnQ4QXJyYXlcbiAgfCBVaW50MTZBcnJheVxuICB8IEludDE2QXJyYXlcbiAgfCBVaW50MzJBcnJheVxuICB8IEludDMyQXJyYXlcbiAgfCBGbG9hdDMyQXJyYXlcbiAgfCBGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGdldFVpbnQ4QXJyYXkoYTogQmluYXJ5VHlwZSk6IFVpbnQ4QXJyYXkge1xuICBpZiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHJldHVybiBhO1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpKVxuICAgIC8vIFR5cGVkQXJyYXkgb3IgRGF0YVZpZXdcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYS5idWZmZXIsIGEuYnl0ZU9mZnNldCwgYS5ieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEpOyAvLyBBcnJheUJ1ZmZlclxufVxuIiwgImltcG9ydCB7IENvbGxlY3Rpb24gYXMgSUNvbGxlY3Rpb24gfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2NvbGxlY3Rpb25cIjtcbmltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2RleGllXCI7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSwgSW5kZXhhYmxlVHlwZUFycmF5UmVhZG9ubHkgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2luZGV4YWJsZS10eXBlXCI7XG5pbXBvcnQgeyBQcm9taXNlRXh0ZW5kZWQgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWRcIjtcbmltcG9ydCB7IGl0ZXIsIGlzUGxhaW5LZXlSYW5nZSwgZ2V0SW5kZXhPclN0b3JlLCBhZGRSZXBsYXlGaWx0ZXIsIGFkZEZpbHRlciwgYWRkTWF0Y2hGaWx0ZXIgfSBmcm9tIFwiLi9jb2xsZWN0aW9uLWhlbHBlcnNcIjtcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2NvbWJpbmVcIjtcbmltcG9ydCB7IGV4dGVuZCwgaGFzT3duLCBkZWVwQ2xvbmUsIGtleXMsIHNldEJ5S2V5UGF0aCwgZ2V0QnlLZXlQYXRoIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgTW9kaWZ5RXJyb3IgfSBmcm9tIFwiLi4vLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSB9IGZyb20gXCIuLi8uLi9nbG9iYWxzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgVGhlblNob3J0Y3V0IH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy90aGVuLXNob3J0Y3V0XCI7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERCQ29yZUN1cnNvciwgREJDb3JlVHJhbnNhY3Rpb24sIERCQ29yZVJhbmdlVHlwZSwgREJDb3JlTXV0YXRlUmVzcG9uc2UsIERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2NtcFwiO1xuXG4vKiogY2xhc3MgQ29sbGVjdGlvblxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvblxuICovXG5leHBvcnQgY2xhc3MgQ29sbGVjdGlvbiBpbXBsZW1lbnRzIElDb2xsZWN0aW9uIHtcbiAgZGI6IERleGllO1xuICBfY3R4OiB7XG4gICAgdGFibGU6IFRhYmxlO1xuICAgIGluZGV4Pzogc3RyaW5nIHwgbnVsbDtcbiAgICBpc1ByaW1LZXk/OiBib29sZWFuO1xuICAgIHJhbmdlOiBEQkNvcmVLZXlSYW5nZTtcbiAgICBrZXlzT25seTogYm9vbGVhbjtcbiAgICBkaXI6IFwibmV4dFwiIHwgXCJwcmV2XCI7XG4gICAgdW5pcXVlOiBcIlwiIHwgXCJ1bmlxdWVcIjtcbiAgICBhbGdvcml0aG0/OiBGdW5jdGlvbiB8IG51bGw7XG4gICAgZmlsdGVyPzogRnVuY3Rpb24gfCBudWxsO1xuICAgIHJlcGxheUZpbHRlcjogRnVuY3Rpb24gfCBudWxsO1xuICAgIGp1c3RMaW1pdDogYm9vbGVhbjsgLy8gVHJ1ZSBpZiBhIHJlcGxheUZpbHRlciBpcyBqdXN0IGEgZmlsdGVyIHRoYXQgcGVyZm9ybXMgYSBcImxpbWl0XCIgb3BlcmF0aW9uIChvciBub25lIGF0IGFsbClcbiAgICBpc01hdGNoOiBGdW5jdGlvbiB8IG51bGw7XG4gICAgb2Zmc2V0OiBudW1iZXIsXG4gICAgbGltaXQ6IG51bWJlcixcbiAgICBlcnJvcjogYW55LCAvLyBJZiBzZXQsIGFueSBwcm9taXNlIG11c3QgYmUgcmVqZWN0ZWQgd2l0aCB0aGlzIGVycm9yXG4gICAgb3I6IENvbGxlY3Rpb24sXG4gICAgdmFsdWVNYXBwZXI6IChhbnkpID0+IGFueVxuICB9XG4gIFxuICBfb25kaXJlY3Rpb25jaGFuZ2U/OiBGdW5jdGlvbjtcblxuICBfcmVhZDxUPihmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPFQ+LCBjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWRvbmx5JywgZm4pLnRoZW4oY2IpO1xuICB9XG5cbiAgX3dyaXRlPFQ+KGZuOiAoaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uLCBkeFRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8VD4pOiBQcm9taXNlRXh0ZW5kZWQ8VD4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgcmV0dXJuIGN0eC5lcnJvciA/XG4gICAgICBjdHgudGFibGUuX3RyYW5zKG51bGwsIHJlamVjdGlvbi5iaW5kKG51bGwsIGN0eC5lcnJvcikpIDpcbiAgICAgIGN0eC50YWJsZS5fdHJhbnMoJ3JlYWR3cml0ZScsIGZuLCBcImxvY2tlZFwiKTsgLy8gV2hlbiBkb2luZyB3cml0ZSBvcGVyYXRpb25zIG9uIGNvbGxlY3Rpb25zLCBhbHdheXMgbG9jayB0aGUgb3BlcmF0aW9uIHNvIHRoYXQgdXBjb21pbmcgb3BlcmF0aW9ucyBnZXRzIHF1ZXVlZC5cbiAgfVxuXG4gIF9hZGRBbGdvcml0aG0oZm4pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5hbGdvcml0aG0gPSBjb21iaW5lKGN0eC5hbGdvcml0aG0sIGZuKTtcbiAgfVxuXG4gIF9pdGVyYXRlKFxuICAgIGZuOiAoaXRlbSwgY3Vyc29yOiBEQkNvcmVDdXJzb3IsIGFkdmFuY2U6IEZ1bmN0aW9uKSA9PiB2b2lkLFxuICAgIGNvcmVUcmFuczogREJDb3JlVHJhbnNhY3Rpb24pIDogUHJvbWlzZTxhbnk+XG4gIHtcbiAgICByZXR1cm4gaXRlcih0aGlzLl9jdHgsIGZuLCBjb3JlVHJhbnMsIHRoaXMuX2N0eC50YWJsZS5jb3JlKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNsb25lKClcbiAgICogXG4gICAqKi9cbiAgY2xvbmUocHJvcHM/KSB7XG4gICAgdmFyIHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSksXG4gICAgICBjdHggPSBPYmplY3QuY3JlYXRlKHRoaXMuX2N0eCk7XG4gICAgaWYgKHByb3BzKSBleHRlbmQoY3R4LCBwcm9wcyk7XG4gICAgcnYuX2N0eCA9IGN0eDtcbiAgICByZXR1cm4gcnY7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5yYXcoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucmF3KClcbiAgICogXG4gICAqKi9cbiAgcmF3KCkge1xuICAgIHRoaXMuX2N0eC52YWx1ZU1hcHBlciA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmVhY2goKVxuICAgKiBcbiAgICoqL1xuICBlYWNoKGZuOiAob2JqLCBjdXJzb3I6IERCQ29yZUN1cnNvcikgPT4gYW55KTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4gaXRlcihjdHgsIGZuLCB0cmFucywgY3R4LnRhYmxlLmNvcmUpKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmNvdW50KClcbiAgICogXG4gICAqKi9cbiAgY291bnQoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBsYWluIGtleSByYW5nZS4gV2UgY2FuIHVzZSB0aGUgY291bnQoKSBtZXRob2QgaWYgdGhlIGluZGV4LlxuICAgICAgICByZXR1cm4gY29yZVRhYmxlLmNvdW50KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXg6IGdldEluZGV4T3JTdG9yZShjdHgsIGNvcmVUYWJsZS5zY2hlbWEpLFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihjb3VudCA9PiBNYXRoLm1pbihjb3VudCwgY3R4LmxpbWl0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbGdvcml0aG1zLCBmaWx0ZXJzIG9yIGV4cHJlc3Npb25zIGFyZSBhcHBsaWVkLiBOZWVkIHRvIGNvdW50IG1hbnVhbGx5LlxuICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gaXRlcihjdHgsICgpID0+IHsgKytjb3VudDsgcmV0dXJuIGZhbHNlOyB9LCB0cmFucywgY29yZVRhYmxlKVxuICAgICAgICAudGhlbigoKT0+Y291bnQpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uc29ydEJ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnNvcnRCeSgpXG4gICAqIFxuICAgKiovXG4gIHNvcnRCeShrZXlQYXRoOiBzdHJpbmcpOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+O1xuICBzb3J0Qnk8Uj4oa2V5UGF0aDogc3RyaW5nLCB0aGVuU2hvcnRjdXQ6IFRoZW5TaG9ydGN1dDxhbnlbXSwgUj4pIDogUHJvbWlzZUV4dGVuZGVkPFI+O1xuICBzb3J0Qnkoa2V5UGF0aDogc3RyaW5nLCBjYj86IFRoZW5TaG9ydGN1dDxhbnlbXSwgYW55Pikge1xuICAgIGNvbnN0IHBhcnRzID0ga2V5UGF0aC5zcGxpdCgnLicpLnJldmVyc2UoKSxcbiAgICAgIGxhc3RQYXJ0ID0gcGFydHNbMF0sXG4gICAgICBsYXN0SW5kZXggPSBwYXJ0cy5sZW5ndGggLSAxO1xuICAgIGZ1bmN0aW9uIGdldHZhbChvYmosIGkpIHtcbiAgICAgIGlmIChpKSByZXR1cm4gZ2V0dmFsKG9ialtwYXJ0c1tpXV0sIGkgLSAxKTtcbiAgICAgIHJldHVybiBvYmpbbGFzdFBhcnRdO1xuICAgIH1cbiAgICB2YXIgb3JkZXIgPSB0aGlzLl9jdHguZGlyID09PSBcIm5leHRcIiA/IDEgOiAtMTtcblxuICAgIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgICB2YXIgYVZhbCA9IGdldHZhbChhLCBsYXN0SW5kZXgpLFxuICAgICAgICBiVmFsID0gZ2V0dmFsKGIsIGxhc3RJbmRleCk7XG4gICAgICByZXR1cm4gYVZhbCA8IGJWYWwgPyAtb3JkZXIgOiBhVmFsID4gYlZhbCA/IG9yZGVyIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheShmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGEuc29ydChzb3J0ZXIpO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udG9BcnJheSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi50b0FycmF5KClcbiAgICogXG4gICAqKi9cbiAgdG9BcnJheShjYj8pOiBQcm9taXNlRXh0ZW5kZWQ8YW55W10+IHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZCh0cmFucyA9PiB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgb3B0aW1hdGlvbiBpZiB3ZSBjb3VsZCB1c2UgSURCT2JqZWN0U3RvcmUuZ2V0QWxsKCkgb3JcbiAgICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsKCk6XG4gICAgICAgIGNvbnN0IHt2YWx1ZU1hcHBlcn0gPSBjdHg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICBsaW1pdDogY3R4LmxpbWl0LFxuICAgICAgICAgIHZhbHVlczogdHJ1ZSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCh7cmVzdWx0fSkgPT4gdmFsdWVNYXBwZXIgPyByZXN1bHQubWFwKHZhbHVlTWFwcGVyKSA6IHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXR0aW5nIGFycmF5IHRocm91Z2ggYSBjdXJzb3IuXG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCBpdGVtID0+IGEucHVzaChpdGVtKSwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKS50aGVuKCgpPT5hKTtcbiAgICAgIH1cbiAgICB9LCBjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5vZmZzZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ub2Zmc2V0KClcbiAgICogXG4gICAqKi9cbiAgb2Zmc2V0KG9mZnNldDogbnVtYmVyKSA6IENvbGxlY3Rpb257XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBpZiAob2Zmc2V0IDw9IDApIHJldHVybiB0aGlzO1xuICAgIGN0eC5vZmZzZXQgKz0gb2Zmc2V0OyAvLyBGb3IgY291bnQoKVxuICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSkge1xuICAgICAgYWRkUmVwbGF5RmlsdGVyKGN0eCwgKCkgPT4ge1xuICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldDtcbiAgICAgICAgcmV0dXJuIChjdXJzb3IsIGFkdmFuY2UpID0+IHtcbiAgICAgICAgICBpZiAob2Zmc2V0TGVmdCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDEpIHsgLS1vZmZzZXRMZWZ0OyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKG9mZnNldExlZnQpO1xuICAgICAgICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiAoKSA9PiAoLS1vZmZzZXRMZWZ0IDwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5saW1pdCgpXG4gICAqIFxuICAgKiovXG4gIGxpbWl0KG51bVJvd3M6IG51bWJlcikgOiBDb2xsZWN0aW9uIHtcbiAgICB0aGlzLl9jdHgubGltaXQgPSBNYXRoLm1pbih0aGlzLl9jdHgubGltaXQsIG51bVJvd3MpOyAvLyBGb3IgY291bnQoKVxuICAgIGFkZFJlcGxheUZpbHRlcih0aGlzLl9jdHgsICgpID0+IHtcbiAgICAgIHZhciByb3dzTGVmdCA9IG51bVJvd3M7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgICBpZiAoLS1yb3dzTGVmdCA8PSAwKSBhZHZhbmNlKHJlc29sdmUpOyAvLyBTdG9wIGFmdGVyIHRoaXMgaXRlbSBoYXMgYmVlbiBpbmNsdWRlZFxuICAgICAgICByZXR1cm4gcm93c0xlZnQgPj0gMDsgLy8gSWYgbnVtUm93cyBpcyBhbHJlYWR5IGJlbG93IDAsIHJldHVybiBmYWxzZSBiZWNhdXNlIHRoZW4gMCB3YXMgcGFzc2VkIHRvIG51bVJvd3MgaW5pdGlhbGx5LiBPdGhlcndpc2Ugd2Ugd291bGRudCBjb21lIGhlcmUuXG4gICAgICB9O1xuICAgIH0sIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW50aWwoKVxuICAgKiBcbiAgICoqL1xuICB1bnRpbChmaWx0ZXJGdW5jdGlvbjogKHgpID0+IGJvb2xlYW4sIGJJbmNsdWRlU3RvcEVudHJ5Pykge1xuICAgIGFkZEZpbHRlcih0aGlzLl9jdHgsIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgIGlmIChmaWx0ZXJGdW5jdGlvbihjdXJzb3IudmFsdWUpKSB7XG4gICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgIHJldHVybiBiSW5jbHVkZVN0b3BFbnRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZmlyc3QoKVxuICAgKiBcbiAgICoqL1xuICBmaXJzdChjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdCgxKS50b0FycmF5KGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmxhc3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ubGFzdCgpXG4gICAqIFxuICAgKiovXG4gIGxhc3QoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0KGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmZpbHRlcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maWx0ZXIoKVxuICAgKiBcbiAgICoqL1xuICBmaWx0ZXIoZmlsdGVyRnVuY3Rpb246ICh4KSA9PiBib29sZWFuKTogQ29sbGVjdGlvbiB7XG4gICAgLy8vIDxwYXJhbSBuYW1lPVwianNGdW5jdGlvbkZpbHRlclwiIHR5cGU9XCJGdW5jdGlvblwiPmZ1bmN0aW9uKHZhbCl7cmV0dXJuIHRydWUvZmFsc2V9PC9wYXJhbT5cbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yKSB7XG4gICAgICByZXR1cm4gZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKTtcbiAgICB9KTtcbiAgICAvLyBtYXRjaCBmaWx0ZXJzIG5vdCB1c2VkIGluIERleGllLmpzIGJ1dCBjYW4gYmUgdXNlZCBieSAzcmQgcGFydCBsaWJyYXJpZXMgdG8gdGVzdCBhXG4gICAgLy8gY29sbGVjdGlvbiBmb3IgYSBtYXRjaCB3aXRob3V0IHF1ZXJ5aW5nIERCLiBVc2VkIGJ5IERleGllLk9ic2VydmFibGUuXG4gICAgYWRkTWF0Y2hGaWx0ZXIodGhpcy5fY3R4LCBmaWx0ZXJGdW5jdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5hbmQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uYW5kKClcbiAgICogXG4gICAqKi9cbiAgYW5kKGZpbHRlcjogKHgpID0+IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm9yKClcbiAgICogXG4gICAqKi9cbiAgb3IoaW5kZXhOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcy5fY3R4LnRhYmxlLCBpbmRleE5hbWUsIHRoaXMpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucmV2ZXJzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5yZXZlcnNlKClcbiAgICogXG4gICAqKi9cbiAgcmV2ZXJzZSgpIHtcbiAgICB0aGlzLl9jdHguZGlyID0gKHRoaXMuX2N0eC5kaXIgPT09IFwicHJldlwiID8gXCJuZXh0XCIgOiBcInByZXZcIik7XG4gICAgaWYgKHRoaXMuX29uZGlyZWN0aW9uY2hhbmdlKSB0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSh0aGlzLl9jdHguZGlyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmRlc2MoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGVzYygpXG4gICAqIFxuICAgKiovXG4gIGRlc2MoKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZWFjaEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoS2V5KClcbiAgICogXG4gICAqKi9cbiAgZWFjaEtleShjYj8pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3Iua2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmVhY2hVbmlxdWVLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZWFjaFVuaXF1ZUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hVbmlxdWVLZXkoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMuZWFjaEtleShjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoUHJpbWFyeUtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hQcmltYXJ5S2V5KGNiPykge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKHZhbCwgY3Vyc29yKSB7IGNiKGN1cnNvci5wcmltYXJ5S2V5LCBjdXJzb3IpOyB9KTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ua2V5cygpXG4gICAqIFxuICAgKiovXG4gIGtleXMoY2I/KSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3Iua2V5KTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucHJpbWFyeUtleXMoKVxuICAgKiBcbiAgICoqL1xuICBwcmltYXJ5S2V5cyhjYj8pIDogUHJvbWlzZUV4dGVuZGVkPEluZGV4YWJsZVR5cGVbXT4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgaWYgKGN0eC5kaXIgPT09ICduZXh0JyAmJiBpc1BsYWluS2V5UmFuZ2UoY3R4LCB0cnVlKSAmJiBjdHgubGltaXQgPiAwKSB7XG4gICAgICAvLyBTcGVjaWFsIG9wdGltYXRpb24gaWYgd2UgY291bGQgdXNlIElEQk9iamVjdFN0b3JlLmdldEFsbEtleXMoKSBvclxuICAgICAgLy8gSURCS2V5UmFuZ2UuZ2V0QWxsS2V5cygpOlxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjdHgudGFibGUuY29yZS5zY2hlbWEpO1xuICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUucXVlcnkoe1xuICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgfX0pO1xuICAgICAgfSkudGhlbigoe3Jlc3VsdH0pPT5yZXN1bHQpLnRoZW4oY2IpO1xuICAgIH1cbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgdmFyIGEgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChpdGVtLCBjdXJzb3IpIHtcbiAgICAgIGEucHVzaChjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnVuaXF1ZUtleXMoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udW5pcXVlS2V5cygpXG4gICAqIFxuICAgKiovXG4gIHVuaXF1ZUtleXMoY2I/KSB7XG4gICAgdGhpcy5fY3R4LnVuaXF1ZSA9IFwidW5pcXVlXCI7XG4gICAgcmV0dXJuIHRoaXMua2V5cyhjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5maXJzdEtleSgpXG4gICAqIFxuICAgKiovXG4gIGZpcnN0S2V5KGNiPykge1xuICAgIHJldHVybiB0aGlzLmxpbWl0KDEpLmtleXMoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGFbMF07IH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ubGFzdEtleSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5sYXN0S2V5KClcbiAgICogXG4gICAqKi9cbiAgbGFzdEtleShjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmlyc3RLZXkoY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGlzdGluY3QoKVxuICAgKiBcbiAgICoqL1xuICBkaXN0aW5jdCgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4LFxuICAgICAgaWR4ID0gY3R4LmluZGV4ICYmIGN0eC50YWJsZS5zY2hlbWEuaWR4QnlOYW1lW2N0eC5pbmRleF07XG4gICAgaWYgKCFpZHggfHwgIWlkeC5tdWx0aSkgcmV0dXJuIHRoaXM7IC8vIGRpc3RpbmN0KCkgb25seSBtYWtlcyBkaWZmZXJlbmNpZXMgb24gbXVsdGlFbnRyeSBpbmRleGVzLlxuICAgIHZhciBzZXQgPSB7fTtcbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yOiBEQkNvcmVDdXJzb3IpIHtcbiAgICAgIHZhciBzdHJLZXkgPSBjdXJzb3IucHJpbWFyeUtleS50b1N0cmluZygpOyAvLyBDb252ZXJ0cyBhbnkgRGF0ZSB0byBTdHJpbmcsIFN0cmluZyB0byBTdHJpbmcsIE51bWJlciB0byBTdHJpbmcgYW5kIEFycmF5IHRvIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmdcbiAgICAgIHZhciBmb3VuZCA9IGhhc093bihzZXQsIHN0cktleSk7XG4gICAgICBzZXRbc3RyS2V5XSA9IHRydWU7XG4gICAgICByZXR1cm4gIWZvdW5kO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy9cbiAgLy8gTWV0aG9kcyB0aGF0IG11dGF0ZSBzdG9yYWdlXG4gIC8vXG5cbiAgLyoqIENvbGxlY3Rpb24ubW9kaWZ5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm1vZGlmeSgpXG4gICAqIFxuICAgKiovXG4gIG1vZGlmeShjaGFuZ2VzOiB7IFtrZXlQYXRoOiBzdHJpbmddOiBhbnkgfSkgOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPlxuICBtb2RpZnkoY2hhbmdlczogKG9iajogYW55LCBjdHg6e3ZhbHVlOiBhbnksIHByaW1LZXk6IEluZGV4YWJsZVR5cGV9KSA9PiB2b2lkIHwgYm9vbGVhbik6IFByb21pc2VFeHRlbmRlZDxudW1iZXI+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICB2YXIgbW9kaWZ5ZXI6IChvYmo6IGFueSwgY3R4Ont2YWx1ZTogYW55LCBwcmltS2V5OiBJbmRleGFibGVUeXBlfSkgPT4gdm9pZCB8IGJvb2xlYW5cbiAgICAgIGlmICh0eXBlb2YgY2hhbmdlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGFuZ2VzIGlzIGEgZnVuY3Rpb24gdGhhdCBtYXkgdXBkYXRlLCBhZGQgb3IgZGVsZXRlIHByb3B0ZXJ0aWVzIG9yIGV2ZW4gcmVxdWlyZSBhIGRlbGV0aW9uIHRoZSBvYmplY3QgaXRzZWxmIChkZWxldGUgdGhpcy5pdGVtKVxuICAgICAgICBtb2RpZnllciA9IGNoYW5nZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGFuZ2VzIGlzIGEgc2V0IG9mIHtrZXlQYXRoOiB2YWx1ZX0gYW5kIG5vIG9uZSBpcyBsaXN0ZW5pbmcgdG8gdGhlIHVwZGF0aW5nIGhvb2suXG4gICAgICAgIHZhciBrZXlQYXRocyA9IGtleXMoY2hhbmdlcyk7XG4gICAgICAgIHZhciBudW1LZXlzID0ga2V5UGF0aHMubGVuZ3RoO1xuICAgICAgICBtb2RpZnllciA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgdmFyIGFueXRoaW5nTW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleVBhdGggPSBrZXlQYXRoc1tpXSwgdmFsID0gY2hhbmdlc1trZXlQYXRoXTtcbiAgICAgICAgICAgIGlmIChnZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCkgIT09IHZhbCkge1xuICAgICAgICAgICAgICBzZXRCeUtleVBhdGgoaXRlbSwga2V5UGF0aCwgdmFsKTsgLy8gQWRkaW5nIHtrZXlQYXRoOiB1bmRlZmluZWR9IG1lYW5zIHRoYXQgdGhlIGtleVBhdGggc2hvdWxkIGJlIGRlbGV0ZWQuIEhhbmRsZWQgYnkgc2V0QnlLZXlQYXRoXG4gICAgICAgICAgICAgIGFueXRoaW5nTW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYW55dGhpbmdNb2RpZmllZDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29yZVRhYmxlID0gY3R4LnRhYmxlLmNvcmU7XG4gICAgICBjb25zdCB7b3V0Ym91bmQsIGV4dHJhY3RLZXl9ID0gY29yZVRhYmxlLnNjaGVtYS5wcmltYXJ5S2V5O1xuICAgICAgY29uc3QgbGltaXQgPSB0aGlzLmRiLl9vcHRpb25zLm1vZGlmeUNodW5rU2l6ZSB8fCAyMDA7XG4gICAgICBjb25zdCB0b3RhbEZhaWx1cmVzID0gW107XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGNvbnN0IGZhaWxlZEtleXM6IEluZGV4YWJsZVR5cGVbXSA9IFtdO1xuICAgICAgY29uc3QgYXBwbHlNdXRhdGVSZXN1bHQgPSAoZXhwZWN0ZWRDb3VudDogbnVtYmVyLCByZXM6IERCQ29yZU11dGF0ZVJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHtmYWlsdXJlcywgbnVtRmFpbHVyZXN9ID0gcmVzO1xuICAgICAgICBzdWNjZXNzQ291bnQgKz0gZXhwZWN0ZWRDb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICBmb3IgKGxldCBwb3Mgb2Yga2V5cyhmYWlsdXJlcykpIHtcbiAgICAgICAgICB0b3RhbEZhaWx1cmVzLnB1c2goZmFpbHVyZXNbcG9zXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNsb25lKCkucHJpbWFyeUtleXMoKS50aGVuKGtleXMgPT4ge1xuXG4gICAgICAgIGNvbnN0IG5leHRDaHVuayA9IChvZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obGltaXQsIGtleXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgICByZXR1cm4gY29yZVRhYmxlLmdldE1hbnkoe1xuICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICBrZXlzOiBrZXlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY291bnQpLFxuICAgICAgICAgICAgY2FjaGU6IFwiaW1tdXRhYmxlXCIgLy8gT3B0aW1pemUgZm9yIDIgdGhpbmdzOlxuICAgICAgICAgICAgLy8gMSkgb2JzZXJ2YWJpbGl0eS1taWRkbGV3YXJlIGNhbiB0cmFjayBjaGFuZ2VzIGJldHRlci5cbiAgICAgICAgICAgIC8vIDIpIGhvb2tzIG1pZGRsZXdhcmUgZG9uJ3QgaGF2ZSB0byBxdWVyeSB0aGUgZXhpc3RpbmcgdmFsdWVzIGFnYWluIHdoZW4gdHJhY2tpbmcgY2hhbmdlcy5cbiAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgXCJpbW11dGFibGVcIiBiZWNhdXNlIHdlIHByb21pc2UgdG8gbm90IHRvdWNoIHRoZSB2YWx1ZXMgd2UgcmV0cmlldmUgaGVyZSFcbiAgICAgICAgICB9KS50aGVuKHZhbHVlcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHB1dFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcHV0S2V5cyA9IG91dGJvdW5kID8gW10gOiBudWxsO1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlS2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlZXBDbG9uZShvcmlnVmFsdWUpLFxuICAgICAgICAgICAgICAgIHByaW1LZXk6IGtleXNbb2Zmc2V0K2ldXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChtb2RpZnllci5jYWxsKGN0eCwgY3R4LnZhbHVlLCBjdHgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgudmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlZFxuICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5wdXNoKGtleXNbb2Zmc2V0K2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFvdXRib3VuZCAmJiBjbXAoZXh0cmFjdEtleShvcmlnVmFsdWUpLCBleHRyYWN0S2V5KGN0eC52YWx1ZSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VkIHByaW1hcnkga2V5IG9mIGluYm91bmRcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgICBhZGRWYWx1ZXMucHVzaChjdHgudmFsdWUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIENoYW5nZWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgIHB1dFZhbHVlcy5wdXNoKGN0eC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIHB1dEtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjcml0ZXJpYSA9IGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAgICAgICAgIGN0eC5saW1pdCA9PT0gSW5maW5pdHkgJiZcbiAgICAgICAgICAgICAgKHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nIHx8IGNoYW5nZXMgPT09IGRlbGV0ZUNhbGxiYWNrKSAmJiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGN0eC5pbmRleCxcbiAgICAgICAgICAgICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWRkVmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdhZGQnLCB2YWx1ZXM6IGFkZFZhbHVlc30pXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBpbiByZXMuZmFpbHVyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gZGVsZXRlS2V5cyB0aGUga2V5IG9mIHRoZSBvYmplY3QgdGhhdCBmYWlsZWQgdG8gY2hhbmdlIGl0cyBwcmltYXJ5IGtleVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnNwbGljZShwYXJzZUludChwb3MpLCAxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFwcGx5TXV0YXRlUmVzdWx0KGFkZFZhbHVlcy5sZW5ndGgsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkudGhlbigoKT0+KHB1dFZhbHVlcy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiB0eXBlb2YgY2hhbmdlcyA9PT0gJ29iamVjdCcpKSAmJlxuICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICB0eXBlOiAncHV0JyxcbiAgICAgICAgICAgICAgICAgIGtleXM6IHB1dEtleXMsXG4gICAgICAgICAgICAgICAgICB2YWx1ZXM6IHB1dFZhbHVlcyxcbiAgICAgICAgICAgICAgICAgIGNyaXRlcmlhLFxuICAgICAgICAgICAgICAgICAgY2hhbmdlU3BlYzogdHlwZW9mIGNoYW5nZXMgIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlc1xuICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzPT5hcHBseU11dGF0ZVJlc3VsdChwdXRWYWx1ZXMubGVuZ3RoLCByZXMpKVxuICAgICAgICAgICAgKS50aGVuKCgpPT4oZGVsZXRlS2V5cy5sZW5ndGggPiAwIHx8IChjcml0ZXJpYSAmJiBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykpICYmXG4gICAgICAgICAgICAgICAgY29yZVRhYmxlLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0cmFucyxcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxldGUnLFxuICAgICAgICAgICAgICAgICAga2V5czogZGVsZXRlS2V5cyxcbiAgICAgICAgICAgICAgICAgIGNyaXRlcmlhXG4gICAgICAgICAgICAgICAgfSkudGhlbihyZXM9PmFwcGx5TXV0YXRlUmVzdWx0KGRlbGV0ZUtleXMubGVuZ3RoLCByZXMpKVxuICAgICAgICAgICAgKS50aGVuKCgpPT57XG4gICAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA+IG9mZnNldCArIGNvdW50ICYmIG5leHRDaHVuayhvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0Q2h1bmsoMCkudGhlbigoKT0+e1xuICAgICAgICAgIGlmICh0b3RhbEZhaWx1cmVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJFcnJvciBtb2RpZnlpbmcgb25lIG9yIG1vcmUgb2JqZWN0c1wiLCB0b3RhbEZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMgYXMgSW5kZXhhYmxlVHlwZUFycmF5UmVhZG9ubHkpO1xuXG4gICAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgfSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5kZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZGVsZXRlKClcbiAgICogXG4gICAqKi9cbiAgZGVsZXRlKCkgOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgIHJhbmdlID0gY3R4LnJhbmdlO1xuICAgICAgLy9kZWxldGluZ0hvb2sgPSBjdHgudGFibGUuaG9vay5kZWxldGluZy5maXJlLFxuICAgICAgLy9oYXNEZWxldGVIb29rID0gZGVsZXRpbmdIb29rICE9PSBub3A7XG4gICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgpICYmXG4gICAgICAoKGN0eC5pc1ByaW1LZXkgJiYgIWhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlKSB8fCByYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuQW55KSkgLy8gaWYgbm8gcmFuZ2UsIHdlJ2xsIHVzZSBjbGVhcigpLlxuICAgIHtcbiAgICAgIC8vIE1heSB1c2UgSURCT2JqZWN0U3RvcmUuZGVsZXRlKElEQktleVJhbmdlKSBpbiB0aGlzIGNhc2UgKElzc3VlICMyMDgpXG4gICAgICAvLyBGb3IgY2hyb21pdW0sIHRoaXMgaXMgdGhlIHdheSBtb3N0IG9wdGltaXplZCB2ZXJzaW9uLlxuICAgICAgLy8gRm9yIElFL0VkZ2UsIHRoaXMgY291bGQgaGFuZyB0aGUgaW5kZXhlZERCIGVuZ2luZSBhbmQgbWFrZSBvcGVyYXRpbmcgc3lzdGVtIGluc3RhYmxlXG4gICAgICAvLyAoaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZGZhaGxhbmRlci81YTM5MzI4ZjAyOWRlMTgyMjJjZjIxMjVkNTZjMzhmNylcbiAgICAgIHJldHVybiB0aGlzLl93cml0ZSh0cmFucyA9PiB7XG4gICAgICAgIC8vIE91ciBBUEkgY29udHJhY3QgaXMgdG8gcmV0dXJuIGEgY291bnQgb2YgZGVsZXRlZCBpdGVtcywgc28gd2UgaGF2ZSB0byBjb3VudCgpIGJlZm9yZSBkZWxldGUoKS5cbiAgICAgICAgY29uc3Qge3ByaW1hcnlLZXl9ID0gY3R4LnRhYmxlLmNvcmUuc2NoZW1hO1xuICAgICAgICBjb25zdCBjb3JlUmFuZ2UgPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLmNvdW50KHt0cmFucywgcXVlcnk6IHtpbmRleDogcHJpbWFyeUtleSwgcmFuZ2U6IGNvcmVSYW5nZX19KS50aGVuKGNvdW50ID0+IHtcbiAgICAgICAgICByZXR1cm4gY3R4LnRhYmxlLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2RlbGV0ZVJhbmdlJywgcmFuZ2U6IGNvcmVSYW5nZX0pXG4gICAgICAgICAgLnRoZW4oKHtmYWlsdXJlcywgbGFzdFJlc3VsdCwgcmVzdWx0cywgbnVtRmFpbHVyZXN9KSA9PiB7XG4gICAgICAgICAgICBpZiAobnVtRmFpbHVyZXMpIHRocm93IG5ldyBNb2RpZnlFcnJvcihcIkNvdWxkIG5vdCBkZWxldGUgc29tZSB2YWx1ZXNcIixcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmFpbHVyZXMpLm1hcChwb3MgPT4gZmFpbHVyZXNbcG9zXSksXG4gICAgICAgICAgICAgIGNvdW50IC0gbnVtRmFpbHVyZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50IC0gbnVtRmFpbHVyZXM7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRlbGV0ZUNhbGxiYWNrKTtcbiAgfVxufVxuXG5jb25zdCBkZWxldGVDYWxsYmFjayA9ICh2YWx1ZSwgY3R4KSA9PiBjdHgudmFsdWUgPSBudWxsO1xuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vLi4vY2xhc3Nlcy9kZXhpZSc7XG5pbXBvcnQgeyBtYWtlQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9tYWtlLWNsYXNzLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IEFueVJhbmdlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2tleXJhbmdlJztcbmltcG9ydCB7IERCQ29yZUtleVJhbmdlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBtaXJyb3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcblxuLyoqIENvbnN0cnVjdHMgYSBDb2xsZWN0aW9uIGluc3RhbmNlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb2xsZWN0aW9uQ29uc3RydWN0b3Ige1xuICBuZXcod2hlcmVDbGF1c2U/OiBXaGVyZUNsYXVzZSB8IG51bGwsIGtleVJhbmdlR2VuZXJhdG9yPzogKCkgPT4gREJDb3JlS2V5UmFuZ2UpOiBDb2xsZWN0aW9uO1xuICBwcm90b3R5cGU6IENvbGxlY3Rpb247XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8Q29sbGVjdGlvbkNvbnN0cnVjdG9yPihcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIENvbGxlY3Rpb24oXG4gICAgICB0aGlzOiBDb2xsZWN0aW9uLFxuICAgICAgd2hlcmVDbGF1c2U/OiBXaGVyZUNsYXVzZSB8IG51bGwsXG4gICAgICBrZXlSYW5nZUdlbmVyYXRvcj86ICgpID0+IERCQ29yZUtleVJhbmdlKVxuICAgIHtcbiAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgIGxldCBrZXlSYW5nZSA9IEFueVJhbmdlLCBlcnJvciA9IG51bGw7XG4gICAgICBpZiAoa2V5UmFuZ2VHZW5lcmF0b3IpIHRyeSB7XG4gICAgICAgIGtleVJhbmdlID0ga2V5UmFuZ2VHZW5lcmF0b3IoKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdoZXJlQ3R4ID0gd2hlcmVDbGF1c2UuX2N0eDtcbiAgICAgIGNvbnN0IHRhYmxlID0gd2hlcmVDdHgudGFibGU7XG4gICAgICBjb25zdCByZWFkaW5nSG9vayA9IHRhYmxlLmhvb2sucmVhZGluZy5maXJlO1xuICAgICAgdGhpcy5fY3R4ID0ge1xuICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgIGluZGV4OiB3aGVyZUN0eC5pbmRleCxcbiAgICAgICAgaXNQcmltS2V5OiAoIXdoZXJlQ3R4LmluZGV4IHx8ICh0YWJsZS5zY2hlbWEucHJpbUtleS5rZXlQYXRoICYmIHdoZXJlQ3R4LmluZGV4ID09PSB0YWJsZS5zY2hlbWEucHJpbUtleS5uYW1lKSksXG4gICAgICAgIHJhbmdlOiBrZXlSYW5nZSxcbiAgICAgICAga2V5c09ubHk6IGZhbHNlLFxuICAgICAgICBkaXI6IFwibmV4dFwiLFxuICAgICAgICB1bmlxdWU6IFwiXCIsXG4gICAgICAgIGFsZ29yaXRobTogbnVsbCxcbiAgICAgICAgZmlsdGVyOiBudWxsLFxuICAgICAgICByZXBsYXlGaWx0ZXI6IG51bGwsXG4gICAgICAgIGp1c3RMaW1pdDogdHJ1ZSwgLy8gVHJ1ZSBpZiBhIHJlcGxheUZpbHRlciBpcyBqdXN0IGEgZmlsdGVyIHRoYXQgcGVyZm9ybXMgYSBcImxpbWl0XCIgb3BlcmF0aW9uIChvciBub25lIGF0IGFsbClcbiAgICAgICAgaXNNYXRjaDogbnVsbCxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsaW1pdDogSW5maW5pdHksXG4gICAgICAgIGVycm9yOiBlcnJvciwgLy8gSWYgc2V0LCBhbnkgcHJvbWlzZSBtdXN0IGJlIHJlamVjdGVkIHdpdGggdGhpcyBlcnJvclxuICAgICAgICBvcjogd2hlcmVDdHgub3IsXG4gICAgICAgIHZhbHVlTWFwcGVyOiByZWFkaW5nSG9vayAhPT0gbWlycm9yID8gcmVhZGluZ0hvb2sgOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4YWJsZS10eXBlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPT09IGIgPyAwIDogMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUNvbXBhcmVSZXZlcnNlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG4iLCAiaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBTVFJJTkdfRVhQRUNURUQgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzaW1wbGVDb21wYXJlLCBzaW1wbGVDb21wYXJlUmV2ZXJzZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jb21wYXJlLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vLi4vcHVibGljJztcbmltcG9ydCB7IERCQ29yZUtleVJhbmdlLCBEQkNvcmVSYW5nZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhaWwoY29sbGVjdGlvbk9yV2hlcmVDbGF1c2U6IENvbGxlY3Rpb24gfCBXaGVyZUNsYXVzZSwgZXJyLCBUPykge1xuICB2YXIgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlIGluc3RhbmNlb2YgV2hlcmVDbGF1c2UgP1xuICAgICAgbmV3IGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlLkNvbGxlY3Rpb24gKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlKSA6XG4gICAgICBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZTtcbiAgICAgIFxuICBjb2xsZWN0aW9uLl9jdHguZXJyb3IgPSBUID8gbmV3IFQoZXJyKSA6IG5ldyBUeXBlRXJyb3IoZXJyKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbXB0eUNvbGxlY3Rpb24od2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlKSB7XG4gIHJldHVybiBuZXcgd2hlcmVDbGF1c2UuQ29sbGVjdGlvbiAod2hlcmVDbGF1c2UsICgpID0+IHJhbmdlRXF1YWwoXCJcIikpLmxpbWl0KDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBwZXJGYWN0b3J5KGRpcjogJ25leHQnIHwgJ3ByZXYnKSB7XG4gIHJldHVybiBkaXIgPT09IFwibmV4dFwiID9cbiAgICAoczogc3RyaW5nKSA9PiBzLnRvVXBwZXJDYXNlKCkgOlxuICAgIChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyRmFjdG9yeShkaXI6ICduZXh0JyB8ICdwcmV2Jykge1xuICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgKHM6IHN0cmluZykgPT4gcy50b0xvd2VyQ2FzZSgpIDpcbiAgICAoczogc3RyaW5nKSA9PiBzLnRvVXBwZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlLCBsb3dlck5lZWRsZSwgY21wLCBkaXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGtleS5sZW5ndGgsIGxvd2VyTmVlZGxlLmxlbmd0aCk7XG4gIHZhciBsbHAgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGx3cktleUNoYXIgPSBsb3dlcktleVtpXTtcbiAgICAgIGlmIChsd3JLZXlDaGFyICE9PSBsb3dlck5lZWRsZVtpXSkge1xuICAgICAgICAgIGlmIChjbXAoa2V5W2ldLCB1cHBlck5lZWRsZVtpXSkgPCAwKSByZXR1cm4ga2V5LnN1YnN0cigwLCBpKSArIHVwcGVyTmVlZGxlW2ldICsgdXBwZXJOZWVkbGUuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgICBpZiAoY21wKGtleVtpXSwgbG93ZXJOZWVkbGVbaV0pIDwgMCkgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyBsb3dlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgaWYgKGxscCA+PSAwKSByZXR1cm4ga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJLZXlbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChjbXAoa2V5W2ldLCBsd3JLZXlDaGFyKSA8IDApIGxscCA9IGk7XG4gIH1cbiAgaWYgKGxlbmd0aCA8IGxvd2VyTmVlZGxlLmxlbmd0aCAmJiBkaXIgPT09IFwibmV4dFwiKSByZXR1cm4ga2V5ICsgdXBwZXJOZWVkbGUuc3Vic3RyKGtleS5sZW5ndGgpO1xuICBpZiAobGVuZ3RoIDwga2V5Lmxlbmd0aCAmJiBkaXIgPT09IFwicHJldlwiKSByZXR1cm4ga2V5LnN1YnN0cigwLCB1cHBlck5lZWRsZS5sZW5ndGgpO1xuICByZXR1cm4gKGxscCA8IDAgPyBudWxsIDoga2V5LnN1YnN0cigwLCBsbHApICsgbG93ZXJOZWVkbGVbbGxwXSArIHVwcGVyTmVlZGxlLnN1YnN0cihsbHAgKyAxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHdoZXJlQ2xhdXNlOiBXaGVyZUNsYXVzZSwgbWF0Y2gsIG5lZWRsZXMsIHN1ZmZpeCkge1xuICAvLy8gPHBhcmFtIG5hbWU9XCJuZWVkbGVzXCIgdHlwZT1cIkFycmF5XCIgZWxlbWVudFR5cGU9XCJTdHJpbmdcIj48L3BhcmFtPlxuICB2YXIgdXBwZXIsIGxvd2VyLCBjb21wYXJlLCB1cHBlck5lZWRsZXMsIGxvd2VyTmVlZGxlcywgZGlyZWN0aW9uLCBuZXh0S2V5U3VmZml4LFxuICAgICAgbmVlZGxlc0xlbiA9IG5lZWRsZXMubGVuZ3RoO1xuICBpZiAoIW5lZWRsZXMuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICByZXR1cm4gZmFpbCh3aGVyZUNsYXVzZSwgU1RSSU5HX0VYUEVDVEVEKTtcbiAgfVxuICBmdW5jdGlvbiBpbml0RGlyZWN0aW9uKGRpcikge1xuICAgICAgdXBwZXIgPSB1cHBlckZhY3RvcnkoZGlyKTtcbiAgICAgIGxvd2VyID0gbG93ZXJGYWN0b3J5KGRpcik7XG4gICAgICBjb21wYXJlID0gKGRpciA9PT0gXCJuZXh0XCIgPyBzaW1wbGVDb21wYXJlIDogc2ltcGxlQ29tcGFyZVJldmVyc2UpO1xuICAgICAgdmFyIG5lZWRsZUJvdW5kcyA9IG5lZWRsZXMubWFwKGZ1bmN0aW9uIChuZWVkbGUpe1xuICAgICAgICAgIHJldHVybiB7bG93ZXI6IGxvd2VyKG5lZWRsZSksIHVwcGVyOiB1cHBlcihuZWVkbGUpfTtcbiAgICAgIH0pLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmUoYS5sb3dlciwgYi5sb3dlcik7XG4gICAgICB9KTtcbiAgICAgIHVwcGVyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKXsgcmV0dXJuIG5iLnVwcGVyOyB9KTtcbiAgICAgIGxvd2VyTmVlZGxlcyA9IG5lZWRsZUJvdW5kcy5tYXAoZnVuY3Rpb24gKG5iKXsgcmV0dXJuIG5iLmxvd2VyOyB9KTtcbiAgICAgIGRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIG5leHRLZXlTdWZmaXggPSAoZGlyID09PSBcIm5leHRcIiA/IFwiXCIgOiBzdWZmaXgpO1xuICB9XG4gIGluaXREaXJlY3Rpb24oXCJuZXh0XCIpO1xuXG4gIHZhciBjID0gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24gKFxuICAgICAgd2hlcmVDbGF1c2UsXG4gICAgICAoKT0+Y3JlYXRlUmFuZ2UodXBwZXJOZWVkbGVzWzBdLCBsb3dlck5lZWRsZXNbbmVlZGxlc0xlbi0xXSArIHN1ZmZpeClcbiAgKTtcblxuICBjLl9vbmRpcmVjdGlvbmNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgIC8vIFRoaXMgZXZlbnQgb25seXMgb2NjdXIgYmVmb3JlIGZpbHRlciBpcyBjYWxsZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAgICBpbml0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZpcnN0UG9zc2libGVOZWVkbGUgPSAwO1xuXG4gIGMuX2FkZEFsZ29yaXRobShmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjdXJzb3JcIiB0eXBlPVwiSURCQ3Vyc29yXCI+PC9wYXJhbT5cbiAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFkdmFuY2VcIiB0eXBlPVwiRnVuY3Rpb25cIj48L3BhcmFtPlxuICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmVzb2x2ZVwiIHR5cGU9XCJGdW5jdGlvblwiPjwvcGFyYW0+XG4gICAgICB2YXIga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGxvd2VyS2V5ID0gbG93ZXIoa2V5KTtcbiAgICAgIGlmIChtYXRjaChsb3dlcktleSwgbG93ZXJOZWVkbGVzLCBmaXJzdFBvc3NpYmxlTmVlZGxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBudWxsO1xuICAgICAgICAgIGZvciAodmFyIGk9Zmlyc3RQb3NzaWJsZU5lZWRsZTsgaTxuZWVkbGVzTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGNhc2luZyA9IG5leHRDYXNpbmcoa2V5LCBsb3dlcktleSwgdXBwZXJOZWVkbGVzW2ldLCBsb3dlck5lZWRsZXNbaV0sIGNvbXBhcmUsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgIGlmIChjYXNpbmcgPT09IG51bGwgJiYgbG93ZXN0UG9zc2libGVDYXNpbmcgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICBmaXJzdFBvc3NpYmxlTmVlZGxlID0gaSArIDE7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsIHx8IGNvbXBhcmUobG93ZXN0UG9zc2libGVDYXNpbmcsIGNhc2luZykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICBsb3dlc3RQb3NzaWJsZUNhc2luZyA9IGNhc2luZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXN0UG9zc2libGVDYXNpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShmdW5jdGlvbiAoKSB7IGN1cnNvci5jb250aW51ZShsb3dlc3RQb3NzaWJsZUNhc2luZyArIG5leHRLZXlTdWZmaXgpOyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH0pO1xuICByZXR1cm4gYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJhbmdlIChsb3dlcjogSW5kZXhhYmxlVHlwZSwgdXBwZXI6IEluZGV4YWJsZVR5cGUsIGxvd2VyT3Blbj86IGJvb2xlYW4sIHVwcGVyT3Blbj86IGJvb2xlYW4pOiBEQkNvcmVLZXlSYW5nZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogREJDb3JlUmFuZ2VUeXBlLlJhbmdlLFxuICAgICAgICBsb3dlcixcbiAgICAgICAgdXBwZXIsXG4gICAgICAgIGxvd2VyT3BlbixcbiAgICAgICAgdXBwZXJPcGVuXG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlRXF1YWwgKHZhbHVlOiBJbmRleGFibGVUeXBlKSA6IERCQ29yZUtleVJhbmdlIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuRXF1YWwsXG4gICAgICAgIGxvd2VyOiB2YWx1ZSxcbiAgICAgICAgdXBwZXI6IHZhbHVlXG4gICAgfTtcbn1cbiIsICJpbXBvcnQgeyBXaGVyZUNsYXVzZSBhcyBJV2hlcmVDbGF1c2UgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL3doZXJlLWNsYXVzZVwiO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gXCIuLi9jb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvaW5kZXhhYmxlLXR5cGVcIjtcbmltcG9ydCB7IGVtcHR5Q29sbGVjdGlvbiwgZmFpbCwgYWRkSWdub3JlQ2FzZUFsZ29yaXRobSwgY3JlYXRlUmFuZ2UsIHJhbmdlRXF1YWwgfSBmcm9tICcuL3doZXJlLWNsYXVzZS1oZWxwZXJzJztcbmltcG9ydCB7IElOVkFMSURfS0VZX0FSR1VNRU5ULCBTVFJJTkdfRVhQRUNURUQsIG1heFN0cmluZywgbWluS2V5IH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0QXJyYXlPZiwgTk9fQ0hBUl9BUlJBWSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiBhcyBJQ29sbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9jb2xsZWN0aW9uXCI7XG5cbi8qKiBjbGFzcyBXaGVyZUNsYXVzZVxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlXG4gKi9cbmV4cG9ydCBjbGFzcyBXaGVyZUNsYXVzZSBpbXBsZW1lbnRzIElXaGVyZUNsYXVzZSB7XG4gIGRiOiBEZXhpZTtcbiAgX0lEQktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2U7XG4gIF9jdHg6IHtcbiAgICB0YWJsZTogVGFibGU7XG4gICAgaW5kZXg6IHN0cmluZztcbiAgICBvcjogQ29sbGVjdGlvbjtcbiAgfVxuICBfY21wOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gbnVtYmVyO1xuICBfYXNjZW5kaW5nOiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gbnVtYmVyO1xuICBfZGVzY2VuZGluZzogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IG51bWJlcjtcbiAgX21pbjogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IEluZGV4YWJsZVR5cGU7XG4gIF9tYXg6IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBJbmRleGFibGVUeXBlO1xuXG4gIGdldCBDb2xsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHgudGFibGUuZGIuQ29sbGVjdGlvbjtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5iZXR3ZWVuKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYmV0d2VlbigpXG4gICAqIFxuICAgKiovXG4gIGJldHdlZW4obG93ZXI6IEluZGV4YWJsZVR5cGUsIHVwcGVyOiBJbmRleGFibGVUeXBlLCBpbmNsdWRlTG93ZXI/OiBib29sZWFuLCBpbmNsdWRlVXBwZXI/OiBib29sZWFuKSB7XG4gICAgaW5jbHVkZUxvd2VyID0gaW5jbHVkZUxvd2VyICE9PSBmYWxzZTsgICAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICBpbmNsdWRlVXBwZXIgPSBpbmNsdWRlVXBwZXIgPT09IHRydWU7ICAgIC8vIERlZmF1bHQgdG8gZmFsc2VcbiAgICB0cnkge1xuICAgICAgaWYgKCh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA+IDApIHx8XG4gICAgICAgICh0aGlzLl9jbXAobG93ZXIsIHVwcGVyKSA9PT0gMCAmJiAoaW5jbHVkZUxvd2VyIHx8IGluY2x1ZGVVcHBlcikgJiYgIShpbmNsdWRlTG93ZXIgJiYgaW5jbHVkZVVwcGVyKSkpXG4gICAgICAgIHJldHVybiBlbXB0eUNvbGxlY3Rpb24odGhpcyk7IC8vIFdvcmthcm91bmQgZm9yIGlkaW90aWMgVzNDIFNwZWNpZmljYXRpb24gdGhhdCBEYXRhRXJyb3IgbXVzdCBiZSB0aHJvd24gaWYgbG93ZXIgPiB1cHBlci4gVGhlIG5hdHVyYWwgcmVzdWx0IHdvdWxkIGJlIHRvIHJldHVybiBhbiBlbXB0eSBjb2xsZWN0aW9uLlxuICAgICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCk9PmNyZWF0ZVJhbmdlKGxvd2VyLCB1cHBlciwgIWluY2x1ZGVMb3dlciwgIWluY2x1ZGVVcHBlcikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICB9XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuZXF1YWxzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuZXF1YWxzKClcbiAgICogXG4gICAqKi9cbiAgZXF1YWxzKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiByYW5nZUVxdWFsKHZhbHVlKSkgYXMgSUNvbGxlY3Rpb247XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYWJvdmUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hYm92ZSgpXG4gICAqIFxuICAgKiovXG4gIGFib3ZlKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCB0cnVlKSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYWJvdmVPckVxdWFsKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYWJvdmVPckVxdWFsKClcbiAgICogXG4gICAqKi9cbiAgYWJvdmVPckVxdWFsKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh2YWx1ZSwgdW5kZWZpbmVkLCBmYWxzZSkpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmJlbG93KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYmVsb3coKVxuICAgKiBcbiAgICoqL1xuICBiZWxvdyh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodW5kZWZpbmVkLCB2YWx1ZSwgZmFsc2UsIHRydWUpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5iZWxvd09yRXF1YWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5iZWxvd09yRXF1YWwoKVxuICAgKiBcbiAgICoqL1xuICBiZWxvd09yRXF1YWwodmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5zdGFydHNXaXRoKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aCgpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGgoc3RyOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHJldHVybiBmYWlsKHRoaXMsIFNUUklOR19FWFBFQ1RFRCk7XG4gICAgcmV0dXJuIHRoaXMuYmV0d2VlbihzdHIsIHN0ciArIG1heFN0cmluZywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aElnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGhJZ25vcmVDYXNlKHN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHN0ciA9PT0gXCJcIikgcmV0dXJuIHRoaXMuc3RhcnRzV2l0aChzdHIpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4LmluZGV4T2YoYVswXSkgPT09IDAsIFtzdHJdLCBtYXhTdHJpbmcpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmVxdWFsc0lnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5lcXVhbHNJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgZXF1YWxzSWdub3JlQ2FzZShzdHI6IHN0cmluZykge1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiB4ID09PSBhWzBdLCBbc3RyXSwgXCJcIik7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgYW55T2ZJZ25vcmVDYXNlKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZklnbm9yZUNhc2UodmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIGFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLmluZGV4T2YoeCkgIT09IC0xLCBzZXQsIFwiXCIpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLnN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSguLi52YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSh2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpIHtcbiAgICB2YXIgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIHJldHVybiBhZGRJZ25vcmVDYXNlQWxnb3JpdGhtKHRoaXMsICh4LCBhKSA9PiBhLnNvbWUobiA9PiB4LmluZGV4T2YobikgPT09IDApLCBzZXQsIG1heFN0cmluZyk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYW55T2YoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5hbnlPZigpXG4gICAqIFxuICAgKiovXG4gIGFueU9mKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZih2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgYW55T2YoKSB7XG4gICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuICAgIGxldCBjb21wYXJlID0gdGhpcy5fY21wO1xuICAgIHRyeSB7IHNldC5zb3J0KGNvbXBhcmUpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTsgfVxuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIGNvbnN0IGMgPSBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHNldFswXSwgc2V0W3NldC5sZW5ndGggLSAxXSkpO1xuXG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgY29tcGFyZSA9IChkaXJlY3Rpb24gPT09IFwibmV4dFwiID9cbiAgICAgICAgdGhpcy5fYXNjZW5kaW5nIDpcbiAgICAgICAgdGhpcy5fZGVzY2VuZGluZyk7XG4gICAgICBzZXQuc29ydChjb21wYXJlKTtcbiAgICB9O1xuXG4gICAgbGV0IGkgPSAwO1xuICAgIGMuX2FkZEFsZ29yaXRobSgoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5LCBzZXRbaV0pID4gMCkge1xuICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICArK2k7XG4gICAgICAgIGlmIChpID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJlKGtleSwgc2V0W2ldKSA9PT0gMCkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3Vyc29yLmtleSBub3QgeWV0IGF0IHNldFtpXS4gRm9yd2FyZCBjdXJzb3IgdG8gdGhlIG5leHQga2V5IHRvIGh1bnQgZm9yLlxuICAgICAgICBhZHZhbmNlKCgpID0+IHsgY3Vyc29yLmNvbnRpbnVlKHNldFtpXSk7IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uubm90RXF1YWwoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5ub3RFcXVhbCgpXG4gICAqIFxuICAgKiovXG4gIG5vdEVxdWFsKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShbW21pbktleSwgdmFsdWVdLCBbdmFsdWUsIHRoaXMuZGIuX21heEtleV1dLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5ub25lT2YoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZS5ub25lT2YoKVxuICAgKiBcbiAgICoqL1xuICBub25lT2YoLi4udmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIG5vbmVPZih2YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgbm9uZU9mKCkge1xuICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcyk7IC8vIFJldHVybiBlbnRpcmUgY29sbGVjdGlvbi5cbiAgICB0cnkgeyBzZXQuc29ydCh0aGlzLl9hc2NlbmRpbmcpOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTsgfVxuICAgIC8vIFRyYW5zZm9ybSBbXCJhXCIsXCJiXCIsXCJjXCJdIHRvIGEgc2V0IG9mIHJhbmdlcyBmb3IgYmV0d2Vlbi9hYm92ZS9iZWxvdzogW1ttaW5LZXksXCJhXCJdLCBbXCJhXCIsXCJiXCJdLCBbXCJiXCIsXCJjXCJdLCBbXCJjXCIsbWF4S2V5XV1cbiAgICBjb25zdCByYW5nZXMgPSBzZXQucmVkdWNlKFxuICAgICAgKHJlcywgdmFsKSA9PiByZXMgP1xuICAgICAgICByZXMuY29uY2F0KFtbcmVzW3Jlcy5sZW5ndGggLSAxXVsxXSwgdmFsXV0pIDpcbiAgICAgICAgW1ttaW5LZXksIHZhbF1dLFxuICAgICAgbnVsbCk7XG4gICAgcmFuZ2VzLnB1c2goW3NldFtzZXQubGVuZ3RoIC0gMV0sIHRoaXMuZGIuX21heEtleV0pO1xuICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UocmFuZ2VzLCB7IGluY2x1ZGVMb3dlcnM6IGZhbHNlLCBpbmNsdWRlVXBwZXJzOiBmYWxzZSB9KTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5pbkFueVJhbmdlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuaW5BbnlSYW5nZSgpXG4gICAqIFxuICAgKiovXG4gIGluQW55UmFuZ2UoXG4gICAgcmFuZ2VzOiBSZWFkb25seUFycmF5PHsgMDogSW5kZXhhYmxlVHlwZSwgMTogSW5kZXhhYmxlVHlwZSB9PixcbiAgICBvcHRpb25zPzogeyBpbmNsdWRlTG93ZXJzPzogYm9vbGVhbiwgaW5jbHVkZVVwcGVycz86IGJvb2xlYW4gfSlcbiAge1xuICAgIGNvbnN0IGNtcCA9IHRoaXMuX2NtcCxcbiAgICAgICAgICBhc2NlbmRpbmcgPSB0aGlzLl9hc2NlbmRpbmcsXG4gICAgICAgICAgZGVzY2VuZGluZyA9IHRoaXMuX2Rlc2NlbmRpbmcsXG4gICAgICAgICAgbWluID0gdGhpcy5fbWluLFxuICAgICAgICAgIG1heCA9IHRoaXMuX21heDtcblxuICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIGlmICghcmFuZ2VzLmV2ZXJ5KHJhbmdlID0+XG4gICAgICByYW5nZVswXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICByYW5nZVsxXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhc2NlbmRpbmcocmFuZ2VbMF0sIHJhbmdlWzFdKSA8PSAwKSkge1xuICAgICAgcmV0dXJuIGZhaWwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIFwiRmlyc3QgYXJndW1lbnQgdG8gaW5BbnlSYW5nZSgpIG11c3QgYmUgYW4gQXJyYXkgb2YgdHdvLXZhbHVlIEFycmF5cyBbbG93ZXIsdXBwZXJdIHdoZXJlIHVwcGVyIG11c3Qgbm90IGJlIGxvd2VyIHRoYW4gbG93ZXJcIixcbiAgICAgICAgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlTG93ZXJzID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5pbmNsdWRlTG93ZXJzICE9PSBmYWxzZTsgICAvLyBEZWZhdWx0IHRvIHRydWVcbiAgICBjb25zdCBpbmNsdWRlVXBwZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVVcHBlcnMgPT09IHRydWU7ICAgIC8vIERlZmF1bHQgdG8gZmFsc2VcblxuICAgIGZ1bmN0aW9uIGFkZFJhbmdlKHJhbmdlcywgbmV3UmFuZ2UpIHtcbiAgICAgIGxldCBpID0gMCwgbCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKGNtcChuZXdSYW5nZVswXSwgcmFuZ2VbMV0pIDwgMCAmJiBjbXAobmV3UmFuZ2VbMV0sIHJhbmdlWzBdKSA+IDApIHtcbiAgICAgICAgICByYW5nZVswXSA9IG1pbihyYW5nZVswXSwgbmV3UmFuZ2VbMF0pO1xuICAgICAgICAgIHJhbmdlWzFdID0gbWF4KHJhbmdlWzFdLCBuZXdSYW5nZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByYW5nZXMucHVzaChuZXdSYW5nZSk7XG4gICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cblxuICAgIGxldCBzb3J0RGlyZWN0aW9uID0gYXNjZW5kaW5nO1xuICAgIGZ1bmN0aW9uIHJhbmdlU29ydGVyKGEsIGIpIHsgcmV0dXJuIHNvcnREaXJlY3Rpb24oYVswXSwgYlswXSk7IH1cblxuICAgIC8vIEpvaW4gb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgbGV0IHNldDtcbiAgICB0cnkge1xuICAgICAgc2V0ID0gcmFuZ2VzLnJlZHVjZShhZGRSYW5nZSwgW10pO1xuICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgfVxuXG4gICAgbGV0IHJhbmdlUG9zID0gMDtcbiAgICBjb25zdCBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeSA9IGluY2x1ZGVVcHBlcnMgP1xuICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID4gMCA6XG4gICAgICBrZXkgPT4gYXNjZW5kaW5nKGtleSwgc2V0W3JhbmdlUG9zXVsxXSkgPj0gMDtcblxuICAgIGNvbnN0IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5ID0gaW5jbHVkZUxvd2VycyA/XG4gICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID4gMCA6XG4gICAgICBrZXkgPT4gZGVzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMF0pID49IDA7XG5cbiAgICBmdW5jdGlvbiBrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSB7XG4gICAgICByZXR1cm4gIWtleUlzQmV5b25kQ3VycmVudEVudHJ5KGtleSkgJiYgIWtleUlzQmVmb3JlQ3VycmVudEVudHJ5KGtleSk7XG4gICAgfVxuXG4gICAgbGV0IGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG5cbiAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbihcbiAgICAgIHRoaXMsXG4gICAgICAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF1bMF0sIHNldFtzZXQubGVuZ3RoIC0gMV1bMV0sICFpbmNsdWRlTG93ZXJzLCAhaW5jbHVkZVVwcGVycykpO1xuXG4gICAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBkaXJlY3Rpb24gPT4ge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgY2hlY2tLZXkgPSBrZXlJc0JleW9uZEN1cnJlbnRFbnRyeTtcbiAgICAgICAgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZWZvcmVDdXJyZW50RW50cnk7XG4gICAgICAgIHNvcnREaXJlY3Rpb24gPSBkZXNjZW5kaW5nO1xuICAgICAgfVxuICAgICAgc2V0LnNvcnQocmFuZ2VTb3J0ZXIpO1xuICAgIH07XG5cbiAgICBjLl9hZGRBbGdvcml0aG0oKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICB3aGlsZSAoY2hlY2tLZXkoa2V5KSkge1xuICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICArK3JhbmdlUG9zO1xuICAgICAgICBpZiAocmFuZ2VQb3MgPT09IHNldC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXh0LiBTdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleVdpdGhpbkN1cnJlbnRSYW5nZShrZXkpKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGN1cnNvciB2YWx1ZSBzaG91bGQgYmUgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjb250aW51ZSBhIHNpbmdsZSBzdGVwIGluIGNhc2UgbmV4dCBpdGVtIGhhcyB0aGUgc2FtZSBrZXkgb3IgcG9zc2libHkgb3VyIG5leHQga2V5IGluIHNldC5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMV0pID09PSAwIHx8IHRoaXMuX2NtcChrZXksIHNldFtyYW5nZVBvc11bMF0pID09PSAwKSB7XG4gICAgICAgIC8vIGluY2x1ZGVVcHBlciBvciBpbmNsdWRlTG93ZXIgaXMgZmFsc2Ugc28ga2V5V2l0aGluQ3VycmVudFJhbmdlKCkgcmV0dXJucyBmYWxzZSBldmVuIHRob3VnaCB3ZSBhcmUgYXQgcmFuZ2UgYm9yZGVyLlxuICAgICAgICAvLyBDb250aW51ZSB0byBuZXh0IGtleSBidXQgZG9uJ3QgaW5jbHVkZSB0aGlzIG9uZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3Vyc29yLmtleSBub3QgeWV0IGF0IHNldFtpXS4gRm9yd2FyZCBjdXJzb3IgdG8gdGhlIG5leHQga2V5IHRvIGh1bnQgZm9yLlxuICAgICAgICBhZHZhbmNlKCgpID0+IHtcbiAgICAgICAgICBpZiAoc29ydERpcmVjdGlvbiA9PT0gYXNjZW5kaW5nKSBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVswXSk7XG4gICAgICAgICAgZWxzZSBjdXJzb3IuY29udGludWUoc2V0W3JhbmdlUG9zXVsxXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mKClcbiAgICogXG4gICAqKi9cbiAgc3RhcnRzV2l0aEFueU9mKC4uLnByZWZpeGVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIHN0YXJ0c1dpdGhBbnlPZihwcmVmaXhlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBzdGFydHNXaXRoQW55T2YoKSB7XG4gICAgY29uc3Qgc2V0ID0gZ2V0QXJyYXlPZi5hcHBseShOT19DSEFSX0FSUkFZLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKCFzZXQuZXZlcnkocyA9PiB0eXBlb2YgcyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKHRoaXMsIFwic3RhcnRzV2l0aEFueU9mKCkgb25seSB3b3JrcyB3aXRoIHN0cmluZ3NcIik7XG4gICAgfVxuICAgIGlmIChzZXQubGVuZ3RoID09PSAwKSByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuaW5BbnlSYW5nZShzZXQubWFwKChzdHI6IHN0cmluZykgPT4gW3N0ciwgc3RyICsgbWF4U3RyaW5nXSkpO1xuICB9XG5cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4uL3RhYmxlJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdoZXJlQ2xhdXNlQ29uc3RydWN0b3Ige1xuICBuZXcodGFibGU6IFRhYmxlLCBpbmRleD86IHN0cmluZywgb3JDb2xsZWN0aW9uPzogQ29sbGVjdGlvbik6IFdoZXJlQ2xhdXNlO1xuICBwcm90b3R5cGU6IFdoZXJlQ2xhdXNlO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgV2hlcmVDbGF1c2UgY29uc3RydWN0b3IuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8V2hlcmVDbGF1c2VDb25zdHJ1Y3Rvcj4oXG4gICAgV2hlcmVDbGF1c2UucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gV2hlcmVDbGF1c2UodGhpczogV2hlcmVDbGF1c2UsIHRhYmxlOiBUYWJsZSwgaW5kZXg/OiBzdHJpbmcsIG9yQ29sbGVjdGlvbj86IENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuZGIgPSBkYjtcbiAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICBpbmRleDogaW5kZXggPT09IFwiOmlkXCIgPyBudWxsIDogaW5kZXgsXG4gICAgICAgIG9yOiBvckNvbGxlY3Rpb25cbiAgICAgIH07XG4gICAgICBjb25zdCBpbmRleGVkREIgPSBkYi5fZGVwcy5pbmRleGVkREI7XG4gICAgICBpZiAoIWluZGV4ZWREQikgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpO1xuICAgICAgdGhpcy5fY21wID0gdGhpcy5fYXNjZW5kaW5nID0gaW5kZXhlZERCLmNtcC5iaW5kKGluZGV4ZWREQik7XG4gICAgICB0aGlzLl9kZXNjZW5kaW5nID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYiwgYSk7XG4gICAgICB0aGlzLl9tYXggPSAoYSwgYikgPT4gaW5kZXhlZERCLmNtcChhLGIpID4gMCA/IGEgOiBiO1xuICAgICAgdGhpcy5fbWluID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSxiKSA8IDAgPyBhIDogYjtcbiAgICAgIHRoaXMuX0lEQktleVJhbmdlID0gZGIuX2RlcHMuSURCS2V5UmFuZ2U7XG4gICAgfVxuICApO1xufVxuIiwgImltcG9ydCB7IHdyYXAgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgcmVqZWN0IChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50U3VjY2Vzc0hhbmRsZXIgKHJlc29sdmUpIHtcbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KXtcbiAgICAgIHJlc29sdmUoZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaG9va2VkRXZlbnRSZWplY3RIYW5kbGVyIChyZWplY3QpIHtcbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAvLyBTZWUgY29tbWVudCBvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKCkgd2h5IHdyYXAoKSBpcyBuZWVkZWQgb25seSB3aGVuIHN1cHBvcnRpbmcgaG9va3MuXG4gICAgICBcbiAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgZXJyID0gcmVxLmVycm9yLFxuICAgICAgICAgIGN0eCA9IHJlcS5faG9va0N0eCwvLyBDb250YWlucyB0aGUgaG9vayBlcnJvciBoYW5kbGVyLiBQdXQgaGVyZSBpbnN0ZWFkIG9mIGNsb3N1cmUgdG8gYm9vc3QgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgaG9va0Vycm9ySGFuZGxlciA9IGN0eCAmJiBjdHgub25lcnJvcjtcbiAgICAgIGhvb2tFcnJvckhhbmRsZXIgJiYgaG9va0Vycm9ySGFuZGxlcihlcnIpO1xuICAgICAgcHJldmVudERlZmF1bHQoZXZlbnQpO1xuICAgICAgcmVqZWN0IChlcnIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tlZEV2ZW50U3VjY2Vzc0hhbmRsZXIocmVzb2x2ZSkge1xuICAvLyB3cmFwKCkgaXMgbmVlZGVkIHdoZW4gY2FsbGluZyBob29rcyBiZWNhdXNlIHRoZSByYXJlIHNjZW5hcmlvIG9mOlxuICAvLyAgKiBob29rIGRvZXMgYSBkYiBvcGVyYXRpb24gdGhhdCBmYWlscyBpbW1lZGlhdGVseSAoSURCIHRocm93cyBleGNlcHRpb24pXG4gIC8vICAgIEZvciBjYWxsaW5nIGRiIG9wZXJhdGlvbnMgb24gY29ycmVjdCB0cmFuc2FjdGlvbiwgd3JhcCBtYWtlcyBzdXJlIHRvIHNldCBQU0QgY29ycmVjdGx5LlxuICAvLyAgICB3cmFwKCkgd2lsbCBhbHNvIGV4ZWN1dGUgaW4gYSB2aXJ0dWFsIHRpY2suXG4gIC8vICAqIElmIG5vdCB3cmFwcGVkIGluIGEgdmlydHVhbCB0aWNrLCBkaXJlY3QgZXhjZXB0aW9uIHdpbGwgbGF1bmNoIGEgbmV3IHBoeXNpY2FsIHRpY2suXG4gIC8vICAqIElmIHRoaXMgd2FzIHRoZSBsYXN0IGV2ZW50IGluIHRoZSBidWxrLCB0aGUgcHJvbWlzZSB3aWxsIHJlc29sdmUgYWZ0ZXIgYSBwaHlzaWNhbCB0aWNrXG4gIC8vICAgIGFuZCB0aGUgdHJhbnNhY3Rpb24gd2lsbCBoYXZlIGNvbW1pdHRlZCBhbHJlYWR5LlxuICAvLyBJZiBubyBob29rLCB0aGUgdmlydHVhbCB0aWNrIHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHJlamVjdCgpL3Jlc29sdmUgb2YgdGhlIGZpbmFsIHByb21pc2UsXG4gIC8vIGJlY2F1c2UgaXQgaXMgYWx3YXlzIG1hcmtlZCB3aXRoIF9saWIgPSB0cnVlIHdoZW4gY3JlYXRlZCB1c2luZyBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpLlxuICByZXR1cm4gd3JhcChmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIHJlcSA9IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICBjdHggPSByZXEuX2hvb2tDdHgsLy8gQ29udGFpbnMgdGhlIGhvb2sgZXJyb3IgaGFuZGxlci4gUHV0IGhlcmUgaW5zdGVhZCBvZiBjbG9zdXJlIHRvIGJvb3N0IHBlcmZvcm1hbmNlLlxuICAgICAgICAgIHJlc3VsdCA9IGN0eC52YWx1ZSB8fCByZXEucmVzdWx0LCAvLyBQYXNzIHRoZSBvYmplY3QgdmFsdWUgb24gdXBkYXRlcy4gVGhlIHJlc3VsdCBmcm9tIElEQiBpcyB0aGUgcHJpbWFyeSBrZXkuXG4gICAgICAgICAgaG9va1N1Y2Nlc3NIYW5kbGVyID0gY3R4ICYmIGN0eC5vbnN1Y2Nlc3M7XG4gICAgICBob29rU3VjY2Vzc0hhbmRsZXIgJiYgaG9va1N1Y2Nlc3NIYW5kbGVyKHJlc3VsdCk7XG4gICAgICByZXNvbHZlICYmIHJlc29sdmUocmVzdWx0KTtcbiAgfSwgcmVzb2x2ZSk7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIC8vIEluZGV4ZWREQlNoaW0gZG9lc250IHN1cHBvcnQgdGhpcyBvbiBTYWZhcmkgOCBhbmQgYmVsb3cuXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSAvLyBJbmRleGVkREJTaGltIGRvZXNudCBzdXBwb3J0IHRoaXMgb24gU2FmYXJpIDggYW5kIGJlbG93LlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEJ1bGtFcnJvckhhbmRsZXJDYXRjaEFsbChlcnJvckxpc3QsIGRvbmU/LCBzdXBwb3J0SG9va3M/KSB7XG4gIHJldHVybiAoc3VwcG9ydEhvb2tzID8gaG9va2VkRXZlbnRSZWplY3RIYW5kbGVyIDogZXZlbnRSZWplY3RIYW5kbGVyKShlID0+IHtcbiAgICAgIGVycm9yTGlzdC5wdXNoKGUpO1xuICAgICAgZG9uZSAmJiBkb25lKCk7XG4gIH0pO1xufVxuXG4iLCAiaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBHbG9iYWxEZXhpZUV2ZW50cyB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHMnO1xuXG5leHBvcnQgY29uc3QgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgPSAnc3RvcmFnZW11dGF0ZWQnIGFzICdzdG9yYWdlbXV0YXRlZCc7XG5cbi8vIE5hbWUgb2YgdGhlIGdsb2JhbCBldmVudCBmaXJlZCB1c2luZyBET00gZGlzcGF0Y2hFdmVudCAoaWYgbm90IGluIG5vZGUpLlxuLy8gUmVhc29uIGZvciBwcm9wYWdhdGluZyB0aGlzIGFzIGEgRE9NIGV2ZW50IGlzIGZvciBnZXR0aW5nIHJlYWN0aXZpdHkgYWNyb3NzXG4vLyBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBEZXhpZSB3aXRoaW4gdGhlIHNhbWUgYXBwIChhcyBsb25nIGFzIHRoZXkgYXJlXG4vLyBjb21wYXRpYmxlIHdpdGggcmVnYXJkcyB0byB0aGUgZXZlbnQgZGF0YSkuXG4vLyBJZiB0aGUgT2JzZXJ2YWJpbGl0eVNldCBwcm90b2NvbCBjaGFuZ2UgaW4gYSB3YXkgdGhhdCB3b3VsZCBub3QgYmUgYmFja3dhcmRcbi8vIGNvbXBhdGlibGUsIG1ha2Ugc3VyZSBhbHNvIHVwZGF0ZSB0aGUgZXZlbnQgbmFtZSB0byBhIG5ldyBudW1iZXIgYXQgdGhlIGVuZFxuLy8gc28gdGhhdCB0d28gRGV4aWUgaW5zdGFuY2VzIG9mIGRpZmZlcmVudCB2ZXJzaW9ucyBjb250aW51ZSB0byB3b3JrIHRvZ2V0aGVyXG4vLyAgLSBtYXliZSBub3QgYWJsZSB0byBjb21tdW5pY2F0ZSBidXQgd29uJ3QgZmFpbCBkdWUgdG8gdW5leHBlY3RlZCBkYXRhIGluXG4vLyB0aGUgZGV0YWlsIHByb3BlcnR5IG9mIHRoZSBDdXN0b21FdmVudC4gSWYgc28sIGFsc28gbWFrZSBzdXJlIHRvIHVkcGF0ZVxuLy8gZG9jcyBhbmQgZXhwbGFpbiBhdCB3aGljaCBEZXhpZSB2ZXJzaW9uIHRoZSBuZXcgbmFtZSBhbmQgZm9ybWF0IG9mIHRoZSBldmVudFxuLy8gaXMgYmVpbmcgdXNlZC5cbmV4cG9ydCBjb25zdCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgPSAneC1zdG9yYWdlbXV0YXRlZC0xJztcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEV2ZW50cyA9IEV2ZW50cyhudWxsLCBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSkgYXMgR2xvYmFsRGV4aWVFdmVudHM7XG4iLCAiaW1wb3J0IHsgVHJhbnNhY3Rpb24gYXMgSVRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERleGllUHJvbWlzZSwgd3JhcCwgcmVqZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCB7IGFzc2VydCwgaGFzT3duIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IFBTRCwgdXNlUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBzYWZhcmlNdWx0aVN0b3JlRml4IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgeyBuZXdTY29wZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuLi8uLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi4vdGFibGUnO1xuaW1wb3J0IHsgZ2xvYmFsRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcblxuLyoqIFRyYW5zYWN0aW9uXG4gKiBcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb25cbiAqIFxuICoqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGltcGxlbWVudHMgSVRyYW5zYWN0aW9uIHtcbiAgZGI6IERleGllO1xuICBhY3RpdmU6IGJvb2xlYW47XG4gIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZTtcbiAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbjtcbiAgc3RvcmVOYW1lczogc3RyaW5nW107XG4gIG9uOiBhbnk7XG4gIHBhcmVudD86IFRyYW5zYWN0aW9uO1xuICBzY2hlbWE6IERiU2NoZW1hO1xuICBfbWVtb2l6ZWRUYWJsZXM6IHtbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZX07XG5cbiAgX3JlY3Vsb2NrOiBudW1iZXI7XG4gIF9ibG9ja2VkRnVuY3M6IHsgMDogKCkgPT4gYW55LCAxOiBhbnkgfVtdO1xuICBfcmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgX3JlamVjdDogKEVycm9yKSA9PiB2b2lkO1xuICBfd2FpdGluZ0ZvcjogRGV4aWVQcm9taXNlOyAvLyBmb3Igd2FpdEZvcigpXG4gIF93YWl0aW5nUXVldWU6IEZ1bmN0aW9uW107IC8vIGZvciB3YWl0Rm9yKClcbiAgX3NwaW5Db3VudDogbnVtYmVyOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gIF9jb21wbGV0aW9uOiBEZXhpZVByb21pc2U7XG5cbiAgLy9cbiAgLy8gVHJhbnNhY3Rpb24gaW50ZXJuYWwgbWV0aG9kcyAobm90IHJlcXVpcmVkIGJ5IEFQSSB1c2VycywgYnV0IG5lZWRlZCBpbnRlcm5hbGx5IGFuZCBldmVudHVhbGx5IGJ5IGRleGllIGV4dGVuc2lvbnMpXG4gIC8vXG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9sb2NrKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC5cbiAgICovXG4gIF9sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICAvLyBUZW1wb3Jhcnkgc2V0IGFsbCByZXF1ZXN0cyBpbnRvIGEgcGVuZGluZyBxdWV1ZSBpZiB0aGV5IGFyZSBjYWxsZWQgYmVmb3JlIGRhdGFiYXNlIGlzIHJlYWR5LlxuICAgICsrdGhpcy5fcmVjdWxvY2s7IC8vIFJlY3Vyc2l2ZSByZWFkL3dyaXRlIGxvY2sgcGF0dGVybiB1c2luZyBQU0QgKFByb21pc2UgU3BlY2lmaWMgRGF0YSkgaW5zdGVhZCBvZiBUTFMgKFRocmVhZCBMb2NhbCBTdG9yYWdlKVxuICAgIGlmICh0aGlzLl9yZWN1bG9jayA9PT0gMSAmJiAhUFNELmdsb2JhbCkgUFNELmxvY2tPd25lckZvciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX3VubG9jaygpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfdW5sb2NrKCkge1xuICAgIGFzc2VydCghUFNELmdsb2JhbCk7IC8vIExvY2tpbmcgYW5kIHVubG9ja2luZyByZXVpcmVzIHRvIGJlIHdpdGhpbiBhIFBTRCBzY29wZS5cbiAgICBpZiAoLS10aGlzLl9yZWN1bG9jayA9PT0gMCkge1xuICAgICAgaWYgKCFQU0QuZ2xvYmFsKSBQU0QubG9ja093bmVyRm9yID0gbnVsbDtcbiAgICAgIHdoaWxlICh0aGlzLl9ibG9ja2VkRnVuY3MubGVuZ3RoID4gMCAmJiAhdGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgICAgdmFyIGZuQW5kUFNEID0gdGhpcy5fYmxvY2tlZEZ1bmNzLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7IHVzZVBTRChmbkFuZFBTRFsxXSwgZm5BbmRQU0RbMF0pOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX2xvY2soKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKi9cbiAgX2xvY2tlZCgpIHtcbiAgICAvLyBDaGVja3MgaWYgYW55IHdyaXRlLWxvY2sgaXMgYXBwbGllZCBvbiB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIC8vIFRvIHNpbXBsaWZ5IHRoZSBEZXhpZSBBUEkgZm9yIGV4dGVuc2lvbiBpbXBsZW1lbnRhdGlvbnMsIHdlIHN1cHBvcnQgcmVjdXJzaXZlIGxvY2tzLlxuICAgIC8vIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHVzaW5nIFwiUHJvbWlzZSBTcGVjaWZpYyBEYXRhXCIgKFBTRCkuXG4gICAgLy8gUFNEIGRhdGEgaXMgYm91bmQgdG8gYSBQcm9taXNlIGFuZCBhbnkgY2hpbGQgUHJvbWlzZSBlbWl0dGVkIHRocm91Z2ggdGhlbigpIG9yIHJlc29sdmUoIG5ldyBQcm9taXNlKCkgKS5cbiAgICAvLyBQU0QgaXMgbG9jYWwgdG8gY29kZSBleGVjdXRpbmcgb24gdG9wIG9mIHRoZSBjYWxsIHN0YWNrcyBvZiBhbnkgb2YgYW55IGNvZGUgZXhlY3V0ZWQgYnkgUHJvbWlzZSgpOlxuICAgIC8vICAgICAgICAgKiBjYWxsYmFjayBnaXZlbiB0byB0aGUgUHJvbWlzZSgpIGNvbnN0cnVjdG9yICAoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCl7Li4ufSlcbiAgICAvLyAgICAgICAgICogY2FsbGJhY2tzIGdpdmVuIHRvIHRoZW4oKS9jYXRjaCgpL2ZpbmFsbHkoKSBtZXRob2RzIChmdW5jdGlvbiAodmFsdWUpey4uLn0pXG4gICAgLy8gSWYgY3JlYXRpbmcgYSBuZXcgaW5kZXBlbmRhbnQgUHJvbWlzZSBpbnN0YW5jZSBmcm9tIHdpdGhpbiBhIFByb21pc2UgY2FsbCBzdGFjaywgdGhlIG5ldyBQcm9taXNlIHdpbGwgZGVyaXZlIHRoZSBQU0QgZnJvbSB0aGUgY2FsbCBzdGFjayBvZiB0aGUgcGFyZW50IFByb21pc2UuXG4gICAgLy8gRGVyaXZhdGlvbiBpcyBkb25lIHNvIHRoYXQgdGhlIGlubmVyIFBTRCBfX3Byb3RvX18gcG9pbnRzIHRvIHRoZSBvdXRlciBQU0QuXG4gICAgLy8gUFNELmxvY2tPd25lckZvciB3aWxsIHBvaW50IHRvIGN1cnJlbnQgdHJhbnNhY3Rpb24gb2JqZWN0IGlmIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIFBTRCBzY29wZSBvd25zIHRoZSBsb2NrLlxuICAgIHJldHVybiB0aGlzLl9yZWN1bG9jayAmJiBQU0QubG9ja093bmVyRm9yICE9PSB0aGlzO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLmNyZWF0ZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqIFxuICAgKi9cbiAgY3JlYXRlKGlkYnRyYW5zPzogSURCVHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMubW9kZSkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgaWRiZGIgPSB0aGlzLmRiLmlkYmRiO1xuICAgIGNvbnN0IGRiT3BlbkVycm9yID0gdGhpcy5kYi5fc3RhdGUuZGJPcGVuRXJyb3I7XG4gICAgYXNzZXJ0KCF0aGlzLmlkYnRyYW5zKTtcbiAgICBpZiAoIWlkYnRyYW5zICYmICFpZGJkYikge1xuICAgICAgc3dpdGNoIChkYk9wZW5FcnJvciAmJiBkYk9wZW5FcnJvci5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJEYXRhYmFzZUNsb3NlZEVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgICBjYXNlIFwiTWlzc2luZ0FQSUVycm9yXCI6XG4gICAgICAgICAgLy8gRXJyb3JzIHdoZXJlIGl0IGlzIG5vIGRpZmZlcmVuY2Ugd2hldGhlciBpdCB3YXMgY2F1c2VkIGJ5IHRoZSB1c2VyIG9wZXJhdGlvbiBvciBhbiBlYXJsaWVyIGNhbGwgdG8gZGIub3BlbigpXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSShkYk9wZW5FcnJvci5tZXNzYWdlLCBkYk9wZW5FcnJvcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gTWFrZSBpdCBjbGVhciB0aGF0IHRoZSB1c2VyIG9wZXJhdGlvbiB3YXMgbm90IHdoYXQgY2F1c2VkIHRoZSBlcnJvciAtIHRoZSBlcnJvciBoYWQgb2NjdXJyZWQgZWFybGllciBvbiBkYi5vcGVuKCkhXG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuT3BlbkZhaWxlZChkYk9wZW5FcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5hY3RpdmUpIHRocm93IG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKTtcbiAgICBhc3NlcnQodGhpcy5fY29tcGxldGlvbi5fc3RhdGUgPT09IG51bGwpOyAvLyBDb21wbGV0aW9uIFByb21pc2UgbXVzdCBzdGlsbCBiZSBwZW5kaW5nLlxuXG4gICAgaWRidHJhbnMgPSB0aGlzLmlkYnRyYW5zID0gaWRidHJhbnMgfHxcbiAgICAgICh0aGlzLmRiLmNvcmUgXG4gICAgICAgID8gdGhpcy5kYi5jb3JlLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlIGFzICdyZWFkd3JpdGUnIHwgJ3JlYWRvbmx5JywgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgICA6IGlkYmRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lcywgdGhpcy5tb2RlLCB7IGR1cmFiaWxpdHk6IHRoaXMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5IH0pXG4gICAgICApIGFzIElEQlRyYW5zYWN0aW9uO1xuXG4gICAgaWRidHJhbnMub25lcnJvciA9IHdyYXAoZXYgPT4ge1xuICAgICAgcHJldmVudERlZmF1bHQoZXYpOy8vIFByb2hpYml0IGRlZmF1bHQgYnViYmxpbmcgdG8gd2luZG93LmVycm9yXG4gICAgICB0aGlzLl9yZWplY3QoaWRidHJhbnMuZXJyb3IpO1xuICAgIH0pO1xuICAgIGlkYnRyYW5zLm9uYWJvcnQgPSB3cmFwKGV2ID0+IHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2KTtcbiAgICAgIHRoaXMuYWN0aXZlICYmIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydChpZGJ0cmFucy5lcnJvcikpO1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMub24oXCJhYm9ydFwiKS5maXJlKGV2KTtcbiAgICB9KTtcbiAgICBpZGJ0cmFucy5vbmNvbXBsZXRlID0gd3JhcCgoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xuICAgICAgaWYgKCdtdXRhdGVkUGFydHMnIGluIGlkYnRyYW5zKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKGlkYnRyYW5zW1wibXV0YXRlZFBhcnRzXCJdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi5fcHJvbWlzZSgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfcHJvbWlzZShcbiAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgZm46IChyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8YW55PiB8IHZvaWQsXG4gICAgYldyaXRlTG9jaz86IHN0cmluZyB8IGJvb2xlYW4pOiBEZXhpZVByb21pc2VcbiAge1xuICAgIGlmIChtb2RlID09PSAncmVhZHdyaXRlJyAmJiB0aGlzLm1vZGUgIT09ICdyZWFkd3JpdGUnKVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5SZWFkT25seShcIlRyYW5zYWN0aW9uIGlzIHJlYWRvbmx5XCIpKTtcblxuICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlRyYW5zYWN0aW9uSW5hY3RpdmUoKSk7XG5cbiAgICBpZiAodGhpcy5fbG9ja2VkKCkpIHtcbiAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzLnB1c2goWygpID0+IHtcbiAgICAgICAgICB0aGlzLl9wcm9taXNlKG1vZGUsIGZuLCBiV3JpdGVMb2NrKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0sIFBTRF0pO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKGJXcml0ZUxvY2spIHtcbiAgICAgIHJldHVybiBuZXdTY29wZSgoKSA9PiB7XG4gICAgICAgIHZhciBwID0gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgdGhpcy5fbG9jaygpO1xuICAgICAgICAgIGNvbnN0IHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcC5maW5hbGx5KCgpID0+IHRoaXMuX3VubG9jaygpKTtcbiAgICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgcnYgPSBmbihyZXNvbHZlLCByZWplY3QsIHRoaXMpO1xuICAgICAgICBpZiAocnYgJiYgcnYudGhlbikgcnYudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBwLl9saWIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9yb290KClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gUmV0cmlldmVzIHRoZSByb290IHRyYW5zYWN0aW9uIGluIHRoZSB0cmVlIG9mIHN1YiB0cmFuc2FjdGlvbnMuXG4gICAqL1xuICBfcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5fcm9vdCgpIDogdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC4gQ2FuIGJlIGFjY2Vzc2VkIGZyb20gdGhlIHB1YmxpYyBBUEkgdGhyb3VnaFxuICAgKiBEZXhpZS53YWl0Rm9yKCk6IGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvRGV4aWUvRGV4aWUud2FpdEZvcigpXG4gICAqIFxuICAgKiovXG4gIHdhaXRGb3IocHJvbWlzZUxpa2U6IFByb21pc2VMaWtlPGFueT4pIHtcbiAgICAvLyBBbHdheXMgb3BlcmF0ZSBvbiB0aGUgcm9vdCB0cmFuc2FjdGlvbiAoaW4gY2FzZSB0aGlzIGlzIGEgc3ViIHN0cmFuc2FjdGlvbilcbiAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3QoKTtcbiAgICAvLyBGb3Igc3RhYmlsaXR5IHJlYXNvbnMsIGNvbnZlcnQgcGFyYW1ldGVyIHRvIHByb21pc2Ugbm8gbWF0dGVyIHdoYXQgdHlwZSBpcyBwYXNzZWQgdG8gd2FpdEZvcigpLlxuICAgIC8vIChXZSBtdXN0IGJlIGFibGUgdG8gY2FsbCAudGhlbigpIG9uIGl0LilcbiAgICBjb25zdCBwcm9taXNlID0gRGV4aWVQcm9taXNlLnJlc29sdmUocHJvbWlzZUxpa2UpO1xuICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSB7XG4gICAgICAvLyBBbHJlYWR5IGNhbGxlZCB3YWl0Rm9yKCkuIFdhaXQgZm9yIGJvdGggdG8gY29tcGxldGUuXG4gICAgICByb290Ll93YWl0aW5nRm9yID0gcm9vdC5fd2FpdGluZ0Zvci50aGVuKCgpID0+IHByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBub3QgaW4gd2FpdGluZyBzdGF0ZS4gU3RhcnQgd2FpdGluZyBzdGF0ZS5cbiAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBwcm9taXNlO1xuICAgICAgcm9vdC5fd2FpdGluZ1F1ZXVlID0gW107XG4gICAgICAvLyBTdGFydCBpbnRlcmFjdGluZyB3aXRoIGluZGV4ZWREQiB1bnRpbCBwcm9taXNlIGNvbXBsZXRlczpcbiAgICAgIHZhciBzdG9yZSA9IHJvb3QuaWRidHJhbnMub2JqZWN0U3RvcmUocm9vdC5zdG9yZU5hbWVzWzBdKTtcbiAgICAgIChmdW5jdGlvbiBzcGluKCkge1xuICAgICAgICArK3Jvb3QuX3NwaW5Db3VudDsgLy8gRm9yIGRlYnVnZ2luZyBvbmx5XG4gICAgICAgIHdoaWxlIChyb290Ll93YWl0aW5nUXVldWUubGVuZ3RoKSAocm9vdC5fd2FpdGluZ1F1ZXVlLnNoaWZ0KCkpKCk7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yKSBzdG9yZS5nZXQoLUluZmluaXR5KS5vbnN1Y2Nlc3MgPSBzcGluO1xuICAgICAgfSgpKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRXYWl0UHJvbWlzZSA9IHJvb3QuX3dhaXRpbmdGb3I7XG4gICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcHJvbWlzZS50aGVuKFxuICAgICAgICByZXMgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZXNvbHZlLmJpbmQobnVsbCwgcmVzKSkpLFxuICAgICAgICBlcnIgPT4gcm9vdC5fd2FpdGluZ1F1ZXVlLnB1c2god3JhcChyZWplY3QuYmluZChudWxsLCBlcnIpKSlcbiAgICAgICkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGlmIChyb290Ll93YWl0aW5nRm9yID09PSBjdXJyZW50V2FpdFByb21pc2UpIHtcbiAgICAgICAgICAvLyBObyBvbmUgYWRkZWQgYSB3YWl0IGFmdGVyIHVzLiBTYWZlIHRvIHN0b3AgdGhlIHNwaW5uaW5nLlxuICAgICAgICAgIHJvb3QuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAgXG5cbiAgLyoqIFRyYW5zYWN0aW9uLmFib3J0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb24uYWJvcnQoKVxuICAgKi9cbiAgYWJvcnQoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuaWRidHJhbnMpIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgIHRoaXMuX3JlamVjdChuZXcgZXhjZXB0aW9ucy5BYm9ydCgpKTtcbiAgICB9XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24udGFibGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UcmFuc2FjdGlvbi9UcmFuc2FjdGlvbi50YWJsZSgpXG4gICAqL1xuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1lbW9pemVkVGFibGVzID0gKHRoaXMuX21lbW9pemVkVGFibGVzIHx8ICh0aGlzLl9tZW1vaXplZFRhYmxlcyA9IHt9KSk7XG4gICAgaWYgKGhhc093bihtZW1vaXplZFRhYmxlcywgdGFibGVOYW1lKSlcbiAgICAgIHJldHVybiBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdO1xuICAgIGNvbnN0IHRhYmxlU2NoZW1hID0gdGhpcy5zY2hlbWFbdGFibGVOYW1lXTtcbiAgICBpZiAoIXRhYmxlU2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5Ob3RGb3VuZChcIlRhYmxlIFwiICsgdGFibGVOYW1lICsgXCIgbm90IHBhcnQgb2YgdHJhbnNhY3Rpb25cIik7ICAgICAgICBcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkJvdW5kVGFibGUgPSBuZXcgdGhpcy5kYi5UYWJsZSh0YWJsZU5hbWUsIHRhYmxlU2NoZW1hLCB0aGlzKTtcbiAgICB0cmFuc2FjdGlvbkJvdW5kVGFibGUuY29yZSA9IHRoaXMuZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgIG1lbW9pemVkVGFibGVzW3RhYmxlTmFtZV0gPSB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uQm91bmRUYWJsZTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IFByb21pc2UsIHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvbkNvbnN0cnVjdG9yPFQgZXh0ZW5kcyBUcmFuc2FjdGlvbj1UcmFuc2FjdGlvbj4ge1xuICBuZXcgKFxuICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgcGFyZW50PzogVHJhbnNhY3Rpb24pIDogVDtcbiAgcHJvdG90eXBlOiBUO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgVHJhbnNhY3Rpb24gY29uc3RydWN0b3IgYm91bmQgdG8gZ2l2ZW4gRGV4aWUgaW5zdGFuY2UuXG4gKiBcbiAqIFRoZSBwdXJwb3NlIG9mIGhhdmluZyBkeW5hbWljYWxseSBjcmVhdGVkIGNvbnN0cnVjdG9ycywgaXMgdG8gYWxsb3dcbiAqIGFkZG9ucyB0byBleHRlbmQgY2xhc3NlcyBmb3IgYSBjZXJ0YWluIERleGllIGluc3RhbmNlIHdpdGhvdXQgYWZmZWN0aW5nXG4gKiBvdGhlciBkYiBpbnN0YW5jZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjxUcmFuc2FjdGlvbj4+KFxuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZSxcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbiAoXG4gICAgICB0aGlzOiBUcmFuc2FjdGlvbixcbiAgICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICAgIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgICAgY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5OiBDaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksXG4gICAgICBwYXJlbnQ/OiBUcmFuc2FjdGlvbilcbiAgICB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdG9yZU5hbWVzID0gc3RvcmVOYW1lcztcbiAgICAgIHRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XG4gICAgICB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSA9IGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTtcbiAgICAgIHRoaXMuaWRidHJhbnMgPSBudWxsO1xuICAgICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcImNvbXBsZXRlXCIsIFwiZXJyb3JcIiwgXCJhYm9ydFwiKTtcbiAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IG51bGw7XG4gICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWN1bG9jayA9IDA7XG4gICAgICB0aGlzLl9ibG9ja2VkRnVuY3MgPSBbXTtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dhaXRpbmdGb3IgPSBudWxsO1xuICAgICAgdGhpcy5fd2FpdGluZ1F1ZXVlID0gbnVsbDtcbiAgICAgIHRoaXMuX3NwaW5Db3VudCA9IDA7IC8vIEp1c3QgZm9yIGRlYnVnZ2luZyB3YWl0Rm9yKClcbiAgICAgIHRoaXMuX2NvbXBsZXRpb24gPSBuZXcgUHJvbWlzZSAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21wbGV0aW9uLnRoZW4oXG4gICAgICAgICAgKCk9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMub24uY29tcGxldGUuZmlyZSgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgIHZhciB3YXNBY3RpdmUgPSB0aGlzLmFjdGl2ZTtcbiAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdGhpcy5vbi5lcnJvci5maXJlKGUpO1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudCA/XG4gICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVqZWN0KGUpIDpcbiAgICAgICAgICAgICAgICAgIHdhc0FjdGl2ZSAmJiB0aGlzLmlkYnRyYW5zICYmIHRoaXMuaWRidHJhbnMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTsgLy8gSW5kaWNhdGUgd2UgYWN0dWFsbHkgRE8gTk9UIGNhdGNoIHRoaXMgZXJyb3IuXG4gICAgICAgICAgfSk7XG4gICAgXG4gICAgfSk7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5kZXhTcGVjKFxuICBuYW1lOiBzdHJpbmcsXG4gIGtleVBhdGg6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB1bmlxdWU6IGJvb2xlYW4sXG4gIG11bHRpOiBib29sZWFuLFxuICBhdXRvOiBib29sZWFuLFxuICBjb21wb3VuZDogYm9vbGVhbixcbiAgaXNQcmltS2V5OiBib29sZWFuXG4pOiBJbmRleFNwZWMge1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAga2V5UGF0aCxcbiAgICB1bmlxdWUsXG4gICAgbXVsdGksXG4gICAgYXV0byxcbiAgICBjb21wb3VuZCxcbiAgICBzcmM6ICh1bmlxdWUgJiYgIWlzUHJpbUtleSA/ICcmJyA6ICcnKSArIChtdWx0aSA/ICcqJyA6ICcnKSArIChhdXRvID8gXCIrK1wiIDogXCJcIikgKyBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmFtZUZyb21LZXlQYXRoIChrZXlQYXRoPzogc3RyaW5nIHwgc3RyaW5nW10pOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID9cbiAgICBrZXlQYXRoIDpcbiAgICBrZXlQYXRoID8gKCdbJyArIFtdLmpvaW4uY2FsbChrZXlQYXRoLCAnKycpICsgJ10nKSA6IFwiXCI7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhTcGVjIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IGNyZWF0ZUluZGV4U3BlYyB9IGZyb20gJy4vaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBhcnJheVRvT2JqZWN0IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlU2NoZW1hIChcbiAgbmFtZTogc3RyaW5nLFxuICBwcmltS2V5OiBJbmRleFNwZWMsXG4gIGluZGV4ZXM6IEluZGV4U3BlY1tdXG4pOiBUYWJsZVNjaGVtYSB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcmltS2V5LFxuICAgIGluZGV4ZXMsXG4gICAgbWFwcGVkQ2xhc3M6IG51bGwsXG4gICAgaWR4QnlOYW1lOiBhcnJheVRvT2JqZWN0KGluZGV4ZXMsIGluZGV4ID0+IFtpbmRleC5uYW1lLCBpbmRleF0pXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgbWF4U3RyaW5nIH0gZnJvbSAnLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2FmYXJpTXVsdGlTdG9yZUZpeChzdG9yZU5hbWVzOiBzdHJpbmdbXSkge1xuICByZXR1cm4gc3RvcmVOYW1lcy5sZW5ndGggPT09IDEgPyBzdG9yZU5hbWVzWzBdIDogc3RvcmVOYW1lcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5hdGl2ZUdldERhdGFiYXNlTmFtZXNGbihpbmRleGVkREIpIHtcbiAgdmFyIGZuID0gaW5kZXhlZERCICYmIChpbmRleGVkREIuZ2V0RGF0YWJhc2VOYW1lcyB8fCBpbmRleGVkREIud2Via2l0R2V0RGF0YWJhc2VOYW1lcyk7XG4gIHJldHVybiBmbiAmJiBmbi5iaW5kKGluZGV4ZWREQik7XG59XG5cbmV4cG9ydCBsZXQgZ2V0TWF4S2V5ID0gKElkYktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2UpID0+IHtcbiAgdHJ5IHtcbiAgICBJZGJLZXlSYW5nZS5vbmx5KFtbXV0pO1xuICAgIGdldE1heEtleSA9ICgpID0+IFtbXV07XG4gICAgcmV0dXJuIFtbXV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBnZXRNYXhLZXkgPSAoKSA9PiBtYXhTdHJpbmc7XG4gICAgcmV0dXJuIG1heFN0cmluZztcbiAgfVxufVxuIiwgImltcG9ydCB7IGdldEJ5S2V5UGF0aCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlFeHRyYWN0b3IgKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSkgOiAoYTogYW55KSA9PiBhbnkge1xuICBpZiAoa2V5UGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaW5nbGVQYXRoS2V5RXh0cmFjdG9yKGtleVBhdGg6IHN0cmluZykge1xuICBjb25zdCBzcGxpdCA9IGtleVBhdGguc3BsaXQoJy4nKTtcbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBvYmogPT4gb2JqW2tleVBhdGhdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmogPT4gZ2V0QnlLZXlQYXRoKG9iaiwga2V5UGF0aCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlSW5kZXgsXG4gIERCQ29yZUtleVJhbmdlLFxuICBEQkNvcmVRdWVyeVJlc3BvbnNlLFxuICBEQkNvcmVSYW5nZVR5cGUsXG4gIERCQ29yZVNjaGVtYSxcbiAgREJDb3JlVGFibGVTY2hlbWEsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZXZlbnRSZWplY3RIYW5kbGVyLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgZ2V0S2V5RXh0cmFjdG9yIH0gZnJvbSAnLi9nZXQta2V5LWV4dHJhY3Rvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheWlmeTxUPihhcnJheUxpa2U6IHtsZW5ndGg6IG51bWJlciwgW2luZGV4OiBudW1iZXJdOiBUfSk6IFRbXSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKGFycmF5TGlrZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGljazxULFByb3AgZXh0ZW5kcyBrZXlvZiBUPihvYmo6IFQsIHByb3BzOiBQcm9wW10pOiBQaWNrPFQsIFByb3A+IHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgUGljazxULCBQcm9wPjtcbiAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmxldCBfaWRfY291bnRlciA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gIHJldHVybiBrZXlQYXRoID09IG51bGwgP1xuICAgIFwiOmlkXCIgOlxuICAgIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICBrZXlQYXRoIDpcbiAgICAgIGBbJHtrZXlQYXRoLmpvaW4oJysnKX1dYDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURCQ29yZSAoXG4gIGRiOiBJREJEYXRhYmFzZSxcbiAgSWRiS2V5UmFuZ2U6IHR5cGVvZiBJREJLZXlSYW5nZSxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IERCQ29yZVxue1xuICBmdW5jdGlvbiBleHRyYWN0U2NoZW1hKGRiOiBJREJEYXRhYmFzZSwgdHJhbnM6IElEQlRyYW5zYWN0aW9uKSA6IHtzY2hlbWE6IERCQ29yZVNjaGVtYSwgaGFzR2V0QWxsOiBib29sZWFufSB7XG4gICAgY29uc3QgdGFibGVzID0gYXJyYXlpZnkoZGIub2JqZWN0U3RvcmVOYW1lcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYToge1xuICAgICAgICBuYW1lOiBkYi5uYW1lLFxuICAgICAgICB0YWJsZXM6IHRhYmxlcy5tYXAodGFibGUgPT4gdHJhbnMub2JqZWN0U3RvcmUodGFibGUpKS5tYXAoc3RvcmUgPT4ge1xuICAgICAgICAgIGNvbnN0IHtrZXlQYXRoLCBhdXRvSW5jcmVtZW50fSA9IHN0b3JlO1xuICAgICAgICAgIGNvbnN0IGNvbXBvdW5kID0gaXNBcnJheShrZXlQYXRoKTtcbiAgICAgICAgICBjb25zdCBvdXRib3VuZCA9IGtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgICBjb25zdCBpbmRleEJ5S2V5UGF0aDoge1trZXlQYXRoQWxpYXM6IHN0cmluZ106IERCQ29yZUluZGV4fSA9IHt9O1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWU6IHN0b3JlLm5hbWUsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgIGlzUHJpbWFyeUtleTogdHJ1ZSxcbiAgICAgICAgICAgICAgb3V0Ym91bmQsXG4gICAgICAgICAgICAgIGNvbXBvdW5kLFxuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICBhdXRvSW5jcmVtZW50LFxuICAgICAgICAgICAgICB1bmlxdWU6IHRydWUsXG4gICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgfSBhcyBEQkNvcmVJbmRleCxcbiAgICAgICAgICAgIGluZGV4ZXM6IGFycmF5aWZ5KHN0b3JlLmluZGV4TmFtZXMpLm1hcChpbmRleE5hbWUgPT4gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKSlcbiAgICAgICAgICAgICAgLm1hcChpbmRleCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qge25hbWUsIHVuaXF1ZSwgbXVsdGlFbnRyeSwga2V5UGF0aH0gPSBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0OiBEQkNvcmVJbmRleCA9IHtcbiAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgICAgICB1bmlxdWUsXG4gICAgICAgICAgICAgICAgICBtdWx0aUVudHJ5LFxuICAgICAgICAgICAgICAgICAgZXh0cmFjdEtleTogZ2V0S2V5RXh0cmFjdG9yKGtleVBhdGgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pID0+IGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGluZGV4QnlLZXlQYXRoW1wiOmlkXCJdID0gcmVzdWx0LnByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKGtleVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIGhhc0dldEFsbDogdGFibGVzLmxlbmd0aCA+IDAgJiYgKCdnZXRBbGwnIGluIHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlc1swXSkpICYmXG4gICAgICAgICEodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNCkgLy8gQnVnIHdpdGggZ2V0QWxsKCkgb24gU2FmYXJpIHZlcjw2MDQuIFNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VJREJLZXlSYW5nZSAocmFuZ2U6IERCQ29yZUtleVJhbmdlKSA6IElEQktleVJhbmdlIHwgbnVsbCB7XG4gICAgaWYgKHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5BbnkpIHJldHVybiBudWxsO1xuICAgIGlmIChyYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuTmV2ZXIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb252ZXJ0IG5ldmVyIHR5cGUgdG8gSURCS2V5UmFuZ2VcIik7XG4gICAgY29uc3Qge2xvd2VyLCB1cHBlciwgbG93ZXJPcGVuLCB1cHBlck9wZW59ID0gcmFuZ2U7XG4gICAgY29uc3QgaWRiUmFuZ2UgPSBsb3dlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgIHVwcGVyID09PSB1bmRlZmluZWQgP1xuICAgICAgICBudWxsIDogLy9JREJLZXlSYW5nZS5sb3dlckJvdW5kKC1JbmZpbml0eSwgZmFsc2UpIDogLy8gQW55IHJhbmdlIChUT0RPOiBTaG91bGQgd2UgcmV0dXJuIG51bGwgaW5zdGVhZD8pXG4gICAgICAgIElkYktleVJhbmdlLnVwcGVyQm91bmQodXBwZXIsICEhdXBwZXJPcGVuKSA6IC8vIGJlbG93XG4gICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgSWRiS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgISFsb3dlck9wZW4pIDogLy8gYWJvdmVcbiAgICAgICAgSWRiS2V5UmFuZ2UuYm91bmQobG93ZXIsIHVwcGVyLCAhIWxvd2VyT3BlbiwgISF1cHBlck9wZW4pO1xuICAgIHJldHVybiBpZGJSYW5nZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hOiBEQkNvcmVUYWJsZVNjaGVtYSk6IERCQ29yZVRhYmxlIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZVNjaGVtYS5uYW1lO1xuXG4gICAgZnVuY3Rpb24gbXV0YXRlICh7dHJhbnMsIHR5cGUsIGtleXMsIHZhbHVlcywgcmFuZ2V9KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCBvdXRib3VuZCA9IHN0b3JlLmtleVBhdGggPT0gbnVsbDtcbiAgICAgICAgY29uc3QgaXNBZGRPclB1dCA9IHR5cGUgPT09IFwicHV0XCIgfHwgdHlwZSA9PT0gXCJhZGRcIjtcbiAgICAgICAgaWYgKCFpc0FkZE9yUHV0ICYmIHR5cGUgIT09ICdkZWxldGUnICYmIHR5cGUgIT09ICdkZWxldGVSYW5nZScpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChcIkludmFsaWQgb3BlcmF0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG5cbiAgICAgICAgY29uc3Qge2xlbmd0aH0gPSBrZXlzIHx8IHZhbHVlcyB8fCB7bGVuZ3RoOiAxfTsgLy8ga2V5cy5sZW5ndGggaWYga2V5cy4gdmFsdWVzLmxlbmd0aCBpZiB2YWx1ZXMuIDEgaWYgcmFuZ2UuXG4gICAgICAgIGlmIChrZXlzICYmIHZhbHVlcyAmJiBrZXlzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdpdmVuIGtleXMgYXJyYXkgbXVzdCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGdpdmVuIHZhbHVlcyBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICAgICAgICAvLyBObyBpdGVtcyB0byB3cml0ZS4gRG9uJ3QgZXZlbiBib3RoZXIhXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzOiAwLCBmYWlsdXJlczoge30sIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9KTtcblxuICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0O1xuICAgICAgICBjb25zdCByZXFzOiBJREJSZXF1ZXN0W10gPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgZmFpbHVyZXM6IHtbb3BlcmF0aW9uTnVtYmVyOiBudW1iZXJdOiBFcnJvcn0gPSBbXTtcbiAgICAgICAgbGV0IG51bUZhaWx1cmVzID0gMDtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gXG4gICAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgICAgKytudW1GYWlsdXJlcztcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgICAgICB9O1xuICBcbiAgICAgICAgaWYgKHR5cGUgPT09ICdkZWxldGVSYW5nZScpIHtcbiAgICAgICAgICAvLyBIZXJlIHRoZSBhcmd1bWVudCBpcyB0aGUgcmFuZ2VcbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLk5ldmVyKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe251bUZhaWx1cmVzLCBmYWlsdXJlcywgcmVzdWx0czogW10sIGxhc3RSZXN1bHQ6IHVuZGVmaW5lZH0pOyAvLyBEZWxldGluZyB0aGUgTmV2ZXIgcmFuZ2Ugc2hvdWxudCBkbyBhbnl0aGluZy5cbiAgICAgICAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLkFueSlcbiAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZS5jbGVhcigpKTsgLy8gRGVsZXRpbmcgdGhlIEFueSByYW5nZSBpcyBlcXVpdmFsZW50IHRvIHN0b3JlLmNsZWFyKClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuZGVsZXRlKG1ha2VJREJLZXlSYW5nZShyYW5nZSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBtYXR0ZXIgYWRkLCBwdXQgb3IgZGVsZXRlIC0gZmluZCBvdXQgYXJyYXlzIG9mIGZpcnN0IGFuZCBzZWNvbmQgYXJndW1lbnRzIHRvIGl0LlxuICAgICAgICAgIGNvbnN0IFthcmdzMSwgYXJnczJdID0gaXNBZGRPclB1dCA/XG4gICAgICAgICAgICBvdXRib3VuZCA/XG4gICAgICAgICAgICAgIFt2YWx1ZXMsIGtleXNdIDpcbiAgICAgICAgICAgICAgW3ZhbHVlcywgbnVsbF0gOlxuICAgICAgICAgICAgW2tleXMsIG51bGxdO1xuXG4gICAgICAgICAgaWYgKGlzQWRkT3JQdXQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICByZXFzLnB1c2gocmVxID0gKGFyZ3MyICYmIGFyZ3MyW2ldICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldLCBhcmdzMltpXSkgOlxuICAgICAgICAgICAgICAgIHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSkgYXMgSURCUmVxdWVzdCk7XG4gICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlW3R5cGVdKGFyZ3MxW2ldKSBhcyBJREJSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvbmUgPSBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgbGFzdFJlc3VsdCA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgcmVxcy5mb3JFYWNoKChyZXEsIGkpID0+IHJlcS5lcnJvciAhPSBudWxsICYmIChmYWlsdXJlc1tpXSA9IHJlcS5lcnJvcikpO1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgbnVtRmFpbHVyZXMsXG4gICAgICAgICAgICBmYWlsdXJlcyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHR5cGUgPT09IFwiZGVsZXRlXCIgPyBrZXlzIDogcmVxcy5tYXAocmVxID0+IHJlcS5yZXN1bHQpLFxuICAgICAgICAgICAgbGFzdFJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudCA9PiB7IC8vIHdyYXAoKSBub3QgbmVlZGVkLiBBbGwgcGF0aHMgY2FsbGluZyBvdXRzaWRlIHdpbGwgd3JhcCFcbiAgICAgICAgICBlcnJvckhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgIGRvbmUoZXZlbnQpO1xuICAgICAgICB9O1xuICBcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGRvbmU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gb3BlbkN1cnNvciAoe3RyYW5zLCB2YWx1ZXMsIHF1ZXJ5LCByZXZlcnNlLCB1bmlxdWV9OiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCk6IFByb21pc2U8REJDb3JlQ3Vyc29yPlxuICAgIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICBjb25zdCB7aW5kZXgsIHJhbmdlfSA9IHF1ZXJ5O1xuICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgLy8gc291cmNlXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/XG4gICAgICAgICAgc3RvcmUgOlxuICAgICAgICAgIHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmV2ZXJzZSA/XG4gICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgIFwicHJldnVuaXF1ZVwiIDpcbiAgICAgICAgICAgIFwicHJldlwiIDpcbiAgICAgICAgICB1bmlxdWUgP1xuICAgICAgICAgICAgXCJuZXh0dW5pcXVlXCIgOlxuICAgICAgICAgICAgXCJuZXh0XCI7XG4gICAgICAgIC8vIHJlcXVlc3RcbiAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgIHNvdXJjZS5vcGVuQ3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbikgOlxuICAgICAgICAgIHNvdXJjZS5vcGVuS2V5Q3Vyc29yKG1ha2VJREJLZXlSYW5nZShyYW5nZSksIGRpcmVjdGlvbik7XG4gICAgICAgICAgXG4gICAgICAgIC8vIGl0ZXJhdGlvblxuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiB7XG5cbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSByZXEucmVzdWx0IGFzIHVua25vd24gYXMgREJDb3JlQ3Vyc29yO1xuICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoY3Vyc29yIGFzIGFueSkuX19faWQgPSArK19pZF9jb3VudGVyO1xuICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgX2N1cnNvckNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBsZXQgX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgaWYgKF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkpIF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5LmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBfY3Vyc29yQWR2YW5jZSA9IGN1cnNvci5hZHZhbmNlLmJpbmQoY3Vyc29yKTtcbiAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkID0gKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0YXJ0ZWRcIik7fVxuICAgICAgICAgIGNvbnN0IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBub3Qgc3RvcHBlZFwiKTt9XG4gICAgICAgICAgKGN1cnNvciBhcyBhbnkpLnRyYW5zID0gdHJhbnM7XG4gICAgICAgICAgY3Vyc29yLnN0b3AgPSBjdXJzb3IuY29udGludWUgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gY3Vyc29yLmFkdmFuY2UgPSBkb1Rocm93Q3Vyc29ySXNOb3RTdGFydGVkO1xuICAgICAgICAgIGN1cnNvci5mYWlsID0gd3JhcChyZWplY3QpO1xuICAgICAgICAgIGN1cnNvci5uZXh0ID0gZnVuY3Rpb24gKHRoaXM6IERCQ29yZUN1cnNvcikge1xuICAgICAgICAgICAgLy8gbmV4dCgpIG11c3Qgd29yayB3aXRoIFwidGhpc1wiIHBvaW50ZXIgaW4gb3JkZXIgdG8gZnVuY3Rpb24gY29ycmVjdGx5IGZvciBQcm94eUN1cnNvcnMgKGRlcml2ZWQgb2JqZWN0cylcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlLWRlZmluZSBuZXh0KCkgb24gZWFjaCBjaGlsZC5cbiAgICAgICAgICAgIGxldCBnb3RPbmUgPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKCkgPT4gZ290T25lLS0gPyB0aGlzLmNvbnRpbnVlKCkgOiB0aGlzLnN0b3AoKSkudGhlbigoKSA9PiB0aGlzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGN1cnNvci5zdGFydCA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGN1cnNvclwiLCAoY3Vyc29yIGFzIGFueSkuX19faWQpO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlSXRlcmF0aW9uLCByZWplY3RJdGVyYXRpb24pID0+e1xuICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uID0gd3JhcChyZXNvbHZlSXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0SXRlcmF0aW9uKTtcbiAgICAgICAgICAgICAgY3Vyc29yLmZhaWwgPSByZWplY3RJdGVyYXRpb247XG4gICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gdmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJDdXJzb3Igc3RvcFwiLCBjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzU3RvcHBlZDtcbiAgICAgICAgICAgICAgICByZXNvbHZlSXRlcmF0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTm93IGNoYW5nZSByZXEub25zdWNjZXNzIHRvIGEgY2FsbGJhY2sgdGhhdCBkb2Vzbid0IGNhbGwgaW5pdEN1cnNvciBidXQganVzdCBvYnNlcnZlci5uZXh0KClcbiAgICAgICAgICAgIGNvbnN0IGd1YXJkZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlcS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiTmV4dCByZXN1bHRcIiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5mYWlsKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChjdXJzb3IgYXMgYW55KS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoKT0+e3Rocm93IG5ldyBFcnJvcihcIkN1cnNvciBiZWhpbmQgbGFzdCBlbnRyeVwiKTt9XG4gICAgICAgICAgICAgICAgY3Vyc29yLnN0b3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAvL2N1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuY29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZ3VhcmRlZENhbGxiYWNrO1xuICAgICAgICAgICAgICBndWFyZGVkQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlID0gX2N1cnNvckNvbnRpbnVlO1xuICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSA9IF9jdXJzb3JBZHZhbmNlO1xuICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0aW9uUHJvbWlzZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlc29sdmUoY3Vyc29yKTtcbiAgICAgICAgfSwgcmVqZWN0KTsgXG4gICAgICB9KTtcbiAgICB9XG4gIFxuICAgIGZ1bmN0aW9uIHF1ZXJ5IChoYXNHZXRBbGw6IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiAocmVxdWVzdDogREJDb3JlUXVlcnlSZXF1ZXN0KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxEQkNvcmVRdWVyeVJlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSA9IHdyYXAocmVzb2x2ZSk7XG4gICAgICAgICAgY29uc3Qge3RyYW5zLCB2YWx1ZXMsIGxpbWl0LCBxdWVyeX0gPSByZXF1ZXN0O1xuICAgICAgICAgIGNvbnN0IG5vbkluZmluaXRMaW1pdCA9IGxpbWl0ID09PSBJbmZpbml0eSA/IHVuZGVmaW5lZCA6IGxpbWl0O1xuICAgICAgICAgIGNvbnN0IHtpbmRleCwgcmFuZ2V9ID0gcXVlcnk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSAodHJhbnMgYXMgSURCVHJhbnNhY3Rpb24pLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gaW5kZXguaXNQcmltYXJ5S2V5ID8gc3RvcmUgOiBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgICBjb25zdCBpZGJLZXlSYW5nZSA9IG1ha2VJREJLZXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgaWYgKGxpbWl0ID09PSAwKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0OiBbXX0pO1xuICAgICAgICAgIGlmIChoYXNHZXRBbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyA/XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbChpZGJLZXlSYW5nZSwgbm9uSW5maW5pdExpbWl0KSA6XG4gICAgICAgICAgICAgICAgKHNvdXJjZSBhcyBhbnkpLmdldEFsbEtleXMoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSh7cmVzdWx0OiBldmVudC50YXJnZXQucmVzdWx0fSk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gdmFsdWVzIHx8ICEoJ29wZW5LZXlDdXJzb3InIGluIHNvdXJjZSkgP1xuICAgICAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihpZGJLZXlSYW5nZSkgOlxuICAgICAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihpZGJLZXlSYW5nZSlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdCBhcyBJREJDdXJzb3JXaXRoVmFsdWU7XG4gICAgICAgICAgICAgIGlmICghY3Vyc29yKSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlcyA/IGN1cnNvci52YWx1ZSA6IGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxpbWl0KSByZXR1cm4gcmVzb2x2ZSh7cmVzdWx0fSk7XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICBcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGFibGVOYW1lLFxuICAgICAgc2NoZW1hOiB0YWJsZVNjaGVtYSxcbiAgICAgIFxuICAgICAgbXV0YXRlLFxuXG4gICAgICBnZXRNYW55ICh7dHJhbnMsIGtleXN9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnlbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgICAgICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgICAgICAgbGV0IGNhbGxiYWNrQ291bnQgPSAwO1xuICAgICAgICAgIGxldCB2YWx1ZUNvdW50ID0gMDtcbiAgICAgICAgICBsZXQgcmVxOiBJREJSZXF1ZXN0ICYge19wb3M/OiBudW1iZXJ9O1xuICAgIFxuICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKChyZXN1bHRbcmVxLl9wb3NdID0gcmVxLnJlc3VsdCkgIT0gbnVsbCkgKyt2YWx1ZUNvdW50O1xuICAgICAgICAgICAgaWYgKCsrY2FsbGJhY2tDb3VudCA9PT0ga2V5Q291bnQpIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgIFxuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXEgPSBzdG9yZS5nZXQoa2V5c1tpXSk7XG4gICAgICAgICAgICAgIHJlcS5fcG9zID0gaTtcbiAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHN1Y2Nlc3NIYW5kbGVyO1xuICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgICAgKytrZXlDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleUNvdW50ID09PSAwKSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgZ2V0ICh7dHJhbnMsIGtleX0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwIChyZXNvbHZlKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICBjb25zdCByZXEgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gZXZlbnQgPT4gcmVzb2x2ZSgoZXZlbnQudGFyZ2V0IGFzIGFueSkucmVzdWx0KTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIHF1ZXJ5OiBxdWVyeShoYXNHZXRBbGwpLFxuICAgICAgXG4gICAgICBvcGVuQ3Vyc29yLFxuXG4gICAgICBjb3VudCAoe3F1ZXJ5LCB0cmFuc30pIHtcbiAgICAgICAgY29uc3Qge2luZGV4LCByYW5nZX0gPSBxdWVyeTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPG51bWJlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIGNvbnN0IHJlcSA9IGlkYktleVJhbmdlID8gc291cmNlLmNvdW50KGlkYktleVJhbmdlKSA6IHNvdXJjZS5jb3VudCgpO1xuICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHJlc29sdmUoKGV2LnRhcmdldCBhcyBJREJSZXF1ZXN0KS5yZXN1bHQpKTtcbiAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge3NjaGVtYSwgaGFzR2V0QWxsfSA9IGV4dHJhY3RTY2hlbWEoZGIsIHRtcFRyYW5zKTtcbiAgY29uc3QgdGFibGVzID0gc2NoZW1hLnRhYmxlcy5tYXAodGFibGVTY2hlbWEgPT4gY3JlYXRlRGJDb3JlVGFibGUodGFibGVTY2hlbWEpKTtcbiAgY29uc3QgdGFibGVNYXA6IHtbbmFtZTogc3RyaW5nXTogREJDb3JlVGFibGV9ID0ge307XG4gIHRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHRhYmxlTWFwW3RhYmxlLm5hbWVdID0gdGFibGUpO1xuICByZXR1cm4ge1xuICAgIHN0YWNrOiBcImRiY29yZVwiLFxuICAgIFxuICAgIHRyYW5zYWN0aW9uOiBkYi50cmFuc2FjdGlvbi5iaW5kKGRiKSxcblxuICAgIHRhYmxlKG5hbWU6IHN0cmluZykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGFibGVNYXBbbmFtZV07XG4gICAgICBpZiAoIXJlc3VsdCkgdGhyb3cgbmV3IEVycm9yKGBUYWJsZSAnJHtuYW1lfScgbm90IGZvdW5kYCk7XG4gICAgICByZXR1cm4gdGFibGVNYXBbbmFtZV07XG4gICAgfSxcblxuICAgIE1JTl9LRVk6IC1JbmZpbml0eSxcblxuICAgIE1BWF9LRVk6IGdldE1heEtleShJZGJLZXlSYW5nZSksXG5cbiAgICBzY2hlbWFcblxuICB9O1xufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgY3JlYXRlREJDb3JlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2RiY29yZS1pbmRleGVkZGInO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBEZXhpZURPTURlcGVuZGVuY2llcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1kb20tZGVwZW5kZW5jaWVzJztcbmltcG9ydCB7IERleGllU3RhY2tzLCBNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFjazxUU3RhY2sgZXh0ZW5kcyB7c3RhY2s6IHN0cmluZ30+KFxuICBzdGFja0ltcGw6IHtzdGFjazogc3RyaW5nfSxcbiAgbWlkZGxld2FyZXM6IE1pZGRsZXdhcmU8e3N0YWNrOiBzdHJpbmd9PltdKTogVFN0YWNrIHtcbiAgcmV0dXJuIG1pZGRsZXdhcmVzLnJlZHVjZSgoZG93biwge2NyZWF0ZX0pID0+ICh7Li4uZG93biwgLi4uY3JlYXRlKGRvd24pfSksIHN0YWNrSW1wbCkgYXMgVFN0YWNrO1xufSBcblxuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhcbiAgbWlkZGxld2FyZXM6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IE1pZGRsZXdhcmU8RGV4aWVTdGFja3NbU3RhY2tOYW1lXT5bXX0sXG4gIGlkYmRiOiBJREJEYXRhYmFzZSxcbiAge0lEQktleVJhbmdlLCBpbmRleGVkREJ9OiBEZXhpZURPTURlcGVuZGVuY2llcyxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKToge1tTdGFja05hbWUgaW4ga2V5b2YgRGV4aWVTdGFja3NdPzogRGV4aWVTdGFja3NbU3RhY2tOYW1lXX1cbntcbiAgY29uc3QgZGJjb3JlID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrPERCQ29yZT4oXG4gICAgY3JlYXRlREJDb3JlKGlkYmRiLCBJREJLZXlSYW5nZSwgdG1wVHJhbnMpLFxuICAgIG1pZGRsZXdhcmVzLmRiY29yZSk7XG4gIFxuICAvLyBUT0RPOiBDcmVhdGUgb3RoZXIgc3RhY2tzIHRoZSBzYW1lIHdheSBhcyBhYm92ZS4gVGhleSBtaWdodCBiZSBkZXBlbmRhbnQgb24gdGhlIHJlc3VsdFxuICAvLyBvZiBjcmVhdGluZyBkYmNvcmUgc3RhY2suXG5cbiAgcmV0dXJuIHtcbiAgICBkYmNvcmVcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyh7X25vdmlwOiBkYn06IERleGllLCB0bXBUcmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgaWRiZGIgPSB0bXBUcmFucy5kYjtcbiAgY29uc3Qgc3RhY2tzID0gY3JlYXRlTWlkZGxld2FyZVN0YWNrcyhkYi5fbWlkZGxld2FyZXMsIGlkYmRiLCBkYi5fZGVwcywgdG1wVHJhbnMpO1xuICBkYi5jb3JlID0gc3RhY2tzLmRiY29yZSE7XG4gIGRiLnRhYmxlcy5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS5uYW1lO1xuICAgIGlmIChkYi5jb3JlLnNjaGVtYS50YWJsZXMuc29tZSh0YmwgPT4gdGJsLm5hbWUgPT09IHRhYmxlTmFtZSkpIHtcbiAgICAgIHRhYmxlLmNvcmUgPSBkYi5jb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBpZiAoZGJbdGFibGVOYW1lXSBpbnN0YW5jZW9mIGRiLlRhYmxlKSB7XG4gICAgICAgICAgZGJbdGFibGVOYW1lXS5jb3JlID0gdGFibGUuY29yZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgRGJTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGItc2NoZW1hJztcbmltcG9ydCB7IF9nbG9iYWwgfSBmcm9tIFwiLi4vLi4vZ2xvYmFscy9nbG9iYWxcIjtcbmltcG9ydCB7IHNldFByb3AsIGtleXMsIHNsaWNlLCBpc0FycmF5LCBzaGFsbG93Q2xvbmUsIGlzQXN5bmNGdW5jdGlvbiwgZGVmaW5lUHJvcGVydHksIGdldFByb3BlcnR5RGVzY3JpcHRvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuaW1wb3J0IFByb21pc2UsIHsgUFNELCBuZXdTY29wZSwgTmF0aXZlUHJvbWlzZSwgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IEluZGV4U3BlYyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9pbmRleC1zcGVjJztcbmltcG9ydCB7IGhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcsIGlzSUVPckVkZ2UgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBzYWZhcmlNdWx0aVN0b3JlRml4IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBjcmVhdGVJbmRleFNwZWMsIG5hbWVGcm9tS2V5UGF0aCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyB9IGZyb20gJy4uL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEFwaU9uUGxhY2Uoe19ub3ZpcDogZGJ9OiBEZXhpZSwgb2JqczogT2JqZWN0W10sIHRhYmxlTmFtZXM6IHN0cmluZ1tdLCBkYnNjaGVtYTogRGJTY2hlbWEpIHtcbiAgdGFibGVOYW1lcy5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgY29uc3Qgc2NoZW1hID0gZGJzY2hlbWFbdGFibGVOYW1lXTtcbiAgICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICAgIGNvbnN0IHByb3BEZXNjID0gZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgdGFibGVOYW1lKTtcbiAgICAgIGlmICghcHJvcERlc2MgfHwgKFwidmFsdWVcIiBpbiBwcm9wRGVzYyAmJiBwcm9wRGVzYy52YWx1ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAvLyBFaXRoZXIgdGhlIHByb3AgaXMgbm90IGRlY2xhcmVkLCBvciBpdCBpcyBpbml0aWFsaXplZCB0byB1bmRlZmluZWQuXG4gICAgICAgIGlmIChvYmogPT09IGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSB8fCBvYmogaW5zdGFuY2VvZiBkYi5UcmFuc2FjdGlvbikge1xuICAgICAgICAgIC8vIG9iaiBpcyBhIFRyYW5zYWN0aW9uIHByb3RvdHlwZSAob3IgcHJvdG90eXBlIG9mIGEgc3ViY2xhc3MgdG8gVHJhbnNhY3Rpb24pXG4gICAgICAgICAgLy8gTWFrZSB0aGUgQVBJIGEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGlzLnRhYmxlKHRhYmxlTmFtZSlcbiAgICAgICAgICBzZXRQcm9wKG9iaiwgdGFibGVOYW1lLCB7XG4gICAgICAgICAgICBnZXQodGhpczogVHJhbnNhY3Rpb24pIHsgcmV0dXJuIHRoaXMudGFibGUodGFibGVOYW1lKTsgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZTogYW55KSB7XG4gICAgICAgICAgICAgIC8vIElzc3VlICMxMDM5XG4gICAgICAgICAgICAgIC8vIExldCBcInRoaXMuc2NoZW1hID0gZGJzY2hlbWE7XCIgYW5kIG90aGVyIHByb3BzIGluIHRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIHdvcmsgZXZlbiBpZiB0aGVyZSdzIGEgbmFtZSBjb2xsaXNpb24gd2l0aCB0aGUgdGFibGUgbmFtZS5cbiAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgdGFibGVOYW1lLCB7dmFsdWUsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IHRydWV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUYWJsZSB3aWxsIG5vdCBiZSBib3VuZCB0byBhIHRyYW5zYWN0aW9uICh3aWxsIHVzZSBEZXhpZS5jdXJyZW50VHJhbnNhY3Rpb24pXG4gICAgICAgICAgb2JqW3RhYmxlTmFtZV0gPSBuZXcgZGIuVGFibGUodGFibGVOYW1lLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVGFibGVzQXBpKHtfbm92aXA6IGRifTogRGV4aWUsIG9ianM6IE9iamVjdFtdKSB7XG4gIG9ianMuZm9yRWFjaChvYmogPT4ge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmpba2V5XSBpbnN0YW5jZW9mIGRiLlRhYmxlKSBkZWxldGUgb2JqW2tleV07XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvd2VyVmVyc2lvbkZpcnN0KGE6IFZlcnNpb24sIGI6IFZlcnNpb24pIHtcbiAgcmV0dXJuIGEuX2NmZy52ZXJzaW9uIC0gYi5fY2ZnLnZlcnNpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBydW5VcGdyYWRlcnMoZGI6IERleGllLCBvbGRWZXJzaW9uOiBudW1iZXIsIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24sIHJlamVjdCkge1xuICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gIGNvbnN0IHRyYW5zID0gZGIuX2NyZWF0ZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBkYi5fc3RvcmVOYW1lcywgZ2xvYmFsU2NoZW1hKTtcbiAgdHJhbnMuY3JlYXRlKGlkYlVwZ3JhZGVUcmFucyk7XG4gIHRyYW5zLl9jb21wbGV0aW9uLmNhdGNoKHJlamVjdCk7XG4gIGNvbnN0IHJlamVjdFRyYW5zYWN0aW9uID0gdHJhbnMuX3JlamVjdC5iaW5kKHRyYW5zKTtcbiAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gIG5ld1Njb3BlKCgpID0+IHtcbiAgICBQU0QudHJhbnMgPSB0cmFucztcbiAgICBQU0QudHJhbnNsZXNzID0gdHJhbnNsZXNzO1xuICAgIGlmIChvbGRWZXJzaW9uID09PSAwKSB7XG4gICAgICAvLyBDcmVhdGUgdGFibGVzOlxuICAgICAga2V5cyhnbG9iYWxTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0YWJsZU5hbWUsIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIGdsb2JhbFNjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgICAgfSk7XG4gICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICBQcm9taXNlLmZvbGxvdygoKSA9PiBkYi5vbi5wb3B1bGF0ZS5maXJlKHRyYW5zKSkuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZVxuICAgICAgdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhkYiwgb2xkVmVyc2lvbiwgdHJhbnMsIGlkYlVwZ3JhZGVUcmFucykuY2F0Y2gocmVqZWN0VHJhbnNhY3Rpb24pO1xuICB9KTtcbn1cblxuZXhwb3J0IHR5cGUgVXBncmFkZVF1ZXVlSXRlbSA9IChpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlVGFibGVzQW5kSW5kZXhlcyhcbiAge19ub3ZpcDogZGJ9OiBEZXhpZSxcbiAgb2xkVmVyc2lvbjogbnVtYmVyLFxuICB0cmFuczogVHJhbnNhY3Rpb24sXG4gIGlkYlVwZ3JhZGVUcmFuczogSURCVHJhbnNhY3Rpb24pXG57XG4gIC8vIFVwZ3JhZGUgdmVyc2lvbiB0byB2ZXJzaW9uLCBzdGVwLWJ5LXN0ZXAgZnJvbSBvbGRlc3QgdG8gbmV3ZXN0IHZlcnNpb24uXG4gIC8vIEVhY2ggdHJhbnNhY3Rpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgdGFibGUgc2V0IHRoYXQgd2FzIGN1cnJlbnQgaW4gdGhhdCB2ZXJzaW9uIChidXQgYWxzbyBub3QteWV0LWRlbGV0ZWQgdGFibGVzIGZyb20gaXRzIHByZXZpb3VzIHZlcnNpb24pXG4gIGNvbnN0IHF1ZXVlOiBVcGdyYWRlUXVldWVJdGVtW10gPSBbXTtcbiAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG4gIGxldCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gIGxldCBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSBmYWxzZTtcblxuICBjb25zdCB2ZXJzVG9SdW4gPSB2ZXJzaW9ucy5maWx0ZXIodiA9PiB2Ll9jZmcudmVyc2lvbiA+PSBvbGRWZXJzaW9uKTtcbiAgdmVyc1RvUnVuLmZvckVhY2godmVyc2lvbiA9PiB7XG4gICAgcXVldWUucHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBvbGRTY2hlbWEgPSBnbG9iYWxTY2hlbWE7XG4gICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgb2xkU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG5ld1NjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcblxuICAgICAgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gbmV3U2NoZW1hO1xuXG4gICAgICBjb25zdCBkaWZmID0gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWEsIG5ld1NjaGVtYSk7XG4gICAgICAvLyBBZGQgdGFibGVzICAgICAgICAgICBcbiAgICAgIGRpZmYuYWRkLmZvckVhY2godHVwbGUgPT4ge1xuICAgICAgICBjcmVhdGVUYWJsZShpZGJVcGdyYWRlVHJhbnMsIHR1cGxlWzBdLCB0dXBsZVsxXS5wcmltS2V5LCB0dXBsZVsxXS5pbmRleGVzKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQ2hhbmdlIHRhYmxlc1xuICAgICAgZGlmZi5jaGFuZ2UuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICBpZiAoY2hhbmdlLnJlY3JlYXRlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVXBncmFkZShcIk5vdCB5ZXQgc3VwcG9ydCBmb3IgY2hhbmdpbmcgcHJpbWFyeSBrZXlcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSBpZGJVcGdyYWRlVHJhbnMub2JqZWN0U3RvcmUoY2hhbmdlLm5hbWUpO1xuICAgICAgICAgIC8vIEFkZCBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmFkZC5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gICAgICAgICAgLy8gVXBkYXRlIGluZGV4ZXNcbiAgICAgICAgICBjaGFuZ2UuY2hhbmdlLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIHN0b3JlLmRlbGV0ZUluZGV4KGlkeC5uYW1lKTtcbiAgICAgICAgICAgIGFkZEluZGV4KHN0b3JlLCBpZHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIERlbGV0ZSBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmRlbC5mb3JFYWNoKGlkeE5hbWUgPT4gc3RvcmUuZGVsZXRlSW5kZXgoaWR4TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY29udGVudFVwZ3JhZGUgPSB2ZXJzaW9uLl9jZmcuY29udGVudFVwZ3JhZGU7XG5cbiAgICAgIGlmIChjb250ZW50VXBncmFkZSAmJiB2ZXJzaW9uLl9jZmcudmVyc2lvbiA+IG9sZFZlcnNpb24pIHtcbiAgICAgICAgLy8gVXBkYXRlIGRiLmNvcmUgd2l0aCBuZXcgdGFibGVzIGFuZCBpbmRleGVzOlxuICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIGlkYlVwZ3JhZGVUcmFucyk7XG4gICAgICAgIHRyYW5zLl9tZW1vaXplZFRhYmxlcyA9IHt9OyAvLyBJbnZhbGlkYXRlIG1lbW9pemF0aW9uIGFzIHRyYW5zYWN0aW9uIHNoYXBlIG1heSBjaGFuZ2UgYmV0d2VlbiB2ZXJzaW9ucy5cblxuICAgICAgICBhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gPSB0cnVlO1xuXG4gICAgICAgIC8vIEFkZCB0by1iZS1kZWxldGVkIHRhYmxlcyB0byBjb250ZW50VXBncmFkZSB0cmFuc2FjdGlvblxuICAgICAgICBsZXQgdXBncmFkZVNjaGVtYSA9IHNoYWxsb3dDbG9uZShuZXdTY2hlbWEpO1xuICAgICAgICBkaWZmLmRlbC5mb3JFYWNoKHRhYmxlID0+IHtcbiAgICAgICAgICB1cGdyYWRlU2NoZW1hW3RhYmxlXSA9IG9sZFNjaGVtYVt0YWJsZV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNhZmUgdG8gYWZmZWN0IFRyYW5zYWN0aW9uLnByb3RvdHlwZSBnbG9iYWxseSBpbiB0aGlzIG1vbWVudCxcbiAgICAgICAgLy8gYmVjYXVzZSB3aGVuIHRoaXMgY29kZSBydW5zLCB0aGVyZSBtYXkgbm90IGJlIGFueSBvdGhlciBjb2RlXG4gICAgICAgIC8vIHRoYXQgY2FuIGFjY2VzcyBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2UsIGVsc2UgdGhhbiB0aGlzIHBhcnRpY3VsYXJcbiAgICAgICAgLy8gdXBncmFkZXIgZnVuY3Rpb24uXG4gICAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwga2V5cyh1cGdyYWRlU2NoZW1hKSwgdXBncmFkZVNjaGVtYSk7XG4gICAgICAgIHRyYW5zLnNjaGVtYSA9IHVwZ3JhZGVTY2hlbWE7XG5cbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgbmF0aXZlIGFzeW5jIGF3YWl0LlxuICAgICAgICBjb25zdCBjb250ZW50VXBncmFkZUlzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24oY29udGVudFVwZ3JhZGUpO1xuICAgICAgICBpZiAoY29udGVudFVwZ3JhZGVJc0FzeW5jKSB7XG4gICAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IHJldHVyblZhbHVlOiBhbnk7XG4gICAgICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IFByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgICAgICAvLyBGaW5hbGx5LCBjYWxsIHRoZSBzY29wZSBmdW5jdGlvbiB3aXRoIG91ciB0YWJsZSBhbmQgdHJhbnNhY3Rpb24gYXJndW1lbnRzLlxuICAgICAgICAgIHJldHVyblZhbHVlID0gY29udGVudFVwZ3JhZGUodHJhbnMpO1xuICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgICAgICAvLyBjb250ZW50VXBncmFkZSBpcyBhIG5hdGl2ZSBhc3luYyBmdW5jdGlvbiAtIHdlIGtub3cgZm9yIHN1cmUgcmV0dXJuVmFsdWUgaXMgbmF0aXZlIHByb21pc2UuXG4gICAgICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCk9PnJldHVyblZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcXVldWUucHVzaChpZGJ0cmFucyA9PiB7XG4gICAgICBpZiAoIWFueUNvbnRlbnRVcGdyYWRlckhhc1J1biB8fCAhaGFzSUVEZWxldGVPYmplY3RTdG9yZUJ1ZykgeyAvLyBEb250IGRlbGV0ZSBvbGQgdGFibGVzIGlmIGllQnVnIGlzIHByZXNlbnQgYW5kIGEgY29udGVudCB1cGdyYWRlciBoYXMgcnVuLiBMZXQgdGFibGVzIGJlIGxlZnQgaW4gREIgc28gZmFyLiBUaGlzIG5lZWRzIHRvIGJlIHRha2VuIGNhcmUgb2YuXG4gICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHZlcnNpb24uX2NmZy5kYnNjaGVtYTtcbiAgICAgICAgLy8gRGVsZXRlIG9sZCB0YWJsZXNcbiAgICAgICAgZGVsZXRlUmVtb3ZlZFRhYmxlcyhuZXdTY2hlbWEsIGlkYnRyYW5zKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgdGhlIGZpbmFsIEFQSVxuICAgICAgcmVtb3ZlVGFibGVzQXBpKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSwgZGIuX3N0b3JlTmFtZXMsIGRiLl9kYlNjaGVtYSk7XG4gICAgICB0cmFucy5zY2hlbWEgPSBkYi5fZGJTY2hlbWE7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIE5vdywgY3JlYXRlIGEgcXVldWUgZXhlY3V0aW9uIGVuZ2luZVxuICBmdW5jdGlvbiBydW5RdWV1ZSgpIHtcbiAgICByZXR1cm4gcXVldWUubGVuZ3RoID8gUHJvbWlzZS5yZXNvbHZlKHF1ZXVlLnNoaWZ0KCkodHJhbnMuaWRidHJhbnMpKS50aGVuKHJ1blF1ZXVlKSA6XG4gICAgICBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJldHVybiBydW5RdWV1ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGNyZWF0ZU1pc3NpbmdUYWJsZXMoZ2xvYmFsU2NoZW1hLCBpZGJVcGdyYWRlVHJhbnMpOyAvLyBBdCBsYXN0LCBtYWtlIHN1cmUgdG8gY3JlYXRlIGFueSBtaXNzaW5nIHRhYmxlcy4gKE5lZWRlZCBieSBhZGRvbnMgdGhhdCBhZGQgc3RvcmVzIHRvIERCIHdpdGhvdXQgc3BlY2lmeWluZyB2ZXJzaW9uKVxuICB9KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFEaWZmIHtcbiAgZGVsOiBzdHJpbmdbXSxcbiAgYWRkOiBbc3RyaW5nLCBUYWJsZVNjaGVtYV1bXTtcbiAgY2hhbmdlOiBUYWJsZVNjaGVtYURpZmZbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNjaGVtYURpZmYge1xuICBuYW1lOiBzdHJpbmcsXG4gIHJlY3JlYXRlOiBib29sZWFuLFxuICBkZWw6IHN0cmluZ1tdLFxuICBhZGQ6IEluZGV4U3BlY1tdLFxuICBjaGFuZ2U6IEluZGV4U3BlY1tdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFEaWZmKG9sZFNjaGVtYTogRGJTY2hlbWEsIG5ld1NjaGVtYTogRGJTY2hlbWEpOiBTY2hlbWFEaWZmIHtcbiAgY29uc3QgZGlmZjogU2NoZW1hRGlmZiA9IHtcbiAgICBkZWw6IFtdLCAvLyBBcnJheSBvZiB0YWJsZSBuYW1lc1xuICAgIGFkZDogW10sIC8vIEFycmF5IG9mIFt0YWJsZU5hbWUsIG5ld0RlZmluaXRpb25dXG4gICAgY2hhbmdlOiBbXSAvLyBBcnJheSBvZiB7bmFtZTogdGFibGVOYW1lLCByZWNyZWF0ZTogbmV3RGVmaW5pdGlvbiwgZGVsOiBkZWxJbmRleE5hbWVzLCBhZGQ6IG5ld0luZGV4RGVmcywgY2hhbmdlOiBjaGFuZ2VkSW5kZXhEZWZzfVxuICB9O1xuICBsZXQgdGFibGU6IHN0cmluZztcbiAgZm9yICh0YWJsZSBpbiBvbGRTY2hlbWEpIHtcbiAgICBpZiAoIW5ld1NjaGVtYVt0YWJsZV0pIGRpZmYuZGVsLnB1c2godGFibGUpO1xuICB9XG4gIGZvciAodGFibGUgaW4gbmV3U2NoZW1hKSB7XG4gICAgY29uc3Qgb2xkRGVmID0gb2xkU2NoZW1hW3RhYmxlXSxcbiAgICAgIG5ld0RlZiA9IG5ld1NjaGVtYVt0YWJsZV07XG4gICAgaWYgKCFvbGREZWYpIHtcbiAgICAgIGRpZmYuYWRkLnB1c2goW3RhYmxlLCBuZXdEZWZdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhbmdlID0ge1xuICAgICAgICBuYW1lOiB0YWJsZSxcbiAgICAgICAgZGVmOiBuZXdEZWYsXG4gICAgICAgIHJlY3JlYXRlOiBmYWxzZSxcbiAgICAgICAgZGVsOiBbXSxcbiAgICAgICAgYWRkOiBbXSxcbiAgICAgICAgY2hhbmdlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmIChcbiAgICAgICAgICAoXG4gICAgICAgICAgICAgLy8gY29tcGFyZSBrZXlQYXRocyBubyBtYXR0ZXIgaWYgc3RyaW5nIG9yIHN0cmluZ1tdXG4gICAgICAgICAgICAgLy8gY29tcGFyZSBmYWxzeSBrZXlwYXRocyBzYW1lIG5vIG1hdHRlciBpZiB0aGV5IGFyZSBudWxsIG9yIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgICcnKyhvbGREZWYucHJpbUtleS5rZXlQYXRofHwnJylcbiAgICAgICAgICApICE9PSAoXG4gICAgICAgICAgICAnJysobmV3RGVmLnByaW1LZXkua2V5UGF0aHx8JycpXG4gICAgICAgICAgKSB8fFxuICAgICAgICAgICAgLy8gQ29tcGFyZSB0aGUgYXV0b0luY3JlbWVudCBmbGFnIGFsc29cbiAgICAgICAgICAob2xkRGVmLnByaW1LZXkuYXV0byAhPT0gbmV3RGVmLnByaW1LZXkuYXV0byAmJiAhaXNJRU9yRWRnZSkpIC8vIElFIGhhcyBidWcgcmVhZGluZyBhdXRvSW5jcmVtZW50IHByb3AuXG4gICAgICB7XG4gICAgICAgIC8vIFByaW1hcnkga2V5IGhhcyBjaGFuZ2VkLiBSZW1vdmUgYW5kIHJlLWFkZCB0YWJsZS5cbiAgICAgICAgY2hhbmdlLnJlY3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2FtZSBwcmltYXJ5IGtleS4gSnVzdCBmaW5kIG91dCB3aGF0IGRpZmZlcnM6XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ZXMgPSBvbGREZWYuaWR4QnlOYW1lO1xuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbmV3RGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgbGV0IGlkeE5hbWU6IHN0cmluZztcbiAgICAgICAgZm9yIChpZHhOYW1lIGluIG9sZEluZGV4ZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld0luZGV4ZXNbaWR4TmFtZV0pIGNoYW5nZS5kZWwucHVzaChpZHhOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGlkeE5hbWUgaW4gbmV3SW5kZXhlcykge1xuICAgICAgICAgIGNvbnN0IG9sZElkeCA9IG9sZEluZGV4ZXNbaWR4TmFtZV0sXG4gICAgICAgICAgICBuZXdJZHggPSBuZXdJbmRleGVzW2lkeE5hbWVdO1xuICAgICAgICAgIGlmICghb2xkSWR4KSBjaGFuZ2UuYWRkLnB1c2gobmV3SWR4KTtcbiAgICAgICAgICBlbHNlIGlmIChvbGRJZHguc3JjICE9PSBuZXdJZHguc3JjKSBjaGFuZ2UuY2hhbmdlLnB1c2gobmV3SWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlLmRlbC5sZW5ndGggPiAwIHx8IGNoYW5nZS5hZGQubGVuZ3RoID4gMCB8fCBjaGFuZ2UuY2hhbmdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkaWZmLmNoYW5nZS5wdXNoKGNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJsZShcbiAgaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uLFxuICB0YWJsZU5hbWU6IHN0cmluZyxcbiAgcHJpbUtleTogSW5kZXhTcGVjLFxuICBpbmRleGVzOiBJbmRleFNwZWNbXVxuKSB7XG4gIGNvbnN0IHN0b3JlID0gaWRidHJhbnMuZGIuY3JlYXRlT2JqZWN0U3RvcmUoXG4gICAgdGFibGVOYW1lLFxuICAgIHByaW1LZXkua2V5UGF0aCA/XG4gICAgICB7IGtleVBhdGg6IHByaW1LZXkua2V5UGF0aCwgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH0gOlxuICAgICAgeyBhdXRvSW5jcmVtZW50OiBwcmltS2V5LmF1dG8gfVxuICApO1xuICBpbmRleGVzLmZvckVhY2goaWR4ID0+IGFkZEluZGV4KHN0b3JlLCBpZHgpKTtcbiAgcmV0dXJuIHN0b3JlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlzc2luZ1RhYmxlcyhuZXdTY2hlbWE6IERiU2NoZW1hLCBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAga2V5cyhuZXdTY2hlbWEpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICBpZiAoIWlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGFibGVOYW1lKSkge1xuICAgICAgY3JlYXRlVGFibGUoaWRidHJhbnMsIHRhYmxlTmFtZSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0ucHJpbUtleSwgbmV3U2NoZW1hW3RhYmxlTmFtZV0uaW5kZXhlcyk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hOiBEYlNjaGVtYSwgaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uKSB7XG4gIFtdLnNsaWNlLmNhbGwoaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcykuZm9yRWFjaChzdG9yZU5hbWUgPT5cbiAgICBuZXdTY2hlbWFbc3RvcmVOYW1lXSA9PSBudWxsICYmIGlkYnRyYW5zLmRiLmRlbGV0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkSW5kZXgoc3RvcmU6IElEQk9iamVjdFN0b3JlLCBpZHg6IEluZGV4U3BlYykge1xuICBzdG9yZS5jcmVhdGVJbmRleChpZHgubmFtZSwgaWR4LmtleVBhdGgsIHsgdW5pcXVlOiBpZHgudW5pcXVlLCBtdWx0aUVudHJ5OiBpZHgubXVsdGkgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkR2xvYmFsU2NoZW1hKFxuICBkYjogRGV4aWUsXG4gIGlkYmRiOiBJREJEYXRhYmFzZSxcbiAgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uXG4pIHtcbiAgY29uc3QgZ2xvYmFsU2NoZW1hID0ge307XG4gIGNvbnN0IGRiU3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICBkYlN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdG1wVHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBsZXQga2V5UGF0aCA9IHN0b3JlLmtleVBhdGg7XG4gICAgY29uc3QgcHJpbUtleSA9IGNyZWF0ZUluZGV4U3BlYyhcbiAgICAgIG5hbWVGcm9tS2V5UGF0aChrZXlQYXRoKSxcbiAgICAgIGtleVBhdGggfHwgXCJcIixcbiAgICAgIGZhbHNlLFxuICAgICAgZmFsc2UsXG4gICAgICAhIXN0b3JlLmF1dG9JbmNyZW1lbnQsXG4gICAgICBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc3QgaW5kZXhlczogSW5kZXhTcGVjW10gPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGlkYmluZGV4ID0gc3RvcmUuaW5kZXgoc3RvcmUuaW5kZXhOYW1lc1tqXSk7XG4gICAgICBrZXlQYXRoID0gaWRiaW5kZXgua2V5UGF0aDtcbiAgICAgIHZhciBpbmRleCA9IGNyZWF0ZUluZGV4U3BlYyhcbiAgICAgICAgaWRiaW5kZXgubmFtZSxcbiAgICAgICAga2V5UGF0aCxcbiAgICAgICAgISFpZGJpbmRleC51bmlxdWUsXG4gICAgICAgICEhaWRiaW5kZXgubXVsdGlFbnRyeSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGtleVBhdGggJiYgdHlwZW9mIGtleVBhdGggIT09IFwic3RyaW5nXCIsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gICAgZ2xvYmFsU2NoZW1hW3N0b3JlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYShzdG9yZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICB9KTtcbiAgcmV0dXJuIGdsb2JhbFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRHbG9iYWxTY2hlbWEoe19ub3ZpcDogZGJ9OiBEZXhpZSwgaWRiZGI6IElEQkRhdGFiYXNlLCB0bXBUcmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgZGIudmVybm8gPSBpZGJkYi52ZXJzaW9uIC8gMTA7XG4gIGNvbnN0IGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IGJ1aWxkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICBkYi5fc3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMsIDApO1xuICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlc10sIGtleXMoZ2xvYmFsU2NoZW1hKSwgZ2xvYmFsU2NoZW1hKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUluc3RhbGxlZFNjaGVtYShkYjogRGV4aWUsIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbik6IGJvb2xlYW4ge1xuICBjb25zdCBpbnN0YWxsZWRTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgZGIuaWRiZGIsIHRtcFRyYW5zKTtcbiAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYoaW5zdGFsbGVkU2NoZW1hLCBkYi5fZGJTY2hlbWEpO1xuICByZXR1cm4gIShkaWZmLmFkZC5sZW5ndGggfHwgZGlmZi5jaGFuZ2Uuc29tZShjaCA9PiBjaC5hZGQubGVuZ3RoIHx8IGNoLmNoYW5nZS5sZW5ndGgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKHtfbm92aXA6IGRifTogRGV4aWUsIHNjaGVtYTogRGJTY2hlbWEsIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICAvLyBJc3N1ZSAjMzAgUHJvYmxlbSB3aXRoIGV4aXN0aW5nIGRiIC0gYWRqdXN0IHRvIGV4aXN0aW5nIGluZGV4IG5hbWVzIHdoZW4gbWlncmF0aW5nIGZyb20gbm9uLWRleGllIGRiXG4gIGNvbnN0IHN0b3JlTmFtZXMgPSBpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RvcmVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHN0b3JlTmFtZSA9IHN0b3JlTmFtZXNbaV07XG4gICAgY29uc3Qgc3RvcmUgPSBpZGJ0cmFucy5vYmplY3RTdG9yZShzdG9yZU5hbWUpO1xuICAgIGRiLl9oYXNHZXRBbGwgPSAnZ2V0QWxsJyBpbiBzdG9yZTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RvcmUuaW5kZXhOYW1lcy5sZW5ndGg7ICsraikge1xuICAgICAgY29uc3QgaW5kZXhOYW1lID0gc3RvcmUuaW5kZXhOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGtleVBhdGggPSBzdG9yZS5pbmRleChpbmRleE5hbWUpLmtleVBhdGg7XG4gICAgICBjb25zdCBkZXhpZU5hbWUgPSB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgPyBrZXlQYXRoIDogXCJbXCIgKyBzbGljZShrZXlQYXRoKS5qb2luKCcrJykgKyBcIl1cIjtcbiAgICAgIGlmIChzY2hlbWFbc3RvcmVOYW1lXSkge1xuICAgICAgICBjb25zdCBpbmRleFNwZWMgPSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgaWYgKGluZGV4U3BlYykge1xuICAgICAgICAgIGluZGV4U3BlYy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbZGV4aWVOYW1lXTtcbiAgICAgICAgICBzY2hlbWFbc3RvcmVOYW1lXS5pZHhCeU5hbWVbaW5kZXhOYW1lXSA9IGluZGV4U3BlYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1ZyB3aXRoIGdldEFsbCgpIG9uIFNhZmFyaSB2ZXI8NjA0IG9uIFdvcmtlcnMgb25seSwgc2VlIGRpc2N1c3Npb24gZm9sbG93aW5nIFBSICM1NzlcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAhLyhDaHJvbWVcXC98RWRnZVxcLykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmIF9nbG9iYWwgaW5zdGFuY2VvZiBfZ2xvYmFsLldvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgW10uY29uY2F0KG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1NhZmFyaVxcLyhcXGQqKS8pKVsxXSA8IDYwNClcbiAge1xuICAgIGRiLl9oYXNHZXRBbGwgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbmRleFN5bnRheChwcmltS2V5QW5kSW5kZXhlczogc3RyaW5nKTogSW5kZXhTcGVjW10ge1xuICByZXR1cm4gcHJpbUtleUFuZEluZGV4ZXMuc3BsaXQoJywnKS5tYXAoKGluZGV4LCBpbmRleE51bSkgPT4ge1xuICAgIGluZGV4ID0gaW5kZXgudHJpbSgpO1xuICAgIGNvbnN0IG5hbWUgPSBpbmRleC5yZXBsYWNlKC8oWyYqXXxcXCtcXCspL2csIFwiXCIpOyAvLyBSZW1vdmUgXCImXCIsIFwiKytcIiBhbmQgXCIqXCJcbiAgICAvLyBMZXQga2V5UGF0aCBvZiBcIlthK2JdXCIgYmUgW1wiYVwiLFwiYlwiXTpcbiAgICBjb25zdCBrZXlQYXRoID0gL15cXFsvLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC9eXFxbKC4qKVxcXSQvKVsxXS5zcGxpdCgnKycpIDogbmFtZTtcblxuICAgIHJldHVybiBjcmVhdGVJbmRleFNwZWMoXG4gICAgICBuYW1lLFxuICAgICAga2V5UGF0aCB8fCBudWxsLFxuICAgICAgL1xcJi8udGVzdChpbmRleCksXG4gICAgICAvXFwqLy50ZXN0KGluZGV4KSxcbiAgICAgIC9cXCtcXCsvLnRlc3QoaW5kZXgpLFxuICAgICAgaXNBcnJheShrZXlQYXRoKSxcbiAgICAgIGluZGV4TnVtID09PSAwXG4gICAgKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHsgVmVyc2lvbiBhcyBJVmVyc2lvbiB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy92ZXJzaW9uJztcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgeyBleHRlbmQsIGtleXMgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IHJlbW92ZVRhYmxlc0FwaSwgc2V0QXBpT25QbGFjZSwgcGFyc2VJbmRleFN5bnRheCB9IGZyb20gJy4vc2NoZW1hLWhlbHBlcnMnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IG5vcCwgcHJvbWlzYWJsZUNoYWluIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5cbi8qKiBjbGFzcyBWZXJzaW9uXG4gKlxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9WZXJzaW9uL1ZlcnNpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFZlcnNpb24gaW1wbGVtZW50cyBJVmVyc2lvbiB7XG4gIGRiOiBEZXhpZTtcbiAgX2NmZzoge1xuICAgIHZlcnNpb246IG51bWJlcixcbiAgICBzdG9yZXNTb3VyY2U6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbCB9LFxuICAgIGRic2NoZW1hOiBEYlNjaGVtYSxcbiAgICB0YWJsZXM6IHt9LFxuICAgIGNvbnRlbnRVcGdyYWRlOiBGdW5jdGlvbiB8IG51bGxcbiAgfVxuXG4gIF9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzOiB7IFt0YWJsZU5hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bGwgfSwgb3V0U2NoZW1hOiBEYlNjaGVtYSk6IGFueSB7XG4gICAga2V5cyhzdG9yZXMpLmZvckVhY2godGFibGVOYW1lID0+IHtcbiAgICAgIGlmIChzdG9yZXNbdGFibGVOYW1lXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpbmRleGVzID0gcGFyc2VJbmRleFN5bnRheChzdG9yZXNbdGFibGVOYW1lXSk7XG4gICAgICAgICAgdmFyIHByaW1LZXkgPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKHByaW1LZXkubXVsdGkpIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIlByaW1hcnkga2V5IGNhbm5vdCBiZSBtdWx0aS12YWx1ZWRcIik7XG4gICAgICAgICAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICAgIGlmIChpZHguYXV0bykgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiT25seSBwcmltYXJ5IGtleSBjYW4gYmUgbWFya2VkIGFzIGF1dG9JbmNyZW1lbnQgKCsrKVwiKTtcbiAgICAgICAgICAgICAgaWYgKCFpZHgua2V5UGF0aCkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU2NoZW1hKFwiSW5kZXggbXVzdCBoYXZlIGEgbmFtZSBhbmQgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZ1wiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvdXRTY2hlbWFbdGFibGVOYW1lXSA9IGNyZWF0ZVRhYmxlU2NoZW1hKHRhYmxlTmFtZSwgcHJpbUtleSwgaW5kZXhlcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzdG9yZXMoc3RvcmVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bGw7IH0pOiBJVmVyc2lvbiB7XG4gICAgY29uc3QgZGIgPSB0aGlzLmRiO1xuICAgIHRoaXMuX2NmZy5zdG9yZXNTb3VyY2UgPSB0aGlzLl9jZmcuc3RvcmVzU291cmNlID9cbiAgICAgIGV4dGVuZCh0aGlzLl9jZmcuc3RvcmVzU291cmNlLCBzdG9yZXMpIDpcbiAgICAgIHN0b3JlcztcbiAgICBjb25zdCB2ZXJzaW9ucyA9IGRiLl92ZXJzaW9ucztcblxuICAgIC8vIERlcml2ZSBzdG9yZXMgZnJvbSBlYXJsaWVyIHZlcnNpb25zIGlmIHRoZXkgYXJlIG5vdCBleHBsaWNpdGVseSBzcGVjaWZpZWQgYXMgbnVsbCBvciBhIG5ldyBzeW50YXguXG4gICAgY29uc3Qgc3RvcmVzU3BlYzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0gPSB7fTtcbiAgICBsZXQgZGJzY2hlbWEgPSB7fTtcbiAgICB2ZXJzaW9ucy5mb3JFYWNoKHZlcnNpb24gPT4geyAvLyAndmVyc2lvbnMnIGlzIGFsd2F5cyBzb3J0ZWQgYnkgbG93ZXN0IHZlcnNpb24gZmlyc3QuXG4gICAgICBleHRlbmQoc3RvcmVzU3BlYywgdmVyc2lvbi5fY2ZnLnN0b3Jlc1NvdXJjZSk7XG4gICAgICBkYnNjaGVtYSA9ICh2ZXJzaW9uLl9jZmcuZGJzY2hlbWEgPSB7fSk7XG4gICAgICB2ZXJzaW9uLl9wYXJzZVN0b3Jlc1NwZWMoc3RvcmVzU3BlYywgZGJzY2hlbWEpO1xuICAgIH0pO1xuICAgIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IHNjaGVtYSB0byB0aGlzIHZlcnNpb25cbiAgICBkYi5fZGJTY2hlbWEgPSBkYnNjaGVtYTtcbiAgICAvLyBVcGRhdGUgQVBJc1xuICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICBzZXRBcGlPblBsYWNlKGRiLCBbZGIuX2FsbFRhYmxlcywgZGIsIGRiLlRyYW5zYWN0aW9uLnByb3RvdHlwZSwgdGhpcy5fY2ZnLnRhYmxlc10sIGtleXMoZGJzY2hlbWEpLCBkYnNjaGVtYSk7XG4gICAgZGIuX3N0b3JlTmFtZXMgPSBrZXlzKGRic2NoZW1hKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHVwZ3JhZGUodXBncmFkZUZ1bmN0aW9uOiAodHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBQcm9taXNlTGlrZTxhbnk+IHwgdm9pZCk6IFZlcnNpb24ge1xuICAgIHRoaXMuX2NmZy5jb250ZW50VXBncmFkZSA9IHByb21pc2FibGVDaGFpbih0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgfHwgbm9wLCB1cGdyYWRlRnVuY3Rpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBtYWtlQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9tYWtlLWNsYXNzLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25Db25zdHJ1Y3RvciB7XG4gIG5ldyh2ZXJzaW9uTnVtYmVyOiBudW1iZXIpOiBWZXJzaW9uO1xuICBwcm90b3R5cGU6IFZlcnNpb247XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBWZXJzaW9uIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VmVyc2lvbkNvbnN0cnVjdG9yPihcbiAgICBWZXJzaW9uLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIFZlcnNpb24odGhpczogVmVyc2lvbiwgdmVyc2lvbk51bWJlcjogbnVtYmVyKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl9jZmcgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb25OdW1iZXIsXG4gICAgICAgIHN0b3Jlc1NvdXJjZTogbnVsbCxcbiAgICAgICAgZGJzY2hlbWE6IHt9LFxuICAgICAgICB0YWJsZXM6IHt9LFxuICAgICAgICBjb250ZW50VXBncmFkZTogbnVsbFxuICAgICAgfTtcbiAgICB9KTtcblxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSBcIi4uL2NsYXNzZXMvZGV4aWUvZGV4aWVcIjtcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy90YWJsZVwiO1xuaW1wb3J0IHsgREJOQU1FU19EQiB9IGZyb20gXCIuLi9nbG9iYWxzL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RleGllLWRvbS1kZXBlbmRlbmNpZXNcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zXCI7XG5cbnR5cGUgSURCS2V5TmFtZXNWYXIgPSB0eXBlb2YgSURCS2V5UmFuZ2U7XG5cbmZ1bmN0aW9uIGdldERiTmFtZXNUYWJsZShpbmRleGVkREI6IElEQkZhY3RvcnksIElEQktleVJhbmdlOiBJREJLZXlOYW1lc1Zhcikge1xuICBsZXQgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXTtcbiAgaWYgKCFkYk5hbWVzREIpIHtcbiAgICBkYk5hbWVzREIgPSBpbmRleGVkREJbXCJfZGJOYW1lc0RCXCJdID0gbmV3IERleGllKERCTkFNRVNfREIsIHtcbiAgICAgIGFkZG9uczogW10sXG4gICAgICBpbmRleGVkREIsXG4gICAgICBJREJLZXlSYW5nZSxcbiAgICB9KTtcbiAgICBkYk5hbWVzREIudmVyc2lvbigxKS5zdG9yZXMoeyBkYm5hbWVzOiBcIm5hbWVcIiB9KTtcbiAgfVxuICByZXR1cm4gZGJOYW1lc0RCLnRhYmxlKFwiZGJuYW1lc1wiKSBhcyBUYWJsZTx7IG5hbWU6IHN0cmluZyB9LCBzdHJpbmc+O1xufVxuXG5mdW5jdGlvbiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCOiBJREJGYWN0b3J5KSB7XG4gIHJldHVybiBpbmRleGVkREIgJiYgdHlwZW9mIGluZGV4ZWREQi5kYXRhYmFzZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFiYXNlTmFtZXMoe1xuICBpbmRleGVkREIsXG4gIElEQktleVJhbmdlLFxufTogRGV4aWVET01EZXBlbmRlbmNpZXMpIHtcbiAgcmV0dXJuIGhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpXG4gICAgPyBQcm9taXNlLnJlc29sdmUoaW5kZXhlZERCLmRhdGFiYXNlcygpKS50aGVuKChpbmZvcykgPT5cbiAgICAgICAgaW5mb3NcbiAgICAgICAgICAvLyBTZWxlY3QgbmFtZSBwcm9wIG9mIGluZm9zOlxuICAgICAgICAgIC5tYXAoKGluZm8pID0+IGluZm8ubmFtZSlcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IERCTkFNRVNfREIgYXMgcHJldmlvdXMgRGV4aWUgb3IgYnJvd3NlciB2ZXJzaW9uIHdvdWxkIG5vdCBoYXZlIGluY2x1ZGVkIGl0IGluIHRoZSByZXN1bHQuXG4gICAgICAgICAgLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gREJOQU1FU19EQilcbiAgICAgIClcbiAgICA6IGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS50b0NvbGxlY3Rpb24oKS5wcmltYXJ5S2V5cygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX29uRGF0YWJhc2VDcmVhdGVkKFxuICB7IGluZGV4ZWREQiwgSURCS2V5UmFuZ2UgfTogRGV4aWVET01EZXBlbmRlbmNpZXMsXG4gIG5hbWU6IHN0cmluZ1xuKSB7XG4gICFoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKSAmJlxuICAgIG5hbWUgIT09IERCTkFNRVNfREIgJiZcbiAgICBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkucHV0KHtuYW1lfSkuY2F0Y2gobm9wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vbkRhdGFiYXNlRGVsZXRlZChcbiAgeyBpbmRleGVkREIsIElEQktleVJhbmdlIH06IERleGllRE9NRGVwZW5kZW5jaWVzLFxuICBuYW1lOiBzdHJpbmdcbikge1xuICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLmRlbGV0ZShuYW1lKS5jYXRjaChub3ApO1xufVxuIiwgImltcG9ydCB7IG5ld1Njb3BlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB2aXAgKGZuKSB7XG4gIC8vIFRvIGJlIHVzZWQgYnkgc3Vic2NyaWJlcnMgdG8gdGhlIG9uKCdyZWFkeScpIGV2ZW50LlxuICAvLyBUaGlzIHdpbGwgbGV0IGNhbGxlciB0aHJvdWdoIHRvIGFjY2VzcyBEQiBldmVuIHdoZW4gaXQgaXMgYmxvY2tlZCB3aGlsZSB0aGUgZGIucmVhZHkoKSBzdWJzY3JpYmVycyBhcmUgZmlyaW5nLlxuICAvLyBUaGlzIHdvdWxkIGhhdmUgd29ya2VkIGF1dG9tYXRpY2FsbHkgaWYgd2Ugd2VyZSBjZXJ0YWluIHRoYXQgdGhlIFByb3ZpZGVyIHdhcyB1c2luZyBEZXhpZS5Qcm9taXNlIGZvciBhbGwgYXN5bmNyb25pYyBvcGVyYXRpb25zLiBUaGUgcHJvbWlzZSBQU0RcbiAgLy8gZnJvbSB0aGUgcHJvdmlkZXIuY29ubmVjdCgpIGNhbGwgd291bGQgdGhlbiBiZSBkZXJpdmVkIGFsbCB0aGUgd2F5IHRvIHdoZW4gcHJvdmlkZXIgd291bGQgY2FsbCBsb2NhbERhdGFiYXNlLmFwcGx5Q2hhbmdlcygpLiBCdXQgc2luY2VcbiAgLy8gdGhlIHByb3ZpZGVyIG1vcmUgbGlrZWx5IGlzIHVzaW5nIG5vbi1wcm9taXNlIGFzeW5jIEFQSXMgb3Igb3RoZXIgdGhlbmFibGUgaW1wbGVtZW50YXRpb25zLCB3ZSBjYW5ub3QgYXNzdW1lIHRoYXQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBpcyBvbmx5IHVzZWZ1bCBmb3Igb24oJ3JlYWR5Jykgc3Vic2NyaWJlcnMgdGhhdCBpcyByZXR1cm5pbmcgYSBQcm9taXNlIGZyb20gdGhlIGV2ZW50LiBJZiBub3QgdXNpbmcgdmlwKClcbiAgLy8gdGhlIGRhdGFiYXNlIGNvdWxkIGRlYWRsb2NrIHNpbmNlIGl0IHdvbnQgb3BlbiB1bnRpbCB0aGUgcmV0dXJuZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgYW5kIGFueSBub24tVklQZWQgb3BlcmF0aW9uIHN0YXJ0ZWQgYnlcbiAgLy8gdGhlIGNhbGxlciB3aWxsIG5vdCByZXNvbHZlIHVudGlsIGRhdGFiYXNlIGlzIG9wZW5lZC5cbiAgcmV0dXJuIG5ld1Njb3BlKGZ1bmN0aW9uICgpIHtcbiAgICBQU0QubGV0VGhyb3VnaCA9IHRydWU7IC8vIE1ha2Ugc3VyZSB3ZSBhcmUgbGV0IHRocm91Z2ggaWYgc3RpbGwgYmxvY2tpbmcgZGIgZHVlIHRvIG9ucmVhZHkgaXMgZmlyaW5nLlxuICAgIHJldHVybiBmbigpO1xuICB9KTtcbn1cblxuIiwgIi8qKlxuICogV29yayBhcm91bmQgU2FmYXJpIDE0IEluZGV4ZWREQiBvcGVuIGJ1Zy5cbiAqXG4gKiBTYWZhcmkgaGFzIGEgaG9ycmlibGUgYnVnIHdoZXJlIElEQiByZXF1ZXN0cyBjYW4gaGFuZyB3aGlsZSB0aGUgYnJvd3NlciBpcyBzdGFydGluZyB1cC4gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyNjU0N1xuICogVGhlIG9ubHkgc29sdXRpb24gaXMgdG8ga2VlcCBudWRnaW5nIGl0IHVudGlsIGl0J3MgYXdha2UuXG4gKi9cbmZ1bmN0aW9uIGlkYlJlYWR5KCkge1xuICAgIHZhciBpc1NhZmFyaSA9ICFuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJlxuICAgICAgICAvU2FmYXJpXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgICEvQ2hyb20oZXxpdW0pXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIC8vIE5vIHBvaW50IHB1dHRpbmcgb3RoZXIgYnJvd3NlcnMgb3Igb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIHRocm91Z2ggdGhpcyBtZXNzLlxuICAgIGlmICghaXNTYWZhcmkgfHwgIWluZGV4ZWREQi5kYXRhYmFzZXMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB2YXIgaW50ZXJ2YWxJZDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHRyeUlkYiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluZGV4ZWREQi5kYXRhYmFzZXMoKS5maW5hbGx5KHJlc29sdmUpOyB9O1xuICAgICAgICBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodHJ5SWRiLCAxMDApO1xuICAgICAgICB0cnlJZGIoKTtcbiAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7IH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGJSZWFkeTtcbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi4vLi4vaGVscGVycy9kZWJ1Zyc7XG5pbXBvcnQgeyByZWplY3Rpb24gfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBldmVudFJlamVjdEhhbmRsZXIsIHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2V2ZW50LXdyYXBwZXJzJztcbmltcG9ydCBQcm9taXNlLCB7IHdyYXAgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgY29ubmVjdGlvbnMgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBydW5VcGdyYWRlcnMsIHJlYWRHbG9iYWxTY2hlbWEsIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzLCB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEgfSBmcm9tICcuLi92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IHNhZmFyaU11bHRpU3RvcmVGaXggfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IF9vbkRhdGFiYXNlQ3JlYXRlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyB2aXAgfSBmcm9tICcuL3ZpcCc7XG5pbXBvcnQgeyBwcm9taXNhYmxlQ2hhaW4sIG5vcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzIH0gZnJvbSAnLi9nZW5lcmF0ZS1taWRkbGV3YXJlLXN0YWNrcyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgc2FmYXJpMTRXb3JrYXJvdW5kIGZyb20gJ3NhZmFyaS0xNC1pZGItZml4JztcblxuZXhwb3J0IGZ1bmN0aW9uIGRleGllT3BlbiAoZGI6IERleGllKSB7XG4gIGNvbnN0IHN0YXRlID0gZGIuX3N0YXRlO1xuICBjb25zdCB7aW5kZXhlZERCfSA9IGRiLl9kZXBzO1xuICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZCB8fCBkYi5pZGJkYilcbiAgICAgIHJldHVybiBzdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuPERleGllPigoKSA9PiBzdGF0ZS5kYk9wZW5FcnJvciA/XG4gICAgICAgIHJlamVjdGlvbiAoc3RhdGUuZGJPcGVuRXJyb3IpIDpcbiAgICAgICAgZGIpO1xuICBEZWJ1Zy5kZWJ1ZyAmJiAoc3RhdGUub3BlbkNhbmNlbGxlci5fc3RhY2tIb2xkZXIgPSBEZWJ1Zy5nZXRFcnJvcldpdGhTdGFjaygpKTsgLy8gTGV0IHN0YWNrcyBwb2ludCB0byB3aGVuIG9wZW4oKSB3YXMgY2FsbGVkIHJhdGhlciB0aGFuIHdoZXJlIG5ldyBEZXhpZSgpIHdhcyBjYWxsZWQuXG4gIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSB0cnVlO1xuICBzdGF0ZS5kYk9wZW5FcnJvciA9IG51bGw7XG4gIHN0YXRlLm9wZW5Db21wbGV0ZSA9IGZhbHNlO1xuICBjb25zdCBvcGVuQ2FuY2VsbGVyID0gc3RhdGUub3BlbkNhbmNlbGxlcjtcblxuICBmdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKCkge1xuICAgIC8vIElmIHN0YXRlLm9wZW5DYW5jZWxsZXIgb2JqZWN0IHJlZmVyZW5jZSBpcyByZXBsYWNlZCwgaXQgbWVhbnMgZGIuY2xvc2UoKSBoYXMgYmVlbiBjYWxsZWQsXG4gICAgLy8gbWVhbmluZyB0aGlzIG9wZW4gZmxvdyBzaG91bGQgYmUgY2FuY2VsbGVkLlxuICAgIGlmIChzdGF0ZS5vcGVuQ2FuY2VsbGVyICE9PSBvcGVuQ2FuY2VsbGVyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgnZGIub3BlbigpIHdhcyBjYW5jZWxsZWQnKTtcbiAgfVxuICBcbiAgLy8gRnVuY3Rpb24gcG9pbnRlcnMgdG8gY2FsbCB3aGVuIHRoZSBjb3JlIG9wZW5pbmcgcHJvY2VzcyBjb21wbGV0ZXMuXG4gIGxldCByZXNvbHZlRGJSZWFkeSA9IHN0YXRlLmRiUmVhZHlSZXNvbHZlLFxuICAgICAgLy8gdXBncmFkZVRyYW5zYWN0aW9uIHRvIGFib3J0IG9uIGZhaWx1cmUuXG4gICAgICB1cGdyYWRlVHJhbnNhY3Rpb246IChJREJUcmFuc2FjdGlvbiB8IG51bGwpID0gbnVsbCxcbiAgICAgIHdhc0NyZWF0ZWQgPSBmYWxzZTtcblxuICBjb25zdCB0cnlPcGVuREIgPSAoKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gTXVsdGlwbHkgZGIudmVybm8gd2l0aCAxMCB3aWxsIGJlIG5lZWRlZCB0byB3b3JrYXJvdW5kIHVwZ3JhZGluZyBidWcgaW4gSUU6XG4gICAgLy8gSUUgZmFpbHMgd2hlbiBkZWxldGluZyBvYmplY3RTdG9yZSBhZnRlciByZWFkaW5nIGZyb20gaXQuXG4gICAgLy8gQSBmdXR1cmUgdmVyc2lvbiBvZiBEZXhpZS5qcyB3aWxsIHN0b3BvdmVyIGFuIGludGVybWVkaWF0ZSB2ZXJzaW9uIHRvIHdvcmthcm91bmQgdGhpcy5cbiAgICAvLyBBdCB0aGF0IHBvaW50LCB3ZSB3YW50IHRvIGJlIGJhY2t3YXJkIGNvbXBhdGlibGUuIENvdWxkIGhhdmUgYmVlbiBtdWx0aXBsaWVkIHdpdGggMiwgYnV0IGJ5IHVzaW5nIDEwLCBpdCBpcyBlYXNpZXIgdG8gbWFwIHRoZSBudW1iZXIgdG8gdGhlIHJlYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgXG4gICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgIC8vIElmIG5vIEFQSSwgdGhyb3chXG4gICAgaWYgKCFpbmRleGVkREIpIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICBjb25zdCBkYk5hbWUgPSBkYi5uYW1lO1xuICAgIFxuICAgIGNvbnN0IHJlcSA9IHN0YXRlLmF1dG9TY2hlbWEgP1xuICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lKSA6XG4gICAgICBpbmRleGVkREIub3BlbihkYk5hbWUsIE1hdGgucm91bmQoZGIudmVybm8gKiAxMCkpO1xuICAgIGlmICghcmVxKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7IC8vIE1heSBoYXBwZW4gaW4gU2FmYXJpIHByaXZhdGUgbW9kZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2lzc3Vlcy8xMzRcbiAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgIHJlcS5vbmJsb2NrZWQgPSB3cmFwKGRiLl9maXJlT25CbG9ja2VkKTtcbiAgICByZXEub251cGdyYWRlbmVlZGVkID0gd3JhcCAoZSA9PiB7XG4gICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEgJiYgIWRiLl9vcHRpb25zLmFsbG93RW1wdHlEQikgeyAvLyBVbmxlc3MgYW4gYWRkb24gaGFzIHNwZWNpZmllZCBkYi5fYWxsb3dFbXB0eURCLCBsZXRzIG1ha2UgdGhlIGNhbGwgZmFpbC5cbiAgICAgICAgICAgIC8vIENhbGxlciBkaWQgbm90IHNwZWNpZnkgYSB2ZXJzaW9uIG9yIHNjaGVtYS4gRG9pbmcgdGhhdCBpcyBvbmx5IGFjY2VwdGFibGUgZm9yIG9wZW5pbmcgYWxyZWFkIGV4aXN0aW5nIGRhdGFiYXNlcy5cbiAgICAgICAgICAgIC8vIElmIG9udXBncmFkZW5lZWRlZCBpcyBjYWxsZWQgaXQgbWVhbnMgZGF0YWJhc2UgZGlkIG5vdCBleGlzdC4gUmVqZWN0IHRoZSBvcGVuKCkgcHJvbWlzZSBhbmQgbWFrZSBzdXJlIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgYSBuZXcgZGF0YWJhc2UgYnkgYWNjaWRlbnQgaGVyZS5cbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcHJldmVudERlZmF1bHQ7IC8vIFByb2hpYml0IG9uYWJvcnQgZXJyb3IgZnJvbSBmaXJpbmcgYmVmb3JlIHdlJ3JlIGRvbmUhXG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTsgLy8gQWJvcnQgdHJhbnNhY3Rpb24gKHdvdWxkIGhvcGUgdGhhdCB0aGlzIHdvdWxkIG1ha2UgREIgZGlzYXBwZWFyIGJ1dCBpdCBkb2VzbnQuKVxuICAgICAgICAgICAgLy8gQ2xvc2UgZGF0YWJhc2UgYW5kIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgIHJlcS5yZXN1bHQuY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHJlcSA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYk5hbWUpOyAvLyBUaGUgdXBncmFkZSB0cmFuc2FjdGlvbiBpcyBhdG9taWMsIGFuZCBqYXZhc2NyaXB0IGlzIHNpbmdsZSB0aHJlYWRlZCAtIG1lYW5pbmcgdGhhdCB0aGVyZSBpcyBubyByaXNrIHRoYXQgd2UgZGVsZXRlIHNvbWVvbmUgZWxzZXMgZGF0YWJhc2UgaGVyZSFcbiAgICAgICAgICAgIGRlbHJlcS5vbnN1Y2Nlc3MgPSBkZWxyZXEub25lcnJvciA9IHdyYXAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCAobmV3IGV4Y2VwdGlvbnMuTm9TdWNoRGF0YWJhc2UoYERhdGFiYXNlICR7ZGJOYW1lfSBkb2VzbnQgZXhpc3RgKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbi5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCk7XG4gICAgICAgICAgICB2YXIgb2xkVmVyID0gZS5vbGRWZXJzaW9uID4gTWF0aC5wb3coMiwgNjIpID8gMCA6IGUub2xkVmVyc2lvbjsgLy8gU2FmYXJpIDggZml4LlxuICAgICAgICAgICAgd2FzQ3JlYXRlZCA9IG9sZFZlciA8IDE7XG4gICAgICAgICAgICBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0Oy8vIGRiLl9ub3ZpcCBpcyBiZWNhdXNlIGRiIGNhbiBiZSBhbiBPYmplY3QuY3JlYXRlKG9yaWdEYikuXG4gICAgICAgICAgICBydW5VcGdyYWRlcnMoZGIsIG9sZFZlciAvIDEwLCB1cGdyYWRlVHJhbnNhY3Rpb24sIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9LCByZWplY3QpO1xuICAgIFxuICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwICgoKSA9PiB7XG4gICAgICAgIC8vIENvcmUgb3BlbmluZyBwcm9jZWR1cmUgY29tcGxldGUuIE5vdyBsZXQncyBqdXN0IHJlY29yZCBzb21lIHN0dWZmLlxuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICBjb25zdCBpZGJkYiA9IGRiLl9ub3ZpcC5pZGJkYiA9IHJlcS5yZXN1bHQ7IC8vIGRiLl9ub3ZpcCBpcyBiZWNhdXNlIGRiIGNhbiBiZSBhbiBPYmplY3QuY3JlYXRlKG9yaWdEYikuXG5cbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmVOYW1lcyA9IHNsaWNlKGlkYmRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgICAgICBpZiAob2JqZWN0U3RvcmVOYW1lcy5sZW5ndGggPiAwKSB0cnkge1xuICAgICAgICAgIGNvbnN0IHRtcFRyYW5zID0gaWRiZGIudHJhbnNhY3Rpb24oc2FmYXJpTXVsdGlTdG9yZUZpeChvYmplY3RTdG9yZU5hbWVzKSwgJ3JlYWRvbmx5Jyk7XG4gICAgICAgICAgaWYgKHN0YXRlLmF1dG9TY2hlbWEpIHJlYWRHbG9iYWxTY2hlbWEoZGIsIGlkYmRiLCB0bXBUcmFucyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBkYi5fZGJTY2hlbWEsIHRtcFRyYW5zKTtcbiAgICAgICAgICAgICAgaWYgKCF2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGIsIHRtcFRyYW5zKSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZSBTY2hlbWFEaWZmOiBTY2hlbWEgd2FzIGV4dGVuZGVkIHdpdGhvdXQgaW5jcmVhc2luZyB0aGUgbnVtYmVyIHBhc3NlZCB0byBkYi52ZXJzaW9uKCkuIFNvbWUgcXVlcmllcyBtYXkgZmFpbC5gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MoZGIsIHRtcFRyYW5zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNhZmFyaSA4IG1heSBiYWlsIG91dCBpZiA+IDEgc3RvcmUgbmFtZXMuIEhvd2V2ZXIsIHRoaXMgc2hvdWxkbnQgYmUgYSBzaG93c3RvcHBlci4gSXNzdWUgIzEyMC5cbiAgICAgICAgICAvLyBCVUdCVUc6IEl0IHdpbGwgYmFpbCBvdXQgYW55d2F5IGFzIG9mIERleGllIDMuXG4gICAgICAgICAgLy8gU2hvdWxkIHdlIHN1cHBvcnQgU2FmYXJpIDggYW55bW9yZT8gQmVsaWV2ZSBhbGxcbiAgICAgICAgICAvLyBEZXhpZSB1c2VycyB1c2UgdGhlIHNoaW0gZm9yIHRoYXQgcGxhdGZvcm0gYW55d2F5PyFcbiAgICAgICAgICAvLyBJZiByZW1vdmluZyBTYWZhcmkgOCBzdXBwb3J0LCBnbyBhaGVhZCBhbmQgcmVtb3ZlIHRoZSBzYWZhcmlNdWx0aVN0b3JlRml4KCkgZnVuY3Rpb25cbiAgICAgICAgICAvLyBhcyB3ZWxsIGFzIGFic3VyZCB1cGdyYWRlIHZlcnNpb24gcXVpcmsgZm9yIFNhZmFyaS5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29ubmVjdGlvbnMucHVzaChkYik7IC8vIFVzZWQgZm9yIGVtdWxhdGluZyB2ZXJzaW9uY2hhbmdlIGV2ZW50IG9uIElFL0VkZ2UvU2FmYXJpLlxuICAgICAgICBcbiAgICAgICAgaWRiZGIub252ZXJzaW9uY2hhbmdlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52Y0ZpcmVkID0gdHJ1ZTsgLy8gZGV0ZWN0IGltcGxlbWVudGF0aW9ucyB0aGF0IG5vdCBzdXBwb3J0IHZlcnNpb25jaGFuZ2UgKElFL0VkZ2UvU2FmYXJpKVxuICAgICAgICAgICAgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlkYmRiLm9uY2xvc2UgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgIGRiLm9uKFwiY2xvc2VcIikuZmlyZShldik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh3YXNDcmVhdGVkKSBfb25EYXRhYmFzZUNyZWF0ZWQoZGIuX2RlcHMsIGRiTmFtZSk7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgfSwgcmVqZWN0KTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBpZiAoZXJyICYmIGVyci5uYW1lID09PSAnVW5rbm93bkVycm9yJyAmJiBzdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgIC8vIEJ1ZyBpbiBDaHJvbWUgYWZ0ZXIgY2xlYXJpbmcgc2l0ZSBkYXRhXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGV4aWUvRGV4aWUuanMvaXNzdWVzLzU0MyNpc3N1ZWNvbW1lbnQtMTc5NTczNjY5NVxuICAgICAgc3RhdGUuUFIxMzk4X21heExvb3AtLTtcbiAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IFdvcmthcm91bmQgZm9yIENocm9tZSBVbmtub3duRXJyb3Igb24gb3BlbigpJyk7XG4gICAgICByZXR1cm4gdHJ5T3BlbkRCKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBzYWZhcmkxNFdvcmthcm91bmQgPSBXb3JrYXJvdW5kIGJ5IGpha2VhcmNoaWJhbGQgZm9yIG5ldyBuYXN0eSBidWcgaW4gc2FmYXJpIDE0LlxuICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICBvcGVuQ2FuY2VsbGVyLFxuICAgICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IFByb21pc2UucmVzb2x2ZSgpIDogc2FmYXJpMTRXb3JrYXJvdW5kKCkpLnRoZW4odHJ5T3BlbkRCKVxuICBdKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIEJlZm9yZSBmaW5hbGx5IHJlc29sdmluZyB0aGUgZGJSZWFkeVByb21pc2UgYW5kIHRoaXMgcHJvbWlzZSxcbiAgICAgIC8vIGNhbGwgYW5kIGF3YWl0IGFsbCBvbigncmVhZHknKSBzdWJzY3JpYmVyczpcbiAgICAgIC8vIERleGllLnZpcCgpIG1ha2VzIHN1YnNjcmliZXJzIGFibGUgdG8gdXNlIHRoZSBkYXRhYmFzZSB3aGlsZSBiZWluZyBvcGVuZWQuXG4gICAgICAvLyBUaGlzIGlzIGEgbXVzdCBzaW5jZSB0aGVzZSBzdWJzY3JpYmVycyB0YWtlIHBhcnQgb2YgdGhlIG9wZW5pbmcgcHJvY2VkdXJlLlxuICAgICAgdGhyb3dJZkNhbmNlbGxlZCgpO1xuICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmlwKCgpPT5kYi5vbi5yZWFkeS5maXJlKGRiLnZpcCkpKS50aGVuKGZ1bmN0aW9uIGZpcmVSZW1haW5kZXJzKCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIC8vIEluIGNhc2UgYWRkaXRpb25hbCBzdWJzY3JpYmVycyB0byBkYi5vbigncmVhZHknKSB3ZXJlIGFkZGVkIGR1cmluZyB0aGUgdGltZSBkYi5vbi5yZWFkeS5maXJlIHdhcyBleGVjdXRlZC5cbiAgICAgICAgICAgICAgbGV0IHJlbWFpbmRlcnMgPSBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZC5yZWR1Y2UocHJvbWlzYWJsZUNoYWluLCBub3ApO1xuICAgICAgICAgICAgICBzdGF0ZS5vblJlYWR5QmVpbmdGaXJlZCA9IFtdO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZpcCgoKT0+cmVtYWluZGVycyhkYi52aXApKSkudGhlbihmaXJlUmVtYWluZGVycylcbiAgICAgICAgICB9XG4gICAgICB9KTtcbiAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBudWxsO1xuICAgICAgc3RhdGUuaXNCZWluZ09wZW5lZCA9IGZhbHNlO1xuICB9KS50aGVuKCgpPT57XG4gICAgICAvLyBSZXNvbHZlIHRoZSBkYi5vcGVuKCkgd2l0aCB0aGUgZGIgaW5zdGFuY2UuXG4gICAgICByZXR1cm4gZGI7XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBzdGF0ZS5kYk9wZW5FcnJvciA9IGVycjsgLy8gUmVjb3JkIHRoZSBlcnJvci4gSXQgd2lsbCBiZSB1c2VkIHRvIHJlamVjdCBmdXJ0aGVyIHByb21pc2VzIG9mIGRiIG9wZXJhdGlvbnMuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBEaWQgd2UgZmFpbCB3aXRoaW4gb251cGdyYWRlbmVlZGVkPyBNYWtlIHN1cmUgdG8gYWJvcnQgdGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gc28gaXQgZG9lc250IGNvbW1pdC5cbiAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uICYmIHVwZ3JhZGVUcmFuc2FjdGlvbi5hYm9ydCgpO1xuICAgICAgfSBjYXRjaCB7IH1cbiAgICAgIGlmIChvcGVuQ2FuY2VsbGVyID09PSBzdGF0ZS5vcGVuQ2FuY2VsbGVyKSB7XG4gICAgICAgIC8vIFN0aWxsIGluIHRoZSBzYW1lIG9wZW4gZmxvdyAtIFRoZSBlcnJvciByZWFzb24gd2FzIG5vdCBkdWUgdG8gZXh0ZXJuYWwgY2FsbCB0byBkYi5jbG9zZSgpLlxuICAgICAgICAvLyBNYWtlIHN1cmUgdG8gY2FsbCBkYi5jbG9zZSgpIHRvIGZpbmFsaXplIHJlc291cmNlcy5cbiAgICAgICAgZGIuX2Nsb3NlKCk7IC8vIENsb3NlcyBhbmQgcmVzZXRzIGlkYmRiLCByZW1vdmVzIGNvbm5lY3Rpb25zLCByZXNldHMgZGJSZWFkeVByb21pc2UgYW5kIG9wZW5DYW5jZWxsZXIgc28gdGhhdCBhIGxhdGVyIGRiLm9wZW4oKSBpcyBmcmVzaC5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWplY3Rpb24gKGVycik7XG4gIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgIHN0YXRlLm9wZW5Db21wbGV0ZSA9IHRydWU7XG4gICAgICByZXNvbHZlRGJSZWFkeSgpOyAvLyBkYlJlYWR5UHJvbWlzZSBpcyByZXNvbHZlZCBubyBtYXR0ZXIgaWYgb3BlbigpIHJlamVjdHMgb3IgcmVzb2x2ZWQuIEl0J3MganVzdCB0byB3YWtlIHVwIHdhaXRlcnMuXG4gIH0pO1xufVxuIiwgImltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRJdGVyYXRvciAoaXRlcmF0b3I6IEl0ZXJhdG9yPGFueT4pIHtcbiAgdmFyIGNhbGxOZXh0ID0gcmVzdWx0ID0+IGl0ZXJhdG9yLm5leHQocmVzdWx0KSxcbiAgICAgIGRvVGhyb3cgPSBlcnJvciA9PiBpdGVyYXRvci50aHJvdyhlcnJvciksXG4gICAgICBvblN1Y2Nlc3MgPSBzdGVwKGNhbGxOZXh0KSxcbiAgICAgIG9uRXJyb3IgPSBzdGVwKGRvVGhyb3cpO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoZ2V0TmV4dDogKGFueSk9PmFueSkge1xuICAgICAgcmV0dXJuICh2YWw/KSA9PiB7XG4gICAgICAgICAgdmFyIG5leHQgPSBnZXROZXh0KHZhbCksXG4gICAgICAgICAgICAgIHZhbHVlID0gbmV4dC52YWx1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0LmRvbmUgPyB2YWx1ZSA6XG4gICAgICAgICAgICAgICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlLnRoZW4gIT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgICAgaXNBcnJheSh2YWx1ZSkgPyBQcm9taXNlLmFsbCh2YWx1ZSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpIDogb25TdWNjZXNzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcikpO1xuICAgICAgfTtcbiAgfVxuXG4gIHJldHVybiBzdGVwKGNhbGxOZXh0KSgpO1xufVxuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IGVycm5hbWVzLCBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGZsYXR0ZW4sIGlzQXN5bmNGdW5jdGlvbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBhd2FpdEl0ZXJhdG9yIH0gZnJvbSAnLi4vLi4vaGVscGVycy95aWVsZC1zdXBwb3J0JztcbmltcG9ydCBQcm9taXNlLCB7XG4gIFBTRCxcbiAgTmF0aXZlUHJvbWlzZSxcbiAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIHJlamVjdGlvbixcbiAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHNcbn0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MobW9kZTogVHJhbnNhY3Rpb25Nb2RlLCBfdGFibGVBcmdzXywgc2NvcGVGdW5jKSB7XG4gIC8vIExldCB0YWJsZSBhcmd1bWVudHMgYmUgYWxsIGFyZ3VtZW50cyBiZXR3ZWVuIG1vZGUgYW5kIGxhc3QgYXJndW1lbnQuXG4gIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGkgPCAyKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJUb28gZmV3IGFyZ3VtZW50c1wiKTtcbiAgLy8gUHJldmVudCBvcHRpbXphdGlvbiBraWxsZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50cylcbiAgLy8gYW5kIGNsb25lIGFyZ3VtZW50cyBleGNlcHQgdGhlIGZpcnN0IG9uZSBpbnRvIGxvY2FsIHZhciAnYXJncycuXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGkgLSAxKTtcbiAgd2hpbGUgKC0taSkgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIC8vIExldCBzY29wZUZ1bmMgYmUgdGhlIGxhc3QgYXJndW1lbnQgYW5kIHBvcCBpdCBzbyB0aGF0IGFyZ3Mgbm93IG9ubHkgY29udGFpbiB0aGUgdGFibGUgYXJndW1lbnRzLlxuICBzY29wZUZ1bmMgPSBhcmdzLnBvcCgpO1xuICB2YXIgdGFibGVzID0gZmxhdHRlbihhcmdzKTsgLy8gU3VwcG9ydCB1c2luZyBhcnJheSBhcyBtaWRkbGUgYXJndW1lbnQsIG9yIGEgbWl4IG9mIGFycmF5cyBhbmQgbm9uLWFycmF5cy5cbiAgcmV0dXJuIFttb2RlLCB0YWJsZXMsIHNjb3BlRnVuY107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoXG4gIGRiOiBEZXhpZSxcbiAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgcGFyZW50VHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uIHwgdW5kZWZpbmVkLFxuICBzY29wZUZ1bmM6ICgpPT5Qcm9taXNlTGlrZTxhbnk+IHwgYW55XG4pIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIC8vIEtlZXAgYSBwb2ludGVyIHRvIGxhc3Qgbm9uLXRyYW5zYWN0aW9uYWwgUFNEIHRvIHVzZSBpZiBzb21lb25lIGNhbGxzIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkuXG4gICAgY29uc3QgdHJhbnNsZXNzID0gUFNELnRyYW5zbGVzcyB8fCBQU0Q7XG4gICAgLy8gT3VyIHRyYW5zYWN0aW9uLlxuICAgIC8vcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEsIHBhcmVudFRyYW5zYWN0aW9uKTtcbiAgICAvLyBMZXQgdGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIGJlIHBhcnQgb2YgYSBQcm9taXNlLXNwZWNpZmljIGRhdGEgKFBTRCkgdmFsdWUuXG4gICAgY29uc3Qgem9uZVByb3BzID0ge1xuICAgICAgdHJhbnM6IHRyYW5zLFxuICAgICAgdHJhbnNsZXNzOiB0cmFuc2xlc3NcbiAgICB9O1xuXG4gICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB7XG4gICAgICAvLyBFbXVsYXRlIHRyYW5zYWN0aW9uIGNvbW1pdCBhd2FyZW5lc3MgZm9yIGlubmVyIHRyYW5zYWN0aW9uIChtdXN0ICdjb21taXQnIHdoZW4gdGhlIGlubmVyIHRyYW5zYWN0aW9uIGhhcyBubyBtb3JlIG9wZXJhdGlvbnMgb25nb2luZylcbiAgICAgIHRyYW5zLmlkYnRyYW5zID0gcGFyZW50VHJhbnNhY3Rpb24uaWRidHJhbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRyYW5zLmNyZWF0ZSgpOyAvLyBDcmVhdGUgdGhlIG5hdGl2ZSB0cmFuc2FjdGlvbiBzbyB0aGF0IGNvbXBsZXRlKCkgb3IgZXJyb3IoKSB3aWxsIHRyaWdnZXIgZXZlbiBpZiBubyBvcGVyYXRpb24gaXMgbWFkZSB1cG9uIGl0LlxuICAgICAgICBkYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPSAzO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4Lm5hbWUgPT09IGVycm5hbWVzLkludmFsaWRTdGF0ZSAmJiBkYi5pc09wZW4oKSAmJiAtLWRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBOZWVkIHRvIHJlb3BlbiBkYicpO1xuICAgICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICAgIHJldHVybiBkYi5vcGVuKCkudGhlbigoKSA9PiBlbnRlclRyYW5zYWN0aW9uU2NvcGUoXG4gICAgICAgICAgICBkYixcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBzdG9yZU5hbWVzLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHNjb3BlRnVuY1xuICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHNjb3BlRnVuYyk7XG4gICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgfVxuXG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIGNvbnN0IHByb21pc2VGb2xsb3dlZCA9IFByb21pc2UuZm9sbG93KCgpID0+IHtcbiAgICAgIC8vIEZpbmFsbHksIGNhbGwgdGhlIHNjb3BlIGZ1bmN0aW9uIHdpdGggb3VyIHRhYmxlIGFuZCB0cmFuc2FjdGlvbiBhcmd1bWVudHMuXG4gICAgICByZXR1cm5WYWx1ZSA9IHNjb3BlRnVuYy5jYWxsKHRyYW5zLCB0cmFucyk7XG4gICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgaWYgKHNjb3BlRnVuY0lzQXN5bmMpIHtcbiAgICAgICAgICAvLyBzY29wZUZ1bmMgaXMgYSBuYXRpdmUgYXN5bmMgZnVuY3Rpb24gLSB3ZSBrbm93IGZvciBzdXJlIHJldHVyblZhbHVlIGlzIG5hdGl2ZSBwcm9taXNlLlxuICAgICAgICAgIHZhciBkZWNyZW1lbnRvciA9IGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLmJpbmQobnVsbCwgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuVmFsdWUudGhlbihkZWNyZW1lbnRvciwgZGVjcmVtZW50b3IpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZS5uZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIHNjb3BlRnVuYyByZXR1cm5lZCBhbiBpdGVyYXRvciB3aXRoIHRocm93LXN1cHBvcnQuIEhhbmRsZSB5aWVsZCBhcyBhd2FpdC5cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGF3YWl0SXRlcmF0b3IocmV0dXJuVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgem9uZVByb3BzKTtcbiAgICByZXR1cm4gKHJldHVyblZhbHVlICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nID9cbiAgICAgIC8vIFByb21pc2UgcmV0dXJuZWQuIFVzZXIgdXNlcyBwcm9taXNlLXN0eWxlIHRyYW5zYWN0aW9ucy5cbiAgICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSkudGhlbih4ID0+IHRyYW5zLmFjdGl2ZSA/XG4gICAgICAgIHggLy8gVHJhbnNhY3Rpb24gc3RpbGwgYWN0aXZlLiBDb250aW51ZS5cbiAgICAgICAgOiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUHJlbWF0dXJlQ29tbWl0KFxuICAgICAgICAgIFwiVHJhbnNhY3Rpb24gY29tbWl0dGVkIHRvbyBlYXJseS4gU2VlIGh0dHA6Ly9iaXQubHkvMmtkY2tNblwiKSkpXG4gICAgICAvLyBObyBwcm9taXNlIHJldHVybmVkLiBXYWl0IGZvciBhbGwgb3V0c3RhbmRpbmcgcHJvbWlzZXMgYmVmb3JlIGNvbnRpbnVpbmcuIFxuICAgICAgOiBwcm9taXNlRm9sbG93ZWQudGhlbigoKSA9PiByZXR1cm5WYWx1ZSlcbiAgICApLnRoZW4oeCA9PiB7XG4gICAgICAvLyBzdWIgdHJhbnNhY3Rpb25zIGRvbid0IHJlYWN0IHRvIGlkYnRyYW5zLm9uY29tcGxldGUuIFdlIG11c3QgdHJpZ2dlciBhIGNvbXBsZXRpb246XG4gICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHRyYW5zLl9yZXNvbHZlKCk7XG4gICAgICAvLyB3YWl0IGZvciB0cmFucy5fY29tcGxldGlvblxuICAgICAgLy8gKGlmIHJvb3QgdHJhbnNhY3Rpb24sIHRoaXMgbWVhbnMgJ2NvbXBsZXRlJyBldmVudC4gSWYgc3ViLXRyYW5zYWN0aW9uLCB3ZSd2ZSBqdXN0IGZpcmVkIGl0IG91cnNlbHZlcylcbiAgICAgIHJldHVybiB0cmFucy5fY29tcGxldGlvbi50aGVuKCgpID0+IHgpO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgdHJhbnMuX3JlamVjdChlKTsgLy8gWWVzLCBhYm92ZSB0aGVuLWhhbmRsZXIgd2VyZSBtYXliZSBub3QgY2FsbGVkIGJlY2F1c2Ugb2YgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBpbiBzY29wZUZ1bmMhXG4gICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVLZXlSYW5nZSxcbiAgREJDb3JlUXVlcnlSZXF1ZXN0LFxuICBEQkNvcmVSYW5nZVR5cGUsXG4gIERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0LFxuICBEQkNvcmVDb3VudFJlcXVlc3QsXG4gIERCQ29yZUN1cnNvcixcbiAgREJDb3JlVGFibGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldEtleUV4dHJhY3RvciB9IGZyb20gJy4vZ2V0LWtleS1leHRyYWN0b3InO1xuaW1wb3J0IHsgZ2V0S2V5UGF0aEFsaWFzIH0gZnJvbSAnLi9kYmNvcmUtaW5kZXhlZGRiJztcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5cbmludGVyZmFjZSBWaXJ0dWFsSW5kZXggZXh0ZW5kcyBEQkNvcmVJbmRleCB7XG4gIC8qKiBUcnVlIGlmIHRoaXMgaW5kZXggaXMgdmlydHVhbCwgaS5lLiByZXByZXNlbnRzIGEgY29tcG91bmQgaW5kZXggaW50ZXJuYWxseSxcbiAgICogYnV0IG1ha2VzIGl0IGFjdCBhcyBhcyBoYXZpbmcgYSBzdWJzZXQgb2YgaXRzIGtleVBhdGhzLlxuICAgKi9cbiAgaXNWaXJ0dWFsOiBib29sZWFuO1xuXG4gIC8qKiBOdW1iZXIgb2Yga2V5cGF0aHMgdGhhdCB0aGlzIGluZGV4IGNvbXByaXNlcy4gQ2FuIGJlIDAuLk4uXG4gICAqIE5vdGU6IFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgKnZpcnR1YWwgaW5kZXgqLCBub3QgdGhlIHJlYWwgaW5kZXguXG4gICAqL1xuICBrZXlMZW5ndGg6IG51bWJlcjtcblxuICAvKiogTnVtYmVyIG9mIHBvcHBlZCBrZXlwYXRocyBmcm9tIHRoZSByZWFsIGluZGV4LlxuICAgKi9cbiAga2V5VGFpbDogbnVtYmVyO1xufVxuXG4vLyBNb3ZlIGludG8gc29tZSB1dGlsOlxuZXhwb3J0IGZ1bmN0aW9uIHBhZCAoYTogYW55IHwgYW55W10sIHZhbHVlOiBhbnksIGNvdW50OiBudW1iZXIpIHtcbiAgY29uc3QgcmVzdWx0ID0gaXNBcnJheShhKSA/IGEuc2xpY2UoKSA6IFthXTtcbiAgZm9yIChsZXQgaT0wOyBpPGNvdW50OyArK2kpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZSAoZG93bjogREJDb3JlKSA6IERCQ29yZSB7XG4gIHJldHVybiB7XG4gICAgLi4uZG93bixcbiAgICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZykge1xuICAgICAgY29uc3QgdGFibGUgPSBkb3duLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBjb25zdCB7c2NoZW1hfSA9IHRhYmxlO1xuICAgICAgY29uc3QgaW5kZXhMb29rdXA6IHtbaW5kZXhBbGlhczogc3RyaW5nXTogVmlydHVhbEluZGV4W119ID0ge307XG4gICAgICBjb25zdCBhbGxWaXJ0dWFsSW5kZXhlczogVmlydHVhbEluZGV4W10gPSBbXTtcblxuICAgICAgZnVuY3Rpb24gYWRkVmlydHVhbEluZGV4ZXMgKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSwga2V5VGFpbDogbnVtYmVyLCBsb3dMZXZlbEluZGV4OiBEQkNvcmVJbmRleCk6IFZpcnR1YWxJbmRleCB7XG4gICAgICAgIGNvbnN0IGtleVBhdGhBbGlhcyA9IGdldEtleVBhdGhBbGlhcyhrZXlQYXRoKTtcbiAgICAgICAgY29uc3QgaW5kZXhMaXN0ID0gKGluZGV4TG9va3VwW2tleVBhdGhBbGlhc10gPSBpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdIHx8IFtdKTtcbiAgICAgICAgY29uc3Qga2V5TGVuZ3RoID0ga2V5UGF0aCA9PSBudWxsID8gMDogdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8gMSA6IGtleVBhdGgubGVuZ3RoO1xuICAgICAgICBjb25zdCBpc1ZpcnR1YWwgPSBrZXlUYWlsID4gMDtcbiAgICAgICAgY29uc3QgdmlydHVhbEluZGV4ID0ge1xuICAgICAgICAgIC4uLmxvd0xldmVsSW5kZXgsXG4gICAgICAgICAgaXNWaXJ0dWFsLFxuICAgICAgICAgIGtleVRhaWwsXG4gICAgICAgICAga2V5TGVuZ3RoLFxuICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKSxcbiAgICAgICAgICB1bmlxdWU6ICFpc1ZpcnR1YWwgJiYgbG93TGV2ZWxJbmRleC51bmlxdWVcbiAgICAgICAgfTtcbiAgICAgICAgaW5kZXhMaXN0LnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgaWYgKCF2aXJ0dWFsSW5kZXguaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgYWxsVmlydHVhbEluZGV4ZXMucHVzaCh2aXJ0dWFsSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlMZW5ndGggPiAxKSB7XG4gICAgICAgICAgY29uc3QgdmlydHVhbEtleVBhdGggPSBrZXlMZW5ndGggPT09IDIgP1xuICAgICAgICAgICAga2V5UGF0aFswXSA6IC8vIFRoaXMgaXMgYSBjb21wb3VuZCBbYSwgYl0uIEFkZCBhIHZpcnR1YWwgbm9ybWFsIGluZGV4IGEuXG4gICAgICAgICAgICBrZXlQYXRoLnNsaWNlKDAsIGtleUxlbmd0aCAtIDEpOyAvLyBUaGlzIGlzIGNvbXBvdW5kIFthLGIsY10uIEFkZCB2aXJ0dWFsIGNvbXBvdW5kIFthLGJdLlxuICAgICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKHZpcnR1YWxLZXlQYXRoLCBrZXlUYWlsICsgMSwgbG93TGV2ZWxJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXhMaXN0LnNvcnQoKGEsYikgPT4gYS5rZXlUYWlsIC0gYi5rZXlUYWlsKTsgLy8gU2hvcnRlc3Qga2V5VGFpbCBpcyB0aGUgYmVzdCBvbmUgKHJlcHJlc2VudHMgcmVhbCBpbmRleClcbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJbmRleDtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHByaW1hcnlLZXkgPSBhZGRWaXJ0dWFsSW5kZXhlcyhzY2hlbWEucHJpbWFyeUtleS5rZXlQYXRoLCAwLCBzY2hlbWEucHJpbWFyeUtleSk7XG4gICAgICBpbmRleExvb2t1cFtcIjppZFwiXSA9IFtwcmltYXJ5S2V5XTtcbiAgICAgIGZvciAoY29uc3QgaW5kZXggb2Ygc2NoZW1hLmluZGV4ZXMpIHtcbiAgICAgICAgYWRkVmlydHVhbEluZGV4ZXMoaW5kZXgua2V5UGF0aCwgMCwgaW5kZXgpO1xuICAgICAgfVxuICAgIFxuICAgICAgZnVuY3Rpb24gZmluZEJlc3RJbmRleChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pOiBWaXJ0dWFsSW5kZXgge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpbmRleExvb2t1cFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFswXTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJhbmdlIChyYW5nZTogREJDb3JlS2V5UmFuZ2UsIGtleVRhaWw6IG51bWJlcik6IERCQ29yZUtleVJhbmdlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiByYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuRXF1YWwgP1xuICAgICAgICAgICAgREJDb3JlUmFuZ2VUeXBlLlJhbmdlIDpcbiAgICAgICAgICAgIHJhbmdlLnR5cGUsXG4gICAgICAgICAgbG93ZXI6IHBhZChyYW5nZS5sb3dlciwgcmFuZ2UubG93ZXJPcGVuID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICBsb3dlck9wZW46IHRydWUsIC8vIGRvZXNuJ3QgbWF0dGVyIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICB1cHBlcjogcGFkKHJhbmdlLnVwcGVyLCByYW5nZS51cHBlck9wZW4gPyBkb3duLk1JTl9LRVkgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpLFxuICAgICAgICAgIHVwcGVyT3BlbjogdHJ1ZSAvLyBkb2Vzbid0IG1hdHRlciB0cnVlIG9yIGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0IChyZXE6IERCQ29yZVF1ZXJ5UmVxdWVzdCk6IERCQ29yZVF1ZXJ5UmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpOiBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdDtcbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZVJlcXVlc3QgKHJlcTogREJDb3JlQ291bnRSZXF1ZXN0KTogREJDb3JlQ291bnRSZXF1ZXN0IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4O1xuICAgICAgICByZXR1cm4gaW5kZXguaXNWaXJ0dWFsID8ge1xuICAgICAgICAgIC4uLnJlcSxcbiAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByYW5nZTogdHJhbnNsYXRlUmFuZ2UocmVxLnF1ZXJ5LnJhbmdlLCBpbmRleC5rZXlUYWlsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSA6IHJlcTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGNvbnN0IHJlc3VsdDogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLnRhYmxlLFxuICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgcHJpbWFyeUtleSxcbiAgICAgICAgICBpbmRleGVzOiBhbGxWaXJ0dWFsSW5kZXhlcyxcbiAgICAgICAgICBnZXRJbmRleEJ5S2V5UGF0aDogZmluZEJlc3RJbmRleFxuICAgICAgICB9LFxuXG4gICAgICAgIGNvdW50KHJlcSkge1xuICAgICAgICAgIHJldHVybiB0YWJsZS5jb3VudCh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICB9LCAgICBcbiAgICBcbiAgICAgICAgcXVlcnkocmVxKSB7XG4gICAgICAgICAgcmV0dXJuIHRhYmxlLnF1ZXJ5KHRyYW5zbGF0ZVJlcXVlc3QocmVxKSk7XG4gICAgICAgIH0sXG4gICAgXG4gICAgICAgIG9wZW5DdXJzb3IocmVxKSB7XG4gICAgICAgICAgY29uc3Qge2tleVRhaWwsIGlzVmlydHVhbCwga2V5TGVuZ3RofSA9IChyZXEucXVlcnkuaW5kZXggYXMgVmlydHVhbEluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzVmlydHVhbCkgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IocmVxKTtcbiAgICBcbiAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcjogREJDb3JlQ3Vyc29yKSA6IERCQ29yZUN1cnNvciB7XG4gICAgICAgICAgICBmdW5jdGlvbiBfY29udGludWUgKGtleT86IGFueSkge1xuICAgICAgICAgICAgICBrZXkgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKHBhZChrZXksIHJlcS5yZXZlcnNlID8gZG93bi5NQVhfS0VZIDogZG93bi5NSU5fS0VZLCBrZXlUYWlsKSkgOlxuICAgICAgICAgICAgICAgIHJlcS51bmlxdWUgP1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKFxuICAgICAgICAgICAgICAgICAgICBjdXJzb3Iua2V5LnNsaWNlKDAsIGtleUxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHJlcS5yZXZlcnNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRvd24uTUlOX0tFWVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkb3duLk1BWF9LRVksIGtleVRhaWwpXG4gICAgICAgICAgICAgICAgICApIDpcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsQ3Vyc29yID0gT2JqZWN0LmNyZWF0ZShjdXJzb3IsIHtcbiAgICAgICAgICAgICAgY29udGludWU6IHt2YWx1ZTogX2NvbnRpbnVlfSxcbiAgICAgICAgICAgICAgY29udGludWVQcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgdmFsdWUoa2V5OiBhbnksIHByaW1hcnlLZXk6IGFueSkge1xuICAgICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleShwYWQoa2V5LCBkb3duLk1BWF9LRVksIGtleVRhaWwpLCBwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjdXJzb3Iua2V5IGFzIGFueVtdOyAvLyBBIHZpcnR1YWwgY3Vyc29yIGFsd2F5cyBvcGVyYXRlcyBvbiBjb21wb3VuZCBrZXlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlMZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgICAgICAgICBrZXlbMF0gOiAvLyBDdXJzb3Iua2V5IHNob3VsZCBub3QgYmUgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGtleS5zbGljZSgwLCBrZXlMZW5ndGgpOyAvLyBDdXJzb3Iua2V5IHNob3VsZCBiZSBmaXJzdCBwYXJ0IG9mIGFycmF5LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmlydHVhbEN1cnNvcjtcbiAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgcmV0dXJuIHRhYmxlLm9wZW5DdXJzb3IodHJhbnNsYXRlUmVxdWVzdChyZXEpKVxuICAgICAgICAgICAgLnRoZW4oY3Vyc29yID0+IGN1cnNvciAmJiBjcmVhdGVWaXJ0dWFsQ3Vyc29yKGN1cnNvcikpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBuYW1lOiBcIlZpcnR1YWxJbmRleE1pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDEsXG4gIGNyZWF0ZTogY3JlYXRlVmlydHVhbEluZGV4TWlkZGxld2FyZVxufTtcblxuIiwgImltcG9ydCB7IGtleXMsIGhhc093biwgdG9TdHJpbmdUYWcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9iamVjdERpZmYoYTogYW55LCBiOiBhbnksIHJ2PzogYW55LCBwcmZ4Pzogc3RyaW5nKSB7XG4gIC8vIENvbXBhcmVzIG9iamVjdHMgYSBhbmQgYiBhbmQgcHJvZHVjZXMgYSBkaWZmIG9iamVjdC5cbiAgcnYgPSBydiB8fCB7fTtcbiAgcHJmeCA9IHByZnggfHwgJyc7XG4gIGtleXMoYSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICghaGFzT3duKGIsIHByb3ApKSB7XG4gICAgICAvLyBQcm9wZXJ0eSByZW1vdmVkXG4gICAgICBydltwcmZ4ICsgcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcCA9IGFbcHJvcF0sXG4gICAgICAgIGJwID0gYltwcm9wXTtcbiAgICAgIGlmICh0eXBlb2YgYXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBicCA9PT0gJ29iamVjdCcgJiYgYXAgJiYgYnApIHtcbiAgICAgICAgY29uc3QgYXBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGFwKTtcbiAgICAgICAgY29uc3QgYnBUeXBlTmFtZSA9IHRvU3RyaW5nVGFnKGJwKTtcblxuICAgICAgICBpZiAoYXBUeXBlTmFtZSAhPT0gYnBUeXBlTmFtZSkge1xuICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGNoYW5nZWQgdG8gb3RoZXIgdHlwZVxuICAgICAgICB9IGVsc2UgaWYgKGFwVHlwZU5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgLy8gUG9qbyBvYmplY3RzIChub3QgRGF0ZSwgQXJyYXlCdWZmZXIsIEFycmF5IGV0YykuIEdvIGRlZXAuXG4gICAgICAgICAgZ2V0T2JqZWN0RGlmZihhcCwgYnAsIHJ2LCBwcmZ4ICsgcHJvcCArICcuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXAgIT09IGJwKSB7XG4gICAgICAgICAgLy8gVmFsdWVzIGRpZmZlci5cbiAgICAgICAgICAvLyBDb3VsZCBoYXZlIGNoZWNrZWQgaWYgRGF0ZSwgYXJyYXlzIG9yIGJpbmFyeSB0eXBlcyBoYXZlIHNhbWVcbiAgICAgICAgICAvLyBjb250ZW50IGhlcmUgYnV0IEkgdGhpbmsgdGhhdCB3b3VsZCBiZSBhIHN1Ym9wdGltYXRpb24uXG4gICAgICAgICAgLy8gUHJlZmVyIHNpbXBsaWNpdHkuXG4gICAgICAgICAgcnZbcHJmeCArIHByb3BdID0gYltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcCAhPT0gYnApIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByaW1pdGl2ZSB2YWx1ZSBjaGFuZ2VkXG4gICAgfVxuICB9KTtcbiAga2V5cyhiKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgaWYgKCFoYXNPd24oYSwgcHJvcCkpIHtcbiAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07IC8vIFByb3BlcnR5IGFkZGVkXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJ2O1xufVxuIiwgImltcG9ydCB7XG4gIERCQ29yZUFkZFJlcXVlc3QsXG4gIERCQ29yZVB1dFJlcXVlc3QsXG4gIERCQ29yZURlbGV0ZVJlcXVlc3QsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVUYWJsZSxcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVmZmVjdGl2ZUtleXMgKFxuICBwcmltYXJ5S2V5OiBEQkNvcmVJbmRleCxcbiAgcmVxOiAoUGljazxEQkNvcmVBZGRSZXF1ZXN0IHwgREJDb3JlUHV0UmVxdWVzdCwgXCJ0eXBlXCIgfCBcInZhbHVlc1wiPiAmIHtrZXlzPzogYW55W119KSB8IFBpY2s8REJDb3JlRGVsZXRlUmVxdWVzdCwgXCJrZXlzXCIgfCBcInR5cGVcIj4pXG57XG4gIC8vY29uc3Qge291dGJvdW5kfSA9IHByaW1hcnlLZXk7XG4gIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHJldHVybiByZXEua2V5cztcbiAgcmV0dXJuIHJlcS5rZXlzIHx8IHJlcS52YWx1ZXMubWFwKHByaW1hcnlLZXkuZXh0cmFjdEtleSlcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVNdXRhdGVSZXNwb25zZSxcbiAgREJDb3JlRGVsZXRlUmFuZ2VSZXF1ZXN0LFxuICBEQkNvcmVBZGRSZXF1ZXN0LFxuICBEQkNvcmVQdXRSZXF1ZXN0LFxuICBEQkNvcmVEZWxldGVSZXF1ZXN0LFxuICBEQkNvcmVUcmFuc2FjdGlvbixcbiAgREJDb3JlS2V5UmFuZ2Vcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IG5vcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgaGFzT3duLCBzZXRCeUtleVBhdGggfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBQU0QgfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2UnO1xuLy9pbXBvcnQgeyBMb2NrYWJsZVRhYmxlTWlkZGxld2FyZSB9IGZyb20gJy4uL2RiY29yZS9sb2NrYWJsZS10YWJsZS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGdldEVmZmVjdGl2ZUtleXMgfSBmcm9tICcuLi9kYmNvcmUvZ2V0LWVmZmVjdGl2ZS1rZXlzJztcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL2NsYXNzZXMvdHJhbnNhY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaG9va3NNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gID0ge1xuICBzdGFjazogXCJkYmNvcmVcIixcbiAgbmFtZTogXCJIb29rc01pZGRsZXdhcmVcIixcbiAgbGV2ZWw6IDIsXG4gIGNyZWF0ZTogKGRvd25Db3JlOiBEQkNvcmUpID0+ICh7XG4gICAgLi4uZG93bkNvcmUsXG4gICAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IGRvd25UYWJsZSA9IGRvd25Db3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICBjb25zdCB7cHJpbWFyeUtleX0gPSBkb3duVGFibGUuc2NoZW1hO1xuICBcbiAgICAgIGNvbnN0IHRhYmxlTWlkZGxld2FyZTogREJDb3JlVGFibGUgPSB7XG4gICAgICAgIC4uLmRvd25UYWJsZSxcbiAgICAgICAgbXV0YXRlKHJlcSk6UHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnMgYXMgVHJhbnNhY3Rpb247XG4gICAgICAgICAgLy8gSG9va3MgY2FuIGJlIHRyYW5zYWN0aW9uLWJvdW5kLiBOZWVkIHRvIGdyYWIgdGhlbSBmcm9tIHRyYW5zYWN0aW9uLnRhYmxlIGFuZCBub3RcbiAgICAgICAgICAvLyBkYi50YWJsZSFcbiAgICAgICAgICBjb25zdCB7ZGVsZXRpbmcsIGNyZWF0aW5nLCB1cGRhdGluZ30gPSBkeFRyYW5zLnRhYmxlKHRhYmxlTmFtZSkuaG9vaztcbiAgICAgICAgICBzd2l0Y2ggKHJlcS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ3B1dCc6XG4gICAgICAgICAgICAgIGlmIChjcmVhdGluZy5maXJlID09PSBub3AgJiYgdXBkYXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgIGlmIChkZWxldGluZy5maXJlID09PSBub3ApIGJyZWFrO1xuICAgICAgICAgICAgICByZXR1cm4gZHhUcmFucy5fcHJvbWlzZSgncmVhZHdyaXRlJywgKCk9PmFkZFB1dE9yRGVsZXRlKHJlcSksIHRydWUpO1xuICAgICAgICAgICAgY2FzZSAnZGVsZXRlUmFuZ2UnOlxuICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5kZWxldGVSYW5nZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQW55IG9mIHRoZSBicmVha3MgYWJvdmUgaGFwcGVuZWQgKG5vIGhvb2tzKSAtIGRvIHRoZSBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSk7XG5cblxuICAgICAgICAgIGZ1bmN0aW9uIGFkZFB1dE9yRGVsZXRlKHJlcTogREJDb3JlQWRkUmVxdWVzdCB8IERCQ29yZVB1dFJlcXVlc3QgfCBEQkNvcmVEZWxldGVSZXF1ZXN0KTogUHJvbWlzZTxEQkNvcmVNdXRhdGVSZXNwb25zZT4ge1xuICAgICAgICAgICAgY29uc3QgZHhUcmFucyA9IFBTRC50cmFucztcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSByZXEua2V5cyB8fCBnZXRFZmZlY3RpdmVLZXlzKHByaW1hcnlLZXksIHJlcSk7XG4gICAgICAgICAgICBpZiAoIWtleXMpIHRocm93IG5ldyBFcnJvcihcIktleXMgbWlzc2luZ1wiKTtcbiAgICAgICAgICAgIC8vIENsb25lIFJlcXVlc3QgYW5kIHNldCBrZXlzIGFyZ1xuICAgICAgICAgICAgcmVxID0gcmVxLnR5cGUgPT09ICdhZGQnIHx8IHJlcS50eXBlID09PSAncHV0JyA/XG4gICAgICAgICAgICAgIHsuLi5yZXEsIGtleXN9IDpcbiAgICAgICAgICAgICAgey4uLnJlcX07XG4gICAgICAgICAgICBpZiAocmVxLnR5cGUgIT09ICdkZWxldGUnKSByZXEudmFsdWVzID0gWy4uLnJlcS52YWx1ZXNdO1xuICAgICAgICAgICAgaWYgKHJlcS5rZXlzKSByZXEua2V5cyA9IFsuLi5yZXEua2V5c107XG4gIFxuICAgICAgICAgICAgcmV0dXJuIGdldEV4aXN0aW5nVmFsdWVzKGRvd25UYWJsZSwgcmVxLCBrZXlzKS50aGVuIChleGlzdGluZ1ZhbHVlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRzID0ga2V5cy5tYXAoKGtleSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBleGlzdGluZ1ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB7IG9uZXJyb3I6IG51bGwsIG9uc3VjY2VzczogbnVsbCB9O1xuICAgICAgICAgICAgICAgIGlmIChyZXEudHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgIGRlbGV0aW5nLmZpcmUuY2FsbChjdHgsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXEudHlwZSA9PT0gJ2FkZCcgfHwgZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYWRkKCkgb3IgcHV0KCkgcmVzdWx0ZWQgaW4gYSBjcmVhdGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFByaW1hcnlLZXkgPSBjcmVhdGluZy5maXJlLmNhbGwoY3R4LCBrZXksIHJlcS52YWx1ZXNbaV0sIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBudWxsICYmIGdlbmVyYXRlZFByaW1hcnlLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBnZW5lcmF0ZWRQcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgICAgICByZXEua2V5c1tpXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5Lm91dGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcS52YWx1ZXNbaV0sIHByaW1hcnlLZXkua2V5UGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgcHV0KCkgb3BlcmF0aW9uIHJlc3VsdGVkIGluIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0RGlmZiA9IGdldE9iamVjdERpZmYoZXhpc3RpbmdWYWx1ZSwgcmVxLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsQ2hhbmdlcyA9IHVwZGF0aW5nLmZpcmUuY2FsbChjdHgsIG9iamVjdERpZmYsIGtleSwgZXhpc3RpbmdWYWx1ZSwgZHhUcmFucyk7XG4gICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVmFsdWUgPSByZXEudmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRpdGlvbmFsQ2hhbmdlcykuZm9yRWFjaChrZXlQYXRoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2V5UGF0aCBpcyBhbHJlYWR5IHByZXNlbnQgYXMgYSBsaXRlcmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFZhbHVlW2tleVBhdGhdID0gYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleVBhdGggcmVwcmVzZW50cyBhIG5ldyBvciBleGlzdGluZyBwYXRoIGludG8gdGhlIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKHJlcXVlc3RlZFZhbHVlLCBrZXlQYXRoLCBhZGRpdGlvbmFsQ2hhbmdlc1trZXlQYXRoXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBkb3duVGFibGUubXV0YXRlKHJlcSkudGhlbigoe2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8a2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJpbUtleSA9IHJlc3VsdHMgPyByZXN1bHRzW2ldIDoga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKHByaW1LZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihmYWlsdXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgub25zdWNjZXNzICYmIGN0eC5vbnN1Y2Nlc3MoXG4gICAgICAgICAgICAgICAgICAgICAgcmVxLnR5cGUgPT09ICdwdXQnICYmIGV4aXN0aW5nVmFsdWVzW2ldID8gLy8gdGhlIHB1dCByZXN1bHRlZCBpbiBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS52YWx1ZXNbaV0gOiAvLyB1cGRhdGUgaG9va3MgZXhwZWN0cyBleGlzdGluZyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbUtleSAvLyBjcmVhdGUgaG9va3MgZXhwZWN0cyBwcmltYXJ5IGtleVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge2ZhaWx1cmVzLCByZXN1bHRzLCBudW1GYWlsdXJlcywgbGFzdFJlc3VsdH07XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGN0eCA9PiBjdHgub25lcnJvciAmJiBjdHgub25lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBmdW5jdGlvbiBkZWxldGVSYW5nZShyZXE6IERCQ29yZURlbGV0ZVJhbmdlUmVxdWVzdCk6IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVOZXh0Q2h1bmsocmVxLnRyYW5zLCByZXEucmFuZ2UsIDEwMDAwKTtcbiAgICAgICAgICB9XG4gIFxuICAgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZU5leHRDaHVuayh0cmFuczogREJDb3JlVHJhbnNhY3Rpb24sIHJhbmdlOiBEQkNvcmVLZXlSYW5nZSwgbGltaXQ6IG51bWJlcikge1xuICAgICAgICAgICAgLy8gUXVlcnkgd2hhdCBrZXlzIGluIHRoZSBEQiB3aXRoaW4gdGhlIGdpdmVuIHJhbmdlXG4gICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLnF1ZXJ5KHt0cmFucywgdmFsdWVzOiBmYWxzZSwgcXVlcnk6IHtpbmRleDogcHJpbWFyeUtleSwgcmFuZ2V9LCBsaW1pdH0pXG4gICAgICAgICAgICAudGhlbigoe3Jlc3VsdH0pID0+IHtcbiAgICAgICAgICAgICAgLy8gR2l2ZW4gYSBzZXQgb2Yga2V5cywgYnVsayBkZWxldGUgdGhvc2UgdXNpbmcgdGhlIHNhbWUgcHJvY2VkdXJlIGFzIGluIGFkZFB1dE9yRGVsZXRlKCkuXG4gICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgdGhhdCBkZWxldGluZyBob29rIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAgcmV0dXJuIGFkZFB1dE9yRGVsZXRlKHt0eXBlOiAnZGVsZXRlJywga2V5czogcmVzdWx0LCB0cmFuc30pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLm51bUZhaWx1cmVzID4gMCkgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcy5mYWlsdXJlc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtmYWlsdXJlczogW10sIG51bUZhaWx1cmVzOiAwLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9IGFzIERCQ29yZU11dGF0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHRyYW5zLCB7Li4ucmFuZ2UsIGxvd2VyOiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLCBsb3dlck9wZW46IHRydWV9LCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgLy9jb25zdCB7bG9jaywgbG9ja2FibGVNaWRkbGV3YXJlfSA9IExvY2thYmxlVGFibGVNaWRkbGV3YXJlKHRhYmxlTWlkZGxld2FyZSk7XG5cbiAgICAgIHJldHVybiB0YWJsZU1pZGRsZXdhcmU7XG4gICAgfSxcbiAgfSkgYXMgREJDb3JlXG59O1xuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ1ZhbHVlcyhcbiAgdGFibGU6IERCQ29yZVRhYmxlLFxuICByZXE6IERCQ29yZUFkZFJlcXVlc3QgfCBEQkNvcmVQdXRSZXF1ZXN0IHwgREJDb3JlRGVsZXRlUmVxdWVzdCxcbiAgZWZmZWN0aXZlS2V5czogYW55W11cbikge1xuICByZXR1cm4gcmVxLnR5cGUgPT09IFwiYWRkXCJcbiAgICA/IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICA6IHRhYmxlLmdldE1hbnkoeyB0cmFuczogcmVxLnRyYW5zLCBrZXlzOiBlZmZlY3RpdmVLZXlzLCBjYWNoZTogXCJpbW11dGFibGVcIiB9KTtcbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBEQkNvcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiY29yZVwiO1xuaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZVwiO1xuaW1wb3J0IFByb21pc2UgZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vZnVuY3Rpb25zL2NtcCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZShcbiAga2V5czogYW55W10sXG4gIGNhY2hlOiB7IGtleXM6IGFueVtdOyB2YWx1ZXM6IGFueVtdIH0gfCB1bmRlZmluZWQgfCBudWxsLFxuICBjbG9uZT86IGJvb2xlYW5cbikge1xuICB0cnkge1xuICAgIGlmICghY2FjaGUpIHJldHVybiBudWxsO1xuICAgIGlmIChjYWNoZS5rZXlzLmxlbmd0aCA8IGtleXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgLy8gQ29tcGFyZSBpZiB0aGUgZXhhY3Qgc2FtZSBvcmRlciBvZiBrZXlzIHdhcyByZXRyaWV2ZWQgaW4gc2FtZSB0cmFuc2FjdGlvbjpcbiAgICAvLyBBbGxvdyBzb21lIGNhY2hlZCBrZXlzIHRvIGJlIG9taXR0ZWQgZnJvbSBwcm92aWRlZCBzZXQgb2Yga2V5c1xuICAgIC8vIFVzZSBjYXNlOiAxLiBnZXRNYW55KGtleXMpIDIuIHVwZGF0ZSBhIHN1YnNldCBvZiB0aG9zZSAzLiBjYWxsIHB1dCB3aXRoIHRoZSB1cGRhdGVkIG9uZXMgPT0+IG1pZGRsZXdhcmVzIHNob3VsZCBiZSBhYmxlIHRvIGZpbmQgb2xkIHZhbHVlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNhY2hlLmtleXMubGVuZ3RoICYmIGogPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoY21wKGNhY2hlLmtleXNbaV0sIGtleXNbal0pICE9PSAwKSBjb250aW51ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGNsb25lID8gZGVlcENsb25lKGNhY2hlLnZhbHVlc1tpXSkgOiBjYWNoZS52YWx1ZXNbaV0pO1xuICAgICAgKytqO1xuICAgIH1cbiAgICAvLyBJZiBnb3QgYWxsIGtleXMgY2FsbGVyIHdhcyBsb29raW5nIGZvciwgcmV0dXJuIHJlc3VsdC5cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0ga2V5cy5sZW5ndGggPyByZXN1bHQgOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmU6IE1pZGRsZXdhcmU8REJDb3JlPiA9IHtcbiAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gIGxldmVsOiAtMSxcbiAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcS5jYWNoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkUmVzdWx0ID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoXG4gICAgICAgICAgICAgIHJlcS5rZXlzLFxuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0sXG4gICAgICAgICAgICAgIHJlcS5jYWNoZSA9PT0gXCJjbG9uZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFibGUuZ2V0TWFueShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5czogcmVxLmtleXMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiByZXEuY2FjaGUgPT09IFwiY2xvbmVcIiA/IGRlZXBDbG9uZShyZXMpIDogcmVzLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgb24gYW55IG11dGF0ZSBleGNlcHQgXCJhZGRcIiB3aGljaCBjYW4ndCBjaGFuZ2UgZXhpc3RpbmcgdmFsdWVzOlxuICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSBcImFkZFwiKSByZXEudHJhbnNbXCJfY2FjaGVcIl0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG59O1xuIiwgImltcG9ydCB7IGNtcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY21wXCI7XG5pbXBvcnQgeyBleHRlbmQsIGl0ZXJhdG9yU3ltYm9sLCBwcm9wcyB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBJbmRleGFibGVUeXBlIH0gZnJvbSAnLi4vcHVibGljJztcbmltcG9ydCB7XG4gIEVtcHR5UmFuZ2UsXG4gIEludGVydmFsVHJlZSxcbiAgSW50ZXJ2YWxUcmVlTm9kZSxcbiAgUmFuZ2VTZXRDb25zdHJ1Y3RvcixcbiAgUmFuZ2VTZXRQcm90b3R5cGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvcmFuZ2VzZXRcIjtcblxuLyogQW4gaW50ZXJ2YWwgdHJlZSBpbXBsZW1lbnRhdGlvbiB0byBlZmZpY2llbnRseSBkZXRlY3Qgb3ZlcmxhcHBpbmcgcmFuZ2VzIG9mIHF1ZXJpZWQgaW5kZXhlcy5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcnZhbF90cmVlXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBpc0VtcHR5UmFuZ2Uobm9kZTogSW50ZXJ2YWxUcmVlIHwge2Zyb206IEluZGV4YWJsZVR5cGUsIHRvOiBJbmRleGFibGVUeXBlfSk6IG5vZGUgaXMgRW1wdHlSYW5nZSB7XG4gIHJldHVybiAhKFwiZnJvbVwiIGluIG5vZGUpO1xufVxuXG5leHBvcnQgdHlwZSBSYW5nZVNldCA9IFJhbmdlU2V0UHJvdG90eXBlICYgSW50ZXJ2YWxUcmVlO1xuXG5leHBvcnQgY29uc3QgUmFuZ2VTZXQgPSBmdW5jdGlvbihmcm9tT3JUcmVlOiBhbnksIHRvPzogYW55KSB7XG4gIGlmICh0aGlzKSB7XG4gICAgLy8gQ2FsbGVkIHdpdGggbmV3KClcbiAgICBleHRlbmQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IHtkOjEsIGZyb206IGZyb21PclRyZWUsIHRvOiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHRvIDogZnJvbU9yVHJlZX0gOiB7ZDowfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FsbGVkIHdpdGhvdXQgbmV3KClcbiAgICBjb25zdCBydiA9IG5ldyBSYW5nZVNldCgpO1xuICAgIGlmIChmcm9tT3JUcmVlICYmIChcImRcIiBpbiBmcm9tT3JUcmVlKSkge1xuICAgICAgZXh0ZW5kKHJ2LCBmcm9tT3JUcmVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9XG59IGFzIFJhbmdlU2V0Q29uc3RydWN0b3I7XG5cbnByb3BzKFJhbmdlU2V0LnByb3RvdHlwZSwge1xuICBhZGQocmFuZ2VTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgICBtZXJnZVJhbmdlcyh0aGlzLCByYW5nZVNldCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleShrZXk6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEtleXMoa2V5czogSW5kZXhhYmxlVHlwZVtdKSB7XG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRSYW5nZSh0aGlzLCBrZXksIGtleSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIFtpdGVyYXRvclN5bWJvbF0oKTogSXRlcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGdldFJhbmdlU2V0SXRlcmF0b3IodGhpcyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRSYW5nZSh0YXJnZXQ6IEludGVydmFsVHJlZSwgZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGUpIHtcbiAgY29uc3QgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gIC8vIGNtcCgpIHJldHVybnMgTmFOIGlmIG9uZSBvZiB0aGUgYXJncyBhcmUgSURCLWludmFsaWQga2V5cy5cbiAgLy8gQXZvaWQgc3RvcmluZyBpbnZhbGlkIGtleXMgaW4gcmFuZ2VzZXQ6XG4gIGlmIChpc05hTihkaWZmKSkgcmV0dXJuO1xuXG4gIC8vIENhbGxlciBpcyB0cnlpbmcgdG8gYWRkIGEgcmFuZ2Ugd2hlcmUgZnJvbSBpcyBncmVhdGVyIHRoYW4gdG86XG4gIGlmIChkaWZmID4gMCkgdGhyb3cgUmFuZ2VFcnJvcigpO1xuICBcbiAgaWYgKGlzRW1wdHlSYW5nZSh0YXJnZXQpKSByZXR1cm4gZXh0ZW5kKHRhcmdldCwgeyBmcm9tLCB0bywgZDogMSB9KTtcbiAgY29uc3QgbGVmdCA9IHRhcmdldC5sO1xuICBjb25zdCByaWdodCA9IHRhcmdldC5yO1xuICBpZiAoY21wKHRvLCB0YXJnZXQuZnJvbSkgPCAwKSB7XG4gICAgbGVmdFxuICAgICAgPyBhZGRSYW5nZShsZWZ0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5sID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgaWYgKGNtcChmcm9tLCB0YXJnZXQudG8pID4gMCkge1xuICAgIHJpZ2h0XG4gICAgICA/IGFkZFJhbmdlKHJpZ2h0LCBmcm9tLCB0bylcbiAgICAgIDogKHRhcmdldC5yID0geyBmcm9tLCB0bywgZDogMSwgbDogbnVsbCwgcjogbnVsbCB9KTtcbiAgICByZXR1cm4gcmViYWxhbmNlKHRhcmdldCk7XG4gIH1cbiAgLy8gTm93IHdlIGhhdmUgc29tZSBraW5kIG9mIG92ZXJsYXAuIFdlIHdpbGwgYmUgYWJsZSB0byBtZXJnZSB0aGUgbmV3IHJhbmdlIGludG8gdGhlIG5vZGUgb3IgbGV0IGl0IGJlIHN3YWxsb3dlZC5cblxuICAvLyBHcm93IGxlZnQ/XG4gIGlmIChjbXAoZnJvbSwgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgIHRhcmdldC5mcm9tID0gZnJvbTtcbiAgICB0YXJnZXQubCA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gcmlnaHQgPyByaWdodC5kICsgMSA6IDE7XG4gIH1cbiAgLy8gR3JvdyByaWdodD9cbiAgaWYgKGNtcCh0bywgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICB0YXJnZXQudG8gPSB0bztcbiAgICB0YXJnZXQuciA9IG51bGw7IC8vIEN1dCBvZmYgZm9yIG5vdy4gUmUtYWRkIGxhdGVyLlxuICAgIHRhcmdldC5kID0gdGFyZ2V0LmwgPyB0YXJnZXQubC5kICsgMSA6IDE7XG4gIH1cbiAgY29uc3QgcmlnaHRXYXNDdXRPZmYgPSAhdGFyZ2V0LnI7XG4gIC8vIFJlLWFkZCBsZWZ0P1xuICBpZiAobGVmdCAmJiAhdGFyZ2V0LmwpIHtcbiAgICAvL1JhbmdlcyB0byB0aGUgbGVmdCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCBsZWZ0KTtcbiAgfVxuICAvLyBSZS1hZGQgcmlnaHQ/XG4gIGlmIChyaWdodCAmJiByaWdodFdhc0N1dE9mZikge1xuICAgIC8vUmFuZ2VzIHRvIHRoZSByaWdodCBtYXkgYmUgc3dhbGxvd2VkLiBDdXQgaXQgb2YgYW5kIHJlLWFkZCBhbGwuXG4gICAgLy9Db3VsZCBwcm9iYWJseSBiZSBkb25lIG1vcmUgZWZmaWNpZW50bHkhXG4gICAgbWVyZ2VSYW5nZXModGFyZ2V0LCByaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmFuZ2VzKHRhcmdldDogSW50ZXJ2YWxUcmVlLCBuZXdTZXQ6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pIHtcbiAgZnVuY3Rpb24gX2FkZFJhbmdlU2V0KFxuICAgIHRhcmdldDogSW50ZXJ2YWxUcmVlLFxuICAgIHsgZnJvbSwgdG8sIGwsIHIgfTogSW50ZXJ2YWxUcmVlTm9kZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZSwgbD86IHVuZGVmaW5lZCwgcj86IHVuZGVmaW5lZH1cbiAgKSB7XG4gICAgYWRkUmFuZ2UodGFyZ2V0LCBmcm9tLCB0byk7XG4gICAgaWYgKGwpIF9hZGRSYW5nZVNldCh0YXJnZXQsIGwpO1xuICAgIGlmIChyKSBfYWRkUmFuZ2VTZXQodGFyZ2V0LCByKTtcbiAgfVxuXG4gIGlmKCFpc0VtcHR5UmFuZ2UobmV3U2V0KSkgX2FkZFJhbmdlU2V0KHRhcmdldCwgbmV3U2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlc092ZXJsYXAoXG4gIHJhbmdlU2V0MTogSW50ZXJ2YWxUcmVlLFxuICByYW5nZVNldDI6IEludGVydmFsVHJlZVxuKTogYm9vbGVhbiB7XG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIG90aGVyIGZyb20gc2NyYXRjaC5cbiAgICBjb25zdCBpMSA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQyKTtcbiAgICBsZXQgbmV4dFJlc3VsdDEgPSBpMS5uZXh0KCk7XG4gICAgaWYgKG5leHRSZXN1bHQxLmRvbmUpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYSA9IG5leHRSZXN1bHQxLnZhbHVlO1xuXG4gICAgLy8gU3RhcnQgaXRlcmF0aW5nIHRoaXMgZnJvbSBzdGFydCBvZiBvdGhlclxuICAgIGNvbnN0IGkyID0gZ2V0UmFuZ2VTZXRJdGVyYXRvcihyYW5nZVNldDEpO1xuICAgIGxldCBuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKTsgLy8gU3RhcnQgZnJvbSBiZWdpbm5pbmcgb2Ygb3RoZXIgcmFuZ2VcbiAgICBsZXQgYiA9IG5leHRSZXN1bHQyLnZhbHVlO1xuXG4gICAgd2hpbGUgKCFuZXh0UmVzdWx0MS5kb25lICYmICFuZXh0UmVzdWx0Mi5kb25lKSB7XG4gICAgICBpZiAoY21wKGIhLmZyb20sIGEudG8pIDw9IDAgJiYgY21wKGIhLnRvLCBhLmZyb20pID49IDApIHJldHVybiB0cnVlO1xuICAgICAgY21wKGEuZnJvbSwgYiEuZnJvbSkgPCAwXG4gICAgICAgID8gKGEgPSAobmV4dFJlc3VsdDEgPSBpMS5uZXh0KGIhLmZyb20pKS52YWx1ZSEpIC8vIGEgaXMgYmVoaW5kLiBmb3J3YXJkIGl0IHRvIGJlZ2lubmluZyBvZiBuZXh0IGItcmFuZ2VcbiAgICAgICAgOiAoYiA9IChuZXh0UmVzdWx0MiA9IGkyLm5leHQoYS5mcm9tKSkudmFsdWUpOyAvLyBiIGlzIGJlaGluZC4gZm9yd2FyZCBpdCB0byBiZWdpbm5pbmcgb2YgbmV4dCBhLXJhbmdlXG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnR5cGUgUmFuZ2VTZXRJdGVyYXRvclN0YXRlID1cbiAgfCB7XG4gICAgICB1cD86IFJhbmdlU2V0SXRlcmF0b3JTdGF0ZTtcbiAgICAgIG46IEludGVydmFsVHJlZU5vZGU7XG4gICAgICBzOiAwIHwgMSB8IDIgfCAzO1xuICAgIH1cbiAgfCB1bmRlZmluZWRcbiAgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmdlU2V0SXRlcmF0b3IoXG4gIG5vZGU6IEVtcHR5UmFuZ2UgfCBJbnRlcnZhbFRyZWVOb2RlXG4pOiBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlIHwgdW5kZWZpbmVkPiB7XG4gIGxldCBzdGF0ZTogUmFuZ2VTZXRJdGVyYXRvclN0YXRlID0gaXNFbXB0eVJhbmdlKG5vZGUpID8gbnVsbCA6IHsgczogMCwgbjogbm9kZSB9O1xuXG4gIHJldHVybiB7XG4gICAgbmV4dChrZXk/KSB7XG4gICAgICBjb25zdCBrZXlQcm92aWRlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgICAgd2hpbGUgKHN0YXRlKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUucykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIC8vIEluaXRpYWwgc3RhdGUgZm9yIG5vZGUuXG4gICAgICAgICAgICAvLyBGYXN0IGZvcndhcmQgdG8gbGVmdG1vc3Qgbm9kZS5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAxO1xuICAgICAgICAgICAgaWYgKGtleVByb3ZpZGVkKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5uLmwgJiYgY21wKGtleSwgc3RhdGUubi5mcm9tKSA8IDApXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sKSBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLmwsIHM6IDEgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGZhbGwgaW50byBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gV2UncmUgb24gYSBub2RlIHdoZXJlIGl0J3MgbGVmdCBwYXJ0IGlzIGFscmVhZHkgaGFuZGxlZCBvciBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgICAgIHN0YXRlLnMgPSAyO1xuICAgICAgICAgICAgaWYgKCFrZXlQcm92aWRlZCB8fCBjbXAoa2V5LCBzdGF0ZS5uLnRvKSA8PSAwKVxuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc3RhdGUubiwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBXZSd2ZSBlbWl0dGVkIG91ciBub2RlIGFuZCBzaG91bGQgY29udGludWUgd2l0aCB0aGUgcmlnaHQgcGFydCBvciBsZXQgcGFyZW50IHRha2Ugb3ZlciBmcm9tIGl0J3Mgc3RhdGUgMVxuICAgICAgICAgICAgaWYgKHN0YXRlLm4ucikge1xuICAgICAgICAgICAgICBzdGF0ZS5zID0gMzsgLy8gU28gd2hlbiBjaGlsZCBpcyBkb25lLCB3ZSBrbm93IHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4uciwgczogMCB9O1xuICAgICAgICAgICAgICBjb250aW51ZTsgLy8gV2lsbCBmYWxsIGluIHRvIGNhc2UgMCB3aXRoIGZhc3QgZm9yd2FyZCB0byBsZWZ0IGxlYWYgb2YgdGhpcyBzdWJ0cmVlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZmFsbCBpbnRvIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLnVwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgfSxcbiAgfSBhcyBHZW5lcmF0b3I8SW50ZXJ2YWxUcmVlTm9kZSwgdW5kZWZpbmVkLCBJbmRleGFibGVUeXBlPjtcbn1cblxuZnVuY3Rpb24gcmViYWxhbmNlKHRhcmdldDogSW50ZXJ2YWxUcmVlTm9kZSkge1xuICBjb25zdCBkaWZmID0gKHRhcmdldC5yPy5kIHx8IDApIC0gKHRhcmdldC5sPy5kIHx8IDApO1xuICBjb25zdCByID0gZGlmZiA+IDEgPyBcInJcIiA6IGRpZmYgPCAtMSA/IFwibFwiIDogXCJcIjtcbiAgaWYgKHIpIHtcblxuICAgIC8vIFJvdGF0ZSAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV9yb3RhdGlvbilcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbT0xEUk9PVF1cbiAgICAvLyAgICAgICBbT0xEUk9PVC5MXSAgICAgICAgICAgIFtORVdST09UXVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgW05FV1JPT1QuTF0gW05FV1JPT1QuUl1cbiAgICAvL1xuICAgIC8vIElzIGdvaW5nIHRvIGJlY29tZTpcbiAgICAvL1xuICAgIC8vIFxuICAgIC8vICAgICAgICAgICAgICAgICAgICBbTkVXUk9PVF1cbiAgICAvLyAgICAgICAgW09MRFJPT1RdICAgICAgICAgICAgIFtORVdST09ULlJdXG4gICAgLy8gW09MRFJPT1QuTF0gW05FV1JPT1QuTF0gIFxuXG4gICAgLy8gKiBjbG9uZSBub3cgaGFzIHRoZSBwcm9wcyBvZiBPTERST09UXG4gICAgLy8gUGxhbjpcbiAgICAvLyAqIHRhcmdldCBtdXN0IGJlIGdpdmVuIHRoZSBwcm9wcyBvZiBORVdST09UXG4gICAgLy8gKiB0YXJnZXRbbF0gbXVzdCBwb2ludCB0byBhIG5ldyBPTERST09UXG4gICAgLy8gKiB0YXJnZXRbcl0gbXVzdCBwb2ludCB0byBORVdST09ULlJcbiAgICAvLyAqIE9MRFJPT1Rbcl0gbXVzdCBwb2ludCB0byBORVdST09ULkxcbiAgICBjb25zdCBsID0gciA9PT0gXCJyXCIgPyBcImxcIiA6IFwiclwiOyAvLyBTdXBwb3J0IGJvdGggbGVmdC9yaWdodCByb3RhdGlvblxuICAgIGNvbnN0IHJvb3RDbG9uZSA9IHsgLi4udGFyZ2V0IH07XG4gICAgLy8gV2UncmUgZ29ubmEgY29weSBwcm9wcyBmcm9tIHRhcmdldCdzIHJpZ2h0IG5vZGUgaW50byB0YXJnZXQgc28gdGhhdCB0YXJnZXQgd2lsbFxuICAgIC8vIGhhdmUgc2FtZSByYW5nZSBhcyBvbGQgdGFyZ2V0W3JdIChpbnN0ZWFkIG9mIGNoYW5naW5nIHBvaW50ZXJzLCB3ZSBjb3B5IHZhbHVlcy5cbiAgICAvLyB0aGF0IHdheSB3ZSBkbyBub3QgbmVlZCB0byBhZGp1c3QgcG9pbnRlcnMgaW4gcGFyZW50cykuXG4gICAgY29uc3Qgb2xkUm9vdFJpZ2h0ID0gdGFyZ2V0W3JdOyBcbiAgICB0YXJnZXQuZnJvbSA9IG9sZFJvb3RSaWdodC5mcm9tO1xuICAgIHRhcmdldC50byA9IG9sZFJvb3RSaWdodC50bztcbiAgICB0YXJnZXRbcl0gPSBvbGRSb290UmlnaHRbcl07XG4gICAgcm9vdENsb25lW3JdID0gb2xkUm9vdFJpZ2h0W2xdO1xuICAgIHRhcmdldFtsXSA9IHJvb3RDbG9uZTtcbiAgICByb290Q2xvbmUuZCA9IGNvbXB1dGVEZXB0aChyb290Q2xvbmUpO1xuICB9XG4gIHRhcmdldC5kID0gY29tcHV0ZURlcHRoKHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZXB0aCh7IHIsIGwgfTogUGljazxJbnRlcnZhbFRyZWVOb2RlLCBcImxcIiB8IFwiclwiPikge1xuICByZXR1cm4gKHIgPyAobCA/IE1hdGgubWF4KHIuZCwgbC5kKSA6IHIuZCkgOiBsID8gbC5kIDogMCkgKyAxO1xufVxuIiwgImltcG9ydCB7IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlIH0gZnJvbSBcIi4uL2RiY29yZS9jYWNoZS1leGlzdGluZy12YWx1ZXMtbWlkZGxld2FyZVwiO1xuaW1wb3J0IHsgY21wIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy9jbXBcIjtcbmltcG9ydCB7IGlzQXJyYXksIGtleXMgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBQU0QgfSBmcm9tIFwiLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBSYW5nZVNldCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5pbXBvcnQgeyBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcbmltcG9ydCB7XG4gIERCQ29yZSxcbiAgREJDb3JlQ291bnRSZXF1ZXN0LFxuICBEQkNvcmVDdXJzb3IsXG4gIERCQ29yZUdldE1hbnlSZXF1ZXN0LFxuICBEQkNvcmVHZXRSZXF1ZXN0LFxuICBEQkNvcmVJbmRleCxcbiAgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlUXVlcnlSZXNwb25zZSxcbiAgREJDb3JlVGFibGUsXG4gIERCQ29yZVRhYmxlU2NoZW1hLFxuICBEQkNvcmVUcmFuc2FjdGlvbixcbn0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmVcIjtcblxuZXhwb3J0IGNvbnN0IG9ic2VydmFiaWxpdHlNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBsZXZlbDogMCxcbiAgY3JlYXRlOiAoY29yZSkgPT4ge1xuICAgIGNvbnN0IGRiTmFtZSA9IGNvcmUuc2NoZW1hLm5hbWU7XG4gICAgY29uc3QgRlVMTF9SQU5HRSA9IG5ldyBSYW5nZVNldChjb3JlLk1JTl9LRVksIGNvcmUuTUFYX0tFWSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uY29yZSxcbiAgICAgIHRhYmxlOiAodGFibGVOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgICBjb25zdCB7IHNjaGVtYSB9ID0gdGFibGU7XG4gICAgICAgIGNvbnN0IHsgcHJpbWFyeUtleSB9ID0gc2NoZW1hO1xuICAgICAgICBjb25zdCB7IGV4dHJhY3RLZXksIG91dGJvdW5kIH0gPSBwcmltYXJ5S2V5O1xuICAgICAgICBjb25zdCB0YWJsZUNsb25lOiBEQkNvcmVUYWJsZSA9IHtcbiAgICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgICBtdXRhdGU6IChyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zID0gcmVxLnRyYW5zIGFzIERCQ29yZVRyYW5zYWN0aW9uICYge1xuICAgICAgICAgICAgICBtdXRhdGVkUGFydHM/OiBPYnNlcnZhYmlsaXR5U2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG11dGF0ZWRQYXJ0cyA9XG4gICAgICAgICAgICAgIHRyYW5zLm11dGF0ZWRQYXJ0cyB8fCAodHJhbnMubXV0YXRlZFBhcnRzID0ge30pO1xuICAgICAgICAgICAgY29uc3QgZ2V0UmFuZ2VTZXQgPSAoaW5kZXhOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgIHJldHVybiAobXV0YXRlZFBhcnRzW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgKG11dGF0ZWRQYXJ0c1twYXJ0XSA9IG5ldyBSYW5nZVNldCgpKSkgYXMgUmFuZ2VTZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVsc1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCI6ZGVsc1wiKTtcblxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSByZXE7XG4gICAgICAgICAgICBsZXQgW2tleXMsIG5ld09ianNdID1cbiAgICAgICAgICAgICAgcmVxLnR5cGUgPT09IFwiZGVsZXRlUmFuZ2VcIlxuICAgICAgICAgICAgICAgID8gW3JlcS5yYW5nZV0gLy8ga2V5cyB3aWxsIGJlIGFuIERCQ29yZUtleVJhbmdlIG9iamVjdCAtIHRyYW5zZm9ybWVkIGxhdGVyIG9uIHRvIGEgW2Zyb20sdG9dLXN0eWxlIHJhbmdlLlxuICAgICAgICAgICAgICAgIDogcmVxLnR5cGUgPT09IFwiZGVsZXRlXCJcbiAgICAgICAgICAgICAgICA/IFtyZXEua2V5c10gLy8ga2V5cyBrbm93biBhbHJlYWR5IGhlcmUuIG5ld09ianMgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAgICAgICAgOiByZXEudmFsdWVzLmxlbmd0aCA8IDUwXG4gICAgICAgICAgICAgICAgPyBbW10sIHJlcS52YWx1ZXNdIC8vIGtleXMgPSBlbXB0eSBhcnJheSAtIHdpbGwgYmUgcmVzb2x2ZWQgaW4gbXV0YXRlKCkudGhlbiguLi4pLlxuICAgICAgICAgICAgICAgIDogW107IC8vIGtleXMgYW5kIG5ld09ianMgd2lsbCBib3RoIGJlIHVuZGVmaW5lZCAtIGNoYW5nZVNwZWMgd2lsbCBiZWNvbWUgdHJ1ZSAoY2hhbmdlZCBmb3IgZW50aXJlIHRhYmxlKVxuICAgICAgICAgICAgY29uc3Qgb2xkQ2FjaGUgPSByZXEudHJhbnNbXCJfY2FjaGVcIl07XG4gICAgICAgICAgICByZXR1cm4gdGFibGUubXV0YXRlKHJlcSkudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgbXV0YXRlZCB0YWJsZSBhbmQgb3B0aW9uYWxseSBrZXlzIHRvIHRoZSBtdXRhdGVkVGFibGVzIHNldCBvbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgIC8vIFVzZWQgYnkgc3Vic2NyaWJlcnMgdG8gdHhjb21taXQgZXZlbnQgYW5kIGZvciBDb2xsZWN0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUoKS5cbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgICAgICAgICAvLyBrZXlzIGlzIGFuIGFycmF5IC0gZGVsZXRlLCBhZGQgb3IgcHV0IG9mIGxlc3MgdGhhbiA1MCByb3dzLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBcImRlbGV0ZVwiKSBrZXlzID0gcmVzLnJlc3VsdHM7XG4gICAgICAgICAgICAgICAgLy8gaW5kaXZpZHVhbCBrZXlzIChhZGQgcHV0IG9yIGRlbGV0ZSlcbiAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZEtleXMoa2V5cyk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBnZXQgb2xkT2JqcyBpZiB0aGV5IGhhdmUgYmVlbiBjYWNoZWQgcmVjZW50bHlcbiAgICAgICAgICAgICAgICAvLyAoVGhpcyBhcHBsaWVzIHRvIENvbGxlY3Rpb24ubW9kaWZ5KCkgb25seSwgYnV0IGFsc28gaWYgdXBkYXRpbmcvZGVsZXRpbmcgaG9va3MgaGF2ZSBzdWJzY3JpYmVycylcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRPYmpzID0gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoa2V5cywgb2xkQ2FjaGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3VwcGx5IGRldGFpbGVkIHZhbHVlcyBwZXIgaW5kZXggZm9yIGJvdGggb2xkIGFuZCBuZXcgb2JqZWN0czpcbiAgICAgICAgICAgICAgICBpZiAoIW9sZE9ianMgJiYgdHlwZSAhPT0gXCJhZGRcIikge1xuICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9yIHB1dCBhbmQgd2UgZG9uJ3Qga25vdyBvbGQgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgdGhpcyBpbiB0aGUgXCI6ZGVsc1wiIHBhcnQsIGZvciB0aGUgc2FrZSBvZiBjb3VudCgpIHF1ZXJpZXMgb25seSFcbiAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkT2JqcyB8fCBuZXdPYmpzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBObyBtYXR0ZXIgaWYga25vd25pbmcgb2xkT2JqcyBvciBub3QsIHRyYWNrIHRoZSBpbmRpY2VzIGlmIGl0J3MgYSBwdXQsIGFkZCBvciBkZWxldGUuXG4gICAgICAgICAgICAgICAgICB0cmFja0FmZmVjdGVkSW5kZXhlcyhnZXRSYW5nZVNldCwgc2NoZW1hLCBvbGRPYmpzLCBuZXdPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5cykge1xuICAgICAgICAgICAgICAgIC8vIEFzIHdlIGNhbid0IGtub3cgZGVsZXRlZCBpbmRleCByYW5nZXMsIG1hcmsgaW5kZXgtYmFzZWQgc3Vic2NyaXB0aW9ucyBtdXN0IHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7IGZyb206IGtleXMubG93ZXIsIHRvOiBrZXlzLnVwcGVyIH07XG4gICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlUmFuZ2UuIGtleXMgaXMgYSBEQkNvcmVLZXlSYW5nZSBvYmplY3RzLiBUcmFuc2Zvcm0gaXQgdG8gW2Zyb20sdG9dLXN0eWxlIHJhbmdlLlxuICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKHJhbmdlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUb28gbWFueSByZXF1ZXN0cyB0byByZWNvcmQgdGhlIGRldGFpbHMgd2l0aG91dCBzbG93aW5nIGRvd24gd3JpdGUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgLy8gTGV0J3MganVzdCByZWNvcmQgYSBnZW5lcmljIGxhcmdlIHJhbmdlIG9uIHByaW1hcnkga2V5LCB0aGUgdmlydHVhbCA6ZGVscyBpbmRleCBhbmRcbiAgICAgICAgICAgICAgICAvLyBhbGwgc2Vjb25kYXJ5IGluZGljZXM6XG4gICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZChGVUxMX1JBTkdFKTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBnZXRSYW5nZVNldChpZHgubmFtZSkuYWRkKEZVTExfUkFOR0UpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBnZXRSYW5nZTogKHJlcTogYW55KSA9PiBbREJDb3JlSW5kZXgsIFJhbmdlU2V0XSA9ICh7XG4gICAgICAgICAgcXVlcnk6IHsgaW5kZXgsIHJhbmdlIH0sXG4gICAgICAgIH06XG4gICAgICAgICAgfCBEQkNvcmVRdWVyeVJlcXVlc3RcbiAgICAgICAgICB8IERCQ29yZUNvdW50UmVxdWVzdFxuICAgICAgICAgIHwgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpID0+IFtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBuZXcgUmFuZ2VTZXQocmFuZ2UubG93ZXIgPz8gY29yZS5NSU5fS0VZLCByYW5nZS51cHBlciA/PyBjb3JlLk1BWF9LRVkpLFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IHJlYWRTdWJzY3JpYmVyczoge1ttZXRob2QgaW5cbiAgICAgICAgICBFeGNsdWRlPGtleW9mIERCQ29yZVRhYmxlLCBcIm5hbWVcIiB8IFwic2NoZW1hXCIgfCBcIm11dGF0ZVwiPl06IFxuICAgICAgICAgIChyZXE6IGFueSkgPT4gW0RCQ29yZUluZGV4LCBSYW5nZVNldF1cbiAgICAgICAgfSA9IHtcbiAgICAgICAgICBnZXQ6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQocmVxLmtleSldLFxuICAgICAgICAgIGdldE1hbnk6IChyZXEpID0+IFtwcmltYXJ5S2V5LCBuZXcgUmFuZ2VTZXQoKS5hZGRLZXlzKHJlcS5rZXlzKV0sXG4gICAgICAgICAgY291bnQ6IGdldFJhbmdlLFxuICAgICAgICAgIHF1ZXJ5OiBnZXRSYW5nZSxcbiAgICAgICAgICBvcGVuQ3Vyc29yOiBnZXRSYW5nZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGtleXMocmVhZFN1YnNjcmliZXJzKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgdGFibGVDbG9uZVttZXRob2RdID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgcmVxOlxuICAgICAgICAgICAgICB8IERCQ29yZUdldFJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVHZXRNYW55UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZVF1ZXJ5UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZUNvdW50UmVxdWVzdFxuICAgICAgICAgICAgICB8IERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN1YnNjciB9ID0gUFNEO1xuICAgICAgICAgICAgaWYgKHN1YnNjcikge1xuICAgICAgICAgICAgICAvLyBDdXJyZW50IHpvbmUgd2FudCdzIHRvIHRyYWNrIGFsbCBxdWVyaWVzIHNvIHRoZXkgY2FuIGJlIHN1YnNjcmliZWQgdG8uXG4gICAgICAgICAgICAgIC8vIChUaGUgcXVlcnkgaXMgZXhlY3V0ZWQgd2l0aGluIGEgXCJsaXZlUXVlcnlcIiB6b25lKVxuICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBxdWVyeSBhcHBsaWVzIHRvIGEgY2VydGFpbiBzZXQgb2YgcmFuZ2VzOlxuICAgICAgICAgICAgICAvLyBUcmFjayB3aGF0IHdlIHNob3VsZCBiZSBvYnNlcnZpbmc6XG4gICAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGBpZGI6Ly8ke2RiTmFtZX0vJHt0YWJsZU5hbWV9LyR7aW5kZXhOYW1lfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzdWJzY3JbcGFydF0gfHxcbiAgICAgICAgICAgICAgICAgIChzdWJzY3JbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpIGFzIFJhbmdlU2V0O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBwa1JhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoXCJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG4gICAgICAgICAgICAgIGNvbnN0IFtxdWVyaWVkSW5kZXgsIHF1ZXJpZWRSYW5nZXNdID0gcmVhZFN1YnNjcmliZXJzW21ldGhvZF0ocmVxKTtcbiAgICAgICAgICAgICAgLy8gQSBnZW5lcmljIHJ1bGUgaGVyZTogcXVlcmllZCByYW5nZXMgc2hvdWxkIGFsd2F5cyBiZSBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgICAgICBnZXRSYW5nZVNldChxdWVyaWVkSW5kZXgubmFtZSB8fCBcIlwiKS5hZGQocXVlcmllZFJhbmdlcyk7XG4gICAgICAgICAgICAgIGlmICghcXVlcmllZEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY291bnQoKSwgcXVlcnkoKSBhbmQgb3BlbkN1cnNvcigpIG9wZXJhdGVzIG9uIHNlY29uZGFyeSBpbmRpY2VzLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHB1dCgpLCBkZWxldGUoKSBhbmQgZGVsZXRlUmFuZ2UoKSBtdXRhdGlvbnMgbWF5IGhhcHBlbiB3aXRob3V0IGtub3dpbmcgb2xkT2JqcyxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbXV0YXRlKCkgbWV0aG9kIHdpbGwgYmUgbWlzc2luZyB3aGF0IHNlY29uZGFyeSBpbmRpY2VzIHRoYXQgYXJlIGJlaW5nIGRlbGV0ZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJzY3JpYmVkIHJhbmdlLiBXZSBhcmUgd29ya2luZyBhcm91bmQgdGhpcyBpc3N1ZSBieSByZWNvcmRpbmcgYWxsIHRoZSByZXN1bHRpbmdcbiAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGtleXMgZnJvbSB0aGUgcXVlcmllcy4gVGhpcyBvbmx5IHdvcmtzIGZvciB0aG9zZSBraW5kcyBvZiBxdWVyaWVzIHdoZXJlIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgcHJpbWFyeSBrZXkgZnJvbSB0aGUgcmVzdWx0LlxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgYmxvY2sgd2UgYXJlIGFjY29tcGxpc2hpbmcgdGhpcyB1c2luZyB2YXJpb3VzIHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIHF1ZXJ5IHJlc3VsdC5cblxuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiY291bnRcIikge1xuICAgICAgICAgICAgICAgICAgLy8gV2UndmUgZ290IGEgcHJvYmxlbSEgRGVsZXRlIGFuZCBwdXQgbXV0YXRpb25zIGhhcHBlbiB3aXRob3V0IGtub3duIHRoZSBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgLy8gVGhvc2UgbXV0YXRpb24gY291bGQgY2hhbmdlIHRoZSBjb3VudC5cbiAgICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uOiBEZWRpY2F0ZWQgXCI6ZGVsc1wiIHVybCByZXByZXNlbmRzIGEgc3Vic2NyaXB0aW9uIHRvIGFsbCBtdXRhdGlvbnMgd2l0aG91dCBvbGRPYmpzXG4gICAgICAgICAgICAgICAgICAvLyAoc3BlY2lhbGx5IHRyaWdnZXJlZCBpbiB0aGUgbXV0YXRvcnMgcHV0KCksIGRlbGV0ZSgpIGFuZCBkZWxldGVSYW5nZSgpIHdoZW4gdGhleSBkb24ndCBrbm93IG9sZE9iamVjdClcbiAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIG9wZW5DdXJzb3IoKSBvciBxdWVyeSgpXG5cbiAgICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgYSBrZXlzUHJvbWlzZSBpbiBjYXNlIHRoZSB3ZSdyZSBkb2luZyBhbiBJREJJbmRleC5nZXRBbGwoKSBvbiBhIHN0b3JlIHdpdGggb3V0Ym91bmQga2V5cy5cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXNQcm9taXNlID1cbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID09PSBcInF1ZXJ5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym91bmQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICB0YWJsZS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcInF1ZXJ5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQgJiYgKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYga2V5cyBhcmUgb3V0Ym91bmQsIHdlIGNhbid0IHVzZSBleHRyYWN0S2V5IHRvIG1hcCB3aGF0IGtleXMgdG8gb2JzZXJ2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIHF1ZXJpZWQgYW4gaW5kZXggKGxpa2UgJ2RhdGVUaW1lJykgb24gYW4gb3V0Ym91bmQgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZXRyaWV2ZSBhIGxpc3Qgb2Ygb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB3aG8gd2UgY2Fubm90IGtub3cgdGhlaXIgcHJpbWFyeSBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJMdWNraWx5XCIgdGhvdWdoLCB3ZSd2ZSBwcmVwYXJlZCB0aGUga2V5c1Byb21pc2UgdG8gYXNzaXN0IHVzIGluIGV4YWN0IHRoaXMgY29uZGl0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh7IHJlc3VsdDogcmVzdWx0aW5nS2V5cyB9OiBEQkNvcmVRdWVyeVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHJlc3VsdGluZ0tleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHF1ZXJ5KCkgaW5ib3VuZCB2YWx1ZXMsIGtleXMgb3Igb3V0Ym91bmQga2V5cy4gU2Vjb25kYXJ5IGluZGV4ZXMgb25seSBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBwcmltYXJ5IGtleXMgd2Ugd291bGQgb25seSBhZGQgcmVzdWx0cyB3aXRoaW4gdGhlIGFscmVhZHkgcmVnaXN0ZXJlZCByYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwS2V5cyA9IChyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHJlcyBhcyBEQkNvcmVRdWVyeVJlc3BvbnNlKS5yZXN1bHQubWFwKGV4dHJhY3RLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChyZXMgYXMgREJDb3JlUXVlcnlSZXNwb25zZSkucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVxIGFzIERCQ29yZVF1ZXJ5UmVxdWVzdCkudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gYW55IG11dGF0aW9uIG1hZGUgb24gdGhlIHJldHVybmVkIGtleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHdlIGRldGVjdCBib3RoIGRlbGV0aW9ucyBhbmQgdXBkYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKHBLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIG9ubHkgdG8gbXV0YXRpb25zIG9uIHRoZSByZXR1cm5lZCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtdXRhdG9yIHdhcyB1bmFibGUgdG8ga25vdyBvbGRPYmpzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaGFzIG9sZE9iaiwgdGhlIG11dGF0b3Igd29uJ3QgcHV0IGFueXRoaW5nIGluIFwiOmRlbHNcIiBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBjYW4gbW9yZSBmaW5lLWdyYWluZWQgcHV0IHRoZSBleGFjdCByZW1vdmVkIGFuZCBhZGRlZCBpbmRleCB2YWx1ZSBpbiB0aGUgY29ycmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggcmFuZ2UgdGhhdCB3ZSBzdWJzY3JpYmUgdG8gaW4gdGhlIHF1ZXJpZWQgcmFuZ2Ugc2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGxvYWQgdmFsdWVzIHNvIGEgY2hhbmdlIG9uIGEgcHJvcGVydHkgb3V0c2lkZSBvdXIgaW5kZXggd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmUgdXMgdG8gcmUtZXhlY3V0ZSB0aGUgcXVlcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJvcGVuQ3Vyc29yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZXIgcmVxdWVzdHMgYSBjdXJzb3IuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRoZSBzYW1lIHJlYXNvbiBhcyB3aGVuIG1ldGhvZD09PVwicXVlcnlcIiwgd2Ugb25seSBuZWVkIHRvIG9ic2VydmVcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0aG9zZSBrZXlzIHdob3NlIHZhbHVlcyBhcmUgcG9zc2libHkgdXNlZCBvciByZW5kZXJlZCAtIHdoaWNoIGNvdWxkXG4gICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBoYXBwZW4gb24ga2V5cyB3aGVyZSB0aGV5IGdldCB0aGUgY3Vyc29yJ3Mga2V5LCBwcmltYXJ5S2V5IG9yIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvcjogREJDb3JlQ3Vyc29yIHwgbnVsbCA9IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YW50VmFsdWVzID0gKHJlcSBhcyBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCkudmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBrZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGRLZXkocGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbnRWYWx1ZXMgJiYgcGtSYW5nZVNldC5hZGRLZXkoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YWJsZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YWJsZUNsb25lO1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhY2tBZmZlY3RlZEluZGV4ZXMoXG4gIGdldFJhbmdlU2V0OiAoaW5kZXg6IHN0cmluZykgPT4gUmFuZ2VTZXQsXG4gIHNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEsXG4gIG9sZE9ianM6IGFueVtdIHwgdW5kZWZpbmVkLFxuICBuZXdPYmpzOiBhbnlbXSB8IHVuZGVmaW5lZFxuKSB7XG4gIGZ1bmN0aW9uIGFkZEFmZmVjdGVkSW5kZXgoaXg6IERCQ29yZUluZGV4KSB7XG4gICAgY29uc3QgcmFuZ2VTZXQgPSBnZXRSYW5nZVNldChpeC5uYW1lIHx8IFwiXCIpO1xuICAgIGZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqOiBhbnkpIHtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IGl4LmV4dHJhY3RLZXkob2JqKSA6IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFkZEtleU9yS2V5cyA9IChrZXk6IGFueSkgPT4gaXgubXVsdGlFbnRyeSAmJiBpc0FycmF5KGtleSlcbiAgICAgIC8vIG11bHRpRW50cnkgYW5kIHRoZSBvbGQgcHJvcGVydHkgd2FzIGFuIGFycmF5IC0gYWRkIGVhY2ggYXJyYXkgZW50cnkgdG8gdGhlIHJhbmdlU2V0OlxuICAgICAgPyBrZXkuZm9yRWFjaChrZXkgPT4gcmFuZ2VTZXQuYWRkS2V5KGtleSkpXG4gICAgICAvLyBOb3QgbXVsdGlFbnRyeSBvciB0aGUgb2xkIHByb3BlcnR5IHdhcyBub3QgYW4gYXJyYXkgLSBhZGQgZWFjaCBhcnJheSBlbnRyeSB0byB0aGUgcmFuZ2VTZXQ6XG4gICAgICA6IHJhbmdlU2V0LmFkZEtleShrZXkpO1xuXG4gICAgKG9sZE9ianMgfHwgbmV3T2JqcykuZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgY29uc3Qgb2xkS2V5ID0gb2xkT2JqcyAmJiBleHRyYWN0S2V5KG9sZE9ianNbaV0pO1xuICAgICAgY29uc3QgbmV3S2V5ID0gbmV3T2JqcyAmJiBleHRyYWN0S2V5KG5ld09ianNbaV0pO1xuICAgICAgaWYgKGNtcChvbGRLZXksIG5ld0tleSkgIT09IDApIHtcbiAgICAgICAgLy8gVGhlIGluZGV4IGhhcyBjaGFuZ2VkLiBBZGQgYm90aCBvbGQgYW5kIG5ldyB2YWx1ZSBvZiB0aGUgaW5kZXguXG4gICAgICAgIGlmIChvbGRLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG9sZEtleSk7IC8vIElmIG9sZEtleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICAgIGlmIChuZXdLZXkgIT0gbnVsbCkgYWRkS2V5T3JLZXlzKG5ld0tleSk7IC8vIElmIG5ld0tleSBpcyBpbnZhbGlkIGtleSwgYWRkS2V5KCkgd2lsbCBiZSBhIG5vb3AuXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChhZGRBZmZlY3RlZEluZGV4KTtcbn1cbiIsICIvLyBJbXBvcnQgdHlwZXMgZnJvbSB0aGUgcHVibGljIEFQSVxuaW1wb3J0IHsgRGV4aWUgYXMgSURleGllIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZVwiO1xuaW1wb3J0IHsgRGV4aWVPcHRpb25zLCBEZXhpZUNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHsgRGJFdmVudHMgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuLy9pbXBvcnQgeyBQcm9taXNlRXh0ZW5kZWQsIFByb21pc2VFeHRlbmRlZENvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWQnO1xuaW1wb3J0IHsgVGFibGUgYXMgSVRhYmxlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWFcIjtcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5cbi8vIEludGVybmFsIGltcG9ydHNcbmltcG9ydCB7IFRhYmxlLCBUYWJsZUNvbnN0cnVjdG9yLCBjcmVhdGVUYWJsZUNvbnN0cnVjdG9yIH0gZnJvbSBcIi4uL3RhYmxlXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uLCBDb2xsZWN0aW9uQ29uc3RydWN0b3IsIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgV2hlcmVDbGF1c2UgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlQ29uc3RydWN0b3IsIGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IgfSBmcm9tICcuLi93aGVyZS1jbGF1c2Uvd2hlcmUtY2xhdXNlLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciwgY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tIFwiLi4vdmVyc2lvbi92ZXJzaW9uXCI7XG5pbXBvcnQgeyBWZXJzaW9uQ29uc3RydWN0b3IsIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvciB9IGZyb20gJy4uL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvcic7XG5cbi8vIE90aGVyIGltcG9ydHMuLi5cbmltcG9ydCB7IERleGllRXZlbnRTZXQgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZXZlbnQtc2V0JztcbmltcG9ydCB7IERleGllRXhjZXB0aW9uQ2xhc3NlcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBub3AsIHByb21pc2FibGVDaGFpbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuaW1wb3J0IFByb21pc2UsIHsgUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4dGVuZCwgb3ZlcnJpZGUsIGtleXMsIGhhc093biB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCB7IG1heFN0cmluZywgY29ubmVjdGlvbnMsIFJFQURPTkxZLCBSRUFEV1JJVEUgfSBmcm9tICcuLi8uLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRNYXhLZXkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgbG93ZXJWZXJzaW9uRmlyc3QgfSBmcm9tICcuLi92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IGRleGllT3BlbiB9IGZyb20gJy4vZGV4aWUtb3Blbic7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IF9vbkRhdGFiYXNlRGVsZXRlZCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyBldmVudFJlamVjdEhhbmRsZXIgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgZXh0cmFjdFRyYW5zYWN0aW9uQXJncywgZW50ZXJUcmFuc2FjdGlvblNjb3BlIH0gZnJvbSAnLi90cmFuc2FjdGlvbi1oZWxwZXJzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uTW9kZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbi1tb2RlJztcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlLCBEZXhpZVN0YWNrcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IHZpcnR1YWxJbmRleE1pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9kYmNvcmUvdmlydHVhbC1pbmRleC1taWRkbGV3YXJlJztcbmltcG9ydCB7IGhvb2tzTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYyc7XG5pbXBvcnQgeyBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvb2JzZXJ2YWJpbGl0eS1taWRkbGV3YXJlJztcbmltcG9ydCB7IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL2NhY2hlLWV4aXN0aW5nLXZhbHVlcy1taWRkbGV3YXJlJztcblxuZXhwb3J0IGludGVyZmFjZSBEYlJlYWR5U3RhdGUge1xuICBkYk9wZW5FcnJvcjogYW55O1xuICBpc0JlaW5nT3BlbmVkOiBib29sZWFuO1xuICBvblJlYWR5QmVpbmdGaXJlZDogdW5kZWZpbmVkIHwgRnVuY3Rpb25bXTtcbiAgb3BlbkNvbXBsZXRlOiBib29sZWFuO1xuICBkYlJlYWR5UmVzb2x2ZTogKCkgPT4gdm9pZDtcbiAgZGJSZWFkeVByb21pc2U6IFByb21pc2U8YW55PjtcbiAgY2FuY2VsT3BlbjogKHJlYXNvbj86IEVycm9yKSA9PiB2b2lkO1xuICBvcGVuQ2FuY2VsbGVyOiBQcm9taXNlPGFueT4gJiB7IF9zdGFja0hvbGRlcj86IEVycm9yIH07XG4gIGF1dG9TY2hlbWE6IGJvb2xlYW47XG4gIHZjRmlyZWQ/OiBib29sZWFuO1xuICBQUjEzOThfbWF4TG9vcD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIERleGllIGltcGxlbWVudHMgSURleGllIHtcbiAgX29wdGlvbnM6IERleGllT3B0aW9ucztcbiAgX3N0YXRlOiBEYlJlYWR5U3RhdGU7XG4gIF92ZXJzaW9uczogVmVyc2lvbltdO1xuICBfc3RvcmVOYW1lczogc3RyaW5nW107XG4gIF9kZXBzOiBEZXhpZURPTURlcGVuZGVuY2llcztcbiAgX2FsbFRhYmxlczogeyBbbmFtZTogc3RyaW5nXTogVGFibGU7IH07XG4gIF9jcmVhdGVUcmFuc2FjdGlvbjogKHRoaXM6IERleGllLCBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsIHN0b3JlTmFtZXM6IEFycmF5TGlrZTxzdHJpbmc+LCBkYnNjaGVtYTogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZVNjaGVtYTsgfSwgcGFyZW50VHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4gVHJhbnNhY3Rpb247XG4gIF9kYlNjaGVtYTogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBUYWJsZVNjaGVtYTsgfTtcbiAgX2hhc0dldEFsbD86IGJvb2xlYW47XG4gIF9tYXhLZXk6IEluZGV4YWJsZVR5cGU7XG4gIF9maXJlT25CbG9ja2VkOiAoZXY6IEV2ZW50KSA9PiB2b2lkO1xuICBfbWlkZGxld2FyZXM6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IE1pZGRsZXdhcmU8RGV4aWVTdGFja3NbU3RhY2tOYW1lXT5bXX0gPSB7fTtcbiAgX3ZpcD86IGJvb2xlYW47XG4gIF9ub3ZpcD86IERleGllOy8vIGRiLl9ub3ZpcCBpcyB0byBlc2NhcGUgdG8gb3JpZyBkYiBmcm9tIGRiLnZpcC5cbiAgY29yZTogREJDb3JlO1xuXG4gIG5hbWU6IHN0cmluZztcbiAgdmVybm86IG51bWJlciA9IDA7XG4gIGlkYmRiOiBJREJEYXRhYmFzZSB8IG51bGw7XG4gIHZpcDogRGV4aWU7XG4gIG9uOiBEYkV2ZW50cztcblxuICBUYWJsZTogVGFibGVDb25zdHJ1Y3RvcjtcbiAgV2hlcmVDbGF1c2U6IFdoZXJlQ2xhdXNlQ29uc3RydWN0b3I7XG4gIENvbGxlY3Rpb246IENvbGxlY3Rpb25Db25zdHJ1Y3RvcjtcbiAgVmVyc2lvbjogVmVyc2lvbkNvbnN0cnVjdG9yO1xuICBUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjtcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIG9wdGlvbnM/OiBEZXhpZU9wdGlvbnMpIHtcbiAgICBjb25zdCBkZXBzID0gKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5kZXBlbmRlbmNpZXM7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgPSB7XG4gICAgICAvLyBEZWZhdWx0IE9wdGlvbnNcbiAgICAgIGFkZG9uczogKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS5hZGRvbnMsIC8vIFBpY2sgc3RhdGljYWxseSByZWdpc3RlcmVkIGFkZG9ucyBieSBkZWZhdWx0XG4gICAgICBhdXRvT3BlbjogdHJ1ZSwgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlcXVpcmUgZGIub3BlbigpIGV4cGxpY2l0ZWx5LlxuICAgICAgLy8gRGVmYXVsdCBET00gZGVwZW5kZW5jeSBpbXBsZW1lbnRhdGlvbnMgZnJvbSBzdGF0aWMgcHJvcC5cbiAgICAgIGluZGV4ZWREQjogZGVwcy5pbmRleGVkREIsICAgICAgLy8gQmFja2VuZCBJbmRleGVkREIgYXBpLiBEZWZhdWx0IHRvIGJyb3dzZXIgZW52LlxuICAgICAgSURCS2V5UmFuZ2U6IGRlcHMuSURCS2V5UmFuZ2UsICAvLyBCYWNrZW5kIElEQktleVJhbmdlIGFwaS4gRGVmYXVsdCB0byBicm93c2VyIGVudi5cbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIHRoaXMuX2RlcHMgPSB7XG4gICAgICBpbmRleGVkREI6IG9wdGlvbnMuaW5kZXhlZERCIGFzIElEQkZhY3RvcnksXG4gICAgICBJREJLZXlSYW5nZTogb3B0aW9ucy5JREJLZXlSYW5nZSBhcyB0eXBlb2YgSURCS2V5UmFuZ2VcbiAgICB9O1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZG9ucyxcbiAgICB9ID0gb3B0aW9ucztcbiAgICB0aGlzLl9kYlNjaGVtYSA9IHt9O1xuICAgIHRoaXMuX3ZlcnNpb25zID0gW107XG4gICAgdGhpcy5fc3RvcmVOYW1lcyA9IFtdO1xuICAgIHRoaXMuX2FsbFRhYmxlcyA9IHt9O1xuICAgIHRoaXMuaWRiZGIgPSBudWxsO1xuICAgIHRoaXMuX25vdmlwID0gdGhpcztcbiAgICBjb25zdCBzdGF0ZTogRGJSZWFkeVN0YXRlID0ge1xuICAgICAgZGJPcGVuRXJyb3I6IG51bGwsXG4gICAgICBpc0JlaW5nT3BlbmVkOiBmYWxzZSxcbiAgICAgIG9uUmVhZHlCZWluZ0ZpcmVkOiBudWxsLFxuICAgICAgb3BlbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIGRiUmVhZHlSZXNvbHZlOiBub3AsXG4gICAgICBkYlJlYWR5UHJvbWlzZTogbnVsbCBhcyBQcm9taXNlLFxuICAgICAgY2FuY2VsT3Blbjogbm9wLFxuICAgICAgb3BlbkNhbmNlbGxlcjogbnVsbCBhcyBQcm9taXNlLFxuICAgICAgYXV0b1NjaGVtYTogdHJ1ZSxcbiAgICAgIFBSMTM5OF9tYXhMb29wOiAzXG4gICAgfTtcbiAgICBzdGF0ZS5kYlJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgc3RhdGUuZGJSZWFkeVJlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHN0YXRlLm9wZW5DYW5jZWxsZXIgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzdGF0ZS5jYW5jZWxPcGVuID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9uID0gRXZlbnRzKHRoaXMsIFwicG9wdWxhdGVcIiwgXCJibG9ja2VkXCIsIFwidmVyc2lvbmNoYW5nZVwiLCBcImNsb3NlXCIsIHsgcmVhZHk6IFtwcm9taXNhYmxlQ2hhaW4sIG5vcF0gfSkgYXMgRGJFdmVudHM7XG4gICAgdGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUgPSBvdmVycmlkZSh0aGlzLm9uLnJlYWR5LnN1YnNjcmliZSwgc3Vic2NyaWJlID0+IHtcbiAgICAgIHJldHVybiAoc3Vic2NyaWJlciwgYlN0aWNreSkgPT4ge1xuICAgICAgICAoRGV4aWUgYXMgYW55IGFzIERleGllQ29uc3RydWN0b3IpLnZpcCgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICBpZiAoc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBEYXRhYmFzZSBhbHJlYWR5IG9wZW4uIENhbGwgc3Vic2NyaWJlciBhc2FwLlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5kYk9wZW5FcnJvcikgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIC8vIGJTdGlja3k6IEFsc28gc3Vic2NyaWJlIHRvIGZ1dHVyZSBvcGVuIHN1Y2Vzc2VzIChhZnRlciBjbG9zZSAvIHJlb3BlbikgXG4gICAgICAgICAgICBpZiAoYlN0aWNreSkgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQpIHtcbiAgICAgICAgICAgIC8vIGRiLm9uKCdyZWFkeScpIHN1YnNjcmliZXJzIGFyZSBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgYW5kIGhhdmUgbm90IHlldCByZXNvbHZlZCBvciByZWplY3RlZFxuICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIGlmIChiU3RpY2t5KSBzdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERhdGFiYXNlIG5vdCB5ZXQgb3Blbi4gU3Vic2NyaWJlIHRvIGl0LlxuICAgICAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgLy8gSWYgYlN0aWNreSBpcyBmYWxzeSwgbWFrZSBzdXJlIHRvIHVuc3Vic2NyaWJlIHN1YnNjcmliZXIgd2hlbiBmaXJlZCBvbmNlLlxuICAgICAgICAgICAgY29uc3QgZGIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFiU3RpY2t5KSBzdWJzY3JpYmUoZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICAgIGRiLm9uLnJlYWR5LnVuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZSh1bnN1YnNjcmliZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIGRlcml2ZWQgY2xhc3NlcyBib3VuZCB0byB0aGlzIGluc3RhbmNlIG9mIERleGllOlxuICAgIHRoaXMuQ29sbGVjdGlvbiA9IGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlRhYmxlID0gY3JlYXRlVGFibGVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlRyYW5zYWN0aW9uID0gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLlZlcnNpb24gPSBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5XaGVyZUNsYXVzZSA9IGNyZWF0ZVdoZXJlQ2xhdXNlQ29uc3RydWN0b3IodGhpcyk7XG5cbiAgICAvLyBEZWZhdWx0IHN1YnNjcmliZXJzIHRvIFwidmVyc2lvbmNoYW5nZVwiIGFuZCBcImJsb2NrZWRcIi5cbiAgICAvLyBDYW4gYmUgb3ZlcnJpZGRlbiBieSBjdXN0b20gaGFuZGxlcnMuIElmIGN1c3RvbSBoYW5kbGVycyByZXR1cm4gZmFsc2UsIHRoZXNlIGRlZmF1bHRcbiAgICAvLyBiZWhhdmlvdXJzIHdpbGwgYmUgcHJldmVudGVkLlxuICAgIHRoaXMub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGV2ID0+IHtcbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgZm9yIHZlcnNpb25jaGFuZ2UgZXZlbnQgaXMgdG8gY2xvc2UgZGF0YWJhc2UgY29ubmVjdGlvbi5cbiAgICAgIC8vIENhbGxlciBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciBieSBkb2luZyBkYi5vbihcInZlcnNpb25jaGFuZ2VcIiwgZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9KTtcbiAgICAgIC8vIExldCdzIG5vdCBibG9jayB0aGUgb3RoZXIgd2luZG93IGZyb20gbWFraW5nIGl0J3MgZGVsZXRlKCkgb3Igb3BlbigpIGNhbGwuXG4gICAgICAvLyBOT1RFISBUaGlzIGV2ZW50IGlzIG5ldmVyIGZpcmVkIGluIElFLEVkZ2Ugb3IgU2FmYXJpLlxuICAgICAgaWYgKGV2Lm5ld1ZlcnNpb24gPiAwKVxuICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byB1cGdyYWRlIGRhdGFiYXNlICcke3RoaXMubmFtZX0nLiBDbG9zaW5nIGRiIG5vdyB0byByZXN1bWUgdGhlIHVwZ3JhZGUuYCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUud2FybihgQW5vdGhlciBjb25uZWN0aW9uIHdhbnRzIHRvIGRlbGV0ZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSBkZWxldGUgcmVxdWVzdC5gKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIC8vIEluIG1hbnkgd2ViIGFwcGxpY2F0aW9ucywgaXQgd291bGQgYmUgcmVjb21tZW5kZWQgdG8gZm9yY2Ugd2luZG93LnJlbG9hZCgpXG4gICAgICAvLyB3aGVuIHRoaXMgZXZlbnQgb2NjdXJzLiBUbyBkbyB0aGF0LCBzdWJzY3JpYmUgdG8gdGhlIHZlcnNpb25jaGFuZ2UgZXZlbnRcbiAgICAgIC8vIGFuZCBjYWxsIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSkgaWYgZXYubmV3VmVyc2lvbiA+IDAgKG5vdCBhIGRlbGV0aW9uKVxuICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBpcyB0aGF0IHlvdXIgY3VycmVudCB3ZWIgYXBwIG9idmlvdXNseSBoYXMgb2xkIHNjaGVtYSBjb2RlIHRoYXQgbmVlZHNcbiAgICAgIC8vIHRvIGJlIHVwZGF0ZWQuIEFub3RoZXIgd2luZG93IGdvdCBhIG5ld2VyIHZlcnNpb24gb2YgdGhlIGFwcCBhbmQgbmVlZHMgdG8gdXBncmFkZSBEQiBidXRcbiAgICAgIC8vIHlvdXIgd2luZG93IGlzIGJsb2NraW5nIGl0IHVubGVzcyB3ZSBjbG9zZSBpdCBoZXJlLlxuICAgIH0pO1xuICAgIHRoaXMub24oXCJibG9ja2VkXCIsIGV2ID0+IHtcbiAgICAgIGlmICghZXYubmV3VmVyc2lvbiB8fCBldi5uZXdWZXJzaW9uIDwgZXYub2xkVmVyc2lvbilcbiAgICAgICAgY29uc29sZS53YXJuKGBEZXhpZS5kZWxldGUoJyR7dGhpcy5uYW1lfScpIHdhcyBibG9ja2VkYCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNvbnNvbGUud2FybihgVXBncmFkZSAnJHt0aGlzLm5hbWV9JyBibG9ja2VkIGJ5IG90aGVyIGNvbm5lY3Rpb24gaG9sZGluZyB2ZXJzaW9uICR7ZXYub2xkVmVyc2lvbiAvIDEwfWApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fbWF4S2V5ID0gZ2V0TWF4S2V5KG9wdGlvbnMuSURCS2V5UmFuZ2UgYXMgdHlwZW9mIElEQktleVJhbmdlKTtcblxuICAgIHRoaXMuX2NyZWF0ZVRyYW5zYWN0aW9uID0gKFxuICAgICAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICAgICAgc3RvcmVOYW1lczogc3RyaW5nW10sXG4gICAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgICBwYXJlbnRUcmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uKSA9PiBuZXcgdGhpcy5UcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYnNjaGVtYSwgdGhpcy5fb3B0aW9ucy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHksIHBhcmVudFRyYW5zYWN0aW9uKTtcblxuICAgIHRoaXMuX2ZpcmVPbkJsb2NrZWQgPSBldiA9PiB7XG4gICAgICB0aGlzLm9uKFwiYmxvY2tlZFwiKS5maXJlKGV2KTtcbiAgICAgIC8vIFdvcmthcm91bmQgKG5vdCBmdWxseSopIGZvciBtaXNzaW5nIFwidmVyc2lvbmNoYW5nZVwiIGV2ZW50IGluIElFLEVkZ2UgYW5kIFNhZmFyaTpcbiAgICAgIGNvbm5lY3Rpb25zXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjLm5hbWUgPT09IHRoaXMubmFtZSAmJiBjICE9PSB0aGlzICYmICFjLl9zdGF0ZS52Y0ZpcmVkKVxuICAgICAgICAubWFwKGMgPT4gYy5vbihcInZlcnNpb25jaGFuZ2VcIikuZmlyZShldikpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgbWlkZGxld2FyZXM6XG4gICAgdGhpcy51c2UodmlydHVhbEluZGV4TWlkZGxld2FyZSk7XG4gICAgdGhpcy51c2UoaG9va3NNaWRkbGV3YXJlKTtcbiAgICB0aGlzLnVzZShvYnNlcnZhYmlsaXR5TWlkZGxld2FyZSk7XG4gICAgdGhpcy51c2UoY2FjaGVFeGlzdGluZ1ZhbHVlc01pZGRsZXdhcmUpO1xuXG4gICAgdGhpcy52aXAgPSBPYmplY3QuY3JlYXRlKHRoaXMsIHtfdmlwOiB7dmFsdWU6IHRydWV9fSkgYXMgRGV4aWU7XG5cbiAgICAvLyBDYWxsIGVhY2ggYWRkb246XG4gICAgYWRkb25zLmZvckVhY2goYWRkb24gPT4gYWRkb24odGhpcykpO1xuICB9XG5cbiAgdmVyc2lvbih2ZXJzaW9uTnVtYmVyOiBudW1iZXIpOiBWZXJzaW9uIHtcbiAgICBpZiAoaXNOYU4odmVyc2lvbk51bWJlcikgfHwgdmVyc2lvbk51bWJlciA8IDAuMSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuVHlwZShgR2l2ZW4gdmVyc2lvbiBpcyBub3QgYSBwb3NpdGl2ZSBudW1iZXJgKTtcbiAgICB2ZXJzaW9uTnVtYmVyID0gTWF0aC5yb3VuZCh2ZXJzaW9uTnVtYmVyICogMTApIC8gMTA7XG4gICAgaWYgKHRoaXMuaWRiZGIgfHwgdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkNhbm5vdCBhZGQgdmVyc2lvbiB3aGVuIGRhdGFiYXNlIGlzIG9wZW5cIik7XG4gICAgdGhpcy52ZXJubyA9IE1hdGgubWF4KHRoaXMudmVybm8sIHZlcnNpb25OdW1iZXIpO1xuICAgIGNvbnN0IHZlcnNpb25zID0gdGhpcy5fdmVyc2lvbnM7XG4gICAgdmFyIHZlcnNpb25JbnN0YW5jZSA9IHZlcnNpb25zLmZpbHRlcihcbiAgICAgIHYgPT4gdi5fY2ZnLnZlcnNpb24gPT09IHZlcnNpb25OdW1iZXIpWzBdO1xuICAgIGlmICh2ZXJzaW9uSW5zdGFuY2UpIHJldHVybiB2ZXJzaW9uSW5zdGFuY2U7XG4gICAgdmVyc2lvbkluc3RhbmNlID0gbmV3IHRoaXMuVmVyc2lvbih2ZXJzaW9uTnVtYmVyKTtcbiAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb25JbnN0YW5jZSk7XG4gICAgdmVyc2lvbnMuc29ydChsb3dlclZlcnNpb25GaXJzdCk7XG4gICAgdmVyc2lvbkluc3RhbmNlLnN0b3Jlcyh7fSk7IC8vIERlcml2ZSBlYXJsaWVyIHNjaGVtYXMgYnkgZGVmYXVsdC5cbiAgICAvLyBEaXNhYmxlIGF1dG9zY2hlbWEgbW9kZSwgYXMgYXQgbGVhc3Qgb25lIHZlcnNpb24gaXMgc3BlY2lmaWVkLlxuICAgIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWEgPSBmYWxzZTtcbiAgICByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICB9XG5cbiAgX3doZW5SZWFkeTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiAodGhpcy5pZGJkYiAmJiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlIHx8IFBTRC5sZXRUaHJvdWdoIHx8IHRoaXMuX3ZpcCkpID8gZm4oKSA6IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgICAgLy8gaWRiZGIgaXMgZmFsc3kgYnV0IG9wZW5Db21wbGV0ZSBpcyB0cnVlLiBNdXN0IGhhdmUgYmVlbiBhbiBleGNlcHRpb24gZHVyaW4gb3Blbi5cbiAgICAgICAgLy8gRG9uJ3Qgd2FpdCBmb3Igb3BlbkNvbXBsZXRlIGFzIGl0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCh0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcikpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5hdXRvT3Blbikge1xuICAgICAgICAgIHJlamVjdChuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuKCkuY2F0Y2gobm9wKTsgLy8gT3BlbiBpbiBiYWNrZ3JvdW5kLiBJZiBpZiBmYWlscywgaXQgd2lsbCBiZSBjYXRjaGVkIGJ5IHRoZSBmaW5hbCBwcm9taXNlIGFueXdheS5cbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KS50aGVuKGZuKTtcbiAgfVxuXG4gIHVzZSh7c3RhY2ssIGNyZWF0ZSwgbGV2ZWwsIG5hbWV9OiBNaWRkbGV3YXJlPERCQ29yZT4pOiB0aGlzIHtcbiAgICBpZiAobmFtZSkgdGhpcy51bnVzZSh7c3RhY2ssIG5hbWV9KTsgLy8gQmUgYWJsZSB0byByZXBsYWNlIGV4aXN0aW5nIG1pZGRsZXdhcmUuXG4gICAgY29uc3QgbWlkZGxld2FyZXMgPSB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gfHwgKHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IFtdKTtcbiAgICBtaWRkbGV3YXJlcy5wdXNoKHtzdGFjaywgY3JlYXRlLCBsZXZlbDogbGV2ZWwgPT0gbnVsbCA/IDEwIDogbGV2ZWwsIG5hbWV9KTtcbiAgICBtaWRkbGV3YXJlcy5zb3J0KChhLCBiKSA9PiBhLmxldmVsIC0gYi5sZXZlbCk7XG4gICAgLy8gVG9kbyB1cGRhdGUgZGIuY29yZSBhbmQgZGIudGFibGVzLi4uY29yZSA/IE9yIHNob3VsZCBiZSBleHBlY3QgdGhpcyB0byBoYXZlIGVmZmVjdFxuICAgIC8vIG9ubHkgYWZ0ZXIgbmV4dCBvcGVuKCk/XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1bnVzZSh7c3RhY2ssIGNyZWF0ZX06IE1pZGRsZXdhcmU8e3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrc30+KTogdGhpcztcbiAgdW51c2Uoe3N0YWNrLCBuYW1lfToge3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrcywgbmFtZTogc3RyaW5nfSk6IHRoaXM7XG4gIHVudXNlKHtzdGFjaywgbmFtZSwgY3JlYXRlfToge3N0YWNrOiBrZXlvZiBEZXhpZVN0YWNrcywgbmFtZT86IHN0cmluZywgY3JlYXRlPzogRnVuY3Rpb259KSB7XG4gICAgaWYgKHN0YWNrICYmIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSkge1xuICAgICAgdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdLmZpbHRlcihtdyA9PlxuICAgICAgICBjcmVhdGUgPyBtdy5jcmVhdGUgIT09IGNyZWF0ZSA6IC8vIEdpdmVuIG1pZGRsZXdhcmUgaGFzIGEgY3JlYXRlIG1ldGhvZC4gTWF0Y2ggdGhhdCBleGFjdGx5LlxuICAgICAgICBuYW1lID8gbXcubmFtZSAhPT0gbmFtZSA6IC8vIEdpdmVuIG1pZGRsZXdhcmUgc3BlYyBcbiAgICAgICAgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgcmV0dXJuIGRleGllT3Blbih0aGlzKTtcbiAgfVxuXG4gIF9jbG9zZSgpOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGNvbnN0IGlkeCA9IGNvbm5lY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgaWYgKGlkeCA+PSAwKSBjb25uZWN0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICBpZiAodGhpcy5pZGJkYikge1xuICAgICAgdHJ5IHsgdGhpcy5pZGJkYi5jbG9zZSgpOyB9IGNhdGNoIChlKSB7IH1cbiAgICAgIHRoaXMuX25vdmlwLmlkYmRiID0gbnVsbDsgLy8gZGIuX25vdmlwIGlzIGJlY2F1c2UgZGIgY2FuIGJlIGFuIE9iamVjdC5jcmVhdGUob3JpZ0RiKS5cbiAgICB9ICAgIFxuICAgIC8vIFJlc2V0IGRiUmVhZHlQcm9taXNlIHByb21pc2U6XG4gICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICB0aGlzLl9vcHRpb25zLmF1dG9PcGVuID0gZmFsc2U7XG4gICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpO1xuICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKVxuICAgICAgc3RhdGUuY2FuY2VsT3BlbihzdGF0ZS5kYk9wZW5FcnJvcik7XG4gIH1cblxuICBkZWxldGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaGFzQXJndW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZG9EZWxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuX2RlcHMuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKHRoaXMubmFtZSk7XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICBfb25EYXRhYmFzZURlbGV0ZWQodGhpcy5fZGVwcywgdGhpcy5uYW1lKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICByZXEub25ibG9ja2VkID0gdGhpcy5fZmlyZU9uQmxvY2tlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0FyZ3VtZW50cykgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiQXJndW1lbnRzIG5vdCBhbGxvd2VkIGluIGRiLmRlbGV0ZSgpXCIpO1xuICAgICAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQpIHtcbiAgICAgICAgc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbihkb0RlbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb0RlbGV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYmFja2VuZERCKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlkYmRiICE9PSBudWxsO1xuICB9XG5cbiAgaGFzQmVlbkNsb3NlZCgpIHtcbiAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgIHJldHVybiBkYk9wZW5FcnJvciAmJiAoZGJPcGVuRXJyb3IubmFtZSA9PT0gJ0RhdGFiYXNlQ2xvc2VkJyk7XG4gIH1cblxuICBoYXNGYWlsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRiT3BlbkVycm9yICE9PSBudWxsO1xuICB9XG5cbiAgZHluYW1pY2FsbHlPcGVuZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmF1dG9TY2hlbWE7XG4gIH1cblxuICBnZXQgdGFibGVzICgpIHtcbiAgICByZXR1cm4ga2V5cyh0aGlzLl9hbGxUYWJsZXMpLm1hcChuYW1lID0+IHRoaXMuX2FsbFRhYmxlc1tuYW1lXSk7XG4gIH1cblxuICB0cmFuc2FjdGlvbigpOiBQcm9taXNlIHtcbiAgICBjb25zdCBhcmdzID0gZXh0cmFjdFRyYW5zYWN0aW9uQXJncy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIF90cmFuc2FjdGlvbihtb2RlOiBUcmFuc2FjdGlvbk1vZGUsIHRhYmxlczogQXJyYXk8SVRhYmxlIHwgc3RyaW5nPiwgc2NvcGVGdW5jOiBGdW5jdGlvbikge1xuICAgIGxldCBwYXJlbnRUcmFuc2FjdGlvbiA9IFBTRC50cmFucyBhcyBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZDtcbiAgICAvLyBDaGVjayBpZiBwYXJlbnQgdHJhbnNhY3Rpb25zIGlzIGJvdW5kIHRvIHRoaXMgZGIgaW5zdGFuY2UsIGFuZCBpZiBjYWxsZXIgd2FudHMgdG8gcmV1c2UgaXRcbiAgICBpZiAoIXBhcmVudFRyYW5zYWN0aW9uIHx8IHBhcmVudFRyYW5zYWN0aW9uLmRiICE9PSB0aGlzIHx8IG1vZGUuaW5kZXhPZignIScpICE9PSAtMSkgcGFyZW50VHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIGNvbnN0IG9ubHlJZkNvbXBhdGlibGUgPSBtb2RlLmluZGV4T2YoJz8nKSAhPT0gLTE7XG4gICAgbW9kZSA9IG1vZGUucmVwbGFjZSgnIScsICcnKS5yZXBsYWNlKCc/JywgJycpIGFzIFRyYW5zYWN0aW9uTW9kZTsgLy8gT2suIFdpbGwgY2hhbmdlIGFyZ3VtZW50c1swXSBhcyB3ZWxsIGJ1dCB3ZSB3b250IHRvdWNoIGFyZ3VtZW50cyBoZW5jZWZvcnRoLlxuICAgIGxldCBpZGJNb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgICAgIHN0b3JlTmFtZXM7XG5cbiAgICB0cnkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBHZXQgc3RvcmVOYW1lcyBmcm9tIGFyZ3VtZW50cy4gRWl0aGVyIHRocm91Z2ggZ2l2ZW4gdGFibGUgaW5zdGFuY2VzLCBvciB0aHJvdWdoIGdpdmVuIHRhYmxlIG5hbWVzLlxuICAgICAgICAvL1xuICAgICAgICBzdG9yZU5hbWVzID0gdGFibGVzLm1hcCh0YWJsZSA9PiB7XG4gICAgICAgICAgICB2YXIgc3RvcmVOYW1lID0gdGFibGUgaW5zdGFuY2VvZiB0aGlzLlRhYmxlID8gdGFibGUubmFtZSA6IHRhYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZU5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YWJsZSBhcmd1bWVudCB0byBEZXhpZS50cmFuc2FjdGlvbigpLiBPbmx5IFRhYmxlIG9yIFN0cmluZyBhcmUgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZU5hbWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc29sdmUgbW9kZS4gQWxsb3cgc2hvcnRjdXRzIFwiclwiIGFuZCBcInJ3XCIuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChtb2RlID09IFwiclwiIHx8IG1vZGUgPT09IFJFQURPTkxZKVxuICAgICAgICAgIGlkYk1vZGUgPSBSRUFET05MWTtcbiAgICAgICAgZWxzZSBpZiAobW9kZSA9PSBcInJ3XCIgfHwgbW9kZSA9PSBSRUFEV1JJVEUpXG4gICAgICAgICAgaWRiTW9kZSA9IFJFQURXUklURTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiSW52YWxpZCB0cmFuc2FjdGlvbiBtb2RlOiBcIiArIG1vZGUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gQmFzaWMgY2hlY2tzXG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24ubW9kZSA9PT0gUkVBRE9OTFkgJiYgaWRiTW9kZSA9PT0gUkVBRFdSSVRFKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3Bhd24gbmV3IHRyYW5zYWN0aW9uIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuU3ViVHJhbnNhY3Rpb24oXCJDYW5ub3QgZW50ZXIgYSBzdWItdHJhbnNhY3Rpb24gd2l0aCBSRUFEV1JJVEUgbW9kZSB3aGVuIHBhcmVudCB0cmFuc2FjdGlvbiBpcyBSRUFET05MWVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHN0b3JlTmFtZXMuZm9yRWFjaChzdG9yZU5hbWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24gJiYgcGFyZW50VHJhbnNhY3Rpb24uc3RvcmVOYW1lcy5pbmRleE9mKHN0b3JlTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiVGFibGUgXCIgKyBzdG9yZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG5vdCBpbmNsdWRlZCBpbiBwYXJlbnQgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25seUlmQ29tcGF0aWJsZSAmJiBwYXJlbnRUcmFuc2FjdGlvbiAmJiAhcGFyZW50VHJhbnNhY3Rpb24uYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgLy8gJz8nIG1vZGUgc2hvdWxkIG5vdCBrZWVwIHVzaW5nIGFuIGluYWN0aXZlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKG51bGwsIChfLCByZWplY3QpID0+IHtyZWplY3QoZSk7fSkgOlxuICAgICAgICAgICAgcmVqZWN0aW9uIChlKTtcbiAgICB9XG4gICAgLy8gSWYgdGhpcyBpcyBhIHN1Yi10cmFuc2FjdGlvbiwgbG9jayB0aGUgcGFyZW50IGFuZCB0aGVuIGxhdW5jaCB0aGUgc3ViLXRyYW5zYWN0aW9uLlxuICAgIGNvbnN0IGVudGVyVHJhbnNhY3Rpb24gPSBlbnRlclRyYW5zYWN0aW9uU2NvcGUuYmluZChudWxsLCB0aGlzLCBpZGJNb2RlLCBzdG9yZU5hbWVzLCBwYXJlbnRUcmFuc2FjdGlvbiwgc2NvcGVGdW5jKTtcbiAgICByZXR1cm4gKHBhcmVudFRyYW5zYWN0aW9uID9cbiAgICAgICAgcGFyZW50VHJhbnNhY3Rpb24uX3Byb21pc2UoaWRiTW9kZSwgZW50ZXJUcmFuc2FjdGlvbiwgXCJsb2NrXCIpIDpcbiAgICAgICAgUFNELnRyYW5zID9cbiAgICAgICAgICAgIC8vIG5vIHBhcmVudCB0cmFuc2FjdGlvbiBkZXNwaXRlIFBTRC50cmFucyBleGlzdHMuIE1ha2Ugc3VyZSBhbHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSB6b25lIHdlIGNyZWF0ZSBpcyBub3QgYSBzdWItem9uZSBvZiBjdXJyZW50LCBiZWNhdXNlXG4gICAgICAgICAgICAvLyBQcm9taXNlLmZvbGxvdygpIHNob3VsZCBub3Qgd2FpdCBmb3IgaXQgaWYgc28uXG4gICAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgKCk9PnRoaXMuX3doZW5SZWFkeShlbnRlclRyYW5zYWN0aW9uKSkgOlxuICAgICAgICAgICAgdGhpcy5fd2hlblJlYWR5IChlbnRlclRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICB0YWJsZSh0YWJsZU5hbWU6IHN0cmluZyk6IFRhYmxlO1xuICB0YWJsZTxULCBUS2V5IGV4dGVuZHMgSW5kZXhhYmxlVHlwZT1JbmRleGFibGVUeXBlPih0YWJsZU5hbWU6IHN0cmluZyk6IElUYWJsZTxULCBUS2V5PjtcbiAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpOiBUYWJsZSB7XG4gICAgaWYgKCFoYXNPd24odGhpcy5fYWxsVGFibGVzLCB0YWJsZU5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkVGFibGUoYFRhYmxlICR7dGFibGVOYW1lfSBkb2VzIG5vdCBleGlzdGApOyB9XG4gICAgcmV0dXJuIHRoaXMuX2FsbFRhYmxlc1t0YWJsZU5hbWVdO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZSBhcyBJT2JzZXJ2YWJsZSxcbiAgT2JzZXJ2ZXIsXG4gIFN1YnNjcmlwdGlvbixcbn0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9vYnNlcnZhYmxlXCI7XG5cbmNvbnN0IHN5bWJvbE9ic2VydmFibGU6IHR5cGVvZiBTeW1ib2wub2JzZXJ2YWJsZSA9XG4gIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJvYnNlcnZhYmxlXCIgaW4gU3ltYm9sXG4gICAgPyBTeW1ib2wub2JzZXJ2YWJsZVxuICAgIDogXCJAQG9ic2VydmFibGVcIiBhcyBhbnk7XG5cbmV4cG9ydCBjbGFzcyBPYnNlcnZhYmxlPFQ+IGltcGxlbWVudHMgSU9ic2VydmFibGU8VD4ge1xuICBwcml2YXRlIF9zdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbjtcbiAgaGFzVmFsdWU/OiAoKT0+Ym9vbGVhbjtcbiAgZ2V0VmFsdWU/OiAoKT0+VDtcblxuICBjb25zdHJ1Y3RvcihzdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VD4pID0+IFN1YnNjcmlwdGlvbikge1xuICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgfVxuXG4gIHN1YnNjcmliZShcbiAgICBvbk5leHQ/OiAoKHZhbHVlOiBUKSA9PiB2b2lkKSB8wqBudWxsLFxuICAgIG9uRXJyb3I/OiAoKGVycm9yOiBhbnkpID0+IHZvaWQpIHwgbnVsbCxcbiAgICBvbkNvbXBsZXRlPzogKCgpID0+IHZvaWQpIHwgbnVsbFxuICApOiBTdWJzY3JpcHRpb247XG4gIHN1YnNjcmliZShvYnNlcnZlcj86IE9ic2VydmVyPFQ+IHwgbnVsbCk6IFN1YnNjcmlwdGlvbjtcbiAgc3Vic2NyaWJlKHg/OiBhbnksIGVycm9yPzogYW55LCBjb21wbGV0ZT86IGFueSk6IFN1YnNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShcbiAgICAgICF4IHx8IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB7IG5leHQ6IHgsIGVycm9yLCBjb21wbGV0ZSB9IDogeFxuICAgICk7XG4gIH1cblxuICBbc3ltYm9sT2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBkZWVwQ2xvbmUsIGtleXMgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBtZXJnZVJhbmdlcywgUmFuZ2VTZXQgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZXNldFwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KFxuICB0YXJnZXQ6IE9ic2VydmFiaWxpdHlTZXQsXG4gIG5ld1NldDogT2JzZXJ2YWJpbGl0eVNldFxuKTogT2JzZXJ2YWJpbGl0eVNldCB7XG4gIGtleXMobmV3U2V0KS5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IHJhbmdlU2V0ID0gdGFyZ2V0W3BhcnRdIHx8ICh0YXJnZXRbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSk7XG4gICAgbWVyZ2VSYW5nZXMocmFuZ2VTZXQsIG5ld1NldFtwYXJ0XSk7XG4gIH0pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuIiwgImltcG9ydCB7IGlzQXN5bmNGdW5jdGlvbiwga2V5cyB9IGZyb20gXCIuLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IGdsb2JhbEV2ZW50cywgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUgfSBmcm9tIFwiLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzXCI7XG5pbXBvcnQge1xuICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cyxcbiAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIG5ld1Njb3BlLFxuICBQU0QsXG4gIHVzZVBTRCxcbn0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlIGFzIElPYnNlcnZhYmxlLFxuICBTdWJzY3JpcHRpb24sXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCIuLi9jbGFzc2VzL29ic2VydmFibGUvb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuL2V4dGVuZC1vYnNlcnZhYmlsaXR5LXNldFwiO1xuaW1wb3J0IHsgcmFuZ2VzT3ZlcmxhcCB9IGZyb20gXCIuLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXZlUXVlcnk8VD4ocXVlcmllcjogKCkgPT4gVCB8IFByb21pc2U8VD4pOiBJT2JzZXJ2YWJsZTxUPiB7XG4gIGxldCBoYXNWYWx1ZSA9IGZhbHNlO1xuICBsZXQgY3VycmVudFZhbHVlOiBUID0gdW5kZWZpbmVkIGFzIGFueTtcbiAgY29uc3Qgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlPFQ+KChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IHNjb3BlRnVuY0lzQXN5bmMgPSBpc0FzeW5jRnVuY3Rpb24ocXVlcmllcik7XG4gICAgZnVuY3Rpb24gZXhlY3V0ZShzdWJzY3I6IE9ic2VydmFiaWxpdHlTZXQpIHtcbiAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBleGVjID0gKCkgPT4gbmV3U2NvcGUocXVlcmllciwgeyBzdWJzY3IsIHRyYW5zOiBudWxsIH0pO1xuICAgICAgY29uc3QgcnYgPSBQU0QudHJhbnNcbiAgICAgICAgPyAvLyBJZ25vcmUgY3VycmVudCB0cmFuc2FjdGlvbiBpZiBhY3RpdmUgd2hlbiBjYWxsaW5nIHN1YnNjcmliZSgpLlxuICAgICAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBleGVjKVxuICAgICAgICA6IGV4ZWMoKTtcbiAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgIChydiBhcyBQcm9taXNlPGFueT4pLnRoZW4oXG4gICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gICAgICAgICAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBydjtcbiAgICB9XG5cbiAgICBsZXQgY2xvc2VkID0gZmFsc2U7XG5cbiAgICBsZXQgYWNjdW1NdXRzOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgbGV0IGN1cnJlbnRPYnM6IE9ic2VydmFiaWxpdHlTZXQgPSB7fTtcblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0ge1xuICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlZDtcbiAgICAgIH0sXG4gICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQudW5zdWJzY3JpYmUobXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBvYnNlcnZlci5zdGFydCAmJiBvYnNlcnZlci5zdGFydChzdWJzY3JpcHRpb24pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG5cbiAgICBsZXQgcXVlcnlpbmcgPSBmYWxzZSxcbiAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHNob3VsZE5vdGlmeSgpIHtcbiAgICAgIHJldHVybiBrZXlzKGN1cnJlbnRPYnMpLnNvbWUoXG4gICAgICAgIChrZXkpID0+XG4gICAgICAgICAgYWNjdW1NdXRzW2tleV0gJiYgcmFuZ2VzT3ZlcmxhcChhY2N1bU11dHNba2V5XSwgY3VycmVudE9ic1trZXldKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtdXRhdGlvbkxpc3RlbmVyID0gKHBhcnRzOiBPYnNlcnZhYmlsaXR5U2V0KSA9PiB7XG4gICAgICBleHRlbmRPYnNlcnZhYmlsaXR5U2V0KGFjY3VtTXV0cywgcGFydHMpO1xuICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgIGRvUXVlcnkoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgZG9RdWVyeSA9ICgpID0+IHtcbiAgICAgIGlmIChxdWVyeWluZyB8fCBjbG9zZWQpIHJldHVybjtcbiAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgY29uc3Qgc3Vic2NyOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG4gICAgICBjb25zdCByZXQgPSBleGVjdXRlKHN1YnNjcik7XG4gICAgICBpZiAoIXN0YXJ0ZWRMaXN0ZW5pbmcpIHtcbiAgICAgICAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBtdXRhdGlvbkxpc3RlbmVyKTtcbiAgICAgICAgc3RhcnRlZExpc3RlbmluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBxdWVyeWluZyA9IHRydWU7XG4gICAgICBQcm9taXNlLnJlc29sdmUocmV0KS50aGVuKFxuICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICBxdWVyeWluZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgIC8vIE11dGF0aW9ucyBoYXMgaGFwcGVuZWQgd2hpbGUgd2Ugd2VyZSBxdWVyeWluZy4gUmVkbyBxdWVyeS5cbiAgICAgICAgICAgIGRvUXVlcnkoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjdW1NdXRzID0ge307XG4gICAgICAgICAgICAvLyBVcGRhdGUgd2hhdCB3ZSBhcmUgc3Vic2NyaWJpbmcgZm9yIGJhc2VkIG9uIHRoaXMgbGFzdCBydW46XG4gICAgICAgICAgICBjdXJyZW50T2JzID0gc3Vic2NyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBoYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcblxuICAgIGRvUXVlcnkoKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9KTtcbiAgb2JzZXJ2YWJsZS5oYXNWYWx1ZSA9ICgpID0+IGhhc1ZhbHVlO1xuICBvYnNlcnZhYmxlLmdldFZhbHVlID0gKCkgPT4gY3VycmVudFZhbHVlO1xuICByZXR1cm4gb2JzZXJ2YWJsZTtcbn1cbiIsICJpbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5cbmV4cG9ydCBsZXQgZG9tRGVwczogRGV4aWVET01EZXBlbmRlbmNpZXNcblxudHJ5IHtcbiAgZG9tRGVwcyA9IHtcbiAgICAvLyBSZXF1aXJlZDpcbiAgICBpbmRleGVkREI6IF9nbG9iYWwuaW5kZXhlZERCIHx8IF9nbG9iYWwubW96SW5kZXhlZERCIHx8IF9nbG9iYWwud2Via2l0SW5kZXhlZERCIHx8IF9nbG9iYWwubXNJbmRleGVkREIsXG4gICAgSURCS2V5UmFuZ2U6IF9nbG9iYWwuSURCS2V5UmFuZ2UgfHwgX2dsb2JhbC53ZWJraXRJREJLZXlSYW5nZVxuICB9O1xufSBjYXRjaCAoZSkge1xuICBkb21EZXBzID0geyBpbmRleGVkREI6IG51bGwsIElEQktleVJhbmdlOiBudWxsIH07XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgYXMgX0RleGllIH0gZnJvbSAnLi9kZXhpZSc7XG5pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwnO1xuaW1wb3J0IHsgcHJvcHMsIGRlcml2ZSwgZXh0ZW5kLCBvdmVycmlkZSwgZ2V0QnlLZXlQYXRoLCBzZXRCeUtleVBhdGgsIGRlbEJ5S2V5UGF0aCwgc2hhbGxvd0Nsb25lLCBkZWVwQ2xvbmUsIGFzYXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0T2JqZWN0RGlmZiB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmXCI7XG5pbXBvcnQgeyBmdWxsTmFtZUV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBnZXREYXRhYmFzZU5hbWVzIH0gZnJvbSAnLi4vLi4vaGVscGVycy9kYXRhYmFzZS1lbnVtZXJhdG9yJztcbmltcG9ydCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyB1c2VQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGF3YWl0SXRlcmF0b3IgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3lpZWxkLXN1cHBvcnQnO1xuaW1wb3J0IFByb21pc2UgZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCAqIGFzIERlYnVnIGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgZGV4aWVTdGFja0ZyYW1lRmlsdGVyLCBtaW5LZXksIGNvbm5lY3Rpb25zLCBERVhJRV9WRVJTSU9OIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGVycm5hbWVzIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGdldE1heEtleSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgdmlwIH0gZnJvbSAnLi92aXAnO1xuaW1wb3J0IHsgZ2xvYmFsRXZlbnRzIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcbmltcG9ydCB7IGxpdmVRdWVyeSB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeSc7XG5pbXBvcnQgeyBleHRlbmRPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSAnLi4vLi4vbGl2ZS1xdWVyeS9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXQnO1xuaW1wb3J0IHsgZG9tRGVwcyB9IGZyb20gJy4vZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBjbXAgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY21wJztcblxuLyogKERleGllKSBpcyBhbiBpbnN0YW5jZSBvZiBEZXhpZUNvbnN0cnVjdG9yLCBhcyBkZWZpbmVkIGluIHB1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvci5kLnRzXG4qICAobmV3IERleGllKCkpIGlzIGFuIGluc3RhbmNlIG9mIERleGllLCBhcyBkZWZpbmVkIGluIHB1YmxpYy90eXBlcy9kZXhpZS5kLnRzXG4qIFxuKiBXaHkgd2UncmUgZG9pbmcgdGhpcz9cblxuKiBCZWNhdXNlIHdlJ3ZlIGNob29zZW4gdG8gZGVmaW5lIHRoZSBwdWJsaWMgRGV4aWUgQVBJIHVzaW5nIGEgRGV4aWVDb25zdHJ1Y3RvciBpbnRlcmZhY2VcbiogcmF0aGVyIHRoYW4gZGVjbGFyaW5nIGEgY2xhc3MuIE9uIHRoYXQgaW50ZXJmYWNlLCBhbGwgc3RhdGljIHByb3BzIGFyZSBkZWZpbmVkLlxuKiBJbiBwcmFjdGljZSwgY2xhc3MgRGV4aWUncyBjb25zdHJ1Y3RvciBpbXBsZW1lbnRzIERleGllQ29uc3RydWN0b3IgYW5kIGFsbCBtZW1iZXIgcHJvcHNcbiogYXJlIGRlZmluZWQgaW4gaW50ZXJmYWNlIERleGllLiBXZSBjb3VsZCBzYXksIGl0J3MgYSB0eXBlc2NyaXB0IGxpbWl0YXRpb24gb2Ygbm90IGJlaW5nXG4qIGFibGUgdG8gZGVmaW5lIGEgc3RhdGljIGludGVyZmFjZSB0aGF0IGZvcmNlcyB1cyB0byBkbyB0aGUgY2FzdCBiZWxvdy5cbiovXG5jb25zdCBEZXhpZSA9IF9EZXhpZSBhcyBhbnkgYXMgRGV4aWVDb25zdHJ1Y3RvcjtcblxuLy9cbi8vIFNldCBhbGwgc3RhdGljIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgb250byBEZXhpZTpcbi8vIFxucHJvcHMoRGV4aWUsIHtcblxuICAvLyBEZXhpZS5CdWxrRXJyb3IgPSBjbGFzcyBCdWxrRXJyb3Igey4uLn07XG4gIC8vIERleGllLlhYWEVycm9yID0gY2xhc3MgWFhYRXJyb3Igey4uLn07XG4gIC4uLmZ1bGxOYW1lRXhjZXB0aW9ucyxcblxuICAvL1xuICAvLyBTdGF0aWMgZGVsZXRlKCkgbWV0aG9kLlxuICAvL1xuICBkZWxldGUoZGF0YWJhc2VOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkYiA9IG5ldyBEZXhpZShkYXRhYmFzZU5hbWUsIHthZGRvbnM6IFtdfSk7XG4gICAgcmV0dXJuIGRiLmRlbGV0ZSgpO1xuICB9LFxuXG4gIC8vXG4gIC8vIFN0YXRpYyBleGlzdHMoKSBtZXRob2QuXG4gIC8vXG4gIGV4aXN0cyhuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IERleGllKG5hbWUsIHsgYWRkb25zOiBbXSB9KS5vcGVuKCkudGhlbihkYiA9PiB7XG4gICAgICBkYi5jbG9zZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkuY2F0Y2goJ05vU3VjaERhdGFiYXNlRXJyb3InLCAoKSA9PiBmYWxzZSk7XG4gIH0sXG5cbiAgLy9cbiAgLy8gU3RhdGljIG1ldGhvZCBmb3IgcmV0cmlldmluZyBhIGxpc3Qgb2YgYWxsIGV4aXN0aW5nIGRhdGFiYXNlcyBhdCBjdXJyZW50IGhvc3QuXG4gIC8vXG4gIGdldERhdGFiYXNlTmFtZXMoY2IpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdldERhdGFiYXNlTmFtZXMoRGV4aWUuZGVwZW5kZW5jaWVzKS50aGVuKGNiKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGRlZmluZUNsYXNzKCkge1xuICAgIGZ1bmN0aW9uIENsYXNzKGNvbnRlbnQpIHtcbiAgICAgIGV4dGVuZCh0aGlzLCBjb250ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIENsYXNzO1xuICB9LFxuXG4gIGlnbm9yZVRyYW5zYWN0aW9uKHNjb3BlRnVuYykge1xuICAgIC8vIEluIGNhc2UgY2FsbGVyIGlzIHdpdGhpbiBhIHRyYW5zYWN0aW9uIGJ1dCBuZWVkcyB0byBjcmVhdGUgYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbi5cbiAgICAvLyBFeGFtcGxlIG9mIHVzYWdlOlxuICAgIC8vXG4gICAgLy8gTGV0J3Mgc2F5IHdlIGhhdmUgYSBsb2dnZXIgZnVuY3Rpb24gaW4gb3VyIGFwcC4gT3RoZXIgYXBwbGljYXRpb24tbG9naWMgc2hvdWxkIGJlIHVuYXdhcmUgb2YgdGhlXG4gICAgLy8gbG9nZ2VyIGZ1bmN0aW9uIGFuZCBub3QgbmVlZCB0byBpbmNsdWRlIHRoZSAnbG9nZW50cmllcycgdGFibGUgaW4gYWxsIHRyYW5zYWN0aW9uIGl0IHBlcmZvcm1zLlxuICAgIC8vIFRoZSBsb2dnaW5nIHNob3VsZCBhbHdheXMgYmUgZG9uZSBpbiBhIHNlcGFyYXRlIHRyYW5zYWN0aW9uIGFuZCBub3QgYmUgZGVwZW5kYW50IG9uIHRoZSBjdXJyZW50XG4gICAgLy8gcnVubmluZyB0cmFuc2FjdGlvbiBjb250ZXh0LiBUaGVuIHlvdSBjb3VsZCB1c2UgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSB0byBydW4gY29kZSB0aGF0IHN0YXJ0cyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAvL1xuICAgIC8vICAgICBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbihmdW5jdGlvbigpIHtcbiAgICAvLyAgICAgICAgIGRiLmxvZ2VudHJpZXMuYWRkKG5ld0xvZ0VudHJ5KTtcbiAgICAvLyAgICAgfSk7XG4gICAgLy9cbiAgICAvLyBVbmxlc3MgdXNpbmcgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSwgdGhlIGFib3ZlIGV4YW1wbGUgd291bGQgdHJ5IHRvIHJldXNlIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uXG4gICAgLy8gaW4gY3VycmVudCBQcm9taXNlLXNjb3BlLlxuICAgIC8vXG4gICAgLy8gQW4gYWx0ZXJuYXRpdmUgdG8gRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oKSB3b3VsZCBiZSBzZXRJbW1lZGlhdGUoKSBvciBzZXRUaW1lb3V0KCkuIFRoZSByZWFzb24gd2Ugc3RpbGwgcHJvdmlkZSBhblxuICAgIC8vIEFQSSBmb3IgdGhpcyBiZWNhdXNlXG4gICAgLy8gIDEpIFRoZSBpbnRlbnRpb24gb2Ygd3JpdGluZyB0aGUgc3RhdGVtZW50IGNvdWxkIGJlIHVuY2xlYXIgaWYgdXNpbmcgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLlxuICAgIC8vICAyKSBzZXRUaW1lb3V0KCkgd291bGQgd2FpdCB1bm5lc2Nlc3NhcnkgdW50aWwgZmlyaW5nLiBUaGlzIGlzIGhvd2V2ZXIgbm90IHRoZSBjYXNlIHdpdGggc2V0SW1tZWRpYXRlKCkuXG4gICAgLy8gIDMpIHNldEltbWVkaWF0ZSgpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIEVTIHN0YW5kYXJkLlxuICAgIC8vICA0KSBZb3UgbWlnaHQgd2FudCB0byBrZWVwIG90aGVyIFBTRCBzdGF0ZSB0aGF0IHdhcyBzZXQgaW4gYSBwYXJlbnQgUFNELCBzdWNoIGFzIFBTRC5sZXRUaHJvdWdoLlxuICAgIHJldHVybiBQU0QudHJhbnMgP1xuICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsIHNjb3BlRnVuYykgOiAvLyBVc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHRoYXQgd2FzIG5vbi10cmFuc2FjdGlvbmFsLlxuICAgICAgc2NvcGVGdW5jKCk7IC8vIE5vIG5lZWQgdG8gY2hhbmdlIHNjb3BlIGJlY2F1c2UgdGhlcmUgaXMgbm8gb25nb2luZyB0cmFuc2FjdGlvbi5cbiAgfSxcblxuICB2aXAsXG5cbiAgYXN5bmM6IGZ1bmN0aW9uIChnZW5lcmF0b3JGbjogRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKCFydiB8fCB0eXBlb2YgcnYudGhlbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgc3Bhd246IGZ1bmN0aW9uIChnZW5lcmF0b3JGbiwgYXJncywgdGhpeikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcnYgPSBhd2FpdEl0ZXJhdG9yKGdlbmVyYXRvckZuLmFwcGx5KHRoaXosIGFyZ3MgfHwgW10pKTtcbiAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocnYpO1xuICAgICAgcmV0dXJuIHJ2O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiByZWplY3Rpb24oZSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIERleGllLmN1cnJlbnRUcmFuc2FjdGlvbiBwcm9wZXJ0eVxuICBjdXJyZW50VHJhbnNhY3Rpb246IHtcbiAgICBnZXQ6ICgpID0+IFBTRC50cmFucyB8fCBudWxsXG4gIH0sXG5cbiAgd2FpdEZvcjogZnVuY3Rpb24gKHByb21pc2VPckZ1bmN0aW9uLCBvcHRpb25hbFRpbWVvdXQpIHtcbiAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpbnZva2UgaXQgYW5kIHBhc3MgdGhlIHJldHVybmluZyB2YWx1ZSB0byBUcmFuc2FjdGlvbi53YWl0Rm9yKClcbiAgICBjb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgdHlwZW9mIHByb21pc2VPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24ocHJvbWlzZU9yRnVuY3Rpb24pIDpcbiAgICAgICAgcHJvbWlzZU9yRnVuY3Rpb24pXG4gICAgICAudGltZW91dChvcHRpb25hbFRpbWVvdXQgfHwgNjAwMDApOyAvLyBEZWZhdWx0IHRoZSB0aW1lb3V0IHRvIG9uZSBtaW51dGUuIENhbGxlciBtYXkgc3BlY2lmeSBJbmZpbml0eSBpZiByZXF1aXJlZC4gICAgICAgXG5cbiAgICAvLyBSdW4gZ2l2ZW4gcHJvbWlzZSBvbiBjdXJyZW50IHRyYW5zYWN0aW9uLiBJZiBubyBjdXJyZW50IHRyYW5zYWN0aW9uLCBqdXN0IHJldHVybiBhIERleGllIHByb21pc2UgYmFzZWRcbiAgICAvLyBvbiBnaXZlbiB2YWx1ZS5cbiAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgIFBTRC50cmFucy53YWl0Rm9yKHByb21pc2UpIDpcbiAgICAgIHByb21pc2U7XG4gIH0sXG5cbiAgLy8gRXhwb3J0IG91ciBQcm9taXNlIGltcGxlbWVudGF0aW9uIHNpbmNlIGl0IGNhbiBiZSBoYW5keSBhcyBhIHN0YW5kYWxvbmUgUHJvbWlzZSBpbXBsZW1lbnRhdGlvblxuICBQcm9taXNlOiBQcm9taXNlLFxuXG4gIC8vIERleGllLmRlYnVnIHByb3B0ZXJ5OlxuICAvLyBEZXhpZS5kZWJ1ZyA9IGZhbHNlXG4gIC8vIERleGllLmRlYnVnID0gdHJ1ZVxuICAvLyBEZXhpZS5kZWJ1ZyA9IFwiZGV4aWVcIiAtIGRvbid0IGhpZGUgZGV4aWUncyBzdGFjayBmcmFtZXMuXG4gIGRlYnVnOiB7XG4gICAgZ2V0OiAoKSA9PiBEZWJ1Zy5kZWJ1ZyxcbiAgICBzZXQ6IHZhbHVlID0+IHtcbiAgICAgIERlYnVnLnNldERlYnVnKHZhbHVlLCB2YWx1ZSA9PT0gJ2RleGllJyA/ICgpID0+IHRydWUgOiBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuICAgIH1cbiAgfSxcblxuICAvLyBFeHBvcnQgb3VyIGRlcml2ZS9leHRlbmQvb3ZlcnJpZGUgbWV0aG9kb2xvZ3lcbiAgZGVyaXZlOiBkZXJpdmUsIC8vIERlcHJlY2F0ZT9cbiAgZXh0ZW5kOiBleHRlbmQsIC8vIERlcHJlY2F0ZT9cbiAgcHJvcHM6IHByb3BzLFxuICBvdmVycmlkZTogb3ZlcnJpZGUsIC8vIERlcHJlY2F0ZT9cbiAgLy8gRXhwb3J0IG91ciBFdmVudHMoKSBmdW5jdGlvbiAtIGNhbiBiZSBoYW5keSBhcyBhIHRvb2xraXRcbiAgRXZlbnRzOiBFdmVudHMsXG4gIG9uOiBnbG9iYWxFdmVudHMsXG4gIGxpdmVRdWVyeSxcbiAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCxcbiAgLy8gVXRpbGl0aWVzXG4gIGdldEJ5S2V5UGF0aDogZ2V0QnlLZXlQYXRoLFxuICBzZXRCeUtleVBhdGg6IHNldEJ5S2V5UGF0aCxcbiAgZGVsQnlLZXlQYXRoOiBkZWxCeUtleVBhdGgsXG4gIHNoYWxsb3dDbG9uZTogc2hhbGxvd0Nsb25lLFxuICBkZWVwQ2xvbmU6IGRlZXBDbG9uZSxcbiAgZ2V0T2JqZWN0RGlmZjogZ2V0T2JqZWN0RGlmZixcbiAgY21wLFxuICBhc2FwOiBhc2FwLFxuICAvL21heEtleTogbmV3IERleGllKCcnLHthZGRvbnM6W119KS5fbWF4S2V5LFxuICBtaW5LZXk6IG1pbktleSxcbiAgLy8gQWRkb24gcmVnaXN0cnlcbiAgYWRkb25zOiBbXSxcbiAgLy8gR2xvYmFsIERCIGNvbm5lY3Rpb24gbGlzdFxuICBjb25uZWN0aW9uczogY29ubmVjdGlvbnMsXG5cbiAgLy9NdWx0aU1vZGlmeUVycm9yOiBleGNlcHRpb25zLk1vZGlmeSwgLy8gT2Jzb2xldGUhXG4gIGVycm5hbWVzOiBlcnJuYW1lcyxcblxuICAvLyBFeHBvcnQgb3RoZXIgc3RhdGljIGNsYXNzZXNcbiAgLy9JbmRleFNwZWM6IEluZGV4U3BlYywgT2Jzb2xldGUhXG4gIC8vVGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCBPYnNvbGV0ZSFcblxuICAvL1xuICAvLyBEZXBlbmRlbmNpZXNcbiAgLy9cbiAgLy8gVGhlc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IHdvcmsgaW4gYnJvd3NlcnMgd2l0aCBpbmRleGVkREIgc3VwcG9ydCwgb3Igd2hlcmUgYW4gaW5kZXhlZERCIHBvbHlmaWxsIGhhcyBiZWVuIGluY2x1ZGVkLlxuICAvL1xuICAvLyBJbiBub2RlLmpzLCBob3dldmVyLCB0aGVzZSBwcm9wZXJ0aWVzIG11c3QgYmUgc2V0IFwibWFudWFsbHlcIiBiZWZvcmUgaW5zdGFuc2lhdGluZyBhIG5ldyBEZXhpZSgpLlxuICAvLyBGb3Igbm9kZS5qcywgeW91IG5lZWQgdG8gcmVxdWlyZSBpbmRleGVkZGItanMgb3Igc2ltaWxhciBhbmQgdGhlbiBzZXQgdGhlc2UgZGVwcy5cbiAgLy9cbiAgZGVwZW5kZW5jaWVzOiBkb21EZXBzLFxuXG4gIC8vIEFQSSBWZXJzaW9uIE51bWJlcjogVHlwZSBOdW1iZXIsIG1ha2Ugc3VyZSB0byBhbHdheXMgc2V0IGEgdmVyc2lvbiBudW1iZXIgdGhhdCBjYW4gYmUgY29tcGFyYWJsZSBjb3JyZWN0bHkuIEV4YW1wbGU6IDAuOSwgMC45MSwgMC45MiwgMS4wLCAxLjAxLCAxLjEsIDEuMiwgMS4yMSwgZXRjLlxuICBzZW1WZXI6IERFWElFX1ZFUlNJT04sXG4gIHZlcnNpb246IERFWElFX1ZFUlNJT04uc3BsaXQoJy4nKVxuICAgIC5tYXAobiA9PiBwYXJzZUludChuKSlcbiAgICAucmVkdWNlKChwLCBjLCBpKSA9PiBwICsgKGMgLyBNYXRoLnBvdygxMCwgaSAqIDIpKSksXG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RmYWhsYW5kZXIvRGV4aWUuanMvaXNzdWVzLzE4NlxuICAvLyB0eXBlc2NyaXB0IGNvbXBpbGVyIHRzYyBpbiBtb2RlIHRzLS0+ZXM1ICYgY29tbW9uSlMsIHdpbGwgZXhwZWN0IHJlcXVpcmUoKSB0byByZXR1cm5cbiAgLy8geC5kZWZhdWx0LiBXb3JrYXJvdW5kOiBTZXQgRGV4aWUuZGVmYXVsdCA9IERleGllLlxuICAvLyBkZWZhdWx0OiBEZXhpZSwgLy8gQ29tbWVudGVkIGJlY2F1c2Ugc29sdmVkIGluIGluZGV4LXVtZC50cyBpbnN0ZWFkLlxuICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGltcG9ydCB7RGV4aWV9IChub24tZGVmYXVsdCBpbXBvcnQpXG4gIC8vIFJlYXNvbiAxOiBNYXkgc3dpdGNoIHRvIHRoYXQgaW4gZnV0dXJlLlxuICAvLyBSZWFzb24gMjogV2UgZGVjbGFyZSBpdCBib3RoIGRlZmF1bHQgYW5kIG5hbWVkIGV4cG9ydGVkIGluIGQudHMgdG8gbWFrZSBpdCBwb3NzaWJsZVxuICAvLyB0byBsZXQgYWRkb25zIGV4dGVuZCB0aGUgRGV4aWUgaW50ZXJmYWNlIHdpdGggVHlwZXNjcmlwdCAyLjEgKHdvcmtzIG9ubHkgd2hlbiBleHBsaWNpdGVseVxuICAvLyBleHBvcnRpbmcgdGhlIHN5bWJvbCwgbm90IGp1c3QgZGVmYXVsdCBleHBvcnRpbmcpXG4gIC8vIERleGllOiBEZXhpZSAvLyBDb21tZW50ZWQgYmVjYXVzZSBzb2x2ZWQgaW4gaW5kZXgtdW1kLnRzIGluc3RlYWQuXG59KTtcblxuRGV4aWUubWF4S2V5ID0gZ2V0TWF4S2V5KERleGllLmRlcGVuZGVuY2llcy5JREJLZXlSYW5nZSk7XG4iLCAiaW1wb3J0IHsgaXNJRU9yRWRnZSB9IGZyb20gJy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdsb2JhbEV2ZW50cywgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSB9IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBPYnNlcnZhYmlsaXR5U2V0IH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcblxuaWYgKHR5cGVvZiBkaXNwYXRjaEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsRXZlbnRzKERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCB1cGRhdGVkUGFydHMgPT4ge1xuICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICBsZXQgZXZlbnQ6IEN1c3RvbUV2ZW50PE9ic2VydmFiaWxpdHlTZXQ+O1xuICAgICAgaWYgKGlzSUVPckVkZ2UpIHtcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwgdHJ1ZSwgdHJ1ZSwgdXBkYXRlZFBhcnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSwge1xuICAgICAgICAgIGRldGFpbDogdXBkYXRlZFBhcnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgYWRkRXZlbnRMaXN0ZW5lcihTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsICh7ZGV0YWlsfTogQ3VzdG9tRXZlbnQ8T2JzZXJ2YWJpbGl0eVNldD4pID0+IHtcbiAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgcHJvcGFnYXRlTG9jYWxseShkZXRhaWwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9wYWdhdGVMb2NhbGx5KHVwZGF0ZVBhcnRzOiBPYnNlcnZhYmlsaXR5U2V0KSB7XG4gIGxldCB3YXNNZSA9IHByb3BhZ2F0aW5nTG9jYWxseTtcbiAgdHJ5IHtcbiAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB0cnVlO1xuICAgIGdsb2JhbEV2ZW50cy5zdG9yYWdlbXV0YXRlZC5maXJlKHVwZGF0ZVBhcnRzKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwcm9wYWdhdGluZ0xvY2FsbHkgPSB3YXNNZTtcbiAgfVxufVxuXG5leHBvcnQgbGV0IHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuIiwgImltcG9ydCB7XG4gIGdsb2JhbEV2ZW50cyxcbiAgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICBERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSxcbn0gZnJvbSAnLi4vZ2xvYmFscy9nbG9iYWwtZXZlbnRzJztcbmltcG9ydCB7IHByb3BhZ2F0ZUxvY2FsbHksIHByb3BhZ2F0aW5nTG9jYWxseSB9IGZyb20gJy4vcHJvcGFnYXRlLWxvY2FsbHknO1xuXG5pZiAodHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIGNvbnN0IGJjID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKTtcblxuICAvKipcbiAgICAgKiBUaGUgTm9kZS5qcyBCcm9hZGNhc3RDaGFubmVsIHdpbGwgcHJldmVudCB0aGUgbm9kZSBwcm9jZXNzIGZyb20gZXhpdGluZ1xuICAgICAqIGlmIHRoZSBCcm9hZGNhc3RDaGFubmVsIGlzIG5vdCBjbG9zZWQuXG4gICAgICogVGhlcmVmb3JlIHdlIGhhdmUgdG8gY2FsbCB1bnJlZigpIHdoaWNoIGFsbG93cyB0aGUgcHJvY2VzcyB0byBmaW5pc2hcbiAgICAgKiBwcm9wZXJseSBldmVuIHdoZW4gdGhlIEJyb2FkY2FzdENoYW5uZWwgaXMgbmV2ZXIgY2xvc2VkLlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvd29ya2VyX3RocmVhZHMuaHRtbCNicm9hZGNhc3RjaGFubmVsdW5yZWZcbiAgICAgKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vZGV4aWUvRGV4aWUuanMvcHVsbC8xNTc2XG4gICAgICovXG4gIGlmICh0eXBlb2YgKGJjIGFzIGFueSkudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAoYmMgYXMgYW55KS51bnJlZigpO1xuICB9IFxuICAgXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSBsb2NhbCBjaGFuZ2VzIHRvIHJlbW90ZSB0YWJzLCB3aW5kb3dzIGFuZCB3b3JrZXJzIHZpYSBCcm9hZGNhc3RDaGFubmVsXG4gIC8vXG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgIGlmICghcHJvcGFnYXRpbmdMb2NhbGx5KSB7XG4gICAgICBiYy5wb3N0TWVzc2FnZShjaGFuZ2VkUGFydHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy9cbiAgLy8gUHJvcGFnYXRlIHJlbW90ZSBjaGFuZ2VzIGxvY2FsbHkgdmlhIHN0b3JhZ2UgZXZlbnQ6XG4gIC8vXG4gIGJjLm9ubWVzc2FnZSA9IChldikgPT4ge1xuICAgIGlmIChldi5kYXRhKSBwcm9wYWdhdGVMb2NhbGx5KGV2LmRhdGEpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gRE9NIHZlcmlmaWVkIC0gd2hlbiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiwgd2UgYXJlIGEgd2luZG93IG9yIHdvcmtlci4gTm90IGEgTm9kZSBwcm9jZXNzLlxuXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSBsb2NhbCBjaGFuZ2VzIHRvIHJlbW90ZSB0YWJzL3dpbmRvd3MgdmlhIHN0b3JhZ2UgZXZlbnQgYW5kIHNlcnZpY2Ugd29ya2VyXG4gIC8vIHZpYSBtZXNzYWdlcy4gV2UgaGF2ZSB0aGlzIGNvZGUgaGVyZSBiZWNhdXNlIG9mIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNjE0NzIuXG4gIC8vXG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgKGNoYW5nZWRQYXJ0cykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBXZSdyZSBhIGJyb3dzaW5nIHdpbmRvdyBvciB0YWIuIFByb3BhZ2F0ZSB0byBvdGhlciB3aW5kb3dzL3RhYnMgdmlhIHN0b3JhZ2UgZXZlbnQ6XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHRyaWc6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlbGZbJ2NsaWVudHMnXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBXZSdyZSBhIHNlcnZpY2Ugd29ya2VyLiBQcm9wYWdhdGUgdG8gb3VyIGJyb3dzZXIgY2xpZW50cy5cbiAgICAgICAgICBbLi4uc2VsZlsnY2xpZW50cyddLm1hdGNoQWxsKHsgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZSB9KV0uZm9yRWFjaChcbiAgICAgICAgICAgIChjbGllbnQpID0+XG4gICAgICAgICAgICAgIGNsaWVudC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICAgICAgICAgICAgICAgIGNoYW5nZWRQYXJ0cyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7fVxuICB9KTtcblxuICAvL1xuICAvLyBQcm9wYWdhdGUgcmVtb3RlIGNoYW5nZXMgbG9jYWxseSB2aWEgc3RvcmFnZSBldmVudDpcbiAgLy9cbiAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIChldjogU3RvcmFnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXYua2V5ID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoZXYubmV3VmFsdWUpO1xuICAgICAgICBpZiAoZGF0YSkgcHJvcGFnYXRlTG9jYWxseShkYXRhLmNoYW5nZWRQYXJ0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvL1xuICAvLyBQcm9wYWdhdGUgbWVzc2FnZXMgZnJvbSBzZXJ2aWNlIHdvcmtlclxuICAvL1xuICBjb25zdCBzd0NvbnRhaW5lciA9IHNlbGYuZG9jdW1lbnQgJiYgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXI7IC8vIHNlbGYuZG9jdW1lbnQgaXMgdG8gdmVyaWZ5IHdlJ3JlIG5vdCB0aGUgU1cgb3Vyc2VsZlxuICBpZiAoc3dDb250YWluZXIpIHtcbiAgICAvLyBXZSdyZSBhIGJyb3dzZXIgd2luZG93IGFuZCB3YW50IHRvIHByb3BhZ2F0ZSBtZXNzYWdlIGZyb20gdGhlIFNXOlxuICAgIHN3Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBwcm9wYWdhdGVNZXNzYWdlTG9jYWxseSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkoeyBkYXRhIH06IE1lc3NhZ2VFdmVudCkge1xuICBpZiAoZGF0YSAmJiBkYXRhLnR5cGUgPT09IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSkge1xuICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuL2NsYXNzZXMvZGV4aWUnO1xuaW1wb3J0IHsgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gJy4vcHVibGljL3R5cGVzL2RleGllLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IERleGllUHJvbWlzZSB9IGZyb20gJy4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IG1hcEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IGRleGllU3RhY2tGcmFtZUZpbHRlciB9IGZyb20gJy4vZ2xvYmFscy9jb25zdGFudHMnO1xuXG4vLyBHZW5lcmF0ZSBhbGwgc3RhdGljIHByb3BlcnRpZXMgc3VjaCBhcyBEZXhpZS5tYXhLZXkgZXRjXG4vLyAoaW1wbGVtZW50IGludGVyZmFjZSBEZXhpZUNvbnN0cnVjdG9yKTpcbmltcG9ydCAnLi9jbGFzc2VzL2RleGllL2RleGllLXN0YXRpYy1wcm9wcyc7XG5pbXBvcnQgJy4vbGl2ZS1xdWVyeS9lbmFibGUtYnJvYWRjYXN0JztcbmltcG9ydCB7IGxpdmVRdWVyeSB9IGZyb20gJy4vbGl2ZS1xdWVyeS9saXZlLXF1ZXJ5JztcblxuLy8gU2V0IHJlamVjdGlvbk1hcHBlciBvZiBEZXhpZVByb21pc2Ugc28gdGhhdCBpdCBnZW5lcmFsbHkgdHJpZXMgdG8gbWFwXG4vLyBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnMgdG8gYSBEZXhpZUVycm9yIGluc3RhbmNlIHdpdGggc2FtZSBuYW1lIGJ1dCB3aXRoXG4vLyBhc3luYyBzdGFjayBzdXBwb3J0IGFuZCB3aXRoIGEgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBmcm9tIERleGllRXJyb3IgYW5kIEVycm9yLlxuLy8gb2YgTWFwIERPTUVycm9ycyBhbmQgRE9NRXhjZXB0aW9ucyB0byBjb3JyZXNwb25kaW5nIERleGllIGVycm9ycy5cbkRleGllUHJvbWlzZS5yZWplY3Rpb25NYXBwZXIgPSBtYXBFcnJvcjtcblxuLy8gTGV0IHRoZSBhc3luYyBzdGFjayBmaWx0ZXIgZm9jdXMgb24gYXBwIGNvZGUgYW5kIGZpbHRlciBhd2F5IGZyYW1lcyBmcm9tIGRleGllLm1pbi5qczpcbkRlYnVnLnNldERlYnVnKERlYnVnLmRlYnVnLCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIpO1xuXG5leHBvcnQgeyBSYW5nZVNldCwgbWVyZ2VSYW5nZXMsIHJhbmdlc092ZXJsYXAgfSBmcm9tIFwiLi9oZWxwZXJzL3Jhbmdlc2V0XCI7XG5leHBvcnQgeyBEZXhpZSwgbGl2ZVF1ZXJ5IH07IC8vIENvbXBseSB3aXRoIHB1YmxpYy9pbmRleC5kLnRzLlxuZXhwb3J0IGRlZmF1bHQgRGV4aWU7XG4iLCAiaW1wb3J0IERleGllLCB7IFRhYmxlIH0gZnJvbSBcImRleGllXCJcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRG9jdW1lbnRcIlxuaW1wb3J0IHsgY3JlYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi90b29sc1wiXG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlcIlxuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyXCJcblxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRG9jdW1lbnQge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRm9sZGVyIHtcbiAgcGF0aDogc3RyaW5nLCBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyBcbn1cblxuZXhwb3J0IGNsYXNzIFBlcm1hbmVudFNoYXJlU3RvcmVJbmRleGVkREIge1xuXG4gIG9pZDogc3RyaW5nXG4gIHByaXZhdGUgZG9jdW1lbnRUYWJsZTogVGFibGU8UGVybWFuZW50U2hhcmVEb2N1bWVudCwgc3RyaW5nPlxuICBwcml2YXRlIGZvbGRlclRhYmxlOiBUYWJsZTxQZXJtYW5lbnRTaGFyZUZvbGRlciwgc3RyaW5nPlxuICBwcml2YXRlIGRiOiBEZXhpZVxuXG4gIGtlZXBPcGVuOiBib29sZWFuID0gdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKG9pZDogc3RyaW5nKSB7XG4gICAgdGhpcy5vaWQgPSBvaWRcbiAgICB0aGlzLmRiID0gbmV3IERleGllKCdwZWVyZHJhZnRfJyArIHRoaXMub2lkKVxuICAgIHRoaXMuZGIudmVyc2lvbigyKS5zdG9yZXMoe1xuICAgICAgc2hhcmVkRG9jczogXCJwYXRoLHBlcnNpc3RlbmNlSWQsc2hhcmVJZFwiLFxuICAgICAgc2hhcmVkRm9sZGVyczogXCJwYXRoLHBlcnNpc3RlbmNlSWQsc2hhcmVJZFwiXG4gICAgfSlcbiAgICB0aGlzLmRiLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5rZWVwT3Blbikge1xuICAgICAgICB0aGlzLmRiLm9wZW4oKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5kb2N1bWVudFRhYmxlID0gdGhpcy5kYi5fYWxsVGFibGVzW1wic2hhcmVkRG9jc1wiXSBhcyBUYWJsZTxQZXJtYW5lbnRTaGFyZURvY3VtZW50LCBzdHJpbmc+XG4gICAgdGhpcy5mb2xkZXJUYWJsZSA9IHRoaXMuZGIuX2FsbFRhYmxlc1tcInNoYXJlZEZvbGRlcnNcIl0gYXMgVGFibGU8UGVybWFuZW50U2hhcmVGb2xkZXIsIHN0cmluZz5cbiAgfVxuXG4gIGNsb3NlKCl7XG4gICAgdGhpcy5rZWVwT3BlbiA9IGZhbHNlXG4gICAgdGhpcy5kYi5jbG9zZSgpXG4gIH1cblxuICBhZGQoZG9jOiBTaGFyZWRFbnRpdHkpIHtcbiAgICBpZihkb2MgaW5zdGFuY2VvZiBTaGFyZWREb2N1bWVudCl7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLmFkZCh7XG4gICAgICAgIHBhdGg6IGRvYy5wYXRoLFxuICAgICAgICBzaGFyZUlkOiBkb2Muc2hhcmVJZCxcbiAgICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYoZG9jIGluc3RhbmNlb2YgU2hhcmVkRm9sZGVyKXtcbiAgICAgIHJldHVybiB0aGlzLmZvbGRlclRhYmxlLmFkZCh7XG4gICAgICAgIHBhdGg6IGRvYy5wYXRoLFxuICAgICAgICBzaGFyZUlkOiBkb2Muc2hhcmVJZCxcbiAgICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW1vdmVEb2MocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUYWJsZS5kZWxldGUocGF0aClcbiAgfVxuXG4gIGFzeW5jIGdldERvY0J5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLmdldChwYXRoKVxuICB9XG5cbiAgZ2V0QWxsRG9jcygpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudFRhYmxlLnRvQXJyYXkoKVxuICB9XG5cbiAgcmVtb3ZlRm9sZGVyKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmZvbGRlclRhYmxlLmRlbGV0ZShwYXRoKVxuICB9XG5cbiAgZ2V0QWxsRm9sZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS50b0FycmF5KClcbiAgfVxuXG4gIGFzeW5jIGdldEZvbGRlckJ5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS5nZXQocGF0aClcbiAgfVxuXG5cbiAgYXN5bmMgZGVsZXRlREIoKSB7XG4gICAgd2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmZvbGRlclRhYmxlLm5hbWUpXG4gICAgd2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLmRvY3VtZW50VGFibGUubmFtZSlcbiAgfVxuXG59IiwgImltcG9ydCB7IHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwiLi9wZWVyZHJhZnRQbHVnaW5cIlxuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCIuL3VpXCJcblxuZXhwb3J0IGNvbnN0IHJlcXVlc3RMb2dpbkNvZGUgPSBhc3luYyAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4sIGVtYWlsOiBzdHJpbmcpID0+IHtcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiL2dyb3VwL2xvZ2luL3NlbmQtbWFpbC13aXRoLWNvZGVcIiwgcGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoKS50b1N0cmluZygpXG5cbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgIHVybCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZW1haWxcbiAgICB9KVxuICB9KS5qc29uXG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLm9rKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIHRydWVcblxufVxuXG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0V2ViVG9rZW4gPSBhc3luYyAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4sIGVtYWlsOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcsIGxvbmdMaXZlZDogYm9vbGVhbikgPT4ge1xuXG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoXCIvZ3JvdXAvbG9naW4vdmVyaWZ5LWNvZGVcIiwgcGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoKS50b1N0cmluZygpXG5cbiAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgIHVybCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZW1haWwsIHRva2VuLCBsb25nTGl2ZWRcbiAgICB9KVxuICB9KS5qc29uXG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLmp3dCkge1xuICAgIHJldHVyblxuICB9XG4gIHJldHVybiBkYXRhLmp3dFxufVxuXG5leHBvcnQgY29uc3Qgc2F2ZUpXVCA9IChvaWQ6IHN0cmluZywgand0OiBzdHJpbmcpID0+IHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0ob2lkICsgXCItcGVlcmRyYWZ0LWp3dFwiLCBqd3QpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRKV1QgPSAob2lkOiBzdHJpbmcpID0+IHtcbiAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKG9pZCArIFwiLXBlZXJkcmFmdC1qd3RcIilcbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFySldUID0gKG9pZDogc3RyaW5nKSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG9pZCArIFwiLXBlZXJkcmFmdC1qd3RcIilcbn1cblxuZXhwb3J0IGNvbnN0IGxvZ291dCA9IChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNlcnZlciA9IHBsdWdpbi5zZXJ2ZXJTeW5jXG4gICAgaWYgKHNlcnZlci5hdXRoZW50aWNhdGVkKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBjbGVhckpXVChwbHVnaW4uc2V0dGluZ3Mub2lkKVxuICAgICAgICBzZXJ2ZXIuand0ID0gdW5kZWZpbmVkXG4gICAgICAgIHNlcnZlci5vZmYoJ2Nvbm5lY3Rpb24tY2xvc2UnLCBoYW5kbGVyKVxuICAgICAgICBzaG93Tm90aWNlKFwiTG9nZ2VkIG91dCBvZiBQZWVyZHJhZnRcIilcbiAgICAgICAgc2VydmVyLmNvbm5lY3QoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH1cbiAgICAgIHNlcnZlci5vbignY29ubmVjdGlvbi1jbG9zZScsIGhhbmRsZXIpXG4gICAgICBzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgfVxuICB9KVxufSIsICJpbXBvcnQgeyBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcmVxdWVzdExvZ2luQ29kZSwgcmVxdWVzdFdlYlRva2VuLCBzYXZlSldUIH0gZnJvbSBcInNyYy9sb2dpblwiO1xuaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwic3JjL3BlZXJkcmFmdFBsdWdpblwiO1xuaW1wb3J0IHsgc2F2ZVNldHRpbmdzIH0gZnJvbSBcInNyYy9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCJzcmMvdWlcIjtcblxuY2xhc3MgTG9naW5Nb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuXG4gIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luXG4gIGNiOiAoc3VjY2VzczogYm9vbGVhbikgPT4gYW55XG4gIGNiQ2FsbGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc3RvcmVKV1QgPSBmYWxzZVxuICBjb2RlID0gJydcbiAgZW1haWwgPSAnJ1xuXG4gIGNvbnN0cnVjdG9yKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luLCBjYjogKHN1Y2Nlc3M6IGJvb2xlYW4pID0+IGFueSkge1xuICAgIHN1cGVyKHBsdWdpbi5hcHApXG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW5cbiAgICB0aGlzLmNiID0gY2JcbiAgICB0aGlzLmVtYWlsID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbi5lbWFpbCA/PyAnJ1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIHRoaXMuY29udGVudEVsLmVtcHR5KClcbiAgICBjb25zdCBoZWFkaW5nID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbi5lbWFpbCA/IFwiTG9nIGluIHRvIHlvdXIgUGVlcmRyYWZ0IGFjY291bnRcIiA6IFwiTG9nIGluIG9yIHJlZ2lzdGVyIHdpdGggUGVlcmRyYWZ0XCJcbiAgICBjb25zdCBoZWFkZXJTZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLnNldE5hbWUoaGVhZGluZykgLy8uc2V0SGVhZGluZygpLnNldERlc2MoXCJcIilcblxuICAgIGNvbnN0IGhlYWRlckRpdiA9IGhlYWRlclNldHRpbmcuZGVzY0VsLmNyZWF0ZURpdigpXG5cbiAgICBoZWFkZXJEaXYuY3JlYXRlU3Bhbih7IHRleHQ6IFwiVG8gaW5pdGlhdGUgbmV3IHNoYXJlZCBkb2N1bWVudHMgb3IgZm9sZGVycyB5b3UgbmVlZCB0byBoYXZlIGEgUGVlcmRyYWZ0IGFjY291bnQuIENvbGxhYm9yYXRvcnMgY2FuIGpvaW4gd2l0aG91dCByZWdpc3RyYXRpb24uIElmIHlvdSBuZWVkIGFueSBoZWxwLCBcIiB9KVxuICAgIGhlYWRlckRpdi5jcmVhdGVFbChcImFcIiwge1xuICAgICAgdGV4dDogXCJnZXQgaW4gdG91Y2hcIixcbiAgICAgIGF0dHI6IHtcbiAgICAgICAgaHJlZjogXCJtYWlsdG86ZG9taW5pa0BwZWVyZHJhZnQuYXBwXCJcbiAgICAgIH1cbiAgICB9KVxuICAgIGhlYWRlckRpdi5jcmVhdGVTcGFuKHsgdGV4dDogJy4nIH0pXG5cbiAgICBjb25zdCBlbWFpbFNldHRpbmcgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICBlbWFpbFNldHRpbmcuc2V0TmFtZShcIllvdXIgZS1tYWlsIGFkZHJlc3NcIilcbiAgICBlbWFpbFNldHRpbmcuZGVzY0VsLmlubmVySFRNTCA9ICdCeSBzaWduaW5nIHVwIG9yIGxvZ2dpbmcgaW4sIHlvdSBhZ3JlZSB0byA8YSBocmVmPVwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC90ZXJtc1wiPnRoZSBUZXJtcyBvZiBTZXJ2aWNlPC9hPiBhbmQgdGhlIDxhIGhyZWY9XCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3ByaXZhY3lcIj5Qcml2YWN5IFBvbGljeTwvYT4uJ1xuICAgIGVtYWlsU2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHIoXCJ0eXBlXCIsIFwiZW1haWxcIilcbiAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5lbWFpbClcbiAgICAgIHRleHQub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICB0aGlzLmVtYWlsID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGVtYWlsU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiU2VuZCBMb2dpbiBDb2RlXCIpXG4gICAgICBidXR0b24ub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5lbWFpbC5tYXRjaCgvXlxcUytAXFxTK1xcLlxcUyskLykpIHtcbiAgICAgICAgICBzaG93Tm90aWNlKFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwgYWRkcmVzcy5cIilcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGNvbnN0IGNvZGUgPSBhd2FpdCByZXF1ZXN0TG9naW5Db2RlKHRoaXMucGx1Z2luLCB0aGlzLmVtYWlsKVxuXG4gICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHNob3dOb3RpY2UoXCJDb2RlIHNlbnQgdG8gXCIgKyB0aGlzLmVtYWlsICsgXCIuXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNob3dOb3RpY2UoXCJTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBvciBnZXQgaW4gdG91Y2ggd2l0aCBwZWVyZHJhZnQgc3VwcG9ydC5cIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IHJlbWVtYmVyU2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuICAgIHJlbWVtYmVyU2V0dGluZy5zZXROYW1lKFwiUmVtZW1iZXIgbWVcIilcbiAgICByZW1lbWJlclNldHRpbmcuc2V0RGVzYyhcIklmIGRpc2FibGVkLCB5b3Ugd2lsbCBiZSBhc2tlZCB0byBsb2cgaW4gb24gZXZlcnkgcmVzdGFydCBvZiBPYnNpZGlhbi5cIilcbiAgICByZW1lbWJlclNldHRpbmcuYWRkVG9nZ2xlKCh0b2dnbCkgPT4ge1xuICAgICAgdG9nZ2wuc2V0VmFsdWUodGhpcy5zdG9yZUpXVClcbiAgICAgIHRvZ2dsLm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5zdG9yZUpXVCA9IHZhbHVlXG4gICAgICAgIHRoaXMub25PcGVuKClcbiAgICAgIH0pXG4gICAgfSlcblxuXG4gICAgY29uc3QgY29kZVNldHRpbmcgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICBjb2RlU2V0dGluZy5zZXROYW1lKFwiTG9naW4gQ29kZVwiKVxuICAgIGNvZGVTZXR0aW5nLnNldERlc2MoXCJFbnRlciB0aGUgY29kZSB5b3UgcmVjZWl2ZWQgdmlhIGVtYWlsLlwiKVxuICAgIGNvZGVTZXR0aW5nLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICB0ZXh0LmlucHV0RWwuc2V0QXR0cihcInR5cGVcIiwgXCJwYXNzd29yZFwiKVxuICAgICAgdGV4dC5zZXRWYWx1ZSh0aGlzLmNvZGUpXG4gICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5jb2RlID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvZGVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgY29uc3QgdGV4dCA9IHRoaXMuc3RvcmVKV1QgPyBcIkxvZyBpbiBhbmQgcmVtZW1iZXIgbWVcIiA6IFwiTG9nIGluIGZvciB0aGlzIHNlc3Npb24gb25seVwiXG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dCh0ZXh0KVxuICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW1haWwubWF0Y2goL15cXFMrQFxcUytcXC5cXFMrJC8pKSB7XG4gICAgICAgICAgc2hvd05vdGljZShcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY29kZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgand0ID0gYXdhaXQgcmVxdWVzdFdlYlRva2VuKHRoaXMucGx1Z2luLCB0aGlzLmVtYWlsLCB0aGlzLmNvZGUsIHRoaXMuc3RvcmVKV1QpXG5cblxuICAgICAgICBpZiAoand0KSB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbi5lbWFpbCA9IHRoaXMuZW1haWxcbiAgICAgICAgICBzYXZlU2V0dGluZ3ModGhpcy5wbHVnaW4uc2V0dGluZ3MsIHRoaXMucGx1Z2luKVxuXG4gICAgICAgICAgaWYgKGF3YWl0IHRoaXMucGx1Z2luLnNlcnZlclN5bmMuYXV0aGVudGljYXRlKGp3dCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlSldUKSB7XG4gICAgICAgICAgICAgIHNhdmVKV1QodGhpcy5wbHVnaW4uc2V0dGluZ3Mub2lkLCBqd3QpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNiKHRydWUpXG4gICAgICAgICAgICB0aGlzLmNiQ2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3dOb3RpY2UoXCJTb21ldGhpbmcgd2VudCB3cm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBvciBnZXQgaW4gdG91Y2ggd2l0aCBwZWVyZHJhZnQgc3VwcG9ydC5cIilcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIH0pXG5cbiAgfVxuXG4gIG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLmNiQ2FsbGVkKSB7XG4gICAgICB0aGlzLmNiKGZhbHNlKVxuICAgICAgdGhpcy5jYkNhbGxlZCA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9wZW5Mb2dpbk1vZGFsID0gKHBlZXJkcmFmdFBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IExvZ2luTW9kYWwocGVlcmRyYWZ0UGx1Z2luLCAoY2IpID0+IHtcbiAgICAgIHJlc29sdmUoY2IpXG4gICAgfSkub3BlbigpXG4gIH0pXG5cbn0iLCAiaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudFwiXG5pbXBvcnQgeyBjcmVhdGVSYW5kb21JZCB9IGZyb20gXCIuL3Rvb2xzXCJcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gXCIuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEVudGl0eVwiXG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRGb2xkZXJcIlxuaW1wb3J0IFBlZXJkcmFmdFBsdWdpbiBmcm9tIFwiLi9wZWVyZHJhZnRQbHVnaW5cIlxuaW1wb3J0IHsgc2F2ZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIlxuaW1wb3J0IHsgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVybWFuZW50U2hhcmVEb2N1bWVudCB7XG4gIHBhdGg6IHN0cmluZywgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZXJtYW5lbnRTaGFyZUZvbGRlciB7XG4gIHBhdGg6IHN0cmluZywgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmdcbn1cblxuXG5leHBvcnQgY29uc3QgYWRkID0gYXN5bmMgKGRvYzogU2hhcmVkRW50aXR5LCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBpZiAoZG9jIGluc3RhbmNlb2YgU2hhcmVkRG9jdW1lbnQpIHtcbiAgICBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLnNldChkb2MucGF0aCwge1xuICAgICAgc2hhcmVJZDogZG9jLnNoYXJlSWQsXG4gICAgICBwZXJzaXN0ZW5jZUlkOiBjcmVhdGVSYW5kb21JZCgpXG4gICAgfSlcbiAgfVxuICBpZiAoZG9jIGluc3RhbmNlb2YgU2hhcmVkRm9sZGVyKSB7XG4gICAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLnNldChkb2MucGF0aCwge1xuICAgICAgc2hhcmVJZDogZG9jLnNoYXJlSWQsXG4gICAgICBwZXJzaXN0ZW5jZUlkOiBjcmVhdGVSYW5kb21JZCgpXG4gICAgfSlcbiAgfVxuICBzYXZlU2V0dGluZ3MocGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pXG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVEb2MgPSBhc3luYyAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLmRlbGV0ZShub3JtYWxpemVQYXRoKHBhdGgpKVxuICBzYXZlU2V0dGluZ3MocGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pXG59XG5cbmV4cG9ydCBjb25zdCBnZXREb2NCeVBhdGggPSAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICByZXR1cm4gcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5nZXQocGF0aClcbn1cblxuZXhwb3J0IGNvbnN0IG1vdmVEb2MgPSBhc3luYyAob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IGZpbGVzID0gcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlc1xuICBjb25zdCBlbnRyeSA9IGZpbGVzLmdldChvbGRQYXRoKVxuICBpZiAoZW50cnkpIHtcbiAgICBmaWxlcy5kZWxldGUob2xkUGF0aClcbiAgICBmaWxlcy5zZXQobmV3UGF0aCwgZW50cnkpXG4gICAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZW1vdmVGb2xkZXIgPSBhc3luYyAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnMuZGVsZXRlKHBhdGgpXG4gIHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcbn1cblxuZXhwb3J0IGNvbnN0IGdldEZvbGRlckJ5UGF0aCA9IChwYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiAge1xuICByZXR1cm4gcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLmdldChwYXRoKVxufVxuXG5leHBvcnQgY29uc3QgbW92ZUZvbGRlciA9IGFzeW5jIChvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgY29uc3Qgb2xkUGF0aE5vcm1hbGl6ZWQgPSBub3JtYWxpemVQYXRoKG9sZFBhdGgpXG4gIGNvbnN0IG5ld1BhdGhOb3JtYWxpemVkID0gbm9ybWFsaXplUGF0aChuZXdQYXRoKVxuICBjb25zdCBmaWxlcyA9IHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVyc1xuICBjb25zdCBlbnRyeSA9IGZpbGVzLmdldChvbGRQYXRoTm9ybWFsaXplZClcbiAgaWYgKGVudHJ5KSB7XG4gICAgZmlsZXMuZGVsZXRlKG9sZFBhdGhOb3JtYWxpemVkKVxuICAgIGZpbGVzLnNldChuZXdQYXRoTm9ybWFsaXplZCwgZW50cnkpXG4gICAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gXCJzcmMvc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyXCI7XG5pbXBvcnQgeyBzaG93Tm90aWNlIH0gZnJvbSBcInNyYy91aVwiO1xuXG5jbGFzcyBTaGFyZWRGb2xkZXJPcHRpb25zTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cbiAgZm9sZGVyOiBTaGFyZWRGb2xkZXJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZm9sZGVyOiBTaGFyZWRGb2xkZXIpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5mb2xkZXIgPSBmb2xkZXJcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuc2V0TmFtZSh0aGlzLmZvbGRlci5nZXRPcmlnaW5hbEZvbGRlck5hbWUoKSkuc2V0SGVhZGluZygpXG5cbiAgICAvLyBGb2xkZXIgTmFtZVxuICAgIGNvbnN0IG5hbWVTZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgbGV0IHRlbXBOYW1lID0gdGhpcy5mb2xkZXIuZ2V0T3JpZ2luYWxGb2xkZXJOYW1lKClcbiAgICBuYW1lU2V0dGluZy5zZXROYW1lKFwiUGVlcmRyYWZ0IGZvbGRlciBuYW1lXCIpXG4gICAgbmFtZVNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgIHRleHQuc2V0VmFsdWUodGVtcE5hbWUpXG4gICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgdGVtcE5hbWUgPSB2YWx1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgbmFtZVNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlVwZGF0ZVwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICBpZiAodGVtcE5hbWUgIT09IHRoaXMuZm9sZGVyLmdldE9yaWdpbmFsRm9sZGVyTmFtZSgpKSB7XG4gICAgICAgICAgdGhpcy5mb2xkZXIuc2V0T3JpZ2luYWxGb2xkZXJOYW1lKHRlbXBOYW1lKVxuICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIG9wZW5Gb2xkZXJPcHRpb25zKHRoaXMuYXBwLCB0aGlzLmZvbGRlcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgLy8gQWRkIHBlZXJkcmFmdCBwcm9wZXJ0eVxuXG4gICAgY29uc3QgcHJvcCA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuICAgIHByb3Auc2V0TmFtZShcIkF1dG8gYWRkIHByb3BlcnR5IHdpdGggUGVlcmRyYWZ0IFVSTFwiKVxuICAgIHByb3Auc2V0RGVzYyhcIkxlYXZlIGVtcHR5IGlmIG5vIHByb3BlcnR5IHNob3VsZCBiZSBhZGRlZFwiKVxuICAgIGxldCB0ZW1wUHJvcCA9IHRoaXMuZm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuXG4gICAgcHJvcC5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgdGV4dC5zZXRWYWx1ZSh0ZW1wUHJvcClcbiAgICAgIHRleHQub25DaGFuZ2UodmFsdWUgPT4ge1xuICAgICAgICB0ZW1wUHJvcCA9IHZhbHVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBwcm9wLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJVcGRhdGUgJiBBcHBseVwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGRQcm9wZXJ0eSA9IHRoaXMuZm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuICAgICAgICBpZiAodGVtcFByb3AgIT09IG9sZFByb3BlcnR5KSB7XG4gICAgICAgICAgdGhpcy5mb2xkZXIuc2V0QXV0b0ZpbGxQcm9wZXJ0eSh0ZW1wUHJvcClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RpY2UgPSBzaG93Tm90aWNlKFwiVXBkYXRpbmcgVVJMcy4uLlwiKVxuICAgICAgICBhd2FpdCB0aGlzLmZvbGRlci51cGRhdGVQcm9wZXJ0aWVzT2ZBbGxEb2N1bWVudHMob2xkUHJvcGVydHkpXG4gICAgICAgIG5vdGljZS5oaWRlKClcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIG9wZW5Gb2xkZXJPcHRpb25zKHRoaXMuYXBwLCB0aGlzLmZvbGRlcilcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNvbnN0IGxpbmsgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICBsaW5rLnNldE5hbWUoXCJQZWVyZHJhZnQgVVJMXCIpXG4gICAgbGluay5hZGRCdXR0b24oYnRuID0+IHtcbiAgICAgIGJ0bi5zZXRCdXR0b25UZXh0KFwiQ29weSBQZWVyZHJhZnQgVVJMIHRvIGNsaXBib2FyZFwiKVxuICAgICAgYnRuLm9uQ2xpY2soKCk9PiB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRoaXMuZm9sZGVyLmdldFNoYXJlVVJMKCkpXG4gICAgICAgIHNob3dOb3RpY2UoXCJMaW5rIGNvcGllZCB0byBjbGlwYm9hcmQuXCIpXG4gICAgICB9KVxuICAgIH0pXG5cblxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvcGVuRm9sZGVyT3B0aW9ucyA9IChhcHA6IEFwcCwgZm9sZGVyOiBTaGFyZWRGb2xkZXIpID0+IHtcbiAgbmV3IFNoYXJlZEZvbGRlck9wdGlvbnNNb2RhbChhcHAsIGZvbGRlcikub3BlbigpXG59IiwgImNvbnN0IEVfVElNRU9VVCA9IG5ldyBFcnJvcigndGltZW91dCB3aGlsZSB3YWl0aW5nIGZvciBtdXRleCB0byBiZWNvbWUgYXZhaWxhYmxlJyk7XG5jb25zdCBFX0FMUkVBRFlfTE9DS0VEID0gbmV3IEVycm9yKCdtdXRleCBhbHJlYWR5IGxvY2tlZCcpO1xuY29uc3QgRV9DQU5DRUxFRCA9IG5ldyBFcnJvcigncmVxdWVzdCBmb3IgbG9jayBjYW5jZWxlZCcpO1xuXG52YXIgX19hd2FpdGVyJDIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfY2FuY2VsRXJyb3IgPSBFX0NBTkNFTEVEKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jYW5jZWxFcnJvciA9IF9jYW5jZWxFcnJvcjtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzID0gW107XG4gICAgfVxuICAgIGFjcXVpcmUod2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXNrID0geyByZXNvbHZlLCByZWplY3QsIHdlaWdodCwgcHJpb3JpdHkgfTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBmaW5kSW5kZXhGcm9tRW5kKHRoaXMuX3F1ZXVlLCAob3RoZXIpID0+IHByaW9yaXR5IDw9IG90aGVyLnByaW9yaXR5KTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSAmJiB3ZWlnaHQgPD0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkcyBpbW1lZGlhdGUgZGlzcGF0Y2gsIHNraXAgdGhlIHF1ZXVlXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hJdGVtKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkV4Y2x1c2l2ZShjYWxsYmFja18xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIkMih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChjYWxsYmFjaywgd2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbdmFsdWUsIHJlbGVhc2VdID0geWllbGQgdGhpcy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2sodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd2FpdEZvclVubG9jayh3ZWlnaHQgPSAxLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgaWYgKHRoaXMuX2NvdWxkTG9ja0ltbWVkaWF0ZWx5KHdlaWdodCwgcHJpb3JpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSwgeyByZXNvbHZlLCBwcmlvcml0eSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWUgPD0gMDtcbiAgICB9XG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hRdWV1ZSgpO1xuICAgIH1cbiAgICByZWxlYXNlKHdlaWdodCA9IDEpIHtcbiAgICAgICAgaWYgKHdlaWdodCA8PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgKz0gd2VpZ2h0O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFF1ZXVlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaCgoZW50cnkpID0+IGVudHJ5LnJlamVjdCh0aGlzLl9jYW5jZWxFcnJvcikpO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIH1cbiAgICBfZGlzcGF0Y2hRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwICYmIHRoaXMuX3F1ZXVlWzBdLndlaWdodCA8PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hJdGVtKHRoaXMuX3F1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICAgICAgdGhpcy5fZHJhaW5VbmxvY2tXYWl0ZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Rpc3BhdGNoSXRlbShpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fdmFsdWUgLT0gaXRlbS53ZWlnaHQ7XG4gICAgICAgIGl0ZW0ucmVzb2x2ZShbcHJldmlvdXNWYWx1ZSwgdGhpcy5fbmV3UmVsZWFzZXIoaXRlbS53ZWlnaHQpXSk7XG4gICAgfVxuICAgIF9uZXdSZWxlYXNlcih3ZWlnaHQpIHtcbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKHdlaWdodCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9kcmFpblVubG9ja1dhaXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRlcnMgPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCF3YWl0ZXJzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB3YWl0ZXJzLmZvckVhY2goKHdhaXRlcikgPT4gd2FpdGVyLnJlc29sdmUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZWRQcmlvcml0eSA9IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5O1xuICAgICAgICAgICAgZm9yIChsZXQgd2VpZ2h0ID0gdGhpcy5fdmFsdWU7IHdlaWdodCA+IDA7IHdlaWdodC0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FpdGVycyA9IHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXdhaXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB3YWl0ZXJzLmZpbmRJbmRleCgod2FpdGVyKSA9PiB3YWl0ZXIucHJpb3JpdHkgPD0gcXVldWVkUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIChpID09PSAtMSA/IHdhaXRlcnMgOiB3YWl0ZXJzLnNwbGljZSgwLCBpKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKHdhaXRlciA9PiB3YWl0ZXIucmVzb2x2ZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvdWxkTG9ja0ltbWVkaWF0ZWx5KHdlaWdodCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDAgfHwgdGhpcy5fcXVldWVbMF0ucHJpb3JpdHkgPCBwcmlvcml0eSkgJiZcbiAgICAgICAgICAgIHdlaWdodCA8PSB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYSwgdikge1xuICAgIGNvbnN0IGkgPSBmaW5kSW5kZXhGcm9tRW5kKGEsIChvdGhlcikgPT4gdi5wcmlvcml0eSA8PSBvdGhlci5wcmlvcml0eSk7XG4gICAgYS5zcGxpY2UoaSArIDEsIDAsIHYpO1xufVxuZnVuY3Rpb24gZmluZEluZGV4RnJvbUVuZChhLCBwcmVkaWNhdGUpIHtcbiAgICBmb3IgKGxldCBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbnZhciBfX2F3YWl0ZXIkMSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuY2xhc3MgTXV0ZXgge1xuICAgIGNvbnN0cnVjdG9yKGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NlbWFwaG9yZSA9IG5ldyBTZW1hcGhvcmUoMSwgY2FuY2VsRXJyb3IpO1xuICAgIH1cbiAgICBhY3F1aXJlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDEodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAocHJpb3JpdHkgPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBbLCByZWxlYXNlcl0gPSB5aWVsZCB0aGlzLl9zZW1hcGhvcmUuYWNxdWlyZSgxLCBwcmlvcml0eSk7XG4gICAgICAgICAgICByZXR1cm4gcmVsZWFzZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHByaW9yaXR5ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLnJ1bkV4Y2x1c2l2ZSgoKSA9PiBjYWxsYmFjaygpLCAxLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGlzTG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2socHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUud2FpdEZvclVubG9jaygxLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zZW1hcGhvcmUuaXNMb2NrZWQoKSlcbiAgICAgICAgICAgIHRoaXMuX3NlbWFwaG9yZS5yZWxlYXNlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5jYW5jZWwoKTtcbiAgICB9XG59XG5cbnZhciBfX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIHdpdGhUaW1lb3V0KHN5bmMsIHRpbWVvdXQsIHRpbWVvdXRFcnJvciA9IEVfVElNRU9VVCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjcXVpcmU6ICh3ZWlnaHRPclByaW9yaXR5LCBwcmlvcml0eSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdlaWdodDtcbiAgICAgICAgICAgIGlmIChpc1NlbWFwaG9yZShzeW5jKSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWNrZXQgPSB5aWVsZCAoaXNTZW1hcGhvcmUoc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3luYy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN5bmMuYWNxdWlyZShwcmlvcml0eSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlID0gQXJyYXkuaXNBcnJheSh0aWNrZXQpID8gdGlja2V0WzFdIDogdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRpY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9LFxuICAgICAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2ssIHdlaWdodCwgcHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGVhc2UgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgdGhpcy5hY3F1aXJlKHdlaWdodCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aWNrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHRpY2tldFswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlID0gdGlja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVsZWFzZSh3ZWlnaHQpIHtcbiAgICAgICAgICAgIHN5bmMucmVsZWFzZSh3ZWlnaHQpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3luYy5jYW5jZWwoKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2FpdEZvclVubG9jazogKHdlaWdodE9yUHJpb3JpdHksIHByaW9yaXR5KSA9PiB7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKGlzU2VtYXBob3JlKHN5bmMpKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwcmlvcml0eSA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICE9PSB1bmRlZmluZWQgJiYgd2VpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdCh0aW1lb3V0RXJyb3IpLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAoaXNTZW1hcGhvcmUoc3luYylcbiAgICAgICAgICAgICAgICAgICAgPyBzeW5jLndhaXRGb3JVbmxvY2sod2VpZ2h0LCBwcmlvcml0eSlcbiAgICAgICAgICAgICAgICAgICAgOiBzeW5jLndhaXRGb3JVbmxvY2socHJpb3JpdHkpKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBpc0xvY2tlZDogKCkgPT4gc3luYy5pc0xvY2tlZCgpLFxuICAgICAgICBnZXRWYWx1ZTogKCkgPT4gc3luYy5nZXRWYWx1ZSgpLFxuICAgICAgICBzZXRWYWx1ZTogKHZhbHVlKSA9PiBzeW5jLnNldFZhbHVlKHZhbHVlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNTZW1hcGhvcmUoc3luYykge1xuICAgIHJldHVybiBzeW5jLmdldFZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGlzbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gdHJ5QWNxdWlyZShzeW5jLCBhbHJlYWR5QWNxdWlyZWRFcnJvciA9IEVfQUxSRUFEWV9MT0NLRUQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiB3aXRoVGltZW91dChzeW5jLCAwLCBhbHJlYWR5QWNxdWlyZWRFcnJvcik7XG59XG5cbmV4cG9ydCB7IEVfQUxSRUFEWV9MT0NLRUQsIEVfQ0FOQ0VMRUQsIEVfVElNRU9VVCwgTXV0ZXgsIFNlbWFwaG9yZSwgdHJ5QWNxdWlyZSwgd2l0aFRpbWVvdXQgfTtcbiIsICJjb25zdCBkZWZhdWx0T3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgZGlmZlRpbWVvdXQ6IDEsXG4gIGRpZmZFZGl0Q29zdDogNCxcbiAgbWF0Y2hUaHJlc2hvbGQ6IDAuNSxcbiAgbWF0Y2hEaXN0YW5jZTogMWUzLFxuICBwYXRjaERlbGV0ZVRocmVzaG9sZDogMC41LFxuICBwYXRjaE1hcmdpbjogNCxcbiAgbWF0Y2hNYXhCaXRzOiAzMlxufSk7XG5mdW5jdGlvbiByZXNvbHZlT3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zPy5fX3Jlc29sdmVkKVxuICAgIHJldHVybiBvcHRpb25zO1xuICBjb25zdCByZXNvbHZlZCA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNvbHZlZCwgXCJfX3Jlc29sdmVkXCIsIHsgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG5cbmNvbnN0IERJRkZfREVMRVRFID0gLTE7XG5jb25zdCBESUZGX0lOU0VSVCA9IDE7XG5jb25zdCBESUZGX0VRVUFMID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZURpZmYob3AsIHRleHQpIHtcbiAgcmV0dXJuIFtvcCwgdGV4dF07XG59XG5mdW5jdGlvbiBkaWZmTWFpbih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIG9wdF9jaGVja2xpbmVzID0gdHJ1ZSwgb3B0X2RlYWRsaW5lKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmICh0eXBlb2Ygb3B0X2RlYWRsaW5lID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBpZiAocmVzb2x2ZWQuZGlmZlRpbWVvdXQgPD0gMClcbiAgICAgIG9wdF9kZWFkbGluZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgZWxzZVxuICAgICAgb3B0X2RlYWRsaW5lID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgKyByZXNvbHZlZC5kaWZmVGltZW91dCAqIDFlMztcbiAgfVxuICBjb25zdCBkZWFkbGluZSA9IG9wdF9kZWFkbGluZTtcbiAgaWYgKHRleHQxID09IG51bGwgfHwgdGV4dDIgPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAoZGlmZl9tYWluKVwiKTtcbiAgaWYgKHRleHQxID09PSB0ZXh0Mikge1xuICAgIGlmICh0ZXh0MSlcbiAgICAgIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0VRVUFMLCB0ZXh0MSldO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBjaGVja2xpbmVzID0gb3B0X2NoZWNrbGluZXM7XG4gIGxldCBjb21tb25sZW5ndGggPSBkaWZmQ29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnByZWZpeCA9IHRleHQxLnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xuICBjb21tb25sZW5ndGggPSBkaWZmQ29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XG4gIGNvbnN0IGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZygwLCB0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCB0ZXh0Mi5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICBjb25zdCBkaWZmcyA9IGRpZmZDb21wdXRlKHRleHQxLCB0ZXh0MiwgcmVzb2x2ZWQsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgaWYgKGNvbW1vbnByZWZpeClcbiAgICBkaWZmcy51bnNoaWZ0KGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgY29tbW9ucHJlZml4KSk7XG4gIGlmIChjb21tb25zdWZmaXgpXG4gICAgZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeCkpO1xuICBkaWZmQ2xlYW51cE1lcmdlKGRpZmZzKTtcbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gZGlmZkNvbXB1dGUodGV4dDEsIHRleHQyLCBvcHRpb25zLCBjaGVja2xpbmVzLCBkZWFkbGluZSkge1xuICBsZXQgZGlmZnM7XG4gIGlmICghdGV4dDEpIHtcbiAgICByZXR1cm4gW2NyZWF0ZURpZmYoRElGRl9JTlNFUlQsIHRleHQyKV07XG4gIH1cbiAgaWYgKCF0ZXh0Mikge1xuICAgIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dDEpXTtcbiAgfVxuICBjb25zdCBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIGNvbnN0IHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGNvbnN0IGkgPSBsb25ndGV4dC5pbmRleE9mKHNob3J0dGV4dCk7XG4gIGlmIChpICE9PSAtMSkge1xuICAgIGRpZmZzID0gW2NyZWF0ZURpZmYoRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKSksIGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgc2hvcnR0ZXh0KSwgY3JlYXRlRGlmZihESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKSldO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpXG4gICAgICBkaWZmc1swXVswXSA9IGRpZmZzWzJdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgcmV0dXJuIGRpZmZzO1xuICB9XG4gIGlmIChzaG9ydHRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVEaWZmKERJRkZfREVMRVRFLCB0ZXh0MSksIGNyZWF0ZURpZmYoRElGRl9JTlNFUlQsIHRleHQyKV07XG4gIH1cbiAgY29uc3QgaG0gPSBkaWZmSGFsZk1hdGNoKHRleHQxLCB0ZXh0Miwgb3B0aW9ucyk7XG4gIGlmIChobSkge1xuICAgIGNvbnN0IHRleHQxX2EgPSBobVswXTtcbiAgICBjb25zdCB0ZXh0MV9iID0gaG1bMV07XG4gICAgY29uc3QgdGV4dDJfYSA9IGhtWzJdO1xuICAgIGNvbnN0IHRleHQyX2IgPSBobVszXTtcbiAgICBjb25zdCBtaWRfY29tbW9uID0gaG1bNF07XG4gICAgY29uc3QgZGlmZnNfYSA9IGRpZmZNYWluKHRleHQxX2EsIHRleHQyX2EsIG9wdGlvbnMsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICBjb25zdCBkaWZmc19iID0gZGlmZk1haW4odGV4dDFfYiwgdGV4dDJfYiwgb3B0aW9ucywgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xuICAgIHJldHVybiBkaWZmc19hLmNvbmNhdChbY3JlYXRlRGlmZihESUZGX0VRVUFMLCBtaWRfY29tbW9uKV0sIGRpZmZzX2IpO1xuICB9XG4gIGlmIChjaGVja2xpbmVzICYmIHRleHQxLmxlbmd0aCA+IDEwMCAmJiB0ZXh0Mi5sZW5ndGggPiAxMDApXG4gICAgcmV0dXJuIGRpZmZMaW5lTW9kZSh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIGRlYWRsaW5lKTtcbiAgcmV0dXJuIGRpZmZCaXNlY3QodGV4dDEsIHRleHQyLCBvcHRpb25zLCBkZWFkbGluZSk7XG59XG5mdW5jdGlvbiBkaWZmTGluZU1vZGUodGV4dDEsIHRleHQyLCBvcHRpb25zLCBkZWFkbGluZSkge1xuICBjb25zdCBhID0gZGlmZkxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpO1xuICB0ZXh0MSA9IGEuY2hhcnMxO1xuICB0ZXh0MiA9IGEuY2hhcnMyO1xuICBjb25zdCBsaW5lYXJyYXkgPSBhLmxpbmVBcnJheTtcbiAgY29uc3QgZGlmZnMgPSBkaWZmTWFpbih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIGZhbHNlLCBkZWFkbGluZSk7XG4gIGRpZmZDaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVhcnJheSk7XG4gIGRpZmZDbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuICBkaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgXCJcIikpO1xuICBsZXQgcG9pbnRlciA9IDA7XG4gIGxldCBjb3VudF9kZWxldGUgPSAwO1xuICBsZXQgY291bnRfaW5zZXJ0ID0gMDtcbiAgbGV0IHRleHRfZGVsZXRlID0gXCJcIjtcbiAgbGV0IHRleHRfaW5zZXJ0ID0gXCJcIjtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3BvaW50ZXJdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBjb3VudF9pbnNlcnQrKztcbiAgICAgICAgdGV4dF9pbnNlcnQgKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA+PSAxICYmIGNvdW50X2luc2VydCA+PSAxKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgY29uc3Qgc3ViRGlmZiA9IGRpZmZNYWluKHRleHRfZGVsZXRlLCB0ZXh0X2luc2VydCwgb3B0aW9ucywgZmFsc2UsIGRlYWRsaW5lKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gc3ViRGlmZi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBzdWJEaWZmW2pdKTtcbiAgICAgICAgICBwb2ludGVyID0gcG9pbnRlciArIHN1YkRpZmYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHRleHRfZGVsZXRlID0gXCJcIjtcbiAgICAgICAgdGV4dF9pbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGRpZmZzLnBvcCgpO1xuICByZXR1cm4gZGlmZnM7XG59XG5mdW5jdGlvbiBkaWZmQmlzZWN0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xuICBjb25zdCB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XG4gIGNvbnN0IG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XG4gIGNvbnN0IHZfb2Zmc2V0ID0gbWF4X2Q7XG4gIGNvbnN0IHZfbGVuZ3RoID0gMiAqIG1heF9kO1xuICBjb25zdCB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIGNvbnN0IHYyID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB2X2xlbmd0aDsgeCsrKSB7XG4gICAgdjFbeF0gPSAtMTtcbiAgICB2Mlt4XSA9IC0xO1xuICB9XG4gIHYxW3Zfb2Zmc2V0ICsgMV0gPSAwO1xuICB2Mlt2X29mZnNldCArIDFdID0gMDtcbiAgY29uc3QgZGVsdGEgPSB0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGg7XG4gIGNvbnN0IGZyb250ID0gZGVsdGEgJSAyICE9PSAwO1xuICBsZXQgazFzdGFydCA9IDA7XG4gIGxldCBrMWVuZCA9IDA7XG4gIGxldCBrMnN0YXJ0ID0gMDtcbiAgbGV0IGsyZW5kID0gMDtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XG4gICAgaWYgKCgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpID4gZGVhZGxpbmUpXG4gICAgICBicmVhaztcbiAgICBmb3IgKGxldCBrMSA9IC1kICsgazFzdGFydDsgazEgPD0gZCAtIGsxZW5kOyBrMSArPSAyKSB7XG4gICAgICBjb25zdCBrMV9vZmZzZXQgPSB2X29mZnNldCArIGsxO1xuICAgICAgbGV0IHgxO1xuICAgICAgaWYgKGsxID09PSAtZCB8fCBrMSAhPT0gZCAmJiB2MVtrMV9vZmZzZXQgLSAxXSA8IHYxW2sxX29mZnNldCArIDFdKVxuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCArIDFdO1xuICAgICAgZWxzZVxuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MSA9IHgxIC0gazE7XG4gICAgICB3aGlsZSAoeDEgPCB0ZXh0MV9sZW5ndGggJiYgeTEgPCB0ZXh0Ml9sZW5ndGggJiYgdGV4dDEuY2hhckF0KHgxKSA9PT0gdGV4dDIuY2hhckF0KHkxKSkge1xuICAgICAgICB4MSsrO1xuICAgICAgICB5MSsrO1xuICAgICAgfVxuICAgICAgdjFbazFfb2Zmc2V0XSA9IHgxO1xuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XG4gICAgICAgIGsxZW5kICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHkxID4gdGV4dDJfbGVuZ3RoKSB7XG4gICAgICAgIGsxc3RhcnQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazJfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsxO1xuICAgICAgICBpZiAoazJfb2Zmc2V0ID49IDAgJiYgazJfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjJbazJfb2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MiA9IHRleHQxX2xlbmd0aCAtIHYyW2syX29mZnNldF07XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcbiAgICAgIGNvbnN0IGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XG4gICAgICBsZXQgeDI7XG4gICAgICBpZiAoazIgPT09IC1kIHx8IGsyICE9PSBkICYmIHYyW2syX29mZnNldCAtIDFdIDwgdjJbazJfb2Zmc2V0ICsgMV0pXG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0ICsgMV07XG4gICAgICBlbHNlXG4gICAgICAgIHgyID0gdjJbazJfb2Zmc2V0IC0gMV0gKyAxO1xuICAgICAgbGV0IHkyID0geDIgLSBrMjtcbiAgICAgIHdoaWxlICh4MiA8IHRleHQxX2xlbmd0aCAmJiB5MiA8IHRleHQyX2xlbmd0aCAmJiB0ZXh0MS5jaGFyQXQodGV4dDFfbGVuZ3RoIC0geDIgLSAxKSA9PT0gdGV4dDIuY2hhckF0KHRleHQyX2xlbmd0aCAtIHkyIC0gMSkpIHtcbiAgICAgICAgeDIrKztcbiAgICAgICAgeTIrKztcbiAgICAgIH1cbiAgICAgIHYyW2syX29mZnNldF0gPSB4MjtcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICBrMmVuZCArPSAyO1xuICAgICAgfSBlbHNlIGlmICh5MiA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICBrMnN0YXJ0ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKCFmcm9udCkge1xuICAgICAgICBjb25zdCBrMV9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazI7XG4gICAgICAgIGlmIChrMV9vZmZzZXQgPj0gMCAmJiBrMV9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MVtrMV9vZmZzZXRdICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHgxID0gdjFbazFfb2Zmc2V0XTtcbiAgICAgICAgICBjb25zdCB5MSA9IHZfb2Zmc2V0ICsgeDEgLSBrMV9vZmZzZXQ7XG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcbiAgICAgICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWZmQmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCBvcHRpb25zLCB4MSwgeTEsIGRlYWRsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtjcmVhdGVEaWZmKERJRkZfREVMRVRFLCB0ZXh0MSksIGNyZWF0ZURpZmYoRElGRl9JTlNFUlQsIHRleHQyKV07XG59XG5mdW5jdGlvbiBkaWZmQmlzZWN0U3BsaXQodGV4dDEsIHRleHQyLCBvcHRpb25zLCB4LCB5LCBkZWFkbGluZSkge1xuICBjb25zdCB0ZXh0MWEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgeCk7XG4gIGNvbnN0IHRleHQyYSA9IHRleHQyLnN1YnN0cmluZygwLCB5KTtcbiAgY29uc3QgdGV4dDFiID0gdGV4dDEuc3Vic3RyaW5nKHgpO1xuICBjb25zdCB0ZXh0MmIgPSB0ZXh0Mi5zdWJzdHJpbmcoeSk7XG4gIGNvbnN0IGRpZmZzID0gZGlmZk1haW4odGV4dDFhLCB0ZXh0MmEsIG9wdGlvbnMsIGZhbHNlLCBkZWFkbGluZSk7XG4gIGNvbnN0IGRpZmZzYiA9IGRpZmZNYWluKHRleHQxYiwgdGV4dDJiLCBvcHRpb25zLCBmYWxzZSwgZGVhZGxpbmUpO1xuICByZXR1cm4gZGlmZnMuY29uY2F0KGRpZmZzYik7XG59XG5mdW5jdGlvbiBkaWZmTGluZXNUb0NoYXJzKHRleHQxLCB0ZXh0Mikge1xuICBjb25zdCBsaW5lQXJyYXkgPSBbXTtcbiAgY29uc3QgbGluZUhhc2ggPSB7fTtcbiAgbGV0IG1heExpbmVzID0gNGU0O1xuICBsaW5lQXJyYXlbMF0gPSBcIlwiO1xuICBmdW5jdGlvbiBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dCkge1xuICAgIGxldCBjaGFycyA9IFwiXCI7XG4gICAgbGV0IGxpbmVTdGFydCA9IDA7XG4gICAgbGV0IGxpbmVFbmQgPSAtMTtcbiAgICBsZXQgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobGluZUVuZCA8IHRleHQubGVuZ3RoIC0gMSkge1xuICAgICAgbGluZUVuZCA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBsaW5lU3RhcnQpO1xuICAgICAgaWYgKGxpbmVFbmQgPT09IC0xKVxuICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGggLSAxO1xuICAgICAgbGV0IGxpbmUgPSB0ZXh0LnN1YnN0cmluZyhsaW5lU3RhcnQsIGxpbmVFbmQgKyAxKTtcbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaW5lSGFzaCwgbGluZSkgOiBsaW5lSGFzaFtsaW5lXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmVBcnJheUxlbmd0aCA9PT0gbWF4TGluZXMpIHtcbiAgICAgICAgICBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0KTtcbiAgICAgICAgICBsaW5lRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsaW5lQXJyYXlMZW5ndGgpO1xuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcbiAgICAgICAgbGluZUFycmF5W2xpbmVBcnJheUxlbmd0aCsrXSA9IGxpbmU7XG4gICAgICB9XG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzO1xuICB9XG4gIGNvbnN0IGNoYXJzMSA9IGRpZmZMaW5lc1RvQ2hhcnNNdW5nZSh0ZXh0MSk7XG4gIG1heExpbmVzID0gNjU1MzU7XG4gIGNvbnN0IGNoYXJzMiA9IGRpZmZMaW5lc1RvQ2hhcnNNdW5nZSh0ZXh0Mik7XG4gIHJldHVybiB7IGNoYXJzMSwgY2hhcnMyLCBsaW5lQXJyYXkgfTtcbn1cbmZ1bmN0aW9uIGRpZmZDaGFyc1RvTGluZXMoZGlmZnMsIGxpbmVBcnJheSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhcnMgPSBkaWZmc1tpXVsxXTtcbiAgICBjb25zdCB0ZXh0ID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGFycy5sZW5ndGg7IGorKylcbiAgICAgIHRleHRbal0gPSBsaW5lQXJyYXlbY2hhcnMuY2hhckNvZGVBdChqKV07XG4gICAgZGlmZnNbaV1bMV0gPSB0ZXh0LmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZmZDb21tb25QcmVmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCgwKSAhPT0gdGV4dDIuY2hhckF0KDApKVxuICAgIHJldHVybiAwO1xuICBsZXQgcG9pbnRlcm1pbiA9IDA7XG4gIGxldCBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICBsZXQgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIGxldCBwb2ludGVyc3RhcnQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT09IHRleHQyLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJzdGFydCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufVxuZnVuY3Rpb24gZGlmZkNvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpIHtcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHwgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9PSB0ZXh0Mi5jaGFyQXQodGV4dDIubGVuZ3RoIC0gMSkpXG4gICAgcmV0dXJuIDA7XG4gIGxldCBwb2ludGVybWluID0gMDtcbiAgbGV0IHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XG4gIGxldCBwb2ludGVybWlkID0gcG9pbnRlcm1heDtcbiAgbGV0IHBvaW50ZXJlbmQgPSAwO1xuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQxLmxlbmd0aCAtIHBvaW50ZXJlbmQpID09PSB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcbiAgICAgIHBvaW50ZXJtaW4gPSBwb2ludGVybWlkO1xuICAgICAgcG9pbnRlcmVuZCA9IHBvaW50ZXJtaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xuICAgIH1cbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xuICB9XG4gIHJldHVybiBwb2ludGVybWlkO1xufVxuZnVuY3Rpb24gZGlmZkNvbW1vbk92ZXJsYXAodGV4dDEsIHRleHQyKSB7XG4gIGNvbnN0IHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgY29uc3QgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICBpZiAodGV4dDFfbGVuZ3RoID09PSAwIHx8IHRleHQyX2xlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKHRleHQxX2xlbmd0aCA+IHRleHQyX2xlbmd0aClcbiAgICB0ZXh0MSA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MV9sZW5ndGggLSB0ZXh0Ml9sZW5ndGgpO1xuICBlbHNlIGlmICh0ZXh0MV9sZW5ndGggPCB0ZXh0Ml9sZW5ndGgpXG4gICAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFfbGVuZ3RoKTtcbiAgY29uc3QgdGV4dF9sZW5ndGggPSBNYXRoLm1pbih0ZXh0MV9sZW5ndGgsIHRleHQyX2xlbmd0aCk7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpXG4gICAgcmV0dXJuIHRleHRfbGVuZ3RoO1xuICBsZXQgYmVzdCA9IDA7XG4gIGxldCBsZW5ndGggPSAxO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpO1xuICAgIGNvbnN0IGZvdW5kID0gdGV4dDIuaW5kZXhPZihwYXR0ZXJuKTtcbiAgICBpZiAoZm91bmQgPT09IC0xKVxuICAgICAgcmV0dXJuIGJlc3Q7XG4gICAgbGVuZ3RoICs9IGZvdW5kO1xuICAgIGlmIChmb3VuZCA9PT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpID09PSB0ZXh0Mi5zdWJzdHJpbmcoMCwgbGVuZ3RoKSkge1xuICAgICAgYmVzdCA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCsrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlmZkhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZGlmZlRpbWVvdXQgPD0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGxvbmd0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDEgOiB0ZXh0MjtcbiAgY29uc3Qgc2hvcnR0ZXh0ID0gdGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoID8gdGV4dDIgOiB0ZXh0MTtcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpXG4gICAgcmV0dXJuIG51bGw7XG4gIGZ1bmN0aW9uIGRpZmZIYWxmTWF0Y2hJKGxvbmd0ZXh0Miwgc2hvcnR0ZXh0MiwgaSkge1xuICAgIGNvbnN0IHNlZWQgPSBsb25ndGV4dDIuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Mi5sZW5ndGggLyA0KSk7XG4gICAgbGV0IGogPSAtMTtcbiAgICBsZXQgYmVzdF9jb21tb24gPSBcIlwiO1xuICAgIGxldCBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcbiAgICB3aGlsZSAoKGogPSBzaG9ydHRleHQyLmluZGV4T2Yoc2VlZCwgaiArIDEpKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHByZWZpeExlbmd0aCA9IGRpZmZDb21tb25QcmVmaXgobG9uZ3RleHQyLnN1YnN0cmluZyhpKSwgc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoaikpO1xuICAgICAgY29uc3Qgc3VmZml4TGVuZ3RoID0gZGlmZkNvbW1vblN1ZmZpeChsb25ndGV4dDIuc3Vic3RyaW5nKDAsIGkpLCBzaG9ydHRleHQyLnN1YnN0cmluZygwLCBqKSk7XG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XG4gICAgICAgIGJlc3RfY29tbW9uID0gc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoaiAtIHN1ZmZpeExlbmd0aCwgaikgKyBzaG9ydHRleHQyLnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9hID0gbG9uZ3RleHQyLnN1YnN0cmluZygwLCBpIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQyLnN1YnN0cmluZyhpICsgcHJlZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYSA9IHNob3J0dGV4dDIuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xuICAgICAgICBiZXN0X3Nob3J0dGV4dF9iID0gc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoaiArIHByZWZpeExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0X2NvbW1vbi5sZW5ndGggKiAyID49IGxvbmd0ZXh0Mi5sZW5ndGgpXG4gICAgICByZXR1cm4gW2Jlc3RfbG9uZ3RleHRfYSwgYmVzdF9sb25ndGV4dF9iLCBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaG0xID0gZGlmZkhhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcbiAgY29uc3QgaG0yID0gZGlmZkhhbGZNYXRjaEkobG9uZ3RleHQsIHNob3J0dGV4dCwgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDIpKTtcbiAgbGV0IGhtO1xuICBpZiAoIWhtMSAmJiAhaG0yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoIWhtMikge1xuICAgIGhtID0gaG0xO1xuICB9IGVsc2UgaWYgKCFobTEpIHtcbiAgICBobSA9IGhtMjtcbiAgfSBlbHNlIHtcbiAgICBobSA9IGhtMVs0XS5sZW5ndGggPiBobTJbNF0ubGVuZ3RoID8gaG0xIDogaG0yO1xuICB9XG4gIGxldCB0ZXh0MV9hLCB0ZXh0MV9iLCB0ZXh0Ml9hLCB0ZXh0Ml9iO1xuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XG4gICAgdGV4dDFfYSA9IGhtWzBdO1xuICAgIHRleHQxX2IgPSBobVsxXTtcbiAgICB0ZXh0Ml9hID0gaG1bMl07XG4gICAgdGV4dDJfYiA9IGhtWzNdO1xuICB9IGVsc2Uge1xuICAgIHRleHQyX2EgPSBobVswXTtcbiAgICB0ZXh0Ml9iID0gaG1bMV07XG4gICAgdGV4dDFfYSA9IGhtWzJdO1xuICAgIHRleHQxX2IgPSBobVszXTtcbiAgfVxuICBjb25zdCBtaWRfY29tbW9uID0gaG1bNF07XG4gIHJldHVybiBbdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYiwgbWlkX2NvbW1vbl07XG59XG5mdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljKGRpZmZzKSB7XG4gIGxldCBjaGFuZ2VzID0gZmFsc2U7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICBsZXQgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgbGVuZ3RoX2luc2VydGlvbnMxID0gMDtcbiAgbGV0IGxlbmd0aF9kZWxldGlvbnMxID0gMDtcbiAgbGV0IGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gIGxldCBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gbGVuZ3RoX2luc2VydGlvbnMyO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiA9IDA7XG4gICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICBsYXN0RXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVClcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgIGVsc2VcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xuICAgICAgaWYgKGxhc3RFcXVhbGl0eSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMSwgbGVuZ3RoX2RlbGV0aW9uczEpICYmIGxhc3RFcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoX2luc2VydGlvbnMyLCBsZW5ndGhfZGVsZXRpb25zMikpIHtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBjcmVhdGVEaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTtcbiAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMxID0gMDtcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSAwO1xuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICAgICAgICBsZW5ndGhfZGVsZXRpb25zMiA9IDA7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpXG4gICAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG4gIGRpZmZDbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XG4gIHBvaW50ZXIgPSAxO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfREVMRVRFICYmIGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgY29uc3QgZGVsZXRpb24gPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICBjb25zdCBpbnNlcnRpb24gPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgIGNvbnN0IG92ZXJsYXBfbGVuZ3RoMSA9IGRpZmZDb21tb25PdmVybGFwKGRlbGV0aW9uLCBpbnNlcnRpb24pO1xuICAgICAgY29uc3Qgb3ZlcmxhcF9sZW5ndGgyID0gZGlmZkNvbW1vbk92ZXJsYXAoaW5zZXJ0aW9uLCBkZWxldGlvbik7XG4gICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IG92ZXJsYXBfbGVuZ3RoMikge1xuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgxID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHwgb3ZlcmxhcF9sZW5ndGgxID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDEpKSk7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKDAsIGRlbGV0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMSk7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMiA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBfbGVuZ3RoMiA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDIpKSk7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzBdID0gRElGRl9JTlNFUlQ7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcF9sZW5ndGgyKTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPSBESUZGX0RFTEVURTtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgyKTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG59XG5jb25zdCBub25BbHBoYU51bWVyaWNSZWdleF8gPSAvW15hLXpBLVowLTldLztcbmNvbnN0IHdoaXRlc3BhY2VSZWdleF8gPSAvXFxzLztcbmNvbnN0IGxpbmVicmVha1JlZ2V4XyA9IC9bXFxyXFxuXS87XG5jb25zdCBibGFua2xpbmVFbmRSZWdleF8gPSAvXFxuXFxyP1xcbiQvO1xuY29uc3QgYmxhbmtsaW5lU3RhcnRSZWdleF8gPSAvXlxccj9cXG5cXHI/XFxuLztcbmZ1bmN0aW9uIGRpZmZDbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcykge1xuICBmdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUob25lLCB0d28pIHtcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XG4gICAgICByZXR1cm4gNjtcbiAgICB9XG4gICAgY29uc3QgY2hhcjEgPSBvbmUuY2hhckF0KG9uZS5sZW5ndGggLSAxKTtcbiAgICBjb25zdCBjaGFyMiA9IHR3by5jaGFyQXQoMCk7XG4gICAgY29uc3Qgbm9uQWxwaGFOdW1lcmljMSA9IGNoYXIxLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XG4gICAgY29uc3Qgbm9uQWxwaGFOdW1lcmljMiA9IGNoYXIyLm1hdGNoKG5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XG4gICAgY29uc3Qgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmIGNoYXIxLm1hdGNoKHdoaXRlc3BhY2VSZWdleF8pO1xuICAgIGNvbnN0IHdoaXRlc3BhY2UyID0gbm9uQWxwaGFOdW1lcmljMiAmJiBjaGFyMi5tYXRjaCh3aGl0ZXNwYWNlUmVnZXhfKTtcbiAgICBjb25zdCBsaW5lQnJlYWsxID0gd2hpdGVzcGFjZTEgJiYgY2hhcjEubWF0Y2gobGluZWJyZWFrUmVnZXhfKTtcbiAgICBjb25zdCBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiYgY2hhcjIubWF0Y2gobGluZWJyZWFrUmVnZXhfKTtcbiAgICBjb25zdCBibGFua0xpbmUxID0gbGluZUJyZWFrMSAmJiBvbmUubWF0Y2goYmxhbmtsaW5lRW5kUmVnZXhfKTtcbiAgICBjb25zdCBibGFua0xpbmUyID0gbGluZUJyZWFrMiAmJiB0d28ubWF0Y2goYmxhbmtsaW5lU3RhcnRSZWdleF8pO1xuICAgIGlmIChibGFua0xpbmUxIHx8IGJsYW5rTGluZTIpIHtcbiAgICAgIHJldHVybiA1O1xuICAgIH0gZWxzZSBpZiAobGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyKSB7XG4gICAgICByZXR1cm4gNDtcbiAgICB9IGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgfHwgbm9uQWxwaGFOdW1lcmljMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGxldCBwb2ludGVyID0gMTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGxldCBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XG4gICAgICBsZXQgZWRpdCA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgbGV0IGVxdWFsaXR5MiA9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgIGNvbnN0IGNvbW1vbk9mZnNldCA9IGRpZmZDb21tb25TdWZmaXgoZXF1YWxpdHkxLCBlZGl0KTtcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcbiAgICAgICAgY29uc3QgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTEgPSBlcXVhbGl0eTEuc3Vic3RyaW5nKDAsIGVxdWFsaXR5MS5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlZGl0ID0gY29tbW9uU3RyaW5nICsgZWRpdC5zdWJzdHJpbmcoMCwgZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XG4gICAgICB9XG4gICAgICBsZXQgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgIGxldCBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICBsZXQgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgIGxldCBiZXN0U2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XG4gICAgICAgIGVxdWFsaXR5MSArPSBlZGl0LmNoYXJBdCgwKTtcbiAgICAgICAgZWRpdCA9IGVkaXQuc3Vic3RyaW5nKDEpICsgZXF1YWxpdHkyLmNoYXJBdCgwKTtcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZXF1YWxpdHkxLCBlZGl0KSArIGRpZmZDbGVhbnVwU2VtYW50aWNTY29yZShlZGl0LCBlcXVhbGl0eTIpO1xuICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgYmVzdEVxdWFsaXR5MSA9IGVxdWFsaXR5MTtcbiAgICAgICAgICBiZXN0RWRpdCA9IGVkaXQ7XG4gICAgICAgICAgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVsxXSAhPT0gYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGJlc3RFcXVhbGl0eTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgIH1cbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTIpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0gPSBiZXN0RXF1YWxpdHkyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufVxuZnVuY3Rpb24gZGlmZkNsZWFudXBFZmZpY2llbmN5KGRpZmZzLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGRpZmZFZGl0Q29zdCA9IGRlZmF1bHRPcHRpb25zLmRpZmZFZGl0Q29zdFxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGNoYW5nZXMgPSBmYWxzZTtcbiAgY29uc3QgZXF1YWxpdGllcyA9IFtdO1xuICBsZXQgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gIGxldCBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICBsZXQgcG9pbnRlciA9IDA7XG4gIGxldCBwcmVfaW5zID0gZmFsc2U7XG4gIGxldCBwcmVfZGVsID0gZmFsc2U7XG4gIGxldCBwb3N0X2lucyA9IGZhbHNlO1xuICBsZXQgcG9zdF9kZWwgPSBmYWxzZTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCBkaWZmRWRpdENvc3QgJiYgKHBvc3RfaW5zIHx8IHBvc3RfZGVsKSkge1xuICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGgrK10gPSBwb2ludGVyO1xuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XG4gICAgICAgIHByZV9kZWwgPSBwb3N0X2RlbDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcbiAgICAgICAgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGJvb2xlYW5Db3VudCA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT09IERJRkZfREVMRVRFKVxuICAgICAgICBwb3N0X2RlbCA9IHRydWU7XG4gICAgICBlbHNlXG4gICAgICAgIHBvc3RfaW5zID0gdHJ1ZTtcbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgKHByZV9pbnMgJiYgcHJlX2RlbCAmJiBwb3N0X2lucyAmJiBwb3N0X2RlbCB8fCBsYXN0RXF1YWxpdHkubGVuZ3RoIDwgZGlmZkVkaXRDb3N0IC8gMiAmJiBib29sZWFuQ291bnQocHJlX2lucywgcHJlX2RlbCwgcG9zdF9pbnMsIHBvc3RfZGVsKSA9PT0gMykpIHtcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLCBjcmVhdGVEaWZmKERJRkZfREVMRVRFLCBsYXN0RXF1YWxpdHkpKTtcbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICAgIGlmIChwcmVfaW5zICYmIHByZV9kZWwpIHtcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gdHJ1ZTtcbiAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcbiAgICAgICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICBpZiAoY2hhbmdlcylcbiAgICBkaWZmQ2xlYW51cE1lcmdlKGRpZmZzKTtcbn1cbmZ1bmN0aW9uIGRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpIHtcbiAgZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIFwiXCIpKTtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgY291bnRfZGVsZXRlID0gMDtcbiAgbGV0IGNvdW50X2luc2VydCA9IDA7XG4gIGxldCB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gIGxldCB0ZXh0X2luc2VydCA9IFwiXCI7XG4gIGxldCBjb21tb25sZW5ndGg7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgY291bnRfZGVsZXRlKys7XG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xuICAgICAgICAgIGlmIChjb3VudF9kZWxldGUgIT09IDAgJiYgY291bnRfaW5zZXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmQ29tbW9uUHJlZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ID4gMCAmJiBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1twb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0IC0gMV1bMV0gKz0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlmZnMuc3BsaWNlKDAsIDAsIGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgdGV4dF9pbnNlcnQuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCkpKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1vbmxlbmd0aCA9IGRpZmZDb21tb25TdWZmaXgodGV4dF9pbnNlcnQsIHRleHRfZGVsZXRlKTtcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcodGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKSArIGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICAgICAgICB0ZXh0X2luc2VydCA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCB0ZXh0X2luc2VydC5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyIC09IGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydDtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0KTtcbiAgICAgICAgICBpZiAodGV4dF9kZWxldGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dF9kZWxldGUpKTtcbiAgICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHRfaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGNyZWF0ZURpZmYoRElGRl9JTlNFUlQsIHRleHRfaW5zZXJ0KSk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XG4gICAgICAgIHRleHRfZGVsZXRlID0gXCJcIjtcbiAgICAgICAgdGV4dF9pbnNlcnQgPSBcIlwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdID09PSBcIlwiKVxuICAgIGRpZmZzLnBvcCgpO1xuICBsZXQgY2hhbmdlcyA9IGZhbHNlO1xuICBwb2ludGVyID0gMTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmc1twb2ludGVyICsgMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCkgPT09IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSkge1xuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLSBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKTtcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcbiAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdICs9IGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgKyBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyICsgMSwgMSk7XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpXG4gICAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG59XG5mdW5jdGlvbiBkaWZmWEluZGV4KGRpZmZzLCBsb2MpIHtcbiAgbGV0IGNoYXJzMSA9IDA7XG4gIGxldCBjaGFyczIgPSAwO1xuICBsZXQgbGFzdF9jaGFyczEgPSAwO1xuICBsZXQgbGFzdF9jaGFyczIgPSAwO1xuICBsZXQgeDtcbiAgZm9yICh4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkge1xuICAgICAgY2hhcnMxICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSkge1xuICAgICAgY2hhcnMyICs9IGRpZmZzW3hdWzFdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGNoYXJzMSA+IGxvYykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3RfY2hhcnMxID0gY2hhcnMxO1xuICAgIGxhc3RfY2hhcnMyID0gY2hhcnMyO1xuICB9XG4gIGlmIChkaWZmcy5sZW5ndGggIT09IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFKVxuICAgIHJldHVybiBsYXN0X2NoYXJzMjtcbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcbn1cbmZ1bmN0aW9uIGRpZmZQcmV0dHlIdG1sKGRpZmZzKSB7XG4gIGNvbnN0IGh0bWwgPSBbXTtcbiAgY29uc3QgcGF0dGVybl9hbXAgPSAvJi9nO1xuICBjb25zdCBwYXR0ZXJuX2x0ID0gLzwvZztcbiAgY29uc3QgcGF0dGVybl9ndCA9IC8+L2c7XG4gIGNvbnN0IHBhdHRlcm5fcGFyYSA9IC9cXG4vZztcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IG9wID0gZGlmZnNbeF1bMF07XG4gICAgY29uc3QgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIGNvbnN0IHRleHQgPSBkYXRhLnJlcGxhY2UocGF0dGVybl9hbXAsIFwiJmFtcDtcIikucmVwbGFjZShwYXR0ZXJuX2x0LCBcIiZsdDtcIikucmVwbGFjZShwYXR0ZXJuX2d0LCBcIiZndDtcIikucmVwbGFjZShwYXR0ZXJuX3BhcmEsIFwiJnBhcmE7PGJyPlwiKTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBodG1sW3hdID0gYDxpbnMgc3R5bGU9XCJiYWNrZ3JvdW5kOiNlNmZmZTY7XCI+JHt0ZXh0fTwvaW5zPmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgaHRtbFt4XSA9IGA8ZGVsIHN0eWxlPVwiYmFja2dyb3VuZDojZmZlNmU2O1wiPiR7dGV4dH08L2RlbD5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaHRtbFt4XSA9IGA8c3Bhbj4ke3RleHR9PC9zcGFuPmA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaHRtbC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZlRleHQxKGRpZmZzKSB7XG4gIGNvbnN0IHRleHQgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpXG4gICAgICB0ZXh0W3hdID0gZGlmZnNbeF1bMV07XG4gIH1cbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MihkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKVxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBkaWZmTGV2ZW5zaHRlaW4oZGlmZnMpIHtcbiAgbGV0IGxldmVuc2h0ZWluID0gMDtcbiAgbGV0IGluc2VydGlvbnMgPSAwO1xuICBsZXQgZGVsZXRpb25zID0gMDtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IG9wID0gZGlmZnNbeF1bMF07XG4gICAgY29uc3QgZGF0YSA9IGRpZmZzW3hdWzFdO1xuICAgIHN3aXRjaCAob3ApIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGluc2VydGlvbnMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgZGVsZXRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgICAgICAgaW5zZXJ0aW9ucyA9IDA7XG4gICAgICAgIGRlbGV0aW9ucyA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsZXZlbnNodGVpbiArPSBNYXRoLm1heChpbnNlcnRpb25zLCBkZWxldGlvbnMpO1xuICByZXR1cm4gbGV2ZW5zaHRlaW47XG59XG5mdW5jdGlvbiBkaWZmVG9EZWx0YShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBzd2l0Y2ggKGRpZmZzW3hdWzBdKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICB0ZXh0W3hdID0gYCske2VuY29kZVVSSShkaWZmc1t4XVsxXSl9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICB0ZXh0W3hdID0gYC0ke2RpZmZzW3hdWzFdLmxlbmd0aH1gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgdGV4dFt4XSA9IGA9JHtkaWZmc1t4XVsxXS5sZW5ndGh9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcdFwiKS5yZXBsYWNlKC8lMjAvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gZGlmZkZyb21EZWx0YSh0ZXh0MSwgZGVsdGEpIHtcbiAgY29uc3QgZGlmZnMgPSBbXTtcbiAgbGV0IGRpZmZzTGVuZ3RoID0gMDtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBjb25zdCB0b2tlbnMgPSBkZWx0YS5zcGxpdCgvXFx0L2cpO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IHBhcmFtID0gdG9rZW5zW3hdLnN1YnN0cmluZygxKTtcbiAgICBzd2l0Y2ggKHRva2Vuc1t4XS5jaGFyQXQoMCkpIHtcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCBkZWNvZGVVUkkocGFyYW0pKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgZXNjYXBlIGluIGRpZmZfZnJvbURlbHRhOiAke3BhcmFtfWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgIGNhc2UgXCI9XCI6IHtcbiAgICAgICAgY29uc3QgbiA9IE51bWJlci5wYXJzZUludChwYXJhbSwgMTApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG4pIHx8IG4gPCAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICR7cGFyYW19YCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0MS5zdWJzdHJpbmcocG9pbnRlciwgcG9pbnRlciArPSBuKTtcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT09IFwiPVwiKVxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gY3JlYXRlRGlmZihESUZGX0VRVUFMLCB0ZXh0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHRva2Vuc1t4XSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlmZiBvcGVyYXRpb24gaW4gZGlmZl9mcm9tRGVsdGE6ICR7dG9rZW5zW3hdfWApO1xuICAgIH1cbiAgfVxuICBpZiAocG9pbnRlciAhPT0gdGV4dDEubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihgRGVsdGEgbGVuZ3RoICgke3BvaW50ZXJ9KSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCR7dGV4dDEubGVuZ3RofSkuYCk7XG4gIHJldHVybiBkaWZmcztcbn1cblxuZnVuY3Rpb24gbWF0Y2hNYWluKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0aW9ucykge1xuICBpZiAodGV4dCA9PSBudWxsIHx8IHBhdHRlcm4gPT0gbnVsbCB8fCBsb2MgPT0gbnVsbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdWxsIGlucHV0LiAobWF0Y2hfbWFpbilcIik7XG4gIGxvYyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxvYywgdGV4dC5sZW5ndGgpKTtcbiAgaWYgKHRleHQgPT09IHBhdHRlcm4pIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodGV4dC5zdWJzdHJpbmcobG9jLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCkgPT09IHBhdHRlcm4pIHtcbiAgICByZXR1cm4gbG9jO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaEJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hdGNoQml0YXAodGV4dCwgcGF0dGVybiwgbG9jLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IHJlc29sdmVkLm1hdGNoTWF4Qml0cylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIHRvbyBsb25nIGZvciB0aGlzIGJyb3dzZXIuXCIpO1xuICBjb25zdCBzID0gbWF0Y2hBbHBoYWJldChwYXR0ZXJuKTtcbiAgZnVuY3Rpb24gbWF0Y2hCaXRhcFNjb3JlKGUsIHgpIHtcbiAgICBjb25zdCBhY2N1cmFjeSA9IGUgLyBwYXR0ZXJuLmxlbmd0aDtcbiAgICBjb25zdCBwcm94aW1pdHkgPSBNYXRoLmFicyhsb2MgLSB4KTtcbiAgICBpZiAoIXJlc29sdmVkLm1hdGNoRGlzdGFuY2UpIHtcbiAgICAgIHJldHVybiBwcm94aW1pdHkgPyAxIDogYWNjdXJhY3k7XG4gICAgfVxuICAgIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIHJlc29sdmVkLm1hdGNoRGlzdGFuY2U7XG4gIH1cbiAgbGV0IHNjb3JlX3RocmVzaG9sZCA9IHJlc29sdmVkLm1hdGNoVGhyZXNob2xkO1xuICBsZXQgYmVzdF9sb2MgPSB0ZXh0LmluZGV4T2YocGF0dGVybiwgbG9jKTtcbiAgaWYgKGJlc3RfbG9jICE9PSAtMSkge1xuICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoQml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gICAgYmVzdF9sb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIGxvYyArIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICBpZiAoYmVzdF9sb2MgIT09IC0xKVxuICAgICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hCaXRhcFNjb3JlKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcbiAgfVxuICBjb25zdCBtYXRjaG1hc2sgPSAxIDw8IHBhdHRlcm4ubGVuZ3RoIC0gMTtcbiAgYmVzdF9sb2MgPSAtMTtcbiAgbGV0IGJpbl9taW4sIGJpbl9taWQ7XG4gIGxldCBiaW5fbWF4ID0gcGF0dGVybi5sZW5ndGggKyB0ZXh0Lmxlbmd0aDtcbiAgbGV0IGxhc3RfcmQgPSBbXTtcbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBwYXR0ZXJuLmxlbmd0aDsgZCsrKSB7XG4gICAgYmluX21pbiA9IDA7XG4gICAgYmluX21pZCA9IGJpbl9tYXg7XG4gICAgd2hpbGUgKGJpbl9taW4gPCBiaW5fbWlkKSB7XG4gICAgICBpZiAobWF0Y2hCaXRhcFNjb3JlKGQsIGxvYyArIGJpbl9taWQpIDw9IHNjb3JlX3RocmVzaG9sZClcbiAgICAgICAgYmluX21pbiA9IGJpbl9taWQ7XG4gICAgICBlbHNlXG4gICAgICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcbiAgICB9XG4gICAgYmluX21heCA9IGJpbl9taWQ7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoMSwgbG9jIC0gYmluX21pZCArIDEpO1xuICAgIGNvbnN0IGZpbmlzaCA9IE1hdGgubWluKGxvYyArIGJpbl9taWQsIHRleHQubGVuZ3RoKSArIHBhdHRlcm4ubGVuZ3RoO1xuICAgIGNvbnN0IHJkID0gQXJyYXkoZmluaXNoICsgMik7XG4gICAgcmRbZmluaXNoICsgMV0gPSAoMSA8PCBkKSAtIDE7XG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICBjb25zdCBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XG4gICAgICBpZiAoZCA9PT0gMCkge1xuICAgICAgICByZFtqXSA9IChyZFtqICsgMV0gPDwgMSB8IDEpICYgY2hhck1hdGNoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaCB8ICgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxIHwgMSkgfCBsYXN0X3JkW2ogKyAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xuICAgICAgICBjb25zdCBzY29yZSA9IG1hdGNoQml0YXBTY29yZShkLCBqIC0gMSk7XG4gICAgICAgIGlmIChzY29yZSA8PSBzY29yZV90aHJlc2hvbGQpIHtcbiAgICAgICAgICBzY29yZV90aHJlc2hvbGQgPSBzY29yZTtcbiAgICAgICAgICBiZXN0X2xvYyA9IGogLSAxO1xuICAgICAgICAgIGlmIChiZXN0X2xvYyA+IGxvYykge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCgxLCAyICogbG9jIC0gYmVzdF9sb2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoQml0YXBTY29yZShkICsgMSwgbG9jKSA+IHNjb3JlX3RocmVzaG9sZClcbiAgICAgIGJyZWFrO1xuICAgIGxhc3RfcmQgPSByZDtcbiAgfVxuICByZXR1cm4gYmVzdF9sb2M7XG59XG5mdW5jdGlvbiBtYXRjaEFscGhhYmV0KHBhdHRlcm4pIHtcbiAgY29uc3QgcyA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIGkgLSAxO1xuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gcGF0Y2hBZGRDb250ZXh0KHBhdGNoLCB0ZXh0LCBvcHRpb25zKSB7XG4gIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm47XG4gIGlmIChwYXRjaC5zdGFydDIgPT09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF0Y2ggbm90IGluaXRpYWxpemVkXCIpO1xuICBjb25zdCB7XG4gICAgbWF0Y2hNYXhCaXRzID0gZGVmYXVsdE9wdGlvbnMubWF0Y2hNYXhCaXRzLFxuICAgIHBhdGNoTWFyZ2luID0gZGVmYXVsdE9wdGlvbnMucGF0Y2hNYXJnaW5cbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBwYXR0ZXJuID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxKTtcbiAgbGV0IHBhZGRpbmcgPSAwO1xuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9PSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4pICYmIHBhdHRlcm4ubGVuZ3RoIDwgbWF0Y2hNYXhCaXRzIC0gcGF0Y2hNYXJnaW4gLSBwYXRjaE1hcmdpbikge1xuICAgIHBhZGRpbmcgKz0gcGF0Y2hNYXJnaW47XG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgfVxuICBwYWRkaW5nICs9IHBhdGNoTWFyZ2luO1xuICBjb25zdCBwcmVmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIpO1xuICBpZiAocHJlZml4KVxuICAgIHBhdGNoLmRpZmZzLnVuc2hpZnQoY3JlYXRlRGlmZihESUZGX0VRVUFMLCBwcmVmaXgpKTtcbiAgY29uc3Qgc3VmZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xuICBpZiAoc3VmZml4KVxuICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBzdWZmaXgpKTtcbiAgcGF0Y2guc3RhcnQxIC09IHByZWZpeC5sZW5ndGg7XG4gIHBhdGNoLnN0YXJ0MiAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5sZW5ndGgxICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xufVxuZnVuY3Rpb24gcGF0Y2hNYWtlKGEsIG9wdF9iLCBvcHRfYywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc29sdmVkID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgbGV0IHRleHQxLCBkaWZmcztcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9wdF9iID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG9wdF9jID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0ZXh0MSA9IGE7XG4gICAgZGlmZnMgPSBkaWZmTWFpbih0ZXh0MSwgb3B0X2IsIHJlc29sdmVkLCB0cnVlKTtcbiAgICBpZiAoZGlmZnMubGVuZ3RoID4gMikge1xuICAgICAgZGlmZkNsZWFudXBTZW1hbnRpYyhkaWZmcyk7XG4gICAgICBkaWZmQ2xlYW51cEVmZmljaWVuY3koZGlmZnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9wdF9iID09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG9wdF9jID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7RGlmZltdfSAqL1xuICAgIGE7XG4gICAgdGV4dDEgPSBkaWZmVGV4dDEoZGlmZnMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIgJiYgb3B0X2IgJiYgdHlwZW9mIG9wdF9iID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9wdF9jID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGE7XG4gICAgZGlmZnMgPSAvKiogQHR5cGUge0RpZmZbXX0gKi9cbiAgICBvcHRfYjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvcHRfYiA9PSBcInN0cmluZ1wiICYmIG9wdF9jICYmIHR5cGVvZiBvcHRfYyA9PSBcIm9iamVjdFwiKSB7XG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBhO1xuICAgIGRpZmZzID0gLyoqIEB0eXBlIHtEaWZmW119ICovXG4gICAgb3B0X2M7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlLlwiKTtcbiAgfVxuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdO1xuICBsZXQgcGF0Y2ggPSBjcmVhdGVQYXRjaCgpO1xuICBsZXQgcGF0Y2hEaWZmTGVuZ3RoID0gMDtcbiAgbGV0IGNoYXJfY291bnQxID0gMDtcbiAgbGV0IGNoYXJfY291bnQyID0gMDtcbiAgbGV0IHByZXBhdGNoX3RleHQgPSB0ZXh0MTtcbiAgbGV0IHBvc3RwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBkaWZmX3R5cGUgPSBkaWZmc1t4XVswXTtcbiAgICBjb25zdCBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcbiAgICBpZiAoIXBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmX3R5cGUgIT09IERJRkZfRVFVQUwpIHtcbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xuICAgICAgcGF0Y2guc3RhcnQyID0gY2hhcl9jb3VudDI7XG4gICAgfVxuICAgIHN3aXRjaCAoZGlmZl90eXBlKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgKyBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgIHBvc3RwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKDAsIGNoYXJfY291bnQyKSArIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArIGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGRpZmZfdGV4dC5sZW5ndGggPD0gMiAqIHJlc29sdmVkLnBhdGNoTWFyZ2luICYmIHBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmcy5sZW5ndGggIT09IHggKyAxKSB7XG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3RleHQubGVuZ3RoID49IDIgKiByZXNvbHZlZC5wYXRjaE1hcmdpbikge1xuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcbiAgICAgICAgICAgIHBhdGNoQWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCwgcmVzb2x2ZWQpO1xuICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgICAgICAgICAgIHBhdGNoRGlmZkxlbmd0aCA9IDA7XG4gICAgICAgICAgICBwcmVwYXRjaF90ZXh0ID0gcG9zdHBhdGNoX3RleHQ7XG4gICAgICAgICAgICBjaGFyX2NvdW50MSA9IGNoYXJfY291bnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGRpZmZfdHlwZSAhPT0gRElGRl9JTlNFUlQpXG4gICAgICBjaGFyX2NvdW50MSArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfREVMRVRFKVxuICAgICAgY2hhcl9jb3VudDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgfVxuICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgcGF0Y2hBZGRDb250ZXh0KHBhdGNoLCBwcmVwYXRjaF90ZXh0LCByZXNvbHZlZCk7XG4gICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlcztcbn1cbmZ1bmN0aW9uIHBhdGNoRGVlcENvcHkocGF0Y2hlcykge1xuICBjb25zdCBwYXRjaGVzQ29weSA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgY29uc3QgcGF0Y2hDb3B5ID0gY3JlYXRlUGF0Y2goKTtcbiAgICBwYXRjaENvcHkuZGlmZnMgPSBbXTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhdGNoLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBjcmVhdGVEaWZmKHBhdGNoLmRpZmZzW3ldWzBdLCBwYXRjaC5kaWZmc1t5XVsxXSk7XG4gICAgfVxuICAgIHBhdGNoQ29weS5zdGFydDEgPSBwYXRjaC5zdGFydDE7XG4gICAgcGF0Y2hDb3B5LnN0YXJ0MiA9IHBhdGNoLnN0YXJ0MjtcbiAgICBwYXRjaENvcHkubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDE7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDIgPSBwYXRjaC5sZW5ndGgyO1xuICAgIHBhdGNoZXNDb3B5W3hdID0gcGF0Y2hDb3B5O1xuICB9XG4gIHJldHVybiBwYXRjaGVzQ29weTtcbn1cbmZ1bmN0aW9uIHBhdGNoQXBwbHkocGF0Y2hlcywgdGV4dCwgb3B0aW9ucykge1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFt0ZXh0LCBbXV07XG4gIHBhdGNoZXMgPSBwYXRjaERlZXBDb3B5KHBhdGNoZXMpO1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBudWxsUGFkZGluZyA9IHBhdGNoQWRkUGFkZGluZyhwYXRjaGVzLCByZXNvbHZlZCk7XG4gIHRleHQgPSBudWxsUGFkZGluZyArIHRleHQgKyBudWxsUGFkZGluZztcbiAgcGF0Y2hTcGxpdE1heChwYXRjaGVzLCByZXNvbHZlZCk7XG4gIGxldCBkZWx0YSA9IDA7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZXhwZWN0ZWRfbG9jID0gcGF0Y2hlc1t4XS5zdGFydDIgKyBkZWx0YTtcbiAgICBjb25zdCB0ZXh0MSA9IGRpZmZUZXh0MShwYXRjaGVzW3hdLmRpZmZzKTtcbiAgICBsZXQgc3RhcnRfbG9jO1xuICAgIGxldCBlbmRfbG9jID0gLTE7XG4gICAgaWYgKHRleHQxLmxlbmd0aCA+IHJlc29sdmVkLm1hdGNoTWF4Qml0cykge1xuICAgICAgc3RhcnRfbG9jID0gbWF0Y2hNYWluKFxuICAgICAgICB0ZXh0LFxuICAgICAgICB0ZXh0MS5zdWJzdHJpbmcoMCwgcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKSxcbiAgICAgICAgZXhwZWN0ZWRfbG9jLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHN0YXJ0X2xvYyAhPT0gLTEpIHtcbiAgICAgICAgZW5kX2xvYyA9IG1hdGNoTWFpbihcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICAgIHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSByZXNvbHZlZC5tYXRjaE1heEJpdHMpLFxuICAgICAgICAgIGV4cGVjdGVkX2xvYyArIHRleHQxLmxlbmd0aCAtIHJlc29sdmVkLm1hdGNoTWF4Qml0cyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlbmRfbG9jID09PSAtMSB8fCBzdGFydF9sb2MgPj0gZW5kX2xvYykge1xuICAgICAgICAgIHN0YXJ0X2xvYyA9IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0X2xvYyA9IG1hdGNoTWFpbih0ZXh0LCB0ZXh0MSwgZXhwZWN0ZWRfbG9jLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0X2xvYyA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcbiAgICAgIGRlbHRhIC09IHBhdGNoZXNbeF0ubGVuZ3RoMiAtIHBhdGNoZXNbeF0ubGVuZ3RoMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0c1t4XSA9IHRydWU7XG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcbiAgICAgIGxldCB0ZXh0MjtcbiAgICAgIGlmIChlbmRfbG9jID09PSAtMSlcbiAgICAgICAgdGV4dDIgPSB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MsIHN0YXJ0X2xvYyArIHRleHQxLmxlbmd0aCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBlbmRfbG9jICsgcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKTtcbiAgICAgIGlmICh0ZXh0MSA9PT0gdGV4dDIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYykgKyBkaWZmVGV4dDIocGF0Y2hlc1t4XS5kaWZmcykgKyB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGlmZnMgPSBkaWZmTWFpbih0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHRleHQxLmxlbmd0aCA+IHJlc29sdmVkLm1hdGNoTWF4Qml0cyAmJiBkaWZmTGV2ZW5zaHRlaW4oZGlmZnMpIC8gdGV4dDEubGVuZ3RoID4gcmVzb2x2ZWQucGF0Y2hEZWxldGVUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZkNsZWFudXBTZW1hbnRpY0xvc3NsZXNzKGRpZmZzKTtcbiAgICAgICAgICBsZXQgaW5kZXgxID0gMDtcbiAgICAgICAgICBsZXQgaW5kZXgyID0gMDtcbiAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHBhdGNoZXNbeF0uZGlmZnMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZCA9IHBhdGNoZXNbeF0uZGlmZnNbeV07XG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKVxuICAgICAgICAgICAgICBpbmRleDIgPSBkaWZmWEluZGV4KGRpZmZzLCBpbmRleDEpO1xuICAgICAgICAgICAgaWYgKG1vZFswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gKyB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyBpbmRleDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RbMF0gPT09IERJRkZfREVMRVRFKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgZGlmZlhJbmRleChkaWZmcywgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9ERUxFVEUpXG4gICAgICAgICAgICAgIGluZGV4MSArPSBtb2RbMV0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcobnVsbFBhZGRpbmcubGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIG51bGxQYWRkaW5nLmxlbmd0aCk7XG4gIHJldHVybiBbdGV4dCwgcmVzdWx0c107XG59XG5mdW5jdGlvbiBwYXRjaEFkZFBhZGRpbmcocGF0Y2hlcywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwYXRjaE1hcmdpbjogcGFkZGluZ0xlbmd0aCA9IGRlZmF1bHRPcHRpb25zLnBhdGNoTWFyZ2luXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgbnVsbFBhZGRpbmcgPSBcIlwiO1xuICBmb3IgKGxldCB4ID0gMTsgeCA8PSBwYWRkaW5nTGVuZ3RoOyB4KyspXG4gICAgbnVsbFBhZGRpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xuICB9XG4gIGxldCBwYXRjaCA9IHBhdGNoZXNbMF07XG4gIGxldCBkaWZmcyA9IHBhdGNoLmRpZmZzO1xuICBpZiAoZGlmZnMubGVuZ3RoID09PSAwIHx8IGRpZmZzWzBdWzBdICE9PSBESUZGX0VRVUFMKSB7XG4gICAgZGlmZnMudW5zaGlmdChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIG51bGxQYWRkaW5nKSk7XG4gICAgcGF0Y2guc3RhcnQxIC09IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMSArPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfSBlbHNlIGlmIChwYWRkaW5nTGVuZ3RoID4gZGlmZnNbMF1bMV0ubGVuZ3RoKSB7XG4gICAgY29uc3QgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xuICAgIGRpZmZzWzBdWzFdID0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKGRpZmZzWzBdWzFdLmxlbmd0aCkgKyBkaWZmc1swXVsxXTtcbiAgICBwYXRjaC5zdGFydDEgLT0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICBwYXRjaCA9IHBhdGNoZXNbcGF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVswXSAhPT0gRElGRl9FUVVBTCkge1xuICAgIGRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBudWxsUGFkZGluZykpO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzW2RpZmZzLmxlbmd0aCAtIDFdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gZXh0cmFMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBleHRyYUxlbmd0aDtcbiAgfVxuICByZXR1cm4gbnVsbFBhZGRpbmc7XG59XG5mdW5jdGlvbiBwYXRjaFNwbGl0TWF4KHBhdGNoZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSByZXNvbHZlZC5tYXRjaE1heEJpdHMpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBiaWdwYXRjaCA9IHBhdGNoZXNbeF07XG4gICAgcGF0Y2hlcy5zcGxpY2UoeC0tLCAxKTtcbiAgICBsZXQgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xuICAgIGxldCBzdGFydDIgPSBiaWdwYXRjaC5zdGFydDI7XG4gICAgbGV0IHByZWNvbnRleHQgPSBcIlwiO1xuICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgICAgIGxldCBlbXB0eSA9IHRydWU7XG4gICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IHN0YXJ0MiAtIHByZWNvbnRleHQubGVuZ3RoO1xuICAgICAgaWYgKHByZWNvbnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDIgPSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHByZWNvbnRleHQpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiYgcGF0Y2gubGVuZ3RoMSA8IHJlc29sdmVkLm1hdGNoTWF4Qml0cyAtIHJlc29sdmVkLnBhdGNoTWFyZ2luKSB7XG4gICAgICAgIGNvbnN0IGRpZmZfdHlwZSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzBdO1xuICAgICAgICBsZXQgZGlmZl90ZXh0ID0gYmlncGF0Y2guZGlmZnNbMF1bMV07XG4gICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goYmlncGF0Y2guZGlmZnMuc2hpZnQoKSk7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3R5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PT0gMSAmJiBwYXRjaC5kaWZmc1swXVswXSA9PT0gRElGRl9FUVVBTCAmJiBkaWZmX3RleHQubGVuZ3RoID4gMiAqIHJlc29sdmVkLm1hdGNoTWF4Qml0cykge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihkaWZmX3R5cGUsIGRpZmZfdGV4dCkpO1xuICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLCByZXNvbHZlZC5tYXRjaE1heEJpdHMgLSBwYXRjaC5sZW5ndGgxIC0gcmVzb2x2ZWQucGF0Y2hNYXJnaW4pO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKGRpZmZfdHlwZSwgZGlmZl90ZXh0KSk7XG4gICAgICAgICAgaWYgKGRpZmZfdGV4dCA9PT0gYmlncGF0Y2guZGlmZnNbMF1bMV0pIHtcbiAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdID0gYmlncGF0Y2guZGlmZnNbMF1bMV0uc3Vic3RyaW5nKGRpZmZfdGV4dC5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJlY29udGV4dCA9IGRpZmZUZXh0MihwYXRjaC5kaWZmcyk7XG4gICAgICBwcmVjb250ZXh0ID0gcHJlY29udGV4dC5zdWJzdHJpbmcocHJlY29udGV4dC5sZW5ndGggLSByZXNvbHZlZC5wYXRjaE1hcmdpbik7XG4gICAgICBjb25zdCBwb3N0Y29udGV4dCA9IGRpZmZUZXh0MShiaWdwYXRjaC5kaWZmcykuc3Vic3RyaW5nKDAsIHJlc29sdmVkLnBhdGNoTWFyZ2luKTtcbiAgICAgIGlmIChwb3N0Y29udGV4dCAhPT0gXCJcIikge1xuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IHBvc3Rjb250ZXh0Lmxlbmd0aDtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiYgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdGNvbnRleHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgcG9zdGNvbnRleHQpKTtcbiAgICAgIH1cbiAgICAgIGlmICghZW1wdHkpXG4gICAgICAgIHBhdGNoZXMuc3BsaWNlKCsreCwgMCwgcGF0Y2gpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGF0Y2hUb1RleHQocGF0Y2hlcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKylcbiAgICB0ZXh0W3hdID0gcGF0Y2hlc1t4XTtcbiAgcmV0dXJuIHRleHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGNoRnJvbVRleHQodGV4dGxpbmUpIHtcbiAgY29uc3QgcGF0Y2hlcyA9IFtdO1xuICBpZiAoIXRleHRsaW5lKVxuICAgIHJldHVybiBwYXRjaGVzO1xuICBjb25zdCB0ZXh0ID0gdGV4dGxpbmUuc3BsaXQoXCJcXG5cIik7XG4gIGxldCB0ZXh0UG9pbnRlciA9IDA7XG4gIGNvbnN0IHBhdGNoSGVhZGVyID0gL15AQCAtKFxcZCspLD8oXFxkKikgXFwrKFxcZCspLD8oXFxkKikgQEAkLztcbiAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBtID0gdGV4dFt0ZXh0UG9pbnRlcl0ubWF0Y2gocGF0Y2hIZWFkZXIpO1xuICAgIGlmICghbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXRjaCBzdHJpbmc6ICR7dGV4dFt0ZXh0UG9pbnRlcl19YCk7XG4gICAgY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaCgpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgcGF0Y2guc3RhcnQxID0gTnVtYmVyLnBhcnNlSW50KG1bMV0sIDEwKTtcbiAgICBpZiAobVsyXSA9PT0gXCJcIikge1xuICAgICAgcGF0Y2guc3RhcnQxLS07XG4gICAgICBwYXRjaC5sZW5ndGgxID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bMl0gPT09IFwiMFwiKSB7XG4gICAgICBwYXRjaC5sZW5ndGgxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQxLS07XG4gICAgICBwYXRjaC5sZW5ndGgxID0gTnVtYmVyLnBhcnNlSW50KG1bMl0sIDEwKTtcbiAgICB9XG4gICAgcGF0Y2guc3RhcnQyID0gTnVtYmVyLnBhcnNlSW50KG1bM10sIDEwKTtcbiAgICBpZiAobVs0XSA9PT0gXCJcIikge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMTtcbiAgICB9IGVsc2UgaWYgKG1bNF0gPT09IFwiMFwiKSB7XG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2guc3RhcnQyLS07XG4gICAgICBwYXRjaC5sZW5ndGgyID0gTnVtYmVyLnBhcnNlSW50KG1bNF0sIDEwKTtcbiAgICB9XG4gICAgdGV4dFBvaW50ZXIrKztcbiAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc2lnbiA9IHRleHRbdGV4dFBvaW50ZXJdLmNoYXJBdCgwKTtcbiAgICAgIGxldCBsaW5lID0gXCJcIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpbmUgPSBkZWNvZGVVUkkodGV4dFt0ZXh0UG9pbnRlcl0uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBlc2NhcGUgaW4gcGF0Y2hfZnJvbVRleHQ6ICR7bGluZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduID09PSBcIi1cIikge1xuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9ERUxFVEUsIGxpbmUpKTtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfSU5TRVJULCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09IFwiIFwiKSB7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09IFwiQFwiKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIlwiKSA7IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF0Y2ggbW9kZSBcIiR7c2lnbn1cIiBpbjogJHtsaW5lfWApO1xuICAgICAgfVxuICAgICAgdGV4dFBvaW50ZXIrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaCgpIHtcbiAgY29uc3QgcGF0Y2ggPSB7XG4gICAgZGlmZnM6IFtdLFxuICAgIHN0YXJ0MTogbnVsbCxcbiAgICBzdGFydDI6IG51bGwsXG4gICAgbGVuZ3RoMTogMCxcbiAgICBsZW5ndGgyOiAwXG4gIH07XG4gIHBhdGNoLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGNvb3JkczEsIGNvb3JkczI7XG4gICAgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMClcbiAgICAgIGNvb3JkczEgPSBgJHt0aGlzLnN0YXJ0MX0sMGA7XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGgxID09PSAxKVxuICAgICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgMTtcbiAgICBlbHNlXG4gICAgICBjb29yZHMxID0gYCR7dGhpcy5zdGFydDEgKyAxfSwke3RoaXMubGVuZ3RoMX1gO1xuICAgIGlmICh0aGlzLmxlbmd0aDIgPT09IDApXG4gICAgICBjb29yZHMyID0gYCR7dGhpcy5zdGFydDJ9LDBgO1xuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoMiA9PT0gMSlcbiAgICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XG4gICAgZWxzZVxuICAgICAgY29vcmRzMiA9IGAke3RoaXMuc3RhcnQyICsgMX0sJHt0aGlzLmxlbmd0aDJ9YDtcbiAgICBjb25zdCB0ZXh0ID0gW2BAQCAtJHtjb29yZHMxfSArJHtjb29yZHMyfSBAQFxuYF07XG4gICAgbGV0IG9wO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xuICAgICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XG4gICAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgICAgb3AgPSBcIitcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgICBvcCA9IFwiLVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgICAgb3AgPSBcIiBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRleHRbeCArIDFdID0gYCR7b3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSl9XG5gO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5qb2luKFwiXCIpLnJlcGxhY2UoLyUyMC9nLCBcIiBcIik7XG4gIH07XG4gIHJldHVybiBwYXRjaDtcbn1cblxuZXhwb3J0IHsgRElGRl9ERUxFVEUsIERJRkZfRVFVQUwsIERJRkZfSU5TRVJULCBkZWZhdWx0T3B0aW9ucywgZGlmZk1haW4gYXMgZGlmZiwgZGlmZkNsZWFudXBFZmZpY2llbmN5LCBkaWZmQ2xlYW51cE1lcmdlLCBkaWZmQ2xlYW51cFNlbWFudGljLCBkaWZmQ2xlYW51cFNlbWFudGljTG9zc2xlc3MsIGRpZmZDb21tb25QcmVmaXgsIGRpZmZDb21tb25TdWZmaXgsIGRpZmZGcm9tRGVsdGEsIGRpZmZMZXZlbnNodGVpbiwgZGlmZk1haW4sIGRpZmZQcmV0dHlIdG1sLCBkaWZmVGV4dDEsIGRpZmZUZXh0MiwgZGlmZlRvRGVsdGEsIGRpZmZYSW5kZXgsIG1hdGNoTWFpbiBhcyBtYXRjaCwgbWF0Y2hBbHBoYWJldCwgbWF0Y2hCaXRhcCwgbWF0Y2hNYWluLCBwYXRjaE1ha2UgYXMgcGF0Y2gsIHBhdGNoQWRkUGFkZGluZywgcGF0Y2hBcHBseSwgcGF0Y2hEZWVwQ29weSwgcGF0Y2hGcm9tVGV4dCwgcGF0Y2hNYWtlLCBwYXRjaFNwbGl0TWF4LCBwYXRjaFRvVGV4dCwgcmVzb2x2ZU9wdGlvbnMgfTtcbiIsICJpbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tICcuL3NoYXJlZEVudGl0aWVzL3NoYXJlZERvY3VtZW50J1xuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRGb2xkZXInXG5cbnR5cGUgQ2xpZW50TWVzc2FnZSA9IHtcbiAgdHlwZTogXCJhZGRcIiB8IFwicmVtb3ZlXCIgfCBcImZ1bGxcIixcbiAgZG9jczogQXJyYXk8c3RyaW5nPlxufVxuXG50eXBlIFNlcnZlck1lc3NhZ2UgPSB7XG4gIHR5cGU6IFwiYWRkXCIgfCBcImZ1bGxcIixcbiAgZG9jczogQXJyYXk8c3RyaW5nPlxufVxuXG50eXBlIEV2ZW50cyA9IHtcbiAgXCJjb25uZWN0aW9uLWVycm9yXCI6IChldmVudDogRXZlbnQsIGNsaWVudDogQWN0aXZlU3RyZWFtQ2xpZW50KSA9PiB2b2lkLFxuICBcImNvbm5lY3Rpb24tY2xvc2VcIjogKGV2ZW50OiBFdmVudCwgY2xpZW50OiBBY3RpdmVTdHJlYW1DbGllbnQpID0+IHZvaWQsXG4gIHN0YXR1czogKHN0YXR1czogeyBzdGF0dXM6IHN0cmluZyB9KSA9PiB2b2lkXG59XG5cbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuY29uc3QgaGFuZGxlTWVzc2FnZSA9IChkYXRhOiBzdHJpbmcpID0+IHtcbiAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZGF0YSkgYXMgU2VydmVyTWVzc2FnZVxuICBmb3IgKGNvbnN0IGlkIG9mIG1lc3NhZ2UuZG9jcykge1xuICAgIFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKGlkKT8uc3RhcnRXZWJSVENTeW5jKClcbiAgICBTaGFyZWRGb2xkZXIuZmluZEJ5SWQoaWQpPy5zdGFydFdlYlJUQ1N5bmMoKVxuICB9XG59XG5cbmNvbnN0IHNldHVwV1MgPSAoY2xpZW50OiBBY3RpdmVTdHJlYW1DbGllbnQpID0+IHtcbiAgaWYgKGNsaWVudC5zaG91bGRDb25uZWN0ICYmIGNsaWVudC53cyA9PT0gbnVsbCkge1xuICAgIGNvbnN0IHdlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQoY2xpZW50LnVybClcbiAgICBjbGllbnQud3MgPSB3ZWJzb2NrZXRcbiAgICBjbGllbnQud3Njb25uZWN0aW5nID0gdHJ1ZVxuICAgIGNsaWVudC53c2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjbGllbnQud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBoYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEpXG4gICAgfVxuXG4gICAgd2Vic29ja2V0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNsaWVudC5lbWl0KCdjb25uZWN0aW9uLWVycm9yJywgW2V2ZW50LCBjbGllbnRdKVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbi1jbG9zZScsIFtldmVudCwgY2xpZW50XSlcbiAgICAgIGNsaWVudC53cyA9IG51bGxcbiAgICAgIGNsaWVudC53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKGNsaWVudC53c2Nvbm5lY3RlZCkge1xuICAgICAgICBjbGllbnQud3Njb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgICAgIGNsaWVudC5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICAgIHN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgICAgICAgfV0pXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudC53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMrK1xuICAgICAgfVxuICAgICAgLy8gU3RhcnQgd2l0aCBubyByZWNvbm5lY3QgdGltZW91dCBhbmQgaW5jcmVhc2UgdGltZW91dCBieVxuICAgICAgLy8gdXNpbmcgZXhwb25lbnRpYWwgYmFja29mZiBzdGFydGluZyB3aXRoIDEwMG1zXG4gICAgICBzZXRUaW1lb3V0KFxuICAgICAgICBzZXR1cFdTLFxuICAgICAgICBtYXRoLm1pbihcbiAgICAgICAgICBtYXRoLnBvdygyLCBjbGllbnQud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKSAqIDEwMCxcbiAgICAgICAgICBjbGllbnQubWF4QmFja29mZlRpbWVcbiAgICAgICAgKSxcbiAgICAgICAgY2xpZW50XG4gICAgICApXG4gICAgfVxuICAgIHdlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBjbGllbnQud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjbGllbnQud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGNsaWVudC53c2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgIGNsaWVudC53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICBjbGllbnQuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgc3RhdHVzOiAnY29ubmVjdGVkJ1xuICAgICAgfV0pXG5cbiAgICAgIGNsaWVudC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgIGRvY3M6IEFycmF5LmZyb20oY2xpZW50LmRvY0lkcylcbiAgICAgIH0gc2F0aXNmaWVzIENsaWVudE1lc3NhZ2UpKVxuXG4gICAgfVxuICAgIGNsaWVudC5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgc3RhdHVzOiAnY29ubmVjdGluZydcbiAgICB9XSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWN0aXZlU3RyZWFtQ2xpZW50IGV4dGVuZHMgT2JzZXJ2YWJsZVYyPEV2ZW50cz4ge1xuXG4gIG1heEJhY2tvZmZUaW1lOiBudW1iZXJcbiAgdXJsOiBzdHJpbmdcbiAgd3Njb25uZWN0ZWQ6IGJvb2xlYW5cbiAgd3Njb25uZWN0aW5nOiBib29sZWFuXG4gIHdzVW5zdWNjZXNzZnVsUmVjb25uZWN0czogbnVtYmVyXG4gIHdzOiBXZWJTb2NrZXQgfCBudWxsXG4gIHdzTGFzdE1lc3NhZ2VSZWNlaXZlZDogbnVtYmVyXG4gIHNob3VsZENvbm5lY3Q6IGJvb2xlYW5cbiAgX3Jlc3luY0ludGVydmFsOiBudW1iZXJcblxuICBkb2NJZHM6IFNldDxzdHJpbmc+XG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcsIG9wdHM6IHtcbiAgICBjb25uZWN0OiBib29sZWFuLFxuICAgIHJlc3luY0ludGVydmFsOiBudW1iZXIsXG4gICAgbWF4QmFja29mZlRpbWU6IG51bWJlcixcbiAgfSA9IHtcbiAgICAgIGNvbm5lY3Q6IHRydWUsXG4gICAgICByZXN5bmNJbnRlcnZhbDogLTEsXG4gICAgICBtYXhCYWNrb2ZmVGltZTogMjUwMFxuICAgIH0pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tYXhCYWNrb2ZmVGltZSA9IG9wdHMubWF4QmFja29mZlRpbWVcbiAgICB0aGlzLnVybCA9IHVybFxuXG4gICAgdGhpcy53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuXG4gICAgdGhpcy53cyA9IG51bGxcbiAgICB0aGlzLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDBcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBvcHRzLmNvbm5lY3RcbiAgICB0aGlzLl9yZXN5bmNJbnRlcnZhbCA9IDBcblxuICAgIHRoaXMuZG9jSWRzID0gbmV3IFNldDxzdHJpbmc+KClcblxuICAgIGlmIChvcHRzLnJlc3luY0ludGVydmFsID4gMCkge1xuICAgICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAod2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bGxcIixcbiAgICAgICAgICAgIGRvY3M6IEFycmF5LmZyb20odGhpcy5kb2NJZHMpXG4gICAgICAgICAgfSBzYXRpc2ZpZXMgQ2xpZW50TWVzc2FnZSkpXG4gICAgICAgIH1cbiAgICAgIH0sIG9wdHMucmVzeW5jSW50ZXJ2YWwpKVxuICAgIH1cblxuICAgIGlmIChvcHRzLmNvbm5lY3QpIHtcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgc2VuZChkYXRhOiBzdHJpbmcpIHtcbiAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgIT09IHRoaXMud3MuQ09OTkVDVElORyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgIT09IHRoaXMud3MuT1BFTikge1xuICAgICAgdGhpcy53cy5jbG9zZSgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5zZW5kKGRhdGEpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy53cz8uY2xvc2UoKVxuICAgIH1cbiAgfVxuXG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fcmVzeW5jSW50ZXJ2YWwgIT09IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVzeW5jSW50ZXJ2YWwpXG4gICAgfVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIGlmICghdGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzID09PSBudWxsKSB7XG4gICAgICBzZXR1cFdTKHRoaXMpXG4gICAgfVxuICB9XG5cbiAgYWRkKGlkczogQXJyYXk8c3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICB0aGlzLmRvY0lkcy5hZGQoaWQpXG4gICAgfVxuICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiBcImFkZFwiLFxuICAgICAgZG9jczogaWRzXG4gICAgfSBzYXRpc2ZpZXMgQ2xpZW50TWVzc2FnZSkpXG4gIH1cblxuICByZW1vdmUoaWRzOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgIHRoaXMuZG9jSWRzLmRlbGV0ZShpZClcbiAgICB9XG4gICAgdGhpcy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IFwicmVtb3ZlXCIsXG4gICAgICBkb2NzOiBpZHNcbiAgICB9IHNhdGlzZmllcyBDbGllbnRNZXNzYWdlKSlcbiAgfVxufVxuIiwgImltcG9ydCB7IFBsYXRmb3JtLCBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHNlc3Npb24gfSBmcm9tICdAZWxlY3Ryb24vcmVtb3RlJztcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vbWFpblwiO1xuXG5leHBvcnQgY29uc3QgcHJlcGFyZUNvbW11bmljYXRpb24gPSBhc3luYyAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcblxuICBpZiAoUGxhdGZvcm0uaXNEZXNrdG9wQXBwKSB7ICAgIFxuICAgIGF3YWl0IHNlc3Npb24uZGVmYXVsdFNlc3Npb24uY29va2llcy5zZXQoeyB1cmw6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcFwiLCBcIm5hbWVcIjogXCJvaWRcIiwgXCJ2YWx1ZVwiOiBwbHVnaW4uc2V0dGluZ3Mub2lkLCBcImRvbWFpblwiOiBcInd3dy5wZWVyZHJhZnQuYXBwXCIsIFwicGF0aFwiOiBcIi9cIiwgXCJzZWN1cmVcIjogdHJ1ZSwgXCJodHRwT25seVwiOiB0cnVlLCBcInNhbWVTaXRlXCI6IFwibm9fcmVzdHJpY3Rpb25cIiB9KVxuICAgIGF3YWl0IHNlc3Npb24uZGVmYXVsdFNlc3Npb24uY29va2llcy5zZXQoeyB1cmw6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczXCIsIFwibmFtZVwiOiBcIm9pZFwiLCBcInZhbHVlXCI6IHBsdWdpbi5zZXR0aW5ncy5vaWQsIFwiZG9tYWluXCI6IFwibG9jYWxob3N0XCIsIFwicGF0aFwiOiBcIi9cIiwgXCJzZWN1cmVcIjogdHJ1ZSwgXCJodHRwT25seVwiOiB0cnVlLCBcInNhbWVTaXRlXCI6IFwibm9fcmVzdHJpY3Rpb25cIiB9KVxuICB9XG4gIGVsc2UgaWYgKFBsYXRmb3JtLmlzTW9iaWxlQXBwKSB7XG4gICAgY29uc3Qgc2lnbmFsaW5nVVJMID0gbmV3IFVSTChwbHVnaW4uc2V0dGluZ3Muc2lnbmFsaW5nKVxuICAgIHNpZ25hbGluZ1VSTC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdvaWQnLCBwbHVnaW4uc2V0dGluZ3Mub2lkKVxuICAgIHBsdWdpbi5zZXR0aW5ncy5zaWduYWxpbmcgPSBzaWduYWxpbmdVUkwudG9TdHJpbmcoKVxuICB9XG59IiwgImltcG9ydCB7IHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCIuL3VpXCJcblxuZXhwb3J0IGNsYXNzIFNlcnZlckFQSSB7XG5cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG9wdHM6IHtcbiAgICAgIG9pZDogc3RyaW5nLFxuICAgICAgcGVybWFuZW50U2Vzc2lvblVybDogc3RyaW5nXG4gICAgfVxuICApe31cblxuICBhc3luYyBjcmVhdGVQZXJtYW5lbnRTZXNzaW9uICgpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVxdWVzdFVybCh7XG4gICAgICB1cmw6IHRoaXMub3B0cy5wZXJtYW5lbnRTZXNzaW9uVXJsLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG9pZDogdGhpcy5vcHRzLm9pZFxuICAgICAgfSlcbiAgICB9KS5qc29uXG4gIFxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkge1xuICAgICAgc2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIHNoYXJlZCBmaWxlXCIpXG4gICAgICByZXR1cm4gXG4gICAgfVxuICAgIHJldHVybiBkYXRhIGFzIHtpZDogc3RyaW5nfVxuICB9XG5cbiAgYXN5bmMgaXNTZXNzaW9uUGVybWFuZW50IChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgdXJsOiB0aGlzLm9wdHMucGVybWFuZW50U2Vzc2lvblVybCArIFwiL1wiICsgaWQsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIH0pLmpzb25cbiAgXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBzaG93Tm90aWNlKFwiRXJyb3IgY3JlYXRpbmcgc2hhcmVkIGZpbGVcIilcbiAgICAgIHJldHVybiBcbiAgICB9XG4gICAgcmV0dXJuICEhZGF0YS5wZXJtYW5lbnRcbiAgfVxufVxuIiwgImltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcInNyYy9wZWVyZHJhZnRQbHVnaW5cIjtcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gXCIuL3NoYXJlZEVudGl0eVwiO1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWREb2N1bWVudFwiO1xuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRm9sZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBmcm9tU2hhcmVVUkwgPSBhc3luYyAodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKTogUHJvbWlzZTxTaGFyZWRFbnRpdHkgfCB2b2lkPiA9PiB7XG4gIGNvbnN0IHNwbGl0dGVkVXJsID0gdXJsLnNwbGl0KCcvJylcbiAgaWYgKHNwbGl0dGVkVXJsPy5jb250YWlucygnY20nKSkge1xuICAgIHJldHVybiBTaGFyZWREb2N1bWVudC5mcm9tU2hhcmVVUkwodXJsLCBwbHVnaW4pXG4gIH1cbiAgaWYgKHNwbGl0dGVkVXJsPy5jb250YWlucygndGVhbScpKSB7XG4gICAgcmV0dXJuIFNoYXJlZEZvbGRlci5mcm9tU2hhcmVVUkwodXJsLCBwbHVnaW4pXG4gIH1cbn0iLCAiXG5pbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuY2xhc3MgQ2hvb3NlU2Vzc2lvblR5cGVNb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuICBjYjogKHJlc3VsdDoge3Blcm1hbmVudDogYm9vbGVhbn0pID0+IGFueVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBjYjogKHJlc3VsdDoge3Blcm1hbmVudDogYm9vbGVhbn0pID0+IGFueSkge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmNiID0gY2JcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuc2V0TmFtZShcIlN0YXJ0IHdvcmtpbmcgdG9nZXRoZXJcIikuc2V0SGVhZGluZygpXG5cbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlN0YXJ0IGZsZWV0aW5nIHNlc3Npb25cIilcbiAgICAgIGJ1dHRvbi5zZXRDdGEoKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih7XG4gICAgICAgICAgcGVybWFuZW50OiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KS5zZXREZXNjKFwiQSBmbGVldGluZyBzZXNzaW9uIGF1dG9tYXRpY2FsbHkgY2xvc2VzIHdoZW4geW91IGNsb3NlIHRoZSBkb2N1bWVudCBvciBkaXNjb25uZWN0LlwiKVxuXG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJTaGFyZSBwZXJtYW5lbnRseVwiKVxuICAgICAgYnV0dG9uLnNldEN0YSgpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmNiKHtcbiAgICAgICAgICBwZXJtYW5lbnQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSkuc2V0RGVzYyhcIlRoZSBkb2N1bWVudCB3aWxsIGJlIHNoYXJlZCBwZXJtYW5lbnRseSB1bnRpbCB5b3UgZXhwbGljaXRlbHkgc3RvcCBzaGFyaW5nLiBUaGlzIGlzIHBlcnNpc3RlZCBldmVuIGlmIHlvdSBkaXNjb25uZWN0IG9yIGNsb3NlIE9ic2lkaWFuLlwiKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwcm9tcHRGb3JTZXNzaW9uVHlwZSA9IChhcHA6IEFwcCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8e3Blcm1hbmVudDogYm9vbGVhbn0gfCB2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIG5ldyBDaG9vc2VTZXNzaW9uVHlwZU1vZGFsKGFwcCwgKHJlc3VsdCkgPT4ge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgfSkub3BlbigpXG4gIH0pXG59IiwgIlxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiXG5cbnR5cGUgT1BUUyA9IHtcbiAgaGVhZGVyOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGluaXRpYWw6IFJFU1VMVFxufVxuXG50eXBlIFJFU1VMVCA9IHtcbiAgdGV4dDogc3RyaW5nXG59XG5cbmNsYXNzIEVudGVyVGV4dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXG4gIGNiOiAocmVzdWx0OiB7IHRleHQ6IHN0cmluZyB9KSA9PiBhbnlcbiAgb3B0czogT1BUU1xuICByZXN1bHQ6IFJFU1VMVFxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvcHRzOiBPUFRTLCBjYjogKHJlc3VsdDogUkVTVUxUKSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5jYiA9IGNiXG4gICAgdGhpcy5yZXN1bHQgPSBvcHRzLmluaXRpYWxcbiAgICB0aGlzLm9wdHMgPSBvcHRzXG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLnNldE5hbWUodGhpcy5vcHRzLmhlYWRlcikuc2V0SGVhZGluZygpXG5cbiAgICBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbCkuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5yZXN1bHQudGV4dCksXG4gICAgICAgIHRleHQub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXN1bHQudGV4dCA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICB0ZXh0LmlucHV0RWwub25rZXlkb3duID0gKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmNiKHRoaXMucmVzdWx0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkuc2V0RGVzYyh0aGlzLm9wdHMuZGVzY3JpcHRpb24pXG5cbiAgICBjb25zdCBidXR0b25zID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG5cbiAgICBidXR0b25zLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJDYW5jZWxcIilcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBidXR0b25zLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJPS1wiKVxuICAgICAgYnV0dG9uLnNldEN0YSgpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmNiKHRoaXMucmVzdWx0KVxuICAgICAgfSlcbiAgICB9KVxuXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvclRleHQgPSAoYXBwOiBBcHAsIG9wdHM6IE9QVFMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFJFU1VMVCB8IHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IEVudGVyVGV4dE1vZGFsKGFwcCwgb3B0cywgKGNiKSA9PiB7XG4gICAgICByZXNvbHZlKGNiKVxuICAgIH0pLm9wZW4oKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yVVJMID0gKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBwcm9tcHRGb3JUZXh0KGFwcCwge1xuICAgIGRlc2NyaXB0aW9uOiBcIkVudGVyIHRoZSBVUkwgeW91IHJlY2VpdmVkIHRvIHN0YXJ0IHdvcmtpbmcgdG9nZXRoZXIuXCIsXG4gICAgaGVhZGVyOiBcIkVudGVyIHlvdXIgUGVlcmRyYWZ0IFVSTFwiLFxuICAgIGluaXRpYWw6IHtcbiAgICAgIHRleHQ6IFwiXCJcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBwcm9tcHRGb3JOYW1lID0gKGFwcDogQXBwKSA9PiB7XG4gIHJldHVybiBwcm9tcHRGb3JUZXh0KGFwcCwge1xuICAgIGRlc2NyaXB0aW9uOiBcIlRoaXMgbmFtZSB3aWxsIGJlIHNob3duIHRvIHlvdXIgY29sbGFib3JhdG9yc1wiLFxuICAgIGhlYWRlcjogXCJXaGF0J3MgeW91ciBuYW1lP1wiLFxuICAgIGluaXRpYWw6IHtcbiAgICAgIHRleHQ6IFwiXCJcbiAgICB9XG4gIH0pXG59IiwgImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcbmltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tICcuL3NoYXJlZEVudGl0aWVzL3NoYXJlZERvY3VtZW50J1xuaW1wb3J0IHsgU2hhcmVkRW50aXR5IH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHknXG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tICcuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlcidcbmltcG9ydCB7IGNhbGN1bGF0ZUhhc2gsIHNlcmlhbGl6ZSB9IGZyb20gJy4vdG9vbHMnXG5cbmV4cG9ydCBjb25zdCBNRVNTQUdFX1NZTkMgPSAwXG5leHBvcnQgY29uc3QgTUVTU0FHRV9RVUVSWV9BV0FSRU5FU1MgPSAzXG5leHBvcnQgY29uc3QgTUVTU0FHRV9BV0FSRU5FU1MgPSAxXG5leHBvcnQgY29uc3QgTUVTU0FHRV9BVVRIID0gMlxuXG5cbmV4cG9ydCBjb25zdCBNRVNTQUdFX01VTFRJUExFWF9TWU5DID0gNFxuXG5leHBvcnQgY29uc3QgU1lOQ19TVEVQXzEgPSAwXG5leHBvcnQgY29uc3QgU1lOQ19TVEVQXzIgPSAxXG5leHBvcnQgY29uc3QgVVBEQVRFID0gM1xuZXhwb3J0IGNvbnN0IE5FV19ET0NVTUVOVCA9IDRcbmV4cG9ydCBjb25zdCBORVdfRE9DVU1FTlRfQ09ORklSTUVEID0gNVxuZXhwb3J0IGNvbnN0IEdFVF9ET0NVTUVOVF9BU19VUERBVEUgPSA2XG5leHBvcnQgY29uc3QgU0VORF9ET0NVTUVOVF9BU19VUERBVEUgPSA3XG5cbmV4cG9ydCBjb25zdCBNRVNTQUdFX0FVVEhFTlRJQ0FUSU9OX1JFUVVFU1QgPSA1XG5leHBvcnQgY29uc3QgTUVTU0FHRV9BVVRIRU5USUNBVElPTl9SRVNQT05TRSA9IDZcblxuY29uc3QgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPSAzMDAwMFxuXG5cblxuY29uc3Qgc2V0dXBXUyA9IChwcm92aWRlcjogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIpID0+IHtcbiAgaWYgKHByb3ZpZGVyLnNob3VsZENvbm5lY3QgJiYgcHJvdmlkZXIud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHByb3ZpZGVyLnVybClcbiAgICB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICBwcm92aWRlci53cyA9IHdlYnNvY2tldFxuICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IHRydWVcbiAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IGZhbHNlXG5cbiAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBwcm92aWRlci53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShldmVudC5kYXRhKVxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09IDApIHJldHVyblxuICAgICAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGF0YSlcbiAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAgIGlmIChtZXNzYWdlVHlwZSA9PT0gTUVTU0FHRV9NVUxUSVBMRVhfU1lOQykge1xuICAgICAgICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgICAgICBzd2l0Y2ggKHN5bmNNZXNzYWdlVHlwZSkge1xuICAgICAgICAgIGNhc2UgTkVXX0RPQ1VNRU5UX0NPTkZJUk1FRDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdGVtcElkID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoJ25ldy1kb2MtY29uZmlybWVkJywgW3RlbXBJZCwgaWQsIGNoZWNrc3VtXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU1lOQ19TVEVQXzE6IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgdmVjdG9yID0gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZCkgPz8gU2hhcmVkRm9sZGVyLmZpbmRCeUlkKGlkKVxuICAgICAgICAgICAgaWYgKGRvYyAmJiBoYXNoICE9IGRvYy5jYWxjdWxhdGVIYXNoKCkpIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIuc2VuZFN5bmNTdGVwMihkb2MsIHZlY3RvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGJyZWFrO1xuICAgICAgICAgIGNhc2UgU1lOQ19TVEVQXzI6IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZCkgPz8gU2hhcmVkRm9sZGVyLmZpbmRCeUlkKGlkKVxuICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICBZLmFwcGx5VXBkYXRlKGRvYy55RG9jLCB1cGRhdGUsIHByb3ZpZGVyKVxuICAgICAgICAgICAgICBwcm92aWRlci5lbWl0KCdzeW5jZWQnLCBbaWQsIGhhc2hdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU0VORF9ET0NVTUVOVF9BU19VUERBVEU6IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdChcImRvY3VtZW50LXJlY2VpdmVkXCIsIFtpZCwgdXBkYXRlLCBjaGVja3N1bV0pXG4gICAgICAgICAgfSBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bnJlYWNoYWJsZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG1lc3NhZ2VUeXBlID09PSBNRVNTQUdFX0FVVEhFTlRJQ0FUSU9OX1JFU1BPTlNFKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikpXG4gICAgICAgIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWQgPSB0cnVlXG4gICAgICAgIHByb3ZpZGVyLmVtaXQoJ2F1dGhlbnRpY2F0ZWQnLCBbZGF0YV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Vic29ja2V0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgIHByb3ZpZGVyLmVtaXQoJ2Nvbm5lY3Rpb24tZXJyb3InLCBbZXZlbnQsIHByb3ZpZGVyXSlcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgcHJvdmlkZXIuZW1pdCgnY29ubmVjdGlvbi1jbG9zZScsIFtldmVudCwgcHJvdmlkZXJdKVxuICAgICAgaWYgKHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgcHJvdmlkZXIuYXV0aGVudGljYXRlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgICBwcm92aWRlci53cyA9IG51bGxcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBpZiAocHJvdmlkZXIud3Njb25uZWN0ZWQpIHtcbiAgICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICAgIHN0YXR1czogJ2Rpc2Nvbm5lY3RlZCdcbiAgICAgICAgfV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMrK1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChcbiAgICAgICAgc2V0dXBXUyxcbiAgICAgICAgbWF0aC5taW4oXG4gICAgICAgICAgbWF0aC5wb3coMiwgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKSAqIDEwMCxcbiAgICAgICAgICBwcm92aWRlci5tYXhCYWNrb2ZmVGltZVxuICAgICAgICApLFxuICAgICAgICBwcm92aWRlclxuICAgICAgKVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5vbm9wZW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICBwcm92aWRlci53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IHRydWVcbiAgICAgIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCdcbiAgICAgIH1dKVxuXG4gICAgICBpZiAocHJvdmlkZXIuand0KSB7XG4gICAgICAgIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZShwcm92aWRlci5qd3QpXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZm9sZGVyIG9mIFNoYXJlZEZvbGRlci5nZXRBbGwoKSkge1xuICAgICAgICBpZiAoZm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyKSB7XG4gICAgICAgICAgaWYgKCFmb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIuc3luY2VkKSBhd2FpdCBmb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIud2hlblN5bmNlZFxuICAgICAgICAgIGZvbGRlci5zeW5jV2l0aFNlcnZlcigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBkb2Mgb2YgU2hhcmVkRG9jdW1lbnQuZ2V0QWxsKCkpIHtcbiAgICAgICAgaWYgKGRvYy5pc1Blcm1hbmVudCAmJiBkb2MuaW5kZXhlZERCUHJvdmlkZXIpIHtcbiAgICAgICAgICBpZiAoIWRvYy5pbmRleGVkREJQcm92aWRlci5zeW5jZWQpIGF3YWl0IGRvYy5pbmRleGVkREJQcm92aWRlci53aGVuU3luY2VkXG4gICAgICAgICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnXG4gICAgfV0pXG4gIH1cbn1cblxuaW50ZXJmYWNlIEF1dGhSZXNwb25zZURhdGEge1xuICBwbGFuOiB7XG4gICAgdHlwZTogXCJob2JieVwiIHwgXCJwcm9mZXNzaW9uYWxcIiB8IFwidGVhbVwiXG4gIH1cbn1cblxudHlwZSBFdmVudHMgPSB7XG4gIHN5bmNlZDogKGlkOiBzdHJpbmcsIGhhc2g6IHN0cmluZykgPT4gdm9pZFxuICAvLyBzeW5jOiAoc3RhdGU6IGJvb2xlYW4pID0+IHZvaWRcbiAgXCJjb25uZWN0aW9uLWVycm9yXCI6IChldmVudDogRXZlbnQsIHByb3ZpZGVyOiBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlcikgPT4gdm9pZFxuICBcImNvbm5lY3Rpb24tY2xvc2VcIjogKGV2ZW50OiBFdmVudCwgcHJvdmlkZXI6IFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyKSA9PiB2b2lkXG4gIHN0YXR1czogKHN0YXR1czogeyBzdGF0dXM6IHN0cmluZyB9KSA9PiB2b2lkXG4gICdkb2N1bWVudC1yZWNlaXZlZCc6IChpZDogc3RyaW5nLCB1cGRhdGU6IFVpbnQ4QXJyYXksIGNoZWNrc3VtOiBzdHJpbmcpID0+IHZvaWRcbiAgLy8gJ3N5bmMtY29uZmlybWVkJzogKGlkOiBzdHJpbmcsIGNoZWNrc3VtOiBzdHJpbmcpID0+IHZvaWRcbiAgJ25ldy1kb2MtY29uZmlybWVkJzogKHRlbXBJZDogc3RyaW5nLCBpZDogc3RyaW5nLCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gIC8vICdteS11cGRhdGUtc2VudCc6IChpZDogc3RyaW5nLCB1cGRhdGU6IFVpbnQ4QXJyYXksIGNoZWNrc3VtOiBzdHJpbmcpID0+IHZvaWRcbiAgLy8gJ290aGVyLWRvY3VtZW50LXJlY2VpdmVkLWlmLWNoZWNrc3VtLWRpZmZlcnMnOiAoaWQ6IHN0cmluZywgbXlDaGVja3N1bTogc3RyaW5nLCB5b3VyQ2hlY2tzdW06IHN0cmluZywgdXBkYXRlPzogVWludDhBcnJheSkgPT4gdm9pZFxuICAnYXV0aGVudGljYXRlZCc6IChkYXRhOiBBdXRoUmVzcG9uc2VEYXRhKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjbGFzcyBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlciBleHRlbmRzIE9ic2VydmFibGVWMjxFdmVudHM+IHtcblxuICBwYXJhbXM/OiB7IFtzOiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgV2ViU29ja2V0UG9seWZpbGw/OiB0eXBlb2YgV2ViU29ja2V0O1xuICByZXN5bmNJbnRlcnZhbD86IG51bWJlcjtcbiAgbWF4QmFja29mZlRpbWU6IG51bWJlcjtcbiAgdXJsOiBzdHJpbmdcbiAgd3Njb25uZWN0ZWQ6IGJvb2xlYW5cbiAgd3Njb25uZWN0aW5nOiBib29sZWFuXG4gIHdzVW5zdWNjZXNzZnVsUmVjb25uZWN0czogbnVtYmVyXG4gIF9zeW5jZWQ6IGJvb2xlYW5cbiAgd3M6IFdlYlNvY2tldCB8IG51bGxcbiAgd3NMYXN0TWVzc2FnZVJlY2VpdmVkOiBudW1iZXJcbiAgc2hvdWxkQ29ubmVjdDogYm9vbGVhblxuICBfcmVzeW5jSW50ZXJ2YWw6IG51bWJlclxuICBfdXBkYXRlSGFuZGxlcjogKHVwZGF0ZTogVWludDhBcnJheSwgb3JpZ2luOiBhbnkpID0+IHZvaWRcbiAgX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXI6ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH06IGFueSwgX29yaWdpbjogYW55KSA9PiB2b2lkXG4gIF9leGl0SGFuZGxlcjogKCkgPT4gdm9pZFxuICBfY2hlY2tJbnRlcnZhbDogbnVtYmVyXG4gIGF1dGhlbnRpY2F0ZWQ6IGJvb2xlYW5cbiAgand0OiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICBjb25zdHJ1Y3RvcihzZXJ2ZXJVcmw6IHN0cmluZywge1xuICAgIGNvbm5lY3QgPSB0cnVlLFxuICAgIHJlc3luY0ludGVydmFsID0gLTEsXG4gICAgbWF4QmFja29mZlRpbWUgPSAyNTAwLFxuICAgIGp3dCA9IHVuZGVmaW5lZFxuICB9OiB7IGp3dD86IHN0cmluZywgY29ubmVjdD86IGJvb2xlYW47IHBhcmFtcz86IHsgW3M6IHN0cmluZ106IHN0cmluZyB9OyBXZWJTb2NrZXRQb2x5ZmlsbD86IHR5cGVvZiBXZWJTb2NrZXQ7IHJlc3luY0ludGVydmFsPzogbnVtYmVyOyBtYXhCYWNrb2ZmVGltZT86IG51bWJlcjsgZGlzYWJsZUJjPzogYm9vbGVhbiB9ID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy51cmwgPSBzZXJ2ZXJVcmxcbiAgICB0aGlzLm1heEJhY2tvZmZUaW1lID0gbWF4QmFja29mZlRpbWVcbiAgICB0aGlzLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSByZXN5bmNJbnRlcnZhbFxuICAgIHRoaXMud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgIHRoaXMuX3N5bmNlZCA9IGZhbHNlXG4gICAgdGhpcy53cyA9IG51bGxcbiAgICB0aGlzLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IDBcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBjb25uZWN0XG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAwXG4gICAgdGhpcy5hdXRoZW50aWNhdGVkID0gZmFsc2VcbiAgICB0aGlzLmp3dCA9IGp3dFxuXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9ICh3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLndzY29ubmVjdGVkICYmXG4gICAgICAgIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IDxcbiAgICAgICAgdGltZS5nZXRVbml4VGltZSgpIC0gdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWRcbiAgICAgICkge1xuICAgICAgICAodGhpcy53cyEpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCAvIDEwKSlcbiAgICBpZiAoY29ubmVjdCkge1xuICAgICAgdGhpcy5jb25uZWN0KClcbiAgICB9XG4gIH1cblxuICBzZW5kU3luY1N0ZXAxKGRvYzogU2hhcmVkRW50aXR5KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX01VTFRJUExFWF9TWU5DKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBTWU5DX1NURVBfMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2Muc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZVZlY3Rvcihkb2MueURvYykpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRTeW5jU3RlcDIoZG9jOiBTaGFyZWRFbnRpdHksIHZlY3Rvcj86IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIFNZTkNfU1RFUF8yKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5zaGFyZUlkKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jLnlEb2MsIHZlY3RvcikpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRVcGRhdGUoZG9jOiBTaGFyZWRFbnRpdHksIHVwZGF0ZTogVWludDhBcnJheSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgVVBEQVRFKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5zaGFyZUlkKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB1cGRhdGUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRVcGRhdGVNZXNzYWdlKHNoYXJlSWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX01VTFRJUExFWF9TWU5DKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBVUERBVEUpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwgc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGNoZWNrc3VtKVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9XG5cbiAgc2VuZE5ld0RvY3VtZW50KGRvYzogU2hhcmVkRW50aXR5LCB0ZW1wSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTkVXX0RPQ1VNRU5UKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRlbXBJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYy55RG9jKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2MuY2FsY3VsYXRlSGFzaCgpKVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9XG5cbiAgc2VuZEdldERvY3VtZW50QXNVcGRhdGUoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgR0VUX0RPQ1VNRU5UX0FTX1VQREFURSksXG4gICAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBpZClcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRBdXRoZW5pY2F0aW9uUmVxdWVzdChqd3Q6IHN0cmluZykge1xuICAgIHRoaXMuand0ID0gand0XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX0FVVEhFTlRJQ0FUSU9OX1JFUVVFU1QpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwgand0KVxuICAgIHRoaXMuc2VuZE1lc3NhZ2UoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9XG5cbiAgYXV0aGVudGljYXRlKGp3dDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEF1dGhSZXNwb25zZURhdGE+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChkYXRhOiBBdXRoUmVzcG9uc2VEYXRhKSA9PiB7XG4gICAgICAgIHRoaXMub2ZmKCdhdXRoZW50aWNhdGVkJywgaGFuZGxlcilcbiAgICAgICAgcmVzb2x2ZShkYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy5vbignYXV0aGVudGljYXRlZCcsIGhhbmRsZXIpXG4gICAgICB0aGlzLnNlbmRBdXRoZW5pY2F0aW9uUmVxdWVzdChqd3QpXG4gICAgfSlcbiAgfVxuXG4gIHNlbmRNZXNzYWdlKGJ1ZjogQXJyYXlCdWZmZXIpIHtcbiAgICBpZiAodGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3Muc2VuZChidWYpXG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdERvY3VtZW50KGRvY0lkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8WS5Eb2M+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IChzZXJ2ZXJJZDogc3RyaW5nLCB1cGRhdGU6IFVpbnQ4QXJyYXksIGNoZWNrc3VtOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGRvY0lkID09PSBzZXJ2ZXJJZCkge1xuICAgICAgICAgIHRoaXMub2ZmKCdkb2N1bWVudC1yZWNlaXZlZCcsIGhhbmRsZXIpXG4gICAgICAgICAgY29uc3QgZG9jID0gbmV3IFkuRG9jKClcbiAgICAgICAgICBZLmFwcGx5VXBkYXRlKGRvYywgdXBkYXRlKVxuXG4gICAgICAgICAgLy8gY29ycmVjdCBoYXNoIGZvciBmb2xkZXJzXG4gICAgICAgICAgY29uc3QgZG9jcyA9IEFycmF5LmZyb20oZG9jLmdldE1hcChcImRvY3VtZW50c1wiKSlcbiAgICAgICAgICBpZiAoZG9jcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplKEFycmF5LmZyb20oZG9jcykpXG4gICAgICAgICAgICBjb25zdCBjYWxjdWxhdGVkSGFzaCA9IGNhbGN1bGF0ZUhhc2goc2VyaWFsaXplZClcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkSGFzaCAhPSBjaGVja3N1bSkge1xuICAgICAgICAgICAgICB0aGlzLnNlbmRVcGRhdGVNZXNzYWdlKGRvY0lkLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKSwgY2FsY3VsYXRlZEhhc2gpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoZG9jKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uKCdkb2N1bWVudC1yZWNlaXZlZCcsIGhhbmRsZXIpXG4gICAgICB0aGlzLnNlbmRHZXREb2N1bWVudEFzVXBkYXRlKGRvY0lkKVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9yZXN5bmNJbnRlcnZhbCAhPT0gMCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZXN5bmNJbnRlcnZhbClcbiAgICB9XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGZhbHNlXG4gICAgaWYgKHRoaXMud3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIGlmICghdGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzID09PSBudWxsKSB7XG4gICAgICBzZXR1cFdTKHRoaXMpXG4gICAgfVxuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSw4Q0FBQUEsU0FBQTtBQUtDLEtBQUMsU0FBVSxNQUFNO0FBR2pCLFVBQUksa0JBQWtCO0FBQUEsUUFDckIsSUFBSSxPQUFRLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBRTtBQUFBLFFBQzNCLElBQUksT0FBUSxLQUFLLElBQUksSUFBSSxDQUFDLENBQUU7QUFBQSxRQUM1QixJQUFJLE9BQVEsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFFO0FBQUEsUUFDNUIsR0FBSSxPQUFRLEtBQUssSUFBSSxHQUFHLEVBQUUsQ0FBRTtBQUFBLE1BQzlCO0FBQ0EsVUFBSSxhQUFhO0FBQUEsUUFDaEIsSUFBSSxPQUFPLEVBQUU7QUFBQSxRQUNaLElBQUksT0FBTyxFQUFFO0FBQUEsUUFDYixJQUFJLE9BQU8sRUFBRTtBQUFBLFFBQ2IsR0FBSSxPQUFPLENBQUM7QUFBQSxNQUNkO0FBU0EsZUFBUyxPQUFRLEdBQUcsR0FBRztBQUN0QixZQUFLLEVBQUUsZ0JBQWdCO0FBQ3RCLGlCQUFPLElBQUksT0FBTyxHQUFHLENBQUM7QUFFdkIsYUFBSyxPQUFPO0FBQ1osYUFBSyxRQUFRO0FBQ2IsYUFBSyxZQUFZO0FBQ2pCLFlBQUksT0FBTyxLQUFLO0FBQ2YsaUJBQU8sV0FBVyxLQUFLLE1BQU0sQ0FBQztBQUUvQixZQUFJLE9BQU8sS0FBSztBQUNmLGlCQUFPLFdBQVcsS0FBSyxNQUFNLEdBQUcsQ0FBQztBQUVsQyxpQkFBUyxLQUFLLE1BQU0sR0FBRyxDQUFDO0FBQUEsTUFDekI7QUFTQSxlQUFTLFNBQVUsR0FBRyxHQUFHO0FBQ3hCLGFBQUssT0FBTyxJQUFJO0FBQ2hCLGFBQUss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S0ksSUFBRUgsSUFBRSxHQUFFLE9BQU0sTUFBTSxHQUFFLEtBQUtBLEVBQUMsSUFBRSxNQUFJRyxJQUFFLEtBQUtILEtBQUUsQ0FBQyxJQUFFRyxPQUFJLEdBQUVILEtBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPSSxLQUFFLENBQUNBLElBQUVILFFBQUssR0FBRUQsTUFBRyxFQUFFLE1BQUtJLElBQUVILElBQUUsR0FBRSxPQUFNLE1BQU0sR0FBRSxLQUFLQSxFQUFDLElBQUVHLE9BQUksR0FBRSxLQUFLSCxLQUFFLENBQUMsSUFBRSxNQUFJRyxJQUFFSCxLQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNHLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsWUFBVyxXQUFXLEdBQUUsS0FBS0EsRUFBQyxJQUFFLE1BQUlHLElBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUVHLE9BQUksR0FBRSxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxJQUFHLEtBQUtILEtBQUUsQ0FBQyxJQUFFRyxPQUFJLElBQUdILEtBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPSSxLQUFFLENBQUNBLElBQUVILFFBQUssR0FBRUQsTUFBRyxFQUFFLE1BQUtJLElBQUVILElBQUUsR0FBRSxZQUFXLFdBQVcsR0FBRSxJQUFFRyxPQUFJQSxLQUFFLGFBQVdBLEtBQUUsSUFBRyxLQUFLSCxFQUFDLElBQUVHLE9BQUksSUFBRyxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxJQUFHLEtBQUtILEtBQUUsQ0FBQyxJQUFFRyxPQUFJLEdBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUUsTUFBSUcsSUFBRUgsS0FBRTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUs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QUFFLEdBQUUsQ0FBQyxTQUFTLEdBQUUsR0FBRSxHQUFFO0FBQTBGLFVBQUUsT0FBSyxTQUFTSCxJQUFFRCxJQUFFRyxJQUFFRSxJQUFFLEdBQUU7QUFBQyxjQUFJLEdBQUUsR0FBRSxJQUFFLElBQUUsSUFBRUEsS0FBRSxHQUFFLEtBQUcsS0FBRyxLQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxJQUFHLElBQUVGLEtBQUUsSUFBRSxJQUFFLEdBQUUsSUFBRUEsS0FBRSxLQUFHLEdBQUUsSUFBRUYsR0FBRUQsS0FBRSxDQUFDO0FBQUUsZUFBSSxLQUFHLEdBQUUsSUFBRSxLQUFHLEtBQUcsQ0FBQyxLQUFHLEdBQUUsTUFBSSxDQUFDLEdBQUUsS0FBRyxHQUFFLElBQUUsR0FBRSxJQUFFLE1BQUksSUFBRUMsR0FBRUQsS0FBRSxDQUFDLEdBQUUsS0FBRyxHQUFFLEtBQUc7QUFBRTtBQUFDLGVBQUksSUFBRSxLQUFHLEtBQUcsQ0FBQyxLQUFHLEdBQUUsTUFBSSxDQUFDLEdBQUUsS0FBR0ssSUFBRSxJQUFFLEdBQUUsSUFBRSxNQUFJLElBQUVKLEdBQUVELEtBQUUsQ0FBQyxHQUFFLEtBQUcsR0FBRSxLQUFHO0FBQUU7QUFBQyxjQUFHLE1BQUk7QUFBRSxnQkFBRSxJQUFFO0FBQUEsZUFBTTtBQUFDLGdCQUFHLE1BQUk7QUFBRSxxQkFBTyxJQUFFLE9BQUssSUFBRSxLQUFHLE1BQUksSUFBRTtBQUFHLGlCQUFHLEVBQUUsR0FBRUssRUFBQyxHQUFFLEtBQUc7QUFBQSxVQUFDO0FBQUMsa0JBQU8sSUFBRSxLQUFHLEtBQUcsSUFBRSxFQUFFLEdBQUUsSUFBRUEsRUFBQztBQUFBLFFBQUMsR0FBRSxFQUFFLFFBQU0sU0FBU0YsSUFBRUUsSUFBRSxHQUFFLEdBQUUsR0FBRSxHQUFFO0FBQUMsY0FBSSxHQUFFLEdBQUUsR0FBRSxJQUFFLEtBQUssS0FBSSxJQUFFLEtBQUssS0FBSSxJQUFFLElBQUUsSUFBRSxJQUFFLEdBQUUsS0FBRyxLQUFHLEtBQUcsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLE9BQUssSUFBRSxFQUFFLEdBQUUsR0FBRyxJQUFFLEVBQUUsR0FBRSxHQUFHLElBQUUsR0FBRSxJQUFFLElBQUUsSUFBRSxJQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRyxJQUFFLElBQUVBLE1BQUcsTUFBSUEsTUFBRyxJQUFFLElBQUVBLEtBQUUsSUFBRTtBQUFFLGVBQUlBLEtBQUUsRUFBRUEsRUFBQyxHQUFFLE1BQU1BLEVBQUMsS0FBR0EsT0FBSSxJQUFFLEtBQUcsSUFBRSxNQUFNQSxFQUFDLElBQUUsSUFBRSxHQUFFLElBQUUsTUFBSSxJQUFFLEVBQUUsRUFBRUEsRUFBQyxJQUFFLENBQUMsR0FBRSxJQUFFQSxNQUFHLElBQUUsRUFBRSxHQUFFLENBQUMsQ0FBQyxPQUFLLEtBQUksS0FBRyxJQUFHQSxNQUFHLEtBQUcsSUFBRSxJQUFFLElBQUUsSUFBRSxJQUFFLEVBQUUsR0FBRSxJQUFFLENBQUMsR0FBRSxLQUFHQSxLQUFFLE1BQUksS0FBSSxLQUFHLElBQUcsSUFBRSxLQUFHLEtBQUcsSUFBRSxHQUFFLElBQUUsS0FBRyxLQUFHLElBQUUsS0FBRyxLQUFHQSxLQUFFLElBQUUsS0FBRyxFQUFFLEdBQUUsQ0FBQyxHQUFFLEtBQUcsTUFBSSxJQUFFQSxLQUFFLEVBQUUsR0FBRSxJQUFFLENBQUMsSUFBRSxFQUFFLEdBQUUsQ0FBQyxHQUFFLElBQUUsS0FBSSxLQUFHLEdBQUVGLEdBQUUsSUFBRSxDQUFDLElBQUUsTUFBSSxHQUFFLEtBQUcsR0FBRSxLQUFHLEtBQUksS0FBRztBQUFFO0FBQUMsZUFBSSxJQUFFLEtBQUcsSUFBRSxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUVBLEdBQUUsSUFBRSxDQUFDLElBQUUsTUFBSSxHQUFFLEtBQUcsR0FBRSxLQUFHLEtBQUksS0FBRztBQUFFO0FBQUMsVUFBQUEsR0FBRSxJQUFFLElBQUUsQ0FBQyxLQUFHLE1BQUk7QUFBQSxRQUFDO0FBQUEsTUFBQyxHQUFFLENBQUMsQ0FBQyxHQUFFLElBQUcsQ0FBQyxTQUFTLEdBQUVGLElBQUU7QUFBQyxRQUFB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LEdBQUUsS0FBSyxRQUFPQSxLQUFFQSxHQUFFO0FBQUssbUJBQU9DO0FBQUEsVUFBQyxFQUFDLEdBQUUsRUFBQyxLQUFJLFdBQVUsT0FBTSxTQUFTRyxJQUFFSCxJQUFFO0FBQUMsZ0JBQUlEO0FBQUUsbUJBQU9JLEtBQUUsS0FBSyxLQUFLLEtBQUssVUFBUUosS0FBRSxLQUFLLEtBQUssS0FBSyxNQUFNLEdBQUVJLEVBQUMsR0FBRSxLQUFLLEtBQUssT0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNQSxFQUFDLEtBQUdBLE9BQUksS0FBSyxLQUFLLEtBQUssU0FBT0osS0FBRSxLQUFLLE1BQU0sSUFBRUEsS0FBRUMsS0FBRSxLQUFLLFdBQVdHLEVBQUMsSUFBRSxLQUFLLFdBQVdBLEVBQUMsR0FBRUo7QUFBQSxVQUFDLEVBQUMsR0FBRSxFQUFDLEtBQUksU0FBUSxPQUFNLFdBQVU7QUFBQyxtQkFBTyxLQUFLLEtBQUs7QUFBQSxVQUFJLEVBQUMsR0FBRSxFQUFDLEtBQUksY0FBYSxPQUFNLFNBQVNJLElBQUU7QUFBQyxnQkFBSUgsS0FBRSxLQUFLLE1BQUtDLEtBQUUsR0FBRUMsS0FBRUYsR0FBRTtBQUFLLGlCQUFJRyxNQUFHRCxHQUFFLFFBQU9GLEtBQUVBLEdBQUUsUUFBTTtBQUFDLGtCQUFJSSxLQUFFSixHQUFFLE1BQUtZLEtBQUVULEtBQUVDLEdBQUUsU0FBT0EsR0FBRSxTQUFPRDtBQUFFLGtCQUFHRCxNQUFHVSxPQUFJUixHQUFFLFNBQU9BLEtBQUVBLEdBQUUsTUFBTSxHQUFFRCxFQUFDLEdBQUVBLE1BQUdTLElBQUUsTUFBSVQsSUFBRTtBQUFDLGdCQUFBUyxPQUFJUixHQUFFLFVBQVEsRUFBRUgsSUFBRSxLQUFLLE9BQUtELEdBQUUsT0FBS0EsR0FBRSxPQUFLLEtBQUssT0FBSyxTQUFPLEtBQUssT0FBS0EsSUFBRUEsR0FBRSxPQUFLSSxHQUFFLE1BQU1RLEVBQUM7QUFBRztBQUFBLGNBQUs7QUFBQyxnQkFBRVg7QUFBQSxZQUFDO0FBQUMsbUJBQU8sS0FBSyxVQUFRQSxJQUFFQztBQUFB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QU0sY0FBQUEsS0FBSSxlQUFlLE1BQU1BLEtBQUksWUFBWSxDQUFDO0FBQUEsVUFDckQ7QUFBQSxRQUNELENBQUMsQ0FBRTtBQUFBLE1BQ0o7QUFBQSxJQUNEO0FBRUEsVUFBTSxjQUFjLGtCQUFrQixNQUFNO0FBRTVDLFFBQUksQ0FBQyxPQUFPLFNBQVMsTUFBTTtBQUMxQixZQUFNLE9BQU8sTUFBTSxjQUFjLE9BQU8sR0FBRztBQUMzQyxVQUFJLFFBQVEsS0FBSyxNQUFNO0FBQ3RCLGFBQUssU0FBUyxPQUFPLEtBQUs7QUFDMUIscUJBQWEsS0FBSyxVQUFVLE1BQU07QUFBQSxNQUNuQztBQUFBLElBQ0Q7QUFDQSxXQUFPLGNBQWMsV0FBVztBQUFBLEVBQ2pDO0FBQUEsRUFFQSxXQUFXO0FBQ1YsbUJBQWUsT0FBTyxFQUFFLFFBQVEsQ0FBQ0EsU0FBUTtBQUN4QyxNQUFBQSxLQUFJLFFBQVE7QUFBQSxJQUNiLENBQUM7QUFDRCxpQkFBYSxPQUFPLEVBQUUsUUFBUSxZQUFVO0FBQ3ZDLGFBQU8sUUFBUTtBQUFBLElBQ2hCLENBQUM7QUFDRCxTQUFLLG1CQUFtQixRQUFRO0FBQUEsRUFDakM7QUFBQSxFQUVBLElBQUksU0FBaUI7QUFDcEIsUUFBSSxLQUFLLFNBQVMsT0FBTztBQUN4QixjQUFRLElBQUksT0FBTztBQUFBLElBQ3BCO0FBQUEsRUFDRDtBQUVEOzs7QURqWUEsSUFBTyxlQUFROyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgInNpemUiLCAic2VsZiIsICJtb2R1bGUiLCAiWFhIIiwgImgzMiIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJuIiwgInQiLCAiciIsICJhIiwgImUiLCAibyIsICJkIiwgInMiLCAibCIsICJjIiwgImYiLCAidSIsICJwIiwgImkiLCAiaCIsICJtIiwgImciLCAiXyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNOYU4iLCAibWFwIiwgImNyZWF0ZSIsICJjcmVhdGUiLCAiYXJncyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNOYU4iLCAicGFyc2VJbnQiLCAia2V5cyIsICJjcmVhdGUiLCAiY3JlYXRlIiwgImNyZWF0ZSIsICJsZW5ndGgiLCAiYXJncyIsICJsZW5ndGgiLCAibGVuZ3RoIiwgImNyZWF0ZSIsICJmb3JFYWNoIiwgInRleHQiLCAiZm9yRWFjaCIsICJmcmFnbWVudCIsICJjcmVhdGUiLCAiY3JlYXRlIiwgImFyZ3MiLCAiY3JlYXRlIiwgImFyZ3MiLCAic3R5bGUiLCAiY3JlYXRlIiwgImNyZWF0ZU1vZHVsZUxvZ2dlciIsICJkZWwiLCAiaWQiLCAibGVuZ3RoIiwgImkiLCAiY3JlYXRlIiwgInJlc29sdmUiLCAiZG9jIiwgInR5cGUiLCAiaWQiLCAiYW55IiwgImkiLCAiZG9jIiwgInR5cGUiLCAidHlwZSIsICJkb2MiLCAidHlwZSIsICJjcmVhdGUiLCAiaWQiLCAiZG9jIiwgInR5cGUiLCAiY3JlYXRlIiwgInN0cnVjdCIsICJkb2MiLCAidHlwZSIsICJpIiwgImhhc0NvbnRlbnQiLCAiY3JlYXRlIiwgImtleXMiLCAicGF0aCIsICJ0eXBlIiwgInR5cGUiLCAiZG9jIiwgImNyZWF0ZSIsICJsZW5ndGgiLCAibWFwIiwgImxlbmd0aCIsICJjb3VudCIsICJkb2MiLCAidGV4dCIsICJ0eXBlIiwgImVsZW1lbnQiLCAiZnJhZ21lbnQiLCAiY3JlYXRlIiwgImtleXMiLCAiaWQiLCAiaXRlbSIsICJ0ZXh0IiwgImtleXMiLCAidGV4dCIsICJjbVZpZXciLCAiY21TdGF0ZSIsICJpbnNlcnRUZXh0IiwgImNtVmlldyIsICJjbVN0YXRlIiwgImNyZWF0ZSIsICJpZCIsICJjbVN0YXRlIiwgImNtVmlldyIsICJpbXBvcnRfc3RhdGUiLCAicGF0aCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJjcmVhdGUiLCAiZG9jIiwgImRvYyIsICJjcmVhdGUiLCAiZGF0YSIsICJjcmVhdGVNb2R1bGVMb2dnZXIiLCAiZG9jIiwgImFkZCIsICJQZWVyIiwgImVuY29kZXIiLCAiY3JlYXRlIiwgImRhdGEiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZG9jIiwgImlkIiwgInJlc29sdmUiLCAicGF0aCIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHJhbnNhY3QiLCAiY3JlYXRlIiwgInJlc29sdmUiLCAicmVqZWN0IiwgInRyYW5zYWN0IiwgImRvYyIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJ0cmFuc2FjdCIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc29sdmUiLCAia2V5cyIsICJpc0FycmF5IiwgImFyZ3MiLCAiYXNhcCIsICJhbnkiLCAiRGV4aWVFcnJvciIsICJub3AiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHlwZSIsICJwcm9wcyIsICJ0cmFucyIsICJQcm9taXNlIiwgImkiLCAiYWRkIiwgIlRhYmxlIiwgImNvdW50IiwgImN0eCIsICJDb2xsZWN0aW9uIiwgImNtcCIsICJsZW5ndGgiLCAiZGlyZWN0aW9uIiwgIm1pbiIsICJtYXgiLCAiYWRkUmFuZ2UiLCAicmFuZ2VzIiwgIldoZXJlQ2xhdXNlIiwgImluZGV4ZWREQiIsICJUcmFuc2FjdGlvbiIsICJwIiwgImRiIiwgInRhYmxlcyIsICJrZXlQYXRoIiwgImNvbXBvdW5kIiwgInJlc3VsdCIsICJyZXEiLCAib3BlbkN1cnNvciIsICJxdWVyeSIsICJldiIsICJoYXNHZXRBbGwiLCAiY3JlYXRlIiwgIklEQktleVJhbmdlIiwgIlZlcnNpb24iLCAiRGV4aWUiLCAiRGVidWcuZGVidWciLCAiRGVidWcuZ2V0RXJyb3JXaXRoU3RhY2siLCAic2FmYXJpMTRXb3JrYXJvdW5kIiwgInByaW1hcnlLZXkiLCAiZHhUcmFucyIsICJSYW5nZVNldCIsICJmcm9tIiwgInRhcmdldCIsICJrZXkiLCAic3Vic2NyaWJlIiwgInN0YXRlIiwgInVuc3Vic2NyaWJlIiwgIk9ic2VydmFibGUiLCAiX0RleGllIiwgIkRlYnVnLnNldERlYnVnIiwgImRvYyIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZXNvbHZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgInJlc29sdmUiLCAiZG9jIiwgImZvbGRlcnMiLCAidGV4dCIsICJkaXYiLCAiaW1wb3J0X29ic2lkaWFuIiwgImRvYyIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImRvY3VtZW50IiwgImZvbGRlciIsICJkb2MiLCAibG9jYXRpb24iLCAiaWQiLCAicGF0aCIsICJ0ZXh0IiwgInJlc29sdmUiLCAicmVqZWN0IiwgInRhc2siLCAidGV4dCIsICJsZW5ndGgiLCAiYXJncyIsICJ0ZXh0IiwgImxlbmd0aCIsICJkb2MiLCAiZmlsZSIsICJpZCIsICJyZXNvbHZlIiwgImxvY2F0aW9uIiwgInBhdGgiLCAiaWQiLCAic2V0dXBXUyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlkIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZXNvbHZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgInJlc29sdmUiLCAibWVzc2FnZVJlY29ubmVjdFRpbWVvdXQiLCAic2V0dXBXUyIsICJpZCIsICJkb2MiLCAiZGF0YSIsICJyZXNvbHZlIiwgInBhdGgiLCAiX2EiLCAiZG9jIiwgImZpbGUiXQp9Cg==
